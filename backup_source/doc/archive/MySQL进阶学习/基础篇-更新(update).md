# 基础篇-更新(update)



我有个好奇的地方，如果redolog在 commit阶段没有写入失败，就是binlog写入成功，redo log prepare写入成功， 那么redo log事务要回滚， 而binlog阶段又是直接恢复，那么 数据不还是不一致吗？

**回答：**redolog因为commit不成功要回滚吗？我猜是这里是没有回滚的。redolog prepare+binlog一致，表示系统上认同了这次改动。非commit状态只是说明写入磁盘的动作没有完成而已。不管什么原因commit失败，数据还可以缓存在内存里，对外宣称改动成功，等待下次写入。你要说这时候断电了，内存没了，我就从log中恢复，写入磁盘。多出来的数据我本来就是要写入的，不存在不一致的问题。



Bin log 用于记录了完整的逻辑记录，所有的逻辑记录在 bin log 里都能找到，所以在备份恢复时，是以 bin log 为基础，通过其记录的完整逻辑操作，备份出一个和原库完整的数据。

在两阶段提交时，若 redo log 写入成功，bin log 写入失败，则后续通过 bin log 恢复时，恢复的数据将会缺失一部分。(如 redo log 执行了 update t set status = 1，此时原库的数据 status 已更新为 1，而 bin log 写入失败，没有记录这一操作，后续备份恢复时，其 status = 0，导致数据不一致）。

若先写入 bin log，当 bin log 写入成功，而 redo log 写入失败时，原库中的 status 仍然是 0 ，但是当通过 bin log 恢复时，其记录的操作是 set status = 1，也会导致数据不一致。

其核心就是， redo log 记录的，即使异常重启，都会刷新到磁盘，而 bin log 记录的， 则主要用于备份。

我可以这样理解吗？还有就是如何保证 redo log 和 bin log 操作的一致性啊？

**回答：**几乎全对，除了这个“两阶段提交时，若redo log写入成功，但binlog写入失败…”这句话。

实际上，因为是两阶段提交，这时候redolog只是完成了prepare, 而binlog又失败，那么事务本身会回滚，所以这个库里面status的值是0。

如果通过binlog 恢复出一个库，status值也是0。

这样不算丢失，这样是合理的结果。

两阶段就是保证一致性用的。
你不用担心日志写错，那样就是bug了…



老师您好，有一个问题，如果在非常极端的情况下，redo log被写满，而redo log涉及的事务均未提交，此时又有新的事务进来时，就要擦除redo log，这就意味着被修改的的脏页此时要被迫被flush到磁盘了，因为用来保证事务持久性的redo log就要消失了。但如若真的执行了这样的操作，数据就在被commit之前被持久化到磁盘中了。当真的遇到这样的恶劣情况时，mysql会如何处理呢，会直接报错吗？还是有什么应对的方法和策略呢？

**回答1:** 这些数据在内存中是无效其他事务读不到的（读到了也放弃），同样的，即使写进磁盘，也没关系，再次读到内存以后，还是原来的逻辑

**回答2：**其实举个很简单的例子，如果你来设计一个文件的落库，或者心跳机制，你会选择，每次一个实际动作触发一次落库或者心跳检查，还是选择再额外增加一个定时机制，每间隔一个周期会自动检查一下是否需要落库或者心跳？。。。其实想明白这个就知道你说的场景会有，但是一定会提前解决了，或者db本身早就有问题了。。然后这点想明白了，其实 消息队列的心跳机制或者mq broker的落库 你也就明白了，哈哈哈 其实到最后技术都是互通的。





### 事务

事务使用的方式：1）start transaction/begin显示开启事务，commit获rollback事务；2）set autocommit=0关闭自动提交，commit或者rollback事务，3）commit work and chain。方式1）显示的开启事务有利于避免长事务，因为长事务出现的重要原因是程序员的误用2）的缘故。方式2）避免该种写法。方式3）将提交和开启事务用一条语句完成可以弥补1）带来的开启事务多一次交互。



#### 事务的ACID



#### 事务可能出现的问题



#### 事务的隔离级别



#### 不同隔离级别下值变化 demo



#### 22 事务的启动方式



#### 长事务问题





