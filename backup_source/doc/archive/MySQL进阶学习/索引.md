# 索引

索引的出现是为了提高数据查询的效率，就像书的目录一样。

## 索引模型

索引的实现有很多种，每种实现方式可以成为一个索引模型，常见的的索引模型有：哈希表、有序数组、搜索树。

### 哈希表

哈希表是一种以键 - 值（key - value）存储数据的结构。

哈希的实现思路比较简单，把值放到数组里，用一个哈希函数把 key 换算成数组上一个确定的位置，然后把 value 放到数组的这个位置上。

##### 哈希冲突问题

不可避免的，多个 key 经过哈希函数的计算后，会出现同一个值的情况，处理这种情况的一个方法是，在数组的位置上拉出一个链表。

#### 适用场景

**哈希表这种结构适用于只有等值查询的场景，不适用于区间查询场景**，比如 Memcached 及其他一些 NoSQL 引擎。

### 有序数组

有序数组在等值查询和范围查询场景中的性能都非常优秀。但是在更新数据的时候很麻烦，在某个位置插入一条记录，则必须挪动后面的所有记录，成本太高。

有序数组在等值查询时，若使用二分法查找，则时间复杂度是 O(log(N)) 。

#### 适用场景

**有序数组索引只适用于静态存储引擎**，比如你要保存的是 2017 年某个城市的所有人口信息，这类不会再修改的数据。

### 搜索树

#### 二叉搜索树

二叉搜索树的特点是：父节点左子树所有节点的值都小于父节点的值，右子树所有节点的值都大于父节点的值。

二叉搜索树的查询时间复杂度是 O(log(N)) ，当然为了维持该时间复杂度，需要保持这颗树是平衡二叉树，所以更新的时间复杂度也是 O(log(N)) 。

#### N叉搜索树

二叉搜索树的查询效率是最高的，但实际上大多数数据库存储不使用二叉树，其原因是，索引不止存在内存中，还要写到磁盘上。

> 你可以想象一下一棵 100 万节点的平衡二叉树，树高 20。一次查询可能需要访问 20 个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要 10 ms 左右的寻址时间。也就是说，对于一个 100 万行的表，如果使用二叉树来存储，单独访问一个行可能需要 20 个 10 ms 的时间，这个查询可真够慢的。为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N 叉”树。

N叉树中的 N 取决于数据块的大小。



> 在64位系统中,理论可以访问的内存高达16EB(2的64次幂)字节。实际上,基于需求(用不到那么多内存)、性能(地址越宽在做地址转换时需要的页表级数越多)和成本(消耗更多晶体管)的考虑,在AMD64架构中只支持到52位(4PB)的地址总线和48位(256TB)的虚拟地址空间,所以目前64位的硬件实际能够支持的最大内存只有256TB。此外,操作系统一侧也还会施加自己的约束,64位的Linux则分别支持47位(128TB)的进程虚拟地址空间和46位(64TB)的物理地址空间,64位的Windows系统甚至只支持44位(16TB)的物理地址空间。 ---深入理解Java虚拟机 第三版