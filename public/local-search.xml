<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浅谈 AWS ColudWatch、EventBridge、CloudWatch</title>
    <link href="/2022/06/29/%E6%B5%85%E8%B0%88-AWS-ColudWatch%E3%80%81EventBridge%E3%80%81CloudWatch/"/>
    <url>/2022/06/29/%E6%B5%85%E8%B0%88-AWS-ColudWatch%E3%80%81EventBridge%E3%80%81CloudWatch/</url>
    
    <content type="html"><![CDATA[<p>最近在公司领了一项任务，通过 AWS 的 CloudWatch、EventBridge、CloudWatch 实现当服务内存占用较大时，自动重启服务。</p><h2 id="CloudWatch"><a href="#CloudWatch" class="headerlink" title="CloudWatch"></a>CloudWatch</h2><p>CloudWatch 主要有两大功能，一个是作为日志中心，所有服务的日志都会输出到这里，通过日志组(log groups)的方式进行分类；另一个是指标监控中心，比如各个服务的 CPU使用情况 以及 内存占用情况 都可以在这里查看。</p><p>另外，通过对服务的指标进行监控，拓展出了报警功能，通过对监控的指标设置一定规则，可以在触发规则后发生报警，一条报警信息可以理解为一个 event，AWS 将些 event 再汇总到 EventBridge。</p><h2 id="EventBridge"><a href="#EventBridge" class="headerlink" title="EventBridge"></a>EventBridge</h2><p>EventBridge 主要有两个概念，一个是 Eventbus，可以理解为收集消息的一个容器，默认的 Eventbus 是 default，会将 AWS 上的所有 event 收集，也可以自定义 Eventbus，用于收集特定服务的 event；另一个概念是 rule，作用是从 Eventbus 中过滤特定规则的信息，然后将这些获取到的信息呈递到其他模块处理，比如 Lambda。</p><p>EventBridge 可以收集的 event 不仅来自 AWS 自身的服务，还可以通过 API 直接将信息发送到 EventBridge 的特定 Eventbus 上。</p><h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>Lambda 主要作用是定义做什么的问题，一般在收到 EventBridge 呈递的消息时，会触发 定义的函数，然后完成要做的事情，比如重启服务。</p><p>Lambda 支持多种语言，区别仅在部署方式上有所不同。</p><p>Lambda 里的 函数如果有输出，AWS 会自动在 CloudWatch 的 Log 里创建一个 logs group，命名一般是 aws&#x2F;lambda&#x2F;&lt;函数名&gt;，注意，该操作需要一定的权限，需要确保执行 函数的role 具有将日志发送到 CloudWatch 的权限。</p><p>文档参考：</p><ul><li><a href="https://docs.amazonaws.cn/en_us/AmazonCloudWatch/latest/monitoring/WhatIsCloudWatch.html">Amazon CloudWatch</a></li><li><a href="https://docs.amazonaws.cn/en_us/eventbridge/latest/userguide/eb-what-is.html">Amazon EventBridge</a></li><li><a href="https://docs.aws.amazon.com/lambda/latest/dg/welcome.html">AWS Lambda</a></li><li><a href="https://github.com/aws/aws-lambda-go">SDK: aws-lambda-go</a></li><li><a href="https://github.com/aws/aws-sdk-go-v2">SDK: aws-sdk-go-v2</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac键盘连续输入问题</title>
    <link href="/2022/06/23/problems/Mac%E9%94%AE%E7%9B%98%E8%BF%9E%E7%BB%AD%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98/"/>
    <url>/2022/06/23/problems/Mac%E9%94%AE%E7%9B%98%E8%BF%9E%E7%BB%AD%E8%BE%93%E5%85%A5%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>在 Vim 里移动光标的时候，发现长按 <code>l</code> 会弹出 <code>l</code> 键相关的其他内容，类似于提示框的东西。</p><p>在终端使用下面命令后重启电脑可解决:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">defaults write NSGlobalDomain ApplePressAndHoldEnabled -boolean false<br><br>或者<br><br>defaults write -g ApplePressAndHoldEnabled -bool false<br></code></pre></td></tr></table></figure><p>如果想要恢复，将上方 <code>false</code> 改成 <code>true</code> 后重启电脑即可。</p>]]></content>
    
    
    <categories>
      
      <category>Problems</category>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim查找与替换操作</title>
    <link href="/2022/05/23/Tools/Vim/Vim%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%9B%BF%E6%8D%A2%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/05/23/Tools/Vim/Vim%E6%9F%A5%E6%89%BE%E4%B8%8E%E6%9B%BF%E6%8D%A2%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>原文：<a href="https://linuxize.com/post/vim-find-replace/">Find and Replace in Vim &#x2F; Vi | Linuxize</a></p><h2 id="常规使用"><a href="#常规使用" class="headerlink" title="常规使用"></a>常规使用</h2><p>vim查找与替换的命令结构：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">:[range]s/&#123;pattern&#125;/&#123;string&#125;/[flags] [count]<br></code></pre></td></tr></table></figure><p>在使用上，分隔符并不一定必须斜杠字符 <code>/</code> ，也可以使用其他的非字母数字的字符，例如使用 <code>|</code>（<code>s|foo|bar|</code>)</p><ol><li><p>替换当前行第一个匹配到的模式</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">:s/foo/bar/<br></code></pre></td></tr></table></figure></li><li><p>替换当前行所有匹配到的模式</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">:s/foo/bar/g<br></code></pre></td></tr></table></figure></li><li><p>替换当前文件中所有匹配到的模式</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">:<span class="hljs-comment">%s/foo/bar/g</span><br></code></pre></td></tr></table></figure></li><li><p>删除当前行中所有匹配到的模式</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">:s/foo//g<br></code></pre></td></tr></table></figure></li></ol><h2 id="替换前进行确认"><a href="#替换前进行确认" class="headerlink" title="替换前进行确认"></a>替换前进行确认</h2><p>每次替换前进行确认操作：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">:s/foo/bar/gc<br></code></pre></td></tr></table></figure><p>执行上面命令后，会输出：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">replace with bar (y/n/a/q/l/<span class="hljs-built_in">^</span>E/<span class="hljs-built_in">^</span>Y)?<br></code></pre></td></tr></table></figure><p>含义:</p><ul><li>y: 确认替换</li><li>n: 跳过当前模式</li><li>a: 替换所有匹配的模式</li><li>q: 确认替换并退出，也可以直接按 <code>ESC</code> 达到相同目的</li><li>^E: 为 <code>Ctrl + E</code>，往上翻屏</li><li>^Y: 为 <code>Ctrl + Y</code>，往下翻屏</li></ul><h2 id="使用正则搜索"><a href="#使用正则搜索" class="headerlink" title="使用正则搜索"></a>使用正则搜索</h2><p>搜索模式可以使用正则，比如：将文件中所有以 foo 开头的行 替换为 Vim is the best，并确认每一步操作</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">:<span class="hljs-comment">%s/^foo.*/Vim is the best/gc</span><br></code></pre></td></tr></table></figure><p><code>^</code> 表示从行的开始进行模式匹配，<code>.*</code> 表示匹配任何字符</p><h2 id="大小写敏感性"><a href="#大小写敏感性" class="headerlink" title="大小写敏感性"></a>大小写敏感性</h2><p>默认是大小写敏感的，即模式 <code>foo</code> 无法匹配到 <code>Foo</code>。</p><h4 id="忽略大小写敏感"><a href="#忽略大小写敏感" class="headerlink" title="忽略大小写敏感"></a>忽略大小写敏感</h4><p>在 <code>flag</code> 位置使用 <code>i</code> 字符 或 在模式中加入 <code>\c</code></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">:<span class="hljs-comment">%s/foo/bar/gi</span><br><br>:<span class="hljs-comment">%s/foo\c/bar/g</span><br></code></pre></td></tr></table></figure><h4 id="对大小写敏感"><a href="#对大小写敏感" class="headerlink" title="对大小写敏感"></a>对大小写敏感</h4><p>在 <code>flag</code> 位置使用 <code>I</code> 字符 或 在模式中加入 <code>\C</code></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">:<span class="hljs-comment">%s/foo/bar/gI</span><br><br>:<span class="hljs-comment">%s/foo\C/bar/g</span><br></code></pre></td></tr></table></figure><h2 id="控制搜索范围"><a href="#控制搜索范围" class="headerlink" title="控制搜索范围"></a>控制搜索范围</h2><p>如果没有指定搜索范围，则默认搜索当前行，在上面的使用中，已经知道 <code>%</code> 控制的范围是整个文件。</p><p>范围作用于行，可以使用行号或者特殊符号指定，分割使用 <code>,</code> 或 <code>;</code></p><ol><li><p>搜索第3行到第10行，并替换</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">:3,10s/foo/bar/g<br></code></pre></td></tr></table></figure></li><li><p>搜索当前行到行尾的范围，并替换</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">:.,<span class="hljs-built_in">$</span>s/foo/bar/g<br></code></pre></td></tr></table></figure><ul><li><code>.</code>: 代表当前行</li><li><code>$</code>: 代表行尾</li></ul></li><li><p>从当前行开始，向下搜索4行，并替换</p> <figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">:.,+4s/foo/bar/g<br></code></pre></td></tr></table></figure><p> 可以使用 <code>+</code> 或 <code>-</code> 控制从指定的行加或者减（向下或者向上）多少行用于搜索</p><ul><li><code>+</code>: 搜索范围从指定行向下增加多少行</li><li><code>-</code>: 搜索范围从指定行向上减少多少行</li></ul></li></ol><h2 id="按照词进行匹配"><a href="#按照词进行匹配" class="headerlink" title="按照词进行匹配"></a>按照词进行匹配</h2><p>默认的匹配模式都是基于字符的，比如 <code>gnu</code> 可以匹配到 <code>gnu</code>、<code>cygnus</code>、 <code>magnum</code> ，如果我只想匹配到 <code>gnu</code>，则可以控制模式匹配按词的方式进行。</p><p><code>\&lt;</code> 标识词的开始，<code>\&gt;</code> 标识词的结束</p><p>搜索当前行 词为 <code>foo</code> 的并替换</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">:s/<span class="hljs-keyword">\&lt;</span>foo<span class="hljs-keyword">\&gt;</span>/bar/g<br></code></pre></td></tr></table></figure><h2 id="搜索历史"><a href="#搜索历史" class="headerlink" title="搜索历史"></a>搜索历史</h2><p>使用 <code>:s</code> 调出搜索历史，然后使用 上下方向键 选择之前的操作，按 Enter 可执行选中的命令，当然，执行前也可以编辑历史命令。</p><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><p>注释 5 到 20 行 (在5到20行前加 #) ：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">:5,20s/<span class="hljs-built_in">^</span>/<span class="hljs-params">#</span>/<br></code></pre></td></tr></table></figure><p>取消注释 5 到 20 行 (删除5到20行前的 #) ：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">:5,20s/<span class="hljs-built_in">^</span><span class="hljs-params">#</span>//<br></code></pre></td></tr></table></figure><p>将 <code>apple</code>、<code>orange</code>、 <code>mango</code> 替换为 <code>fruit</code>:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">:s/apple<span class="hljs-keyword">\|</span>orange<span class="hljs-keyword">\|</span>mango/fruid/g<br></code></pre></td></tr></table></figure><p>删除每行行尾空格</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">:s/<span class="hljs-keyword">\s</span><span class="hljs-keyword">\+</span><span class="hljs-built_in">$</span>//e<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Vim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习环境搭建问题汇总</title>
    <link href="/2022/05/18/machinelearning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2022/05/18/machinelearning/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h4 id="切换核显与GPU"><a href="#切换核显与GPU" class="headerlink" title="切换核显与GPU"></a>切换核显与GPU</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 切换到核显</span><br>sudo prime-select intel<br><span class="hljs-comment"># 切换到GPU</span><br>sudo prime-select nvidia<br></code></pre></td></tr></table></figure><p>若提示 没有prime-select 命令，安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install nvidia-prime<br></code></pre></td></tr></table></figure><h4 id="cudnn-与-cuda-版本对应关系"><a href="#cudnn-与-cuda-版本对应关系" class="headerlink" title="cudnn 与 cuda 版本对应关系"></a>cudnn 与 cuda 版本对应关系</h4><p><a href="https://developer.nvidia.com/rdp/cudnn-archive">cuDNN Archive | NVIDIA Developer</a></p><p>cuda版本存档：</p><p><a href="https://developer.nvidia.com/cuda-toolkit-archive">cuda 版本存档</a></p><p><a href="https://developer.download.nvidia.cn/compute/cuda/repos/">cuda 版本存档-国内</a></p><h4 id="通过-apt-安装-NVIDIA-驱动"><a href="#通过-apt-安装-NVIDIA-驱动" class="headerlink" title="通过 apt 安装 NVIDIA 驱动"></a>通过 apt 安装 NVIDIA 驱动</h4><p>查看支持的 nvidia 驱动列表</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">apt search nvidia-driver<br><br><span class="hljs-comment"># or use</span><br><br>apt-cache search nvidia-driver<br></code></pre></td></tr></table></figure><p>安装驱动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt install nvidia-driver-510<br></code></pre></td></tr></table></figure><h4 id="Tensorflow-计算过程中，cudnn-内存分配失败"><a href="#Tensorflow-计算过程中，cudnn-内存分配失败" class="headerlink" title="Tensorflow 计算过程中，cudnn 内存分配失败"></a>Tensorflow 计算过程中，cudnn 内存分配失败</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">failed to create cublas handle: CUBLAS<span class="hljs-built_in">_</span>STATUS<span class="hljs-built_in">_</span>ALLOC<span class="hljs-built_in">_</span>FAILED tf 2.8<br></code></pre></td></tr></table></figure><p>可用两种方法解决，一、如果内存较大，可设置根据需要自动增长内存；二、设置固定内存大小供当前任务使用</p><h5 id="一：设置根据需要自动增长内存"><a href="#一：设置根据需要自动增长内存" class="headerlink" title="一：设置根据需要自动增长内存"></a>一：设置根据需要自动增长内存</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><br>gpus = tf.config.experimental.list_physical_devices(device_type=<span class="hljs-string">&#x27;GPU&#x27;</span>)<br>tf.config.experimental.set_memory_growth(gpus[<span class="hljs-number">0</span>], <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h5 id="二：设置固定内存大小供当前任务使用"><a href="#二：设置固定内存大小供当前任务使用" class="headerlink" title="二：设置固定内存大小供当前任务使用"></a>二：设置固定内存大小供当前任务使用</h5><p>具体可参考：<a href="https://www.tensorflow.org/guide/gpu#limiting_gpu_memory_growth">Use a GPU  |  TensorFlow Core</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><br>gpus = tf.config.list_physical_devices(<span class="hljs-string">&#x27;GPU&#x27;</span>)<br><span class="hljs-keyword">if</span> gpus:<br>    <span class="hljs-comment"># Restrict TensorFlow to only allocate 1GB of memory on the first GPU</span><br>    <span class="hljs-keyword">try</span>:<br>        tf.config.set_logical_device_configuration(<br>            gpus[<span class="hljs-number">0</span>],<br>            [tf.config.LogicalDeviceConfiguration(memory_limit=<span class="hljs-number">1024</span>)])<br>        logical_gpus = tf.config.list_logical_devices(<span class="hljs-string">&#x27;GPU&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(gpus), <span class="hljs-string">&quot;Physical GPUs,&quot;</span>, <span class="hljs-built_in">len</span>(logical_gpus), <span class="hljs-string">&quot;Logical GPUs&quot;</span>)<br>    <span class="hljs-keyword">except</span> RuntimeError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-comment"># Virtual devices must be set before GPUs have been initialized</span><br>        <span class="hljs-built_in">print</span>(e)<br></code></pre></td></tr></table></figure><h4 id="创建-虚拟Python环境-venv"><a href="#创建-虚拟Python环境-venv" class="headerlink" title="创建 虚拟Python环境(venv)"></a>创建 虚拟Python环境(venv)</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">python -m venv &lt;path&gt;<br></code></pre></td></tr></table></figure><p>具体可参考：<a href="https://docs.python.org/3/library/venv.html">venv — Creation of virtual environments — Python 3.10.4 documentation</a></p><p>不过，如果 venv 以后要用于 机器学习，推荐安装 <a href="https://www.anaconda.com/products/distribution#Downloads">Anaconda</a>，可以一步到位避免很多问题，比如 jupyter notebook 无法运行问题。</p><blockquote><p>退出虚拟环境:</p><p>venv 的环境：<code>deactivate</code></p><p>anaconda3 的环境：<code>conda deactivate</code></p></blockquote><h4 id="CUDA-安装-code-256-问题"><a href="#CUDA-安装-code-256-问题" class="headerlink" title="CUDA 安装 code: 256 问题"></a>CUDA 安装 code: 256 问题</h4><p>问题参考：<a href="https://forums.developer.nvidia.com/t/info-finished-with-code-256-error-install-of-driver-component-failed/107661">[INFO]: Finished with code: 256 , [ERROR]: Install of driver component failed - CUDA &#x2F; CUDA Setup and Installation - NVIDIA Developer Forums</a></p><p>通过 <code>/var/log/nvidia-installer.log</code> 检查 nvidia 安装问题，里面可能有这样的 ERROR：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">ERROR: The Nouveau kernel driver is currently in use by your system. This driver is<br>incompatible with the NVIDIA driver, and must be disabled before proceeding.<br></code></pre></td></tr></table></figure><p>如果是 Ubuntu 的话，参照下面，其他系统参考：<a href="https://docs.nvidia.com/cuda/cuda-installation-guide-linux/index.html#runfile-nouveau">Installation Guide Linux :: CUDA Toolkit Documentation</a></p><ol><li><p>创建文件 <code>/etc/modprobe.d/blacklist-nouveau.conf</code>，然后写入下面内容</p> <figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">blacklist</span> nouveau<br><span class="hljs-attribute">options</span> nouveau modeset=<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure></li><li><p>重新生成内核文件</p> <figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo update-initramfs -u</span><br></code></pre></td></tr></table></figure></li></ol><p>然后重新安装 驱动 和 cuda。</p><h4 id="安装-CUDA-时提示-nvidia-drm-已经载入"><a href="#安装-CUDA-时提示-nvidia-drm-已经载入" class="headerlink" title="安装 CUDA 时提示 nvidia-drm 已经载入"></a>安装 CUDA 时提示 nvidia-drm 已经载入</h4><p>错误信息：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">ERROR: An NVIDIA kernel module &#x27;nvidia-drm&#x27; appears to already be loaded in your kernel.<br>This may be because it is in use (for example, by an X server, a CUDA program, or the<br>NVIDIA Persistence Daemon), but this may also happen if your kernel was configured<br>without support for module unloading.  Please be sure to exit any programs that may be<br>using the GPU(s) before attempting to upgrade your driver.  If no GPU-based programs are<br>running, you know that your kernel supports module unloading, and you still receive this<br>message, then an error may have occured that has corrupted an NVIDIA kernel module&#x27;s<br>usage count, for which the simplest remedy is to reboot your computer.<br></code></pre></td></tr></table></figure><p>解决：</p><ol><li>Isolate multi-user.target</li></ol><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nsis">sudo <span class="hljs-params">system</span>ctl isolate multi-<span class="hljs-literal">user</span>.target<br></code></pre></td></tr></table></figure><ol start="2"><li>Note that nvidia-drm is currently in use.</li></ol><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">lsmod <span class="hljs-string">| grep nvidia.drm</span><br></code></pre></td></tr></table></figure><ol start="3"><li>Unload nvidia-drm</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">sudo modprobe -r nvidia-drm</span><br></code></pre></td></tr></table></figure><ol start="4"><li>Note that nvidia-drm is not in use anymore.</li></ol><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c">lsmod <span class="hljs-string">| grep nvidia.drm</span><br></code></pre></td></tr></table></figure><ol start="5"><li>Go to your download folder and run the cuda installation.</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">sudo</span> sh cuda_10.<span class="hljs-number">1</span>.<span class="hljs-number">168</span>_418.<span class="hljs-number">67</span>_linux.run<br></code></pre></td></tr></table></figure><ol start="6"><li><p>Answer any prompts during installation.</p></li><li><p>When installation has finished, confirm that the CUDA Version has been updated.</p></li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">nvidia-smi</span><br></code></pre></td></tr></table></figure><ol start="8"><li>Start the GUI again.</li></ol><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">sudo systemctl start graphical.<span class="hljs-keyword">target</span><br></code></pre></td></tr></table></figure><h4 id="缺少包"><a href="#缺少包" class="headerlink" title="缺少包"></a>缺少包</h4><h5 id="遇到缺少包问题，最先尝试的方案"><a href="#遇到缺少包问题，最先尝试的方案" class="headerlink" title="遇到缺少包问题，最先尝试的方案"></a>遇到缺少包问题，最先尝试的方案</h5><p>将 <code>from keras import xxx</code> 或 <code>from keras.xxx import xxx</code> </p><p>改成 <code>from tensorflow.keras import xxx</code> 或 <code>from tensorflow.keras.xxx import xxx</code></p><h5 id="pillow"><a href="#pillow" class="headerlink" title="pillow"></a>pillow</h5><p>问题：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">ImportError(&#x27;Could not import PIL.Image. &#x27; working with keras-ternsorflow<br></code></pre></td></tr></table></figure><p>解决：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install pillow<br></code></pre></td></tr></table></figure><h5 id="dtensor"><a href="#dtensor" class="headerlink" title="dtensor"></a>dtensor</h5><p>问题：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">ImportError: cannot import name &#x27;dtensor&#x27;<br></code></pre></td></tr></table></figure><p>解决：</p><p>重新安装 tensorflow</p><h5 id="scipy"><a href="#scipy" class="headerlink" title="scipy"></a>scipy</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pip install scipy<br></code></pre></td></tr></table></figure><h4 id="批量清除-dpkg-中的-nvidia-相关包"><a href="#批量清除-dpkg-中的-nvidia-相关包" class="headerlink" title="批量清除 dpkg 中的 nvidia 相关包"></a>批量清除 dpkg 中的 nvidia 相关包</h4><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coq">dpkg -l |<span class="hljs-type">grep</span> nvidia|<span class="hljs-type">awk</span> &#x27;&#123;print $<span class="hljs-number">2</span>&#125;&#x27;|<span class="hljs-type">xargs</span> sudo dpkg -P<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Machine Learning</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ML</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>优雅地把HHKB放到Mac上</title>
    <link href="/2022/04/27/%E4%BC%98%E9%9B%85%E5%9C%B0%E6%8A%8AHHKB%E6%94%BE%E5%88%B0Mac%E4%B8%8A/"/>
    <url>/2022/04/27/%E4%BC%98%E9%9B%85%E5%9C%B0%E6%8A%8AHHKB%E6%94%BE%E5%88%B0Mac%E4%B8%8A/</url>
    
    <content type="html"><![CDATA[<p>参考：</p><ul><li><a href="https://zhuanlan.zhihu.com/p/380353759">一杯星爸爸引发的摸鱼——如何优雅地在新版13寸Macbook上使用HHKB - 知乎</a></li><li><a href="https://sspai.com/post/62533">把 HHKB 放在 MacBook 上使用的解决方案 - 少数派</a></li><li><a href="http://t.zoukankan.com/mushishi-p-10720116.html">把 hhkb 压在mac pro上面用 - 走看看</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>TODO</category>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ohmyzsh插件</title>
    <link href="/2022/04/27/Tools/OhMyZsh/ohmyzsh%E6%8F%92%E4%BB%B6/"/>
    <url>/2022/04/27/Tools/OhMyZsh/ohmyzsh%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="Recommend-One"><a href="#Recommend-One" class="headerlink" title="Recommend One"></a>Recommend One</h3><p><a href="https://travis.media/top-10-oh-my-zsh-plugins-for-productive-developers/#20210719-json">Top 10 Oh My Zsh Plugins For Productive Developers</a></p><p>包含的插件有：</p><ul><li>zsh-autosuggestions</li><li>web-search</li><li>copypath</li><li>copyfile</li><li>copybuffer</li><li>dirhistory</li><li>history</li><li>jsontools</li><li>sudo: Easily prefix your current or previous commands with sudo by pressing esc twice.</li><li>reload: to reload your $HOME&#x2F;.zshrc file (e.g. if you change it).</li></ul>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>ohmyzsh</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tools</tag>
      
      <tag>ohmyzsh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>禁用 Nouveau</title>
    <link href="/2022/04/20/Linux/%E7%A6%81%E7%94%A8Nouveau/"/>
    <url>/2022/04/20/Linux/%E7%A6%81%E7%94%A8Nouveau/</url>
    
    <content type="html"><![CDATA[<p>Ubuntu20.04安装Nvidia driver提示Nouveau问题，要禁用 Nouveau，参考 <code>RHEL/CentOS</code> 部分</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">The Nouveau kernel driver is currently in use by your system.<br></code></pre></td></tr></table></figure><p>To install the Display Driver, the Nouveau drivers must first be disabled. Each distribution of Linux has a different method for disabling Nouveau.</p><p>The Nouveau drivers are loaded if the following command prints anything:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lsmod | grep nouveau<br></code></pre></td></tr></table></figure><ul><li>Fedora<br>Create a file at &#x2F;usr&#x2F;lib&#x2F;modprobe.d&#x2F;blacklist-nouveau.conf with the following contents:<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">blacklist nouveau<br>options nouveau modeset=0<br></code></pre></td></tr></table></figure>Regenerate the kernel initramfs:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo dracut --force<br></code></pre></td></tr></table></figure>Run the following command:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo grub2-mkconfig -o /boot/grub2/grub.cfg<br></code></pre></td></tr></table></figure>Reboot the system.</li><li>RHEL&#x2F;CentOS<br>Create a file at &#x2F;etc&#x2F;modprobe.d&#x2F;blacklist-nouveau.conf with the following contents:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">blacklist nouveau<br>options nouveau modeset=0<br></code></pre></td></tr></table></figure>Regenerate the kernel initramfs:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo dracut --force<br></code></pre></td></tr></table></figure></li><li>OpenSUSE<br>Create a file at &#x2F;etc&#x2F;modprobe.d&#x2F;blacklist-nouveau.conf with the following contents:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Bash">blacklist nouveau<br>options nouveau modeset=0<br></code></pre></td></tr></table></figure>Regenerate the kernel initrd:<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Bash">sudo /sbin/mkinitrd<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>源码编译支持SSL的Python</title>
    <link href="/2022/04/20/Linux/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E6%94%AF%E6%8C%81SSL%E7%9A%84Python/"/>
    <url>/2022/04/20/Linux/%E6%BA%90%E7%A0%81%E7%BC%96%E8%AF%91%E6%94%AF%E6%8C%81SSL%E7%9A%84Python/</url>
    
    <content type="html"><![CDATA[<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤:"></a>步骤:</h3><p><a href="https://techglimpse.com/install-python-openssl-support-tutorial/">https://techglimpse.com/install-python-openssl-support-tutorial/</a></p><p>如果在步骤中遇到了问题，可参考后面部分。</p><h3 id="OpenSSL问题"><a href="#OpenSSL问题" class="headerlink" title="OpenSSL问题"></a>OpenSSL问题</h3><h4 id="使用pip安装程序时提示-SSLError"><a href="#使用pip安装程序时提示-SSLError" class="headerlink" title="使用pip安装程序时提示 SSLError()"></a>使用pip安装程序时提示 <a href="https://stackoverflow.com/questions/63084049/sslerrorcant-connect-to-https-url-because-the-ssl-module-is-not-available">SSLError(</a>)</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">SSLError(&quot;Can&#x27;t connect to HTTPS URL because the SSL module is not available.&quot;) in pip command<br></code></pre></td></tr></table></figure><p>pip 对应的 python 版本不支持 ssl；如果有多个 python 版本，注意 pip 是否对应到正确的 python 版本。</p><h4 id="检查-python-是否支持-ssl"><a href="#检查-python-是否支持-ssl" class="headerlink" title="检查 python 是否支持 ssl"></a>检查 python 是否支持 ssl</h4><p>在python交互器上执行下面命令，没报错说明支持</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">import</span> ssl<br></code></pre></td></tr></table></figure><h4 id="make-：SSL-问题："><a href="#make-：SSL-问题：" class="headerlink" title="make ：SSL 问题："></a><code>make</code> ：SSL 问题：</h4><h5 id="需要更新的版本"><a href="#需要更新的版本" class="headerlink" title="需要更新的版本"></a>需要更新的版本</h5><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Following modules built successfully but were removed because they could not be imported: _hashlib _ssl Could not build the ssl module! Python requires a OpenSSL 1.1.1 or newer<br></code></pre></td></tr></table></figure><p>通过 apt 包管理器下载的 openssl 有点旧（version: 1.1.1f），可以卸载掉(<code>sudo apt autoremove openssl</code>)，从 <a href="https://www.openssl.org/">openssl 官网</a>下载源码编译，编译文档详细可查看解压后包的 <code>INSTALL.md</code>。</p><p>参考：<a href="https://stackoverflow.com/questions/60536472/building-python-and-openssl-from-source-but-ssl-module-fails">https://stackoverflow.com/questions/60536472/building-python-and-openssl-from-source-but-ssl-module-fails</a></p><blockquote><p>openssl 源码编译(copy from INSTALL.md)：</p><h4 id="Unix-x2F-Linux-x2F-macOS"><a href="#Unix-x2F-Linux-x2F-macOS" class="headerlink" title="Unix &#x2F; Linux &#x2F; macOS"></a>Unix &#x2F; Linux &#x2F; macOS</h4><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ ./Configure<br><span class="hljs-comment"># 如果需要指定安装路径，命令换为: ./Configure --prefix=/usr/local/openssl</span><br>$ make<br>$ make <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><h4 id="Unix-x2F-Linux-x2F-macOS-1"><a href="#Unix-x2F-Linux-x2F-macOS-1" class="headerlink" title="Unix &#x2F; Linux &#x2F; macOS"></a>Unix &#x2F; Linux &#x2F; macOS</h4><p>Depending on your distribution, you need to run the following command as<br>root user or prepend <code>sudo</code> to the command:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ make install<br></code></pre></td></tr></table></figure><p>By default, OpenSSL will be installed to</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">/usr/local<br></code></pre></td></tr></table></figure><p>More precisely, the files will be installed into the  subdirectories</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">/usr/local/bin<br>/usr/local/lib<br>/usr/local/include<br>...<br></code></pre></td></tr></table></figure><p>depending on the file type, as it is custom on Unix-like operating systems.</p></blockquote><h5 id="undefined-reference-to-96-EVP-MD-CTX-free’"><a href="#undefined-reference-to-96-EVP-MD-CTX-free’" class="headerlink" title="undefined reference to &#96;EVP_MD_CTX_free’"></a>undefined reference to &#96;EVP_MD_CTX_free’</h5><p>·参考:</p><ul><li><a href="https://stackoverflow.com/questions/46768071/openssl-linking-undefined-reference-evp-md-ctx-new-and-fre">https://stackoverflow.com/questions/46768071/openssl-linking-undefined-reference-evp-md-ctx-new-and-fre</a></li><li><a href="https://github.com/nmap/ncrack/issues/42">https://github.com/nmap/ncrack/issues/42</a></li><li><a href="https://github.com/openssl/openssl/issues/11227">https://github.com/openssl/openssl/issues/11227</a></li></ul><h4 id="libels-sl-3-问题"><a href="#libels-sl-3-问题" class="headerlink" title="libels.sl.3 问题"></a>libels.sl.3 问题</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">openssl: error while loading shared libraries: libssl.so.3<br></code></pre></td></tr></table></figure><p>通过 <code>sudo ldconfig</code> 解决</p><p>参考：<a href="https://stackoverflow.com/questions/54124906/openssl-error-while-loading-shared-libraries-libssl-so-3">https://stackoverflow.com/questions/54124906/openssl-error-while-loading-shared-libraries-libssl-so-3</a></p><h3 id="Zlib问题"><a href="#Zlib问题" class="headerlink" title="Zlib问题"></a>Zlib问题</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">can’t decompress data; zlib not available<br></code></pre></td></tr></table></figure><p>缺少 zlib，通过 <code>sudo apt install zlib-devel</code> 安装。</p><p>参考：<a href="https://trendoceans.com/how-to-solve-zipimport-zipimporterror-cant-decompress-data-zlib-not-available/">https://trendoceans.com/how-to-solve-zipimport-zipimporterror-cant-decompress-data-zlib-not-available/</a></p><h3 id="删除通过源码编译方式安装的-Python"><a href="#删除通过源码编译方式安装的-Python" class="headerlink" title="删除通过源码编译方式安装的 Python"></a>删除通过源码编译方式安装的 Python</h3><p>脚本 :</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs sh">prefix=<span class="hljs-string">&#x27;/usr/local/&#x27;</span><br>pyver=<span class="hljs-string">&#x27;3.6&#x27;</span><br><br><span class="hljs-built_in">rm</span> -rf \<br>    <span class="hljs-variable">$HOME</span>/.local/lib/Python<span class="hljs-variable">$&#123;pyver&#125;</span> \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>bin/python<span class="hljs-variable">$&#123;pyver&#125;</span> \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>bin/python<span class="hljs-variable">$&#123;pyver&#125;</span>-config \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>bin/pip<span class="hljs-variable">$&#123;pyver&#125;</span> \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>bin/pydoc \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>bin/include/python<span class="hljs-variable">$&#123;pyver&#125;</span> \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>lib/libpython<span class="hljs-variable">$&#123;pyver&#125;</span>.a \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>lib/python<span class="hljs-variable">$&#123;pyver&#125;</span> \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>bin/python<span class="hljs-variable">$&#123;pyver&#125;</span> \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>bin/pip<span class="hljs-variable">$&#123;pyver&#125;</span> \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>bin/include/python<span class="hljs-variable">$&#123;pyver&#125;</span> \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>lib/libpython<span class="hljs-variable">$&#123;pyver&#125;</span>.a \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>lib/python<span class="hljs-variable">$&#123;pyver&#125;</span> \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>lib/pkgconfig/python-<span class="hljs-variable">$&#123;pyver&#125;</span>.pc \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>lib/libpython<span class="hljs-variable">$&#123;pyver&#125;</span>m.a \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>bin/python<span class="hljs-variable">$&#123;pyver&#125;</span>m \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>bin/2to3-<span class="hljs-variable">$&#123;pyver&#125;</span> \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>bin/python<span class="hljs-variable">$&#123;pyver&#125;</span>m-config \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>bin/idle<span class="hljs-variable">$&#123;pyver&#125;</span> \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>bin/pydoc<span class="hljs-variable">$&#123;pyver&#125;</span> \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>bin/pyvenv-<span class="hljs-variable">$&#123;pyver&#125;</span> \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>share/man/man1/python<span class="hljs-variable">$&#123;pyver&#125;</span>.1 \<br>    <span class="hljs-variable">$&#123;prefix&#125;</span>include/python<span class="hljs-variable">$&#123;pyver&#125;</span>m<br><span class="hljs-built_in">rm</span> -rI <span class="hljs-variable">$&#123;prefix&#125;</span>bin/pydoc <span class="hljs-comment">## WARN: skip if other pythons in local exist.</span><br></code></pre></td></tr></table></figure><p>注：<code>pyver</code> 的版本需要对应好</p><p>参考：<a href="https://unix.stackexchange.com/questions/190794/uninstall-python-installed-by-compiling-source">https://unix.stackexchange.com/questions/190794/uninstall-python-installed-by-compiling-source</a></p><h2 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h2><h4 id="Creating-Virtual-Environments"><a href="#Creating-Virtual-Environments" class="headerlink" title="Creating Virtual Environments"></a>Creating Virtual Environments</h4><p><a href="https://docs.python.org/3/tutorial/venv.html#creating-virtual-environments">https://docs.python.org/3/tutorial/venv.html#creating-virtual-environments</a></p><h4 id="Copying-a-Directory-with-SCP"><a href="#Copying-a-Directory-with-SCP" class="headerlink" title="Copying a Directory with SCP"></a>Copying a Directory with SCP</h4><p><a href="https://stackabuse.com/copying-a-directory-with-scp/">https://stackabuse.com/copying-a-directory-with-scp/</a></p><h4 id="How-to-unpack-tgz-file-on-a-Linux"><a href="#How-to-unpack-tgz-file-on-a-Linux" class="headerlink" title="How to unpack .tgz file on a Linux"></a><a href="https://www.cyberciti.biz/faq/unpack-tgz-linux-command-line/">How to unpack .tgz file on a Linux</a></h4>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Python</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令:args 将标准输入转为命令行参数</title>
    <link href="/2022/03/26/Linux/LinuxCommand/Linux%E5%91%BD%E4%BB%A4-args-%E5%B0%86%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BD%AC%E4%B8%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/"/>
    <url>/2022/03/26/Linux/LinuxCommand/Linux%E5%91%BD%E4%BB%A4-args-%E5%B0%86%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E8%BD%AC%E4%B8%BA%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.ruanyifeng.com/blog/2019/08/xargs-tutorial.html">xargs 命令教程 - 阮一峰的网络日志</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim分屏操作</title>
    <link href="/2022/03/24/Tools/Vim/Vim%E5%88%86%E5%B1%8F%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/03/24/Tools/Vim/Vim%E5%88%86%E5%B1%8F%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h4 id="水平方向打开新文件"><a href="#水平方向打开新文件" class="headerlink" title="水平方向打开新文件"></a>水平方向打开新文件</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">:sp linuxmi.py  <br>或者  <br>:split linuxmi.py  <br></code></pre></td></tr></table></figure><p>这个命令把窗口横向切分为两个窗口，并把光标置于上面的窗口中。</p><h4 id="垂直方向分屏打开新文件"><a href="#垂直方向分屏打开新文件" class="headerlink" title="垂直方向分屏打开新文件"></a>垂直方向分屏打开新文件</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">:vsp linux.py  <br>:vsplit linux.py <br></code></pre></td></tr></table></figure><p>这个命令把窗口纵向切分为两个窗口，并把光标置于左边的窗口中。</p><h4 id="从命令行直接打开多个文件并分屏"><a href="#从命令行直接打开多个文件并分屏" class="headerlink" title="从命令行直接打开多个文件并分屏"></a>从命令行直接打开多个文件并分屏</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">vim -On file1, file2 ... <span class="hljs-params">#</span> 垂直分屏  <br>vim -on file1, file2 ... <span class="hljs-params">#</span> 水平分屏  <br></code></pre></td></tr></table></figure><h4 id="调整窗口宽度"><a href="#调整窗口宽度" class="headerlink" title="调整窗口宽度"></a>调整窗口宽度</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">Ctrl-w &gt;   <span class="hljs-params">#</span> 向右加宽，默认值为1  <br>Ctrl-w N &gt; <span class="hljs-params">#</span> 向右加宽宽度N  <br>Ctrl-w &lt;   <span class="hljs-params">#</span> 向左加宽，默认值为1 <br>Ctrl-w N &lt; <span class="hljs-params">#</span> 向左加宽宽度N  <br></code></pre></td></tr></table></figure><h4 id="横屏-x2F-竖屏分屏打开当前文件"><a href="#横屏-x2F-竖屏分屏打开当前文件" class="headerlink" title="横屏&#x2F;竖屏分屏打开当前文件"></a><strong>横屏&#x2F;竖屏分屏打开当前文件</strong></h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">Ctrl+w s  <br>Ctrl+w v <br></code></pre></td></tr></table></figure><h4 id="切换分屏"><a href="#切换分屏" class="headerlink" title="切换分屏"></a>切换分屏</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">Ctrl+w h,j,k,l  <br>Ctrl+w 上下左右键  <br>Crtl+w进行分屏窗口的切换 按完以后再按一个w  <br>Crtl+w进行分屏窗口的切换 按完以后再按一个r 互换窗口  <br>Crtl+w进行分屏窗口的切换 按完以后再按一个c 关闭窗口 <br></code></pre></td></tr></table></figure><h4 id="关闭分屏"><a href="#关闭分屏" class="headerlink" title="关闭分屏"></a>关闭分屏</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">Ctrl+W c 关闭当前窗口  <br>Ctrl+w q 关闭当前窗口，若只有一个分屏且退出vim  <br>:only 仅保留当前分屏  <br>:hide 关闭当前分屏  <br></code></pre></td></tr></table></figure><h4 id="调整分屏大小"><a href="#调整分屏大小" class="headerlink" title="调整分屏大小"></a>调整分屏大小</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">Ctrl+w = 所有分屏都统一高度  <br>Ctrl+w + 增加高度，默认值为1  <br>Ctrl+w - 减少高度  <br>10 ctrl+w + 增加10行高度  <br>Ctrl-w N + //当前屏高度加N <br></code></pre></td></tr></table></figure><h4 id="重设当前屏的高度"><a href="#重设当前屏的高度" class="headerlink" title="重设当前屏的高度"></a>重设当前屏的高度</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">:resize 30<br></code></pre></td></tr></table></figure><h4 id="移动分屏"><a href="#移动分屏" class="headerlink" title="移动分屏"></a>移动分屏</h4><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">Ctrl-w + K  <span class="hljs-params">#</span> 将屏幕移动到最顶端 <br>Ctrl-w + J  <span class="hljs-params">#</span> 将屏幕移动到最低端 <br>Ctrl-w + H  <span class="hljs-params">#</span> 将屏幕移动到最左边 <br>Ctrl-w + L  <span class="hljs-params">#</span> 将屏幕移动到最右边 <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Vim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>查看CPU与GPU温度</title>
    <link href="/2022/03/24/Linux/%E6%9F%A5%E7%9C%8BCPU%E4%B8%8EGPU%E6%B8%A9%E5%BA%A6/"/>
    <url>/2022/03/24/Linux/%E6%9F%A5%E7%9C%8BCPU%E4%B8%8EGPU%E6%B8%A9%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="查看CPU温度"><a href="#查看CPU温度" class="headerlink" title="查看CPU温度"></a>查看CPU温度</h2><p>通 <code>lm-sensors</code> 过工具查看：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 安装</span><br>sudo apt-get install lm-sensors -y<br><span class="hljs-built_in">yes</span> | sudo sensors-detect<br><span class="hljs-comment"># 运行</span><br>sensors<br></code></pre></td></tr></table></figure><p>目前我用的这种方式，其他方式可参考：<a href="https://zhuanlan.zhihu.com/p/143123436">如何在Ubuntu Linux上获取CPU温度 - 知乎</a></p><h2 id="查看GPU温度"><a href="#查看GPU温度" class="headerlink" title="查看GPU温度"></a>查看GPU温度</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">nvidia-smi -q -i 0,1 -d TEMPERATURE<br></code></pre></td></tr></table></figure><p><code>-i</code> 是GPU的序号，从0开始，可指定多个GPU</p><h3 id="实时监测多GPU温度"><a href="#实时监测多GPU温度" class="headerlink" title="实时监测多GPU温度"></a>实时监测多GPU温度</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">watch -n 0.5 nvidia-smi -q -i 0,1 -d TEMPERATURE<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈希冲突的应对方法</title>
    <link href="/2022/03/24/todo/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95/"/>
    <url>/2022/03/24/todo/%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E5%BA%94%E5%AF%B9%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>copy from <a href="https://cloud.tencent.com/developer/article/1672781">解决哈希冲突的常用方法分析 - 云+社区 - 腾讯云</a></p></blockquote><h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h3><p><strong>哈希算法</strong>：根据设定的哈希函数H（key）和处理冲突方法将一组关键字映象到一个有限的地址区间上的算法。也称为散列算法、杂凑算法。 </p><p><strong>哈希表</strong>：数据经过哈希算法之后得到的集合。这样关键字和数据在集合中的位置存在一定的关系，可以根据这种关系快速查询。 非哈希表：与哈希表相对应，集合中的 数据和其存放位置没任何关联关系的集合。</p><p>由此可见，哈希算法是一种特殊的算法，能将任意数据散列后映射到有限的空间上，通常计算机软件中用作快速查找或加密使用。</p><p><strong>哈希冲突</strong>：由于哈希算法被计算的数据是无限的，而计算后的结果范围有限，因此总会存在不同的数据经过计算后得到的值相同，这就是哈希冲突。</p><h3 id="2-解决哈希冲突的方法"><a href="#2-解决哈希冲突的方法" class="headerlink" title="2.解决哈希冲突的方法"></a>2.解决哈希冲突的方法</h3><p>解决哈希冲突的方法一般有：开放定址法、链地址法（拉链法）、再哈希法、建立公共溢出区等方法。</p><h4 id="2-1-开放定址法"><a href="#2-1-开放定址法" class="headerlink" title="2.1 开放定址法"></a>2.1 开放定址法</h4><p>从发生冲突的那个单元起，按照一定的次序，从哈希表中找到一个空闲的单元。然后把发生冲突的元素存入到该单元的一种方法。开放定址法需要的表长度要大于等于所需要存放的元素。 在开放定址法中解决冲突的方法有：线行探查法、平方探查法、双散列函数探查法。 开放定址法的缺点在于删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记。只到有下个元素插入才能真正删除该元素。</p><h5 id="2-1-1-线行探查法"><a href="#2-1-1-线行探查法" class="headerlink" title="2.1.1 线行探查法"></a>2.1.1 线行探查法</h5><p>线行探查法是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。</p><h5 id="2-1-2-平方探查法"><a href="#2-1-2-平方探查法" class="headerlink" title="2.1.2 平方探查法"></a>2.1.2 平方探查法</h5><p>平方探查法即是发生冲突时，用发生冲突的单元d[i], 加上 1²、 2²等。即d[i] + 1²，d[i] + 2², d[i] + 3²…直到找到空闲单元。 在实际操作中，平方探查法不能探查到全部剩余的单元。不过在实际应用中，能探查到一半单元也就可以了。若探查到一半单元仍找不到一个空闲单元，表明此散列表太满，应该重新建立。</p><h5 id="2-1-3-双散列函数探查法"><a href="#2-1-3-双散列函数探查法" class="headerlink" title="2.1.3 双散列函数探查法"></a>2.1.3 双散列函数探查法</h5><p>这种方法使用两个散列函数hl和h2。其中hl和前面的h一样，以关键字为自变量，产生一个0至m—l之间的数作为散列地址；h2也以关键字为自变量，产生一个l至m—1之间的、并和m互素的数(即m不能被该数整除)作为探查序列的地址增量(即步长)，探查序列的步长值是固定值l；对于平方探查法，探查序列的步长值是探查次数i的两倍减l；对于双散列函数探查法，其探查序列的步长值是同一关键字的另一散列函数的值。</p><h4 id="2-2-链地址法（拉链法）"><a href="#2-2-链地址法（拉链法）" class="headerlink" title="2.2 链地址法（拉链法）"></a>2.2 链地址法（拉链法）</h4><p>链接地址法的思路是将哈希值相同的元素构成一个同义词的单链表，并将单链表的头指针存放在哈希表的第i个单元中，查找、插入和删除主要在同义词链表中进行。链表法适用于经常进行插入和删除的情况。 如下一组数字,(32、40、36、53、16、46、71、27、42、24、49、64)哈希表长度为13，哈希函数为H(key)&#x3D;key%13,则链表法结果如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs txt">0       <br>1  -&gt; 40 -&gt; 27 -&gt; 53 <br>2<br>3  -&gt; 16 -&gt; 42<br>4<br>5<br>6  -&gt; 32 -&gt; 71<br>7  -&gt; 46<br>8<br>9<br>10 -&gt; 36 -&gt; 49<br>11 -&gt; 24<br>12 -&gt; 64<br></code></pre></td></tr></table></figure><p>注：在java中，链接地址法也是HashMap解决哈希冲突的方法之一，jdk1.7完全采用单链表来存储同义词，jdk1.8则采用了一种混合模式，对于链表长度大于8的，会转换为红黑树存储。</p><h4 id="2-3-再哈希法"><a href="#2-3-再哈希法" class="headerlink" title="2.3 再哈希法"></a>2.3 再哈希法</h4><p>就是同时构造多个不同的哈希函数： Hi &#x3D; RHi(key)   i&#x3D; 1,2,3 … k; 当H1 &#x3D; RH1(key)  发生冲突时，再用H2 &#x3D; RH2(key) 进行计算，直到冲突不再产生，这种方法不易产生聚集，但是增加了计算时间。</p><h4 id="2-4-建立公共溢出区"><a href="#2-4-建立公共溢出区" class="headerlink" title="2.4 建立公共溢出区"></a>2.4 建立公共溢出区</h4><p>将哈希表分为公共表和溢出表，当溢出发生时，将所有溢出数据统一放到溢出区。</p>]]></content>
    
    
    <categories>
      
      <category>TODO</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令: wc 统计文本行数、字符数等</title>
    <link href="/2022/03/24/Linux/LinuxCommand/Linux%E5%91%BD%E4%BB%A4-wc-%E7%BB%9F%E8%AE%A1%E6%96%87%E6%9C%AC%E8%A1%8C%E6%95%B0%E3%80%81%E5%AD%97%E7%AC%A6%E6%95%B0%E7%AD%89/"/>
    <url>/2022/03/24/Linux/LinuxCommand/Linux%E5%91%BD%E4%BB%A4-wc-%E7%BB%9F%E8%AE%A1%E6%96%87%E6%9C%AC%E8%A1%8C%E6%95%B0%E3%80%81%E5%AD%97%E7%AC%A6%E6%95%B0%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<p><code>wc</code> 命令用于统计文件的行数、字符数以及字节数信息。</p><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>wc [选项] 文件…</p><p>选项有：</p><ul><li><p>-l 统计行数</p></li><li><p>-c 统计字节数（一个中文字符占 3 个字节）</p></li><li><p>-m 统计字符数，不能和 <code>-c</code> 连用（一个中文字符占 1 个字符）</p></li><li><p>-w 统计字数（一个字被定义为由<code>空白</code>、<code>跳格</code>或<code>换行字符</code>分隔的字符串）</p></li></ul><p>注：选项可组合使用，但 <code>-m</code> 和 <code>-c</code> 不能组合使用，如果组合使用，或者不使用任何参数，则打印的结果从左到右分别是：行数、字数、字节数、文件名。</p><h4 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h4><h5 id="1-统计一个文件信息"><a href="#1-统计一个文件信息" class="headerlink" title="1.统计一个文件信息"></a>1.统计一个文件信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">wc</span> testfile           <span class="hljs-comment"># testfile文件的统计信息</span></span>  <br>3 92 598 testfile       # testfile文件的行数为3、单词数92、字节数598 <br></code></pre></td></tr></table></figure><h5 id="2-统计多个文件信息"><a href="#2-统计多个文件信息" class="headerlink" title="2.统计多个文件信息"></a>2.统计多个文件信息</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">wc</span> testfile testfile_1 testfile_2  <span class="hljs-comment">#统计三个文件的信息</span></span>  <br>3 92 598 testfile                    #第一个文件行数为3、单词数92、字节数598  <br>9 18 78 testfile_1                   #第二个文件的行数为9、单词数18、字节数78  <br>3 6 32 testfile_2                    #第三个文件的行数为3、单词数6、字节数32  <br>15 116 708 总用量                    #三个文件总共的行数为15、单词数116、字节数708 <br></code></pre></td></tr></table></figure><h5 id="3-配合-cat-使用，统计文件信息，但不打印文件名"><a href="#3-配合-cat-使用，统计文件信息，但不打印文件名" class="headerlink" title="3.配合 cat 使用，统计文件信息，但不打印文件名"></a>3.配合 cat 使用，统计文件信息，但不打印文件名</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> password.md | <span class="hljs-built_in">wc</span></span> <br>     20      22     205<br></code></pre></td></tr></table></figure><h5 id="4-其他"><a href="#4-其他" class="headerlink" title="4.其他"></a>4.其他</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">echo</span> -n <span class="hljs-string">&quot;你好，Mofan&quot;</span> | <span class="hljs-built_in">wc</span> -c <span class="hljs-comment">#中文共9个字节，英文5个，所以输出14</span></span><br>14<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l | grep <span class="hljs-string">&#x27;^d&#x27;</span>| <span class="hljs-built_in">wc</span> -l <span class="hljs-comment"># 当前子目录的数量</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ls</span> -l | grep <span class="hljs-string">&#x27;^-&#x27;</span>| <span class="hljs-built_in">wc</span> -l <span class="hljs-comment"># 当前目录下文件的数量</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> /etc/password | <span class="hljs-built_in">wc</span> -l <span class="hljs-comment"># 当前系统用户数</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">find / -name <span class="hljs-string">&quot;*.sh&quot;</span> | xargs <span class="hljs-built_in">cat</span> | grep -v <span class="hljs-string">&quot;^$&quot;</span> | <span class="hljs-built_in">wc</span> -l <span class="hljs-comment"># 统计目录下所有shell脚本行数（去除空行）</span></span> <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">last | grep [a-zA-Z] | grep -v <span class="hljs-string">&quot;wtmp&quot;</span> | <span class="hljs-built_in">wc</span> -l <span class="hljs-comment"># 统计最近一个月登录用户数</span></span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Linux命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git对比分支差异</title>
    <link href="/2022/03/15/Tools/Git/Git%E5%AF%B9%E6%AF%94%E5%88%86%E6%94%AF%E5%B7%AE%E5%BC%82/"/>
    <url>/2022/03/15/Tools/Git/Git%E5%AF%B9%E6%AF%94%E5%88%86%E6%94%AF%E5%B7%AE%E5%BC%82/</url>
    
    <content type="html"><![CDATA[<h3 id="1-显示出-branch1-和-branch2-中差异的部分"><a href="#1-显示出-branch1-和-branch2-中差异的部分" class="headerlink" title="1. 显示出 branch1 和 branch2 中差异的部分"></a>1. 显示出 branch1 和 branch2 中差异的部分</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git diff branch1 branch2 --<span class="hljs-built_in">stat</span><br></code></pre></td></tr></table></figure><h3 id="2-显示指定文件的详细差异"><a href="#2-显示指定文件的详细差异" class="headerlink" title="2. 显示指定文件的详细差异"></a>2. 显示指定文件的详细差异</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git diff branch1 branch2 &lt;具体文件路径&gt;<br></code></pre></td></tr></table></figure><h3 id="3-显示出所有有差异的文件的详细差异"><a href="#3-显示出所有有差异的文件的详细差异" class="headerlink" title="3. 显示出所有有差异的文件的详细差异"></a>3. 显示出所有有差异的文件的详细差异</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git diff branch1 branch2<br></code></pre></td></tr></table></figure><h3 id="4-查看-branch1-分支有，而-branch2-中没有的-log"><a href="#4-查看-branch1-分支有，而-branch2-中没有的-log" class="headerlink" title="4. 查看 branch1 分支有，而 branch2 中没有的 log"></a>4. 查看 branch1 分支有，而 branch2 中没有的 log</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">log</span> branch1 ^branch2<br></code></pre></td></tr></table></figure><h3 id="5-查看-branch2-中比-branch1-中多提交了哪些内容"><a href="#5-查看-branch2-中比-branch1-中多提交了哪些内容" class="headerlink" title="5. 查看 branch2 中比 branch1 中多提交了哪些内容"></a>5. 查看 branch2 中比 branch1 中多提交了哪些内容</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">log</span> branch1..branch2<br></code></pre></td></tr></table></figure><p>注意，列出来的是两个点后边（此处即branch2）多提交的内容。</p><h3 id="6-不知道谁提交的多谁提交的少，单纯想知道有什么不一样"><a href="#6-不知道谁提交的多谁提交的少，单纯想知道有什么不一样" class="headerlink" title="6. 不知道谁提交的多谁提交的少，单纯想知道有什么不一样"></a>6. 不知道谁提交的多谁提交的少，单纯想知道有什么不一样</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">log</span> branch1...branch2<br></code></pre></td></tr></table></figure><h3 id="7-在上述情况下，在显示出每个提交是在哪个分支上"><a href="#7-在上述情况下，在显示出每个提交是在哪个分支上" class="headerlink" title="7. 在上述情况下，在显示出每个提交是在哪个分支上"></a>7. 在上述情况下，在显示出每个提交是在哪个分支上</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">log</span> -lefg-right branch1...branch2<br></code></pre></td></tr></table></figure><p>注意 commit 后面的箭头，根据我们在 –left-right branch1…branch2 的顺序，左箭头 &lt; 表示是 branch1 的，右箭头 &gt; 表示是branch2的。</p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker镜像相关</title>
    <link href="/2022/03/15/Docker/Docker%E9%95%9C%E5%83%8F%E7%9B%B8%E5%85%B3/"/>
    <url>/2022/03/15/Docker/Docker%E9%95%9C%E5%83%8F%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h3 id="将镜像打包成文件或从文件载入镜像"><a href="#将镜像打包成文件或从文件载入镜像" class="headerlink" title="将镜像打包成文件或从文件载入镜像"></a>将镜像打包成文件或从文件载入镜像</h3><p><strong>镜像打包成文件</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker save -o &lt;文件名&gt; &lt;待打包镜像&gt;<br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker save -o nps.tar ffdfghdf/nps<br></code></pre></td></tr></table></figure><p><strong>从文件导入镜像</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker load --input &lt;文件名&gt;<br>或者<br>docker load &lt; &lt;文件名&gt;<br></code></pre></td></tr></table></figure><p>eg:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">docker load &lt; npc.tar<br></code></pre></td></tr></table></figure><p>TODO:<br><a href="https://www.cnblogs.com/bigben0123/p/7592970.html">docker 拷贝镜像文件 - Bigben - 博客园</a></p><p><a href="https://blog.csdn.net/cs_sword2000/article/details/98453495">(17条消息) docker image 重命名_cs_sword2000的博客-CSDN博客_docker image 重命名</a></p><p><a href="https://blog.csdn.net/qq_24036403/article/details/101125233">(17条消息) Docker将自己的镜像发布到个人私有仓库_1024困不住-CSDN博客</a></p><p><a href="https://www.runoob.com/docker/docker-build-command.html">Docker build 命令 | 菜鸟教程</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac删除launchpad里带问号的图标</title>
    <link href="/2022/03/10/problems/Mac%E5%88%A0%E9%99%A4launchpad%E9%87%8C%E5%B8%A6%E9%97%AE%E5%8F%B7%E7%9A%84%E5%9B%BE%E6%A0%87/"/>
    <url>/2022/03/10/problems/Mac%E5%88%A0%E9%99%A4launchpad%E9%87%8C%E5%B8%A6%E9%97%AE%E5%8F%B7%E7%9A%84%E5%9B%BE%E6%A0%87/</url>
    
    <content type="html"><![CDATA[<p>按住 Option，然后点击图标左上角x号。</p>]]></content>
    
    
    <categories>
      
      <category>Problems</category>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库读写分离架构，主从数据一致性问题</title>
    <link href="/2022/03/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%EF%BC%8C%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/"/>
    <url>/2022/03/03/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E6%9E%B6%E6%9E%84%EF%BC%8C%E4%B8%BB%E4%BB%8E%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s/LMFCfb94f-CvN0DZJl1Qaw">https://mp.weixin.qq.com/s/LMFCfb94f-CvN0DZJl1Qaw</a></p><h4 id="主从同步流程"><a href="#主从同步流程" class="headerlink" title="主从同步流程"></a>主从同步流程</h4><p>1.执行更新sql语句。</p><p>2.主库写成功时，binlog会更新。</p><p>3.主库binlog dump 线程将binlog的更新部分发给从库</p><p>4.从库io线程收到binlog更新部分，然后写入到relay log中</p><p>5.从库sql线程读取relay log内容，重放执行sql，最后主从一致。</p><h4 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h4><p><a href="https://cloud.tencent.com/developer/article/1833688#:~:text=%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB,%E8%AF%BB%20%E8%BF%99%E5%87%A0%E7%B1%BB%E9%97%AE%E9%A2%98%E3%80%82">mysql基础(七) 数据库事务隔离级别 - 云+社区 - 腾讯云</a></p><p>读未提交、读提交、可重复度、串行读</p><p>这四个级别可以逐个解决脏读 、不可重复读 、幻读 这几类问题</p><h4 id="脏读、不可重复度、幻读问题"><a href="#脏读、不可重复度、幻读问题" class="headerlink" title="脏读、不可重复度、幻读问题"></a>脏读、不可重复度、幻读问题</h4><p><a href="https://cloud.tencent.com/developer/article/1450773">快速理解脏读、不可重复读、幻读和MVCC - 云+社区 - 腾讯云</a></p><p>不可重复读和幻读到底有什么区别呢？</p><p>(1) 不可重复读是读取了其他事务更改的数据，针对update操作</p><p>(2) 幻读是读取了其他事务新增的数据，针对insert和delete操作</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Mac鼠标与触摸板手势不工作</title>
    <link href="/2022/02/24/problems/Mac%E9%BC%A0%E6%A0%87%E4%B8%8E%E8%A7%A6%E6%91%B8%E6%9D%BF%E6%89%8B%E5%8A%BF%E4%B8%8D%E5%B7%A5%E4%BD%9C/"/>
    <url>/2022/02/24/problems/Mac%E9%BC%A0%E6%A0%87%E4%B8%8E%E8%A7%A6%E6%91%B8%E6%9D%BF%E6%89%8B%E5%8A%BF%E4%B8%8D%E5%B7%A5%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p>苹果鼠标与触摸板除了简单的移动光标及点击动作正常工作，其他手势都不能工作。</p><p>解决：<br>在终端执行：<code>killall Dock</code> 命令可解决。</p><p>参考：</p><ul><li><a href="https://discussions.apple.com/thread/251461614">3 and 4 Finger Gestures Stopped working i… - Apple Community</a></li><li><a href="https://www.reddit.com/r/MacOS/comments/khofa2/trackpad_gesture_not_working/">TrackPad Gesture not working : MacOS</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Problems</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go defer调用顺序问题</title>
    <link href="/2022/02/21/Go-defer%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/"/>
    <url>/2022/02/21/Go-defer%E8%B0%83%E7%94%A8%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>关于Go中defer</p><ol><li>defer 方法的参数在定义的时候就确定了。</li><li>defer中的参数如果是调用函数得来的值，则在程序结束执行defer的时候从第一个defer开始计算，从上到下先把函数参数结果算出来，然后再按defer定义顺序逆序执行defer函数（也可以理解为最靠近关键字defer的那层函数), 其实读到这里，你也许更加明白了第 1 条。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">calc</span><span class="hljs-params">(index <span class="hljs-type">string</span>, a, b <span class="hljs-type">int</span>, flag <span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span> &#123;<br><span class="hljs-comment">// 这个flag用来标记的，方便追踪调用顺序</span><br>fmt.Println(time.Now().String(), <span class="hljs-string">&quot;   &quot;</span>, flag)<br>ret := a + b<br>fmt.Println(index, a, b, ret)<br><span class="hljs-keyword">return</span> ret<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1, s2 := <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;10&quot;</span><br>a, b := <span class="hljs-number">1</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">defer</span> calc(s1, a, calc(s2, a, calc(s2, a, calc(s2, a, b, <span class="hljs-number">1</span>), <span class="hljs-number">2</span>), <span class="hljs-number">3</span>), <span class="hljs-number">12</span>)<br>a = <span class="hljs-number">0</span><br>s1, s2 = <span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;20&quot;</span><br><span class="hljs-keyword">defer</span> calc(s1, a, calc(s2, a, calc(s2, a, calc(s2, a, b, <span class="hljs-number">4</span>), <span class="hljs-number">5</span>), <span class="hljs-number">6</span>), <span class="hljs-number">11</span>)<br>b = <span class="hljs-number">1</span><br>s1, s2 = <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;30&quot;</span><br><span class="hljs-keyword">defer</span> calc(s1, a, calc(s2, a, calc(s2, a, calc(s2, a, b, <span class="hljs-number">7</span>), <span class="hljs-number">8</span>), <span class="hljs-number">9</span>), <span class="hljs-number">10</span>)<br>&#125;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">1. defer 方法的参数在定义的时候就确定了</span><br><span class="hljs-comment">2. defer中的参数如果是调用函数得来的值，则在程序结束执行defer的时候从第一个defer开始计算，从上到下先把函数参数结果算出来，然后再按defer定义顺序逆序执行defer函数（也可以理解为最靠近关键字defer的那层函数), 其实读到这里，你也许更加明白了第 1 条。</span><br><span class="hljs-comment"></span><br><span class="hljs-comment"></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">执行结果:</span><br><span class="hljs-comment">2022-02-21 10:11:13.83618 +0800 CST m=+0.000127293     1</span><br><span class="hljs-comment">10 1 1 2</span><br><span class="hljs-comment">2022-02-21 10:11:13.836474 +0800 CST m=+0.000421376     2</span><br><span class="hljs-comment">10 1 2 3</span><br><span class="hljs-comment">2022-02-21 10:11:13.836481 +0800 CST m=+0.000428793     3</span><br><span class="hljs-comment">10 1 3 4</span><br><span class="hljs-comment">2022-02-21 10:11:13.836487 +0800 CST m=+0.000434543     4</span><br><span class="hljs-comment">20 0 1 1</span><br><span class="hljs-comment">2022-02-21 10:11:13.836493 +0800 CST m=+0.000440251     5</span><br><span class="hljs-comment">20 0 1 1</span><br><span class="hljs-comment">2022-02-21 10:11:13.836498 +0800 CST m=+0.000445584     6</span><br><span class="hljs-comment">20 0 1 1</span><br><span class="hljs-comment">2022-02-21 10:11:13.836503 +0800 CST m=+0.000450918     7</span><br><span class="hljs-comment">30 0 1 1</span><br><span class="hljs-comment">2022-02-21 10:11:13.836509 +0800 CST m=+0.000456168     8</span><br><span class="hljs-comment">30 0 1 1</span><br><span class="hljs-comment">2022-02-21 10:11:13.836514 +0800 CST m=+0.000461584     9</span><br><span class="hljs-comment">30 0 1 1</span><br><span class="hljs-comment">2022-02-21 10:11:13.836519 +0800 CST m=+0.000466793     10</span><br><span class="hljs-comment">3 0 1 1</span><br><span class="hljs-comment">2022-02-21 10:11:13.836525 +0800 CST m=+0.000472209     11</span><br><span class="hljs-comment">2 0 1 1</span><br><span class="hljs-comment">2022-02-21 10:11:13.83653 +0800 CST m=+0.000477543     12</span><br><span class="hljs-comment">1 1 4 5</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">// 不太理解这个调用顺序，于是引出了上面的</span><br><span class="hljs-comment">func calc(index string, a, b int) int &#123;</span><br><span class="hljs-comment">ret := a + b</span><br><span class="hljs-comment">fmt.Println(index, a, b, ret)</span><br><span class="hljs-comment">return ret</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">func main() &#123;</span><br><span class="hljs-comment">a := 1</span><br><span class="hljs-comment">b := 2</span><br><span class="hljs-comment">defer calc(&quot;1&quot;, a, calc(&quot;10&quot;, a, b))</span><br><span class="hljs-comment">a = 0</span><br><span class="hljs-comment">defer calc(&quot;2&quot;, a, calc(&quot;20&quot;, a, b))</span><br><span class="hljs-comment">b = 1</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">执行结果:</span><br><span class="hljs-comment">10 1 1 2</span><br><span class="hljs-comment">20 0 1 1</span><br><span class="hljs-comment">2 0 1 1</span><br><span class="hljs-comment">1 1 2 3</span><br><span class="hljs-comment">*/</span><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>多goroutine协同工作Demo</title>
    <link href="/2021/11/19/%E5%A4%9Agoroutine%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9CDemo/"/>
    <url>/2021/11/19/%E5%A4%9Agoroutine%E5%8D%8F%E5%90%8C%E5%B7%A5%E4%BD%9CDemo/</url>
    
    <content type="html"><![CDATA[<p>在一个长无序slice里查找目标值。<br>思路：<br>将长slice分块，用多个goroutine去找，如果有一个找到就结束goroutine并返回相对下标值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-comment">// 用于确定目标值位置的信息</span><br><span class="hljs-keyword">type</span> Index <span class="hljs-keyword">struct</span> &#123;<br>Base <span class="hljs-type">int</span><br>Now  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>index := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> Index)<br><span class="hljs-comment">// 待查找slice</span><br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">19</span>, <span class="hljs-number">32</span>, <span class="hljs-number">44</span>, <span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">7</span>, <span class="hljs-number">24</span>, <span class="hljs-number">932</span>, <span class="hljs-number">88</span>, <span class="hljs-number">66</span>, <span class="hljs-number">123</span>&#125;<br><br><span class="hljs-comment">// 分割，这里不会发生内存拷贝</span><br>limit, num, base := <span class="hljs-number">4</span>, <span class="hljs-built_in">len</span>(slice)/<span class="hljs-number">4</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> base &lt; num &#123;<br><span class="hljs-keyword">go</span> findTarget(slice[base*limit:base*limit+limit], <span class="hljs-number">932</span>, base, index)<br>base++<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(slice)%limit != <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">go</span> findTarget(slice[base*limit:], <span class="hljs-number">932</span>, base, index)<br>&#125;<br><br><span class="hljs-comment">// 超时检测</span><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> t := &lt;-index:<br>fmt.Printf(<span class="hljs-string">&quot;下标为: %d \n&quot;</span>, t.Base*limit+t.Now)<br><span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">3</span> * time.Second):<br>fmt.Println(<span class="hljs-string">&quot;timeout&quot;</span>)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">findTarget</span><span class="hljs-params">(arr []<span class="hljs-type">int</span>, target <span class="hljs-type">int</span>, base <span class="hljs-type">int</span>, index <span class="hljs-keyword">chan</span> Index)</span></span> &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> t := &lt;-index:<br>index &lt;- t<br><span class="hljs-keyword">return</span><br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> arr &#123;<br>fmt.Println(arr[i])<br><span class="hljs-keyword">if</span> arr[i] == target &#123;<br>index &lt;- Index&#123;<br>Base: base,<br>Now:  i,<br>&#125;<br><span class="hljs-keyword">return</span><br>&#125;<br>time.Sleep(time.Second)<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go 数组与切片</title>
    <link href="/2021/11/18/Go/%E6%95%B0%E7%BB%84/"/>
    <url>/2021/11/18/Go/%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是由相同类型的元素的集合组成的数据结构，数组中的元素由一块连续的内存存储，因此可通过索引快速地访问数组中特定的元素。</p><p>Go的数组在编译期间初始化，初始化的过程会直接读写内存（如元素的赋值与更新）。数组初始化后无法改变，即数组长度与元素类型不可变。</p><p>Go中数组的类型在编译期间确定，类型受元素类型与数组长度影响，只有二者相同才认为是相同类型数组。</p><p>Go中数组在编译期间，会根据数组长度决定数组初始化的位置</p><ul><li>长度小于等于4的数组在栈中初始化。</li><li>大于4的数组在静态存储区初始化，然后拷贝到栈上。</li></ul><p>Go数组的表示：数组第一个元素的指针，元素类型的长度，元素的数量</p><p>Go为保证数组和字符串的访问不越界，分别在编译阶段与运行阶段进行判断。</p><ul><li>编译阶段：可发现较简单的错误，如：非整数索引、负数索引、大于数组长度的索引</li><li>运行阶段：适用于用变量访问数组</li></ul><h2 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h2><p>切片的长度是动态的。</p><p>在编译阶段生成的切片类型，类型只受切片中元素的类型影响（注意与数组区分，数组还受长度影响）。</p><p>在运行时，切片由<code>reflect.SliceHeader</code>结构体表示，包含三个字段：</p><ul><li>Data 指向数组的指针</li><li>Len 当前切片的长度</li><li>Cap 当前切片的容量，即Data数组的大小</li></ul><p>切片的底层与数组一样，仍然有连续的内存存储，只是，切片的概念相比于数组，在连续内存空间上，多了长度和容量两个标识。</p><h3 id="切片初始化"><a href="#切片初始化" class="headerlink" title="切片初始化"></a>切片初始化</h3><ul><li>通过下标的方式获得数组或者切片的一部分, arr[0:3] or slice[0:3]<ul><li>这种方式最原始，即最接近汇编语言的方式</li><li>通过这种方式不会拷贝原数组或原切片中的数据，只是创建了一个指向原数据的切片结构体，故改变新切片中的数据会同时改变原数据</li></ul></li><li>使用字面量初始化新的切片, slice :&#x3D; []int{1, 2, 3}</li><li>使用关键字make, slice :&#x3D; make([]int, 10)</li></ul><p>切片的操作基本都是在编译期间完成的，除了访问切片的长度、容量或者其中的元素之外，编译期间也会将包含 <code>range</code> 关键字的遍历转换成形式更简单的循环</p><h3 id="访问切片"><a href="#访问切片" class="headerlink" title="访问切片"></a>访问切片</h3><p>使用 <code>len</code> 和 <code>cap</code> 可获取切片的长度和容量.</p><h3 id="追加扩容"><a href="#追加扩容" class="headerlink" title="追加扩容"></a>追加扩容</h3><blockquote><p> 可参考:  <a href="https://juejin.cn/post/6844903812331732999">Go slice扩容深度分析 - 掘金</a></p></blockquote><p>append的时候发生扩容的动作</p><ul><li>append单个元素，或者append少量的多个元素，这里的少量指double之后的容量能容纳，这样就会走以下扩容流程<ul><li>不足1024，双倍扩容</li><li>超过1024的，1.25倍扩容</li></ul></li><li>若是append多个元素，且double后的容量不能容纳，直接使用预估的容量。</li></ul><p><strong>此外，以上两个分支得到新容量后，均需要根据slice的类型size，算出新的容量所需的内存情况<code>capmem</code>，然后再进行<code>capmem</code>向上取整，得到新的所需内存，除上类型size，得到真正的最终容量,作为新的slice的容量。</strong></p><h3 id="切片拷贝"><a href="#切片拷贝" class="headerlink" title="切片拷贝"></a>切片拷贝</h3><p>copy(a, b)</p><p>拷贝可发生在编译阶段与运行时</p><ul><li>区别：<ul><li>编译阶段直接使用 <code>copy</code></li><li>运行时拷贝会将 <code>copy</code> 替换成 <code>runtime.slicecopy</code></li></ul></li><li>相同点：<ul><li>两种拷贝方式最终都通过 <code>runtime.memmove</code> 将整块内存的内容拷贝到目标的内存区域中</li></ul></li></ul><p>相较于通过遍历的的方式达到拷贝的效果，<code>runtime.memmove</code> 可以达到更高的性能，但大片内存拷贝仍会占用更多的资源，开发中要注意到内存拷贝对性能的影响。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>多个goroutine，其中一个发生panic，程序会发生什么</title>
    <link href="/2021/11/18/goroutine%E9%87%8C%E5%8F%91%E7%94%9F%E4%BA%86panic%E4%BC%9A%E6%80%8E%E6%A0%B7/"/>
    <url>/2021/11/18/goroutine%E9%87%8C%E5%8F%91%E7%94%9F%E4%BA%86panic%E4%BC%9A%E6%80%8E%E6%A0%B7/</url>
    
    <content type="html"><![CDATA[<h3 id="多个goroutine，其中一个发生panic，程序会发生什么"><a href="#多个goroutine，其中一个发生panic，程序会发生什么" class="headerlink" title="多个goroutine，其中一个发生panic，程序会发生什么"></a>多个goroutine，其中一个发生panic，程序会发生什么</h3><p>发生panic后，从当前层依次向上执行defer函数，如果在这个过程中被recover捕获该panic，那么程序不会崩溃，否则，待所有defer执行完后，程序崩溃。</p><blockquote><p>以下来自知乎:<br>如果某goroutine在某函数&#x2F;方法F的调用时出现panic，一个被称为”panicking”的过程将被激活。该过程先会调用函数F的defer函数(如果有的话)，然后依次向上，调用函数F的调用者的defer函数，直至该goroutine的顶层函数，即启动该goroutine时(go T())的那个函数T。如果函数T有defer函数，那么defer会被调用。在整个paniking过程的defer调用链中，如果没有使用recover捕获该panic，那么panicking过程的最后一个环节将会发生：整个程序异常退出(无论发生panic的goroutine是否为main Goroutine)并输出panic相关信息。</p></blockquote><p>验证代码:<br>对比recover代码注视和取消注视便可理解</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;main&quot;</span>)<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;main_end&quot;</span>)<br>&#125;()<br><br>hello()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello_1&quot;</span>)<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 如果没有捕获错误的地方程序会崩溃</span><br><span class="hljs-comment">//if err := recover(); err != nil &#123;</span><br><span class="hljs-comment">//fmt.Println(&quot;hello_1, rerecrecover&quot;)</span><br><span class="hljs-comment">//&#125;</span><br>fmt.Println(<span class="hljs-string">&quot;world_1&quot;</span>)<br>&#125;()<br><br>hello2()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">hello2</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;hello_2&quot;</span>)<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;world_2&quot;</span>)<br>&#125;()<br><br>a, b := <span class="hljs-number">666</span>, <span class="hljs-number">0</span><br>c := a / b<br>fmt.Println(c)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络1</title>
    <link href="/2021/11/14/%E7%BD%91%E7%BB%9C1/"/>
    <url>/2021/11/14/%E7%BD%91%E7%BB%9C1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>此部分内容来自于: <a href="https://github.com/wolverinn/Waking-Up">https://github.com/wolverinn/Waking-Up</a>, 感谢!</p></blockquote><!-- GFM-TOC --><ul><li>传输层：TCP和UDP<ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-three-way-handshake">什么是三次握手？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B">什么是四次挥手？</a></li><li><a href="#TCP%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">TCP如何实现流量控制？</a></li><li><a href="#TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84">TCP的拥塞控制是怎么实现的？</a></li><li><a href="#TCP%E4%B8%8EUDP%E7%9A%84%E5%8C%BA%E5%88%AB">TCP与UDP的区别</a></li><li><a href="#TCP%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7">TCP如何保证传输的可靠性</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFTCP%E7%B2%98%E5%8C%85">什么是TCP粘包？</a></li></ul></li><li>应用层：HTTP和HTTPS<ul><li><a href="#HTTP%E5%92%8CHTTPS%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">HTTP和HTTPS有什么区别？</a></li><li><a href="#GET%E4%B8%8EPOST%E7%9A%84%E5%8C%BA%E5%88%AB">GET与POST的区别？</a></li><li><a href="#Session%E4%B8%8ECookie%E7%9A%84%E5%8C%BA%E5%88%AB">Session与Cookie的区别？</a></li><li><a href="#%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E8%8E%B7%E5%BE%97%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B-%E8%B6%8A%E8%AF%A6%E7%BB%86%E8%B6%8A%E5%A5%BD">从输入网址到获得页面的过程 (越详细越好)？</a></li><li><a href="#HTTP%E8%AF%B7%E6%B1%82%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%E7%A0%81">HTTP请求有哪些常见状态码？</a></li></ul></li><li><a href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84">计算机网络体系结构</a></li><li>网络层协议<ul><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFRIP-Routing-Information-Protocol-%E8%B7%9D%E7%A6%BB%E7%9F%A2%E9%87%8F%E8%B7%AF%E7%94%B1%E5%8D%8F%E8%AE%AE-%E7%AE%97%E6%B3%95%E6%98%AF%E4%BB%80%E4%B9%88">什么是RIP (距离矢量路由协议)?</a></li><li><a href="#IP%E5%9C%B0%E5%9D%80%E7%9A%84%E5%88%86%E7%B1%BB">IP地址的分类？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E5%8F%AB%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91">什么叫划分子网？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFARP%E5%8D%8F%E8%AE%AE-Address-Resolution-Protocol">什么是ARP协议？</a></li><li><a href="#%E4%BB%80%E4%B9%88%E6%98%AFNAT-Network-Address-Translation-%E7%BD%91%E7%BB%9C%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2">什么是NAT (网络地址转换)？</a></li></ul></li><li><a href="#%E5%8F%82%E8%80%83">参考</a><!-- GFM-TOC --></li></ul><hr><h3 id="什么是三次握手-three-way-handshake-？"><a href="#什么是三次握手-three-way-handshake-？" class="headerlink" title="什么是三次握手 (three-way handshake)？"></a>什么是三次握手 (three-way handshake)？</h3><p><img src="https://www.cmdbyte.com/2021/202111142224112.png" alt="三次握手"></p><ul><li>第一次握手：Client将SYN置1，随机产生一个初始序列号seq发送给Server，进入SYN_SENT状态；</li><li>第二次握手：Server收到Client的SYN&#x3D;1之后，知道客户端请求建立连接，将自己的SYN置1，ACK置1，产生一个acknowledge number&#x3D;sequence number+1，并随机产生一个自己的初始序列号，发送给客户端；进入SYN_RCVD状态；</li><li>第三次握手：客户端检查acknowledge number是否为序列号+1，ACK是否为1，检查正确之后将自己的ACK置为1，产生一个acknowledge number&#x3D;服务器发的序列号+1，发送给服务器；进入ESTABLISHED状态；服务器检查ACK为1和acknowledge number为序列号+1之后，也进入ESTABLISHED状态；完成三次握手，连接建立。</li></ul><h5 id="TCP建立连接可以两次握手吗？为什么"><a href="#TCP建立连接可以两次握手吗？为什么" class="headerlink" title="TCP建立连接可以两次握手吗？为什么?"></a>TCP建立连接可以两次握手吗？为什么?</h5><p>不可以。可能会出现以下情况：<strong>已失效的连接请求报文段又传到了服务器端</strong>。</p><blockquote><p>client 发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。server 由于收不到确认，就知道 client 并没有要求建立连接。</p></blockquote><h5 id="可以采用四次握手吗？为什么？"><a href="#可以采用四次握手吗？为什么？" class="headerlink" title="可以采用四次握手吗？为什么？"></a>可以采用四次握手吗？为什么？</h5><p>可以。但是会降低传输的效率。</p><p>四次握手是指：第二次握手：Server只发送ACK和acknowledge number；而Server的SYN和初始序列号在第三次握手时发送；原来协议中的第三次握手变为第四次握手。出于优化目的，四次握手中的二、三可以合并。</p><h5 id="第三次握手中，如果客户端的ACK未送达服务器，会怎样？"><a href="#第三次握手中，如果客户端的ACK未送达服务器，会怎样？" class="headerlink" title="第三次握手中，如果客户端的ACK未送达服务器，会怎样？"></a>第三次握手中，如果客户端的ACK未送达服务器，会怎样？</h5><p>由于Server没有收到ACK确认，因此会重发之前的SYN+ACK（默认重发五次，之后自动关闭连接），Client收到后会重新传ACK给Server。</p><p>如果Client向服务器发送数据，服务器会以RST包响应。</p><h5 id="如果已经建立了连接，但客户端出现了故障怎么办？"><a href="#如果已经建立了连接，但客户端出现了故障怎么办？" class="headerlink" title="如果已经建立了连接，但客户端出现了故障怎么办？"></a>如果已经建立了连接，但客户端出现了故障怎么办？</h5><p>服务器每收到一次客户端的请求后都会重新复位一个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p><h5 id="初始序列号是什么？"><a href="#初始序列号是什么？" class="headerlink" title="初始序列号是什么？"></a>初始序列号是什么？</h5><p>TCP连接的一方A，随机选择一个32位的序列号（Sequence Number）作为发送数据的初始序列号（Initial Sequence Number，ISN），比如为1000，以该序列号为原点，对要传送的数据进行编号：1001、1002…三次握手时，把这个初始序列号传送给另一方B，以便在传输数据时，B可以确认什么样的数据编号是合法的；同时在进行数据传输时，A还可以确认B收到的每一个字节，如果A收到了B的确认编号（acknowledge number）是2001，就说明编号为1001-2000的数据已经被B成功接受。</p><h3 id="什么是四次挥手？"><a href="#什么是四次挥手？" class="headerlink" title="什么是四次挥手？"></a>什么是四次挥手？</h3><p><img src="https://www.cmdbyte.com/2021/202111142230620.png" alt="四次挥手"></p><ul><li>第一次挥手：Client将FIN置为1，发送一个序列号seq给Server；进入FIN_WAIT_1状态；</li><li>第二次挥手：Server收到FIN之后，发送一个ACK&#x3D;1，acknowledge number&#x3D;收到的序列号+1；进入CLOSE_WAIT状态。此时客户端已经没有要发送的数据了，但仍可以接受服务器发来的数据。</li><li>第三次挥手：Server将FIN置1，发送一个序列号给Client；进入LAST_ACK状态；</li><li>第四次挥手：Client收到服务器的FIN后，进入TIME_WAIT状态；接着将ACK置1，发送一个acknowledge number&#x3D;序列号+1给服务器；服务器收到后，确认acknowledge number后，变为CLOSED状态，不再向客户端发送数据。客户端等待2*MSL（报文段最长寿命）时间后，也进入CLOSED状态。完成四次挥手。</li></ul><h5 id="为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE-WAIT状态意义是什么）？"><a href="#为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE-WAIT状态意义是什么）？" class="headerlink" title="为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？"></a>为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手（CLOSE_WAIT状态意义是什么）？</h5><p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接收到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。</p><h5 id="如果第二次挥手时服务器的ACK没有送达客户端，会怎样？"><a href="#如果第二次挥手时服务器的ACK没有送达客户端，会怎样？" class="headerlink" title="如果第二次挥手时服务器的ACK没有送达客户端，会怎样？"></a>如果第二次挥手时服务器的ACK没有送达客户端，会怎样？</h5><p>客户端没有收到ACK确认，会重新发送FIN请求。</p><h5 id="客户端TIME-WAIT状态的意义是什么？"><a href="#客户端TIME-WAIT状态的意义是什么？" class="headerlink" title="客户端TIME_WAIT状态的意义是什么？"></a>客户端TIME_WAIT状态的意义是什么？</h5><p>第四次挥手时，客户端发送给服务器的ACK有可能丢失，TIME_WAIT状态就是用来重发可能丢失的ACK报文。如果Server没有收到ACK，就会重发FIN，如果Client在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2MSL，防止Server没有收到ACK而不断重发FIN。</p><p>MSL(Maximum Segment Lifetime)，指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。</p><h3 id="TCP如何实现流量控制？"><a href="#TCP如何实现流量控制？" class="headerlink" title="TCP如何实现流量控制？"></a>TCP如何实现流量控制？</h3><p><img src="https://www.cmdbyte.com/2021/202111142233756.png" alt="滑动窗口"></p><p>使用滑动窗口协议实现流量控制。防止发送方发送速率太快，接收方缓存区不够导致溢出。接收方会维护一个接收窗口 receiver window（窗口大小单位是字节），接受窗口的大小是根据自己的资源情况动态调整的，在返回ACK时将接受窗口大小放在TCP报文中的窗口字段告知发送方。发送窗口的大小不能超过接受窗口的大小，只有当发送方发送并收到确认之后，才能将发送窗口右移。</p><p>发送窗口的上限为接受窗口和拥塞窗口中的较小值。接受窗口表明了接收方的接收能力，拥塞窗口表明了网络的传送能力。</p><h5 id="什么是零窗口（接收窗口为0时会怎样）？"><a href="#什么是零窗口（接收窗口为0时会怎样）？" class="headerlink" title="什么是零窗口（接收窗口为0时会怎样）？"></a>什么是零窗口（接收窗口为0时会怎样）？</h5><p>如果接收方没有能力接收数据，就会将接收窗口设置为0，这时发送方必须暂停发送数据，但是会启动一个持续计时器(persistence timer)，到期后发送一个大小为1字节的探测数据包，以查看接收窗口状态。如果接收方能够接收数据，就会在返回的报文中更新接收窗口大小，恢复数据传送。</p><h3 id="TCP的拥塞控制是怎么实现的？"><a href="#TCP的拥塞控制是怎么实现的？" class="headerlink" title="TCP的拥塞控制是怎么实现的？"></a>TCP的拥塞控制是怎么实现的？</h3><p><img src="https://www.cmdbyte.com/2021/202111142235704.png" alt="拥塞控制"></p><p>拥塞控制主要由四个算法组成：<strong>慢启动（Slow Start）、拥塞避免（Congestion voidance）、快重传 （Fast Retransmit）、快恢复（Fast Recovery）</strong></p><ol><li>慢启动：刚开始发送数据时，先把拥塞窗口（congestion window）设置为一个最大报文段MSS的数值，每收到一个新的确认报文之后，就把拥塞窗口加1个MSS。这样每经过一个传输轮次（或者说是每经过一个往返时间RTT），拥塞窗口的大小就会加倍</li></ol><p><img src="https://www.cmdbyte.com/2021/202111142236867.png" alt="slow start"></p><ol start="2"><li><p>拥塞避免：当拥塞窗口的大小达到慢开始门限(slow start threshold)时，开始执行拥塞避免算法，拥塞窗口大小不再指数增加，而是线性增加，即每经过一个传输轮次只增加1MSS.  </p><blockquote><p>无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。<strong>（这是不使用快重传的情况）</strong></p></blockquote></li><li><p>快重传：快重传要求接收方在收到一个失序的报文段后就立即发出<strong>重复确认</strong>（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时捎带确认。快重传算法规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</p></li></ol><p><img src="https://www.cmdbyte.com/2021/202111142236702.png" alt="快重传"></p><ol start="4"><li>快恢复：当发送方连续收到三个重复确认时，就把慢开始门限减半，然后执行拥塞避免算法。不执行慢开始算法的原因：因为如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方认为现在网络可能没有出现拥塞。<br>也有的快重传是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3*MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络的资源而是停留在接收方的缓存中。可见现在网络中减少了三个分组。因此可以适当把拥塞窗口扩大些。</li></ol><h3 id="TCP与UDP的区别"><a href="#TCP与UDP的区别" class="headerlink" title="TCP与UDP的区别"></a>TCP与UDP的区别</h3><ol><li><p>TCP是面向连接的，UDP是无连接的；</p><blockquote><p>什么叫无连接？</p><p>UDP发送数据之前不需要建立连接</p></blockquote></li><li><p>TCP是可靠的，UDP不可靠；</p><blockquote><p>什么叫不可靠</p><p>UDP接收方收到报文后，不需要给出任何确认</p></blockquote></li><li><p>TCP只支持点对点通信，UDP支持一对一、一对多、多对一、多对多；</p></li><li><p>TCP是面向字节流的，UDP是面向报文的；</p><blockquote><p>什么意思？</p><p>面向字节流是指发送数据时以字节为单位，一个数据包可以拆分成若干组进行发送，而UDP一个报文只能一次发完。</p></blockquote></li><li><p>TCP有拥塞控制机制，UDP没有。网络出现的拥塞不会使源主机的发送速率降低，这对某些实时应用是很重要的，比如媒体通信，游戏；</p></li><li><p>TCP首部开销（20字节）比UDP首部开销（8字节）要大</p></li><li><p>UDP 的主机不需要维持复杂的连接状态表</p></li></ol><h5 id="什么时候选择TCP，什么时候选UDP？"><a href="#什么时候选择TCP，什么时候选UDP？" class="headerlink" title="什么时候选择TCP，什么时候选UDP？"></a>什么时候选择TCP，什么时候选UDP？</h5><p>对某些实时性要求比较高的情况，选择UDP，比如游戏，媒体通信，实时视频流（直播），即使出现传输错误也可以容忍；其它大部分情况下，HTTP都是用TCP，因为要求传输的内容可靠，不出现丢失。</p><h5 id="HTTP可以使用UDP吗？"><a href="#HTTP可以使用UDP吗？" class="headerlink" title="HTTP可以使用UDP吗？"></a>HTTP可以使用UDP吗？</h5><p>HTTP不可以使用UDP，HTTP需要基于可靠的传输协议，而UDP不可靠。</p><h5 id="面向连接和无连接的区别"><a href="#面向连接和无连接的区别" class="headerlink" title="面向连接和无连接的区别"></a>面向连接和无连接的区别</h5><p>无连接的网络服务（数据报服务）– 面向连接的网络服务（虚电路服务）</p><p>虚电路服务：首先建立连接，所有的数据包经过相同的路径，服务质量有较好的保证；</p><p>数据报服务：每个数据包含目的地址，数据路由相互独立（路径可能变化）；网络尽最大努力交付数据，但不保证不丢失、不保证先后顺序、不保证在时限内交付；网络发生拥塞时，可能会将一些分组丢弃；</p><p><img src="https://www.cmdbyte.com/2021/202111142237654.png" alt="virtual circuit"></p><h3 id="TCP如何保证传输的可靠性"><a href="#TCP如何保证传输的可靠性" class="headerlink" title="TCP如何保证传输的可靠性"></a>TCP如何保证传输的可靠性</h3><ol><li>数据包校验</li><li>对失序数据包重新排序（TCP报文具有序列号）</li><li>丢弃重复数据</li><li>应答机制：接收方收到数据之后，会发送一个确认（通常延迟几分之一秒）；</li><li>超时重发：发送方发出数据之后，启动一个定时器，超时未收到接收方的确认，则重新发送这个数据；</li><li>流量控制：确保接收端能够接收发送方的数据而不会缓冲区溢出</li></ol><h3 id="什么是TCP粘包？"><a href="#什么是TCP粘包？" class="headerlink" title="什么是TCP粘包？"></a>什么是TCP粘包？</h3><p>TCP粘包就是指发送方发送的若干包数据到达接收方时粘成了一包，从接收端缓冲区来看，后一包数据的头紧接着前一包数据的尾。</p><p>如果发送方发送的多组数据本来就是同一块数据的不同部分，比如说一个文件被分成多个部分发送，这时当然不需要处理粘包现象；如果多个分组毫不相干，甚至是并列关系，那么这个时候就一定要处理粘包现象了</p><p>出现粘包的原因：</p><ul><li>发送方：默认使用<strong>Nagle算法</strong>（主要作用：减少网络中报文段的数量），将多次间隔较小、数据量较小的数据，合并成一个数据量大的数据块，进行发送；</li><li>接收方：TCP将接收到的数据包保存在<strong>接收缓存</strong>里，然后应用程序主动从缓存读取收到的分组。如果TCP接收数据包到缓存的速度大于应用程序从缓存中读取数据包的速度，多个包就会被缓存，应用程序就有可能读取到多个首尾相接粘到一起的包。</li></ul><h5 id="如何解决粘包问题？"><a href="#如何解决粘包问题？" class="headerlink" title="如何解决粘包问题？"></a>如何解决粘包问题？</h5><ul><li>发送方：关闭Nagle算法；</li><li>接收方：在应用层进行处理。将所有数据全部读完之后，再进行分组。分组的方法可以通过规定开始符和结束符的方法；也可以在每组数据前加上数据长度。</li></ul><h3 id="HTTP和HTTPS有什么区别？"><a href="#HTTP和HTTPS有什么区别？" class="headerlink" title="HTTP和HTTPS有什么区别？"></a>HTTP和HTTPS有什么区别？</h3><ol><li>端口不同：HTTP使用的是80端口，HTTPS使用443端口；</li><li>HTTP（超文本传输协议）信息是明文传输，HTTPS运行在SSL(Secure Socket Layer)之上，添加了加密和认证机制，更加安全；</li><li>HTTPS由于加密解密会带来更大的CPU和内存开销；</li><li>HTTPS通信需要证书，一般需要向证书颁发机构（CA）购买</li></ol><h5 id="Https的连接过程？"><a href="#Https的连接过程？" class="headerlink" title="Https的连接过程？"></a>Https的连接过程？</h5><ol><li>客户端向服务器发送请求，同时发送客户端支持的一套加密规则（包括对称加密、非对称加密、摘要算法）；</li><li>服务器从中选出一组加密算法与HASH算法，并将自己的身份信息以证书的形式发回给浏览器。证书里面包含了网站地址，<strong>加密公钥</strong>（用于非对称加密），以及证书的颁发机构等信息（证书中的私钥只能用于服务器端进行解密）；</li><li>客户端验证服务器的合法性，包括：证书是否过期，CA 是否可靠，发行者证书的公钥能否正确解开服务器证书的“发行者的数字签名”，服务器证书上的域名是否和服务器的实际域名相匹配；</li><li>如果证书受信任，或者用户接收了不受信任的证书，浏览器会生成一个<strong>随机密钥</strong>（用于对称算法），并用服务器提供的公钥加密（采用非对称算法对密钥加密）；使用Hash算法对握手消息进行<strong>摘要</strong>计算，并对摘要使用之前产生的密钥加密（对称算法）；将加密后的随机密钥和摘要一起发送给服务器；</li><li>服务器使用自己的私钥解密，得到对称加密的密钥，用这个密钥解密出Hash摘要值，并验证握手消息是否一致；如果一致，服务器使用对称加密的密钥加密握手消息发给浏览器；</li><li>浏览器解密并验证摘要，若一致，则握手结束。之后的数据传送都使用对称加密的密钥进行加密</li></ol><p>总结：非对称加密算法用于在握手过程中加密生成的密码；对称加密算法用于对真正传输的数据进行加密；HASH算法用于验证数据的完整性。</p><h5 id="输入-www-baidu-com，怎么变成-https-www-baidu-com-的，怎么确定用HTTP还是HTTPS？"><a href="#输入-www-baidu-com，怎么变成-https-www-baidu-com-的，怎么确定用HTTP还是HTTPS？" class="headerlink" title="输入 www.baidu.com，怎么变成 https://www.baidu.com 的，怎么确定用HTTP还是HTTPS？"></a>输入 <a href="http://www.baidu.com,怎么变成/">www.baidu.com，怎么变成</a> <a href="https://www.baidu.com/">https://www.baidu.com</a> 的，怎么确定用HTTP还是HTTPS？</h5><p><a href="https://www.sohu.com/a/136637876_487516">你访问的网站是如何自动切换到 HTTPS 的？</a></p><p>一种是原始的302跳转，服务器把所有的HTTp流量跳转到HTTPS。但这样有一个漏洞，就是中间人可能在第一次访问站点的时候就劫持。<br>解决方法是引入HSTS机制，用户浏览器在访问站点的时候强制使用HTTPS。</p><h5 id="HTTPS连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？"><a href="#HTTPS连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？" class="headerlink" title="HTTPS连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？"></a>HTTPS连接的时候，怎么确定收到的包是服务器发来的（中间人攻击）？</h5><p>待补充…</p><h5 id="什么是对称加密、非对称加密？区别是什么？"><a href="#什么是对称加密、非对称加密？区别是什么？" class="headerlink" title="什么是对称加密、非对称加密？区别是什么？"></a>什么是对称加密、非对称加密？区别是什么？</h5><ul><li>对称加密：加密和解密采用相同的密钥。如：DES、RC2、RC4</li><li>非对称加密：需要两个密钥：公钥和私钥。如果用公钥加密，需要用私钥才能解密。如：RSA</li><li>区别：对称加密速度更快，通常用于大量数据的加密；非对称加密安全性更高（不需要传送私钥）</li></ul><h5 id="数字签名、报文摘要的原理"><a href="#数字签名、报文摘要的原理" class="headerlink" title="数字签名、报文摘要的原理"></a>数字签名、报文摘要的原理</h5><ul><li>发送者A用私钥进行签名，接收者B用公钥验证签名。因为除A外没有人有私钥，所以B相信签名是来自A。A不可抵赖，B也不能伪造报文。</li><li>摘要算法:MD5、SHA</li></ul><h3 id="GET与POST的区别？"><a href="#GET与POST的区别？" class="headerlink" title="GET与POST的区别？"></a>GET与POST的区别？</h3><ol><li>GET是幂等的，即读取同一个资源，总是得到相同的数据，POST不是幂等的；</li><li>GET一般用于从服务器获取资源，而POST有可能改变服务器上的资源；</li><li>请求形式上：GET请求的数据附在URL之后，在HTTP请求头中；POST请求的数据在请求体中；</li><li>安全性：GET请求可被缓存、收藏、保留到历史记录，且其请求数据明文出现在URL中。POST的参数不会被保存，安全性相对较高；</li><li>GET只允许ASCII字符，POST对数据类型没有要求，也允许二进制数据；</li><li>GET的长度有限制（操作系统或者浏览器），而POST数据大小无限制</li></ol><h3 id="Session与Cookie的区别？"><a href="#Session与Cookie的区别？" class="headerlink" title="Session与Cookie的区别？"></a>Session与Cookie的区别？</h3><p>Session是服务器端保持状态的方案，Cookie是客户端保持状态的方案</p><p>Cookie保存在客户端本地，客户端请求服务器时会将Cookie一起提交；Session保存在服务端，通过检索Sessionid查看状态。保存Sessionid的方式可以采用Cookie，如果禁用了Cookie，可以使用URL重写机制（把会话ID保存在URL中）。</p><h3 id="从输入网址到获得页面的过程-越详细越好-？"><a href="#从输入网址到获得页面的过程-越详细越好-？" class="headerlink" title="从输入网址到获得页面的过程 (越详细越好)？"></a>从输入网址到获得页面的过程 (越详细越好)？</h3><ol><li>浏览器查询 DNS，获取域名对应的IP地址:具体过程包括浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地DNS服务器进行查询等。对于向本地DNS服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析(此解析具有权威性)；如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析（此解析不具有权威性）。如果本地域名服务器并未缓存该网址映射关系，那么将根据其设置发起递归查询或者迭代查询；</li><li>浏览器获得域名对应的IP地址以后，浏览器向服务器请求建立链接，发起三次握手；</li><li>TCP&#x2F;IP链接建立起来后，浏览器向服务器发送HTTP请求；</li><li>服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li><li>浏览器解析并渲染视图，若遇到对js文件、css文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源；</li><li>浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li></ol><h3 id="HTTP请求有哪些常见状态码？"><a href="#HTTP请求有哪些常见状态码？" class="headerlink" title="HTTP请求有哪些常见状态码？"></a>HTTP请求有哪些常见状态码？</h3><ol><li>2xx状态码：操作成功。200 OK</li><li>3xx状态码：重定向。301 永久重定向；302暂时重定向</li><li>4xx状态码：客户端错误。400 Bad Request；401 Unauthorized；403 Forbidden；404 Not Found；</li><li>5xx状态码：服务端错误。500服务器内部错误；501服务不可用</li></ol><h3 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h3><p><img src="https://www.cmdbyte.com/2021/202111142237984.png" alt="计算机网络体系结构"></p><ul><li>Physical, Data Link, Network, Transport, Application</li><li>应用层：常见协议：<ul><li>FTP(21端口)：文件传输协议</li><li>SSH(22端口)：远程登陆</li><li>TELNET(23端口)：远程登录</li><li>SMTP(25端口)：发送邮件</li><li>POP3(110端口)：接收邮件</li><li>HTTP(80端口)：超文本传输协议</li><li>DNS(53端口)：运行在UDP上，域名解析服务</li></ul></li><li>传输层：TCP&#x2F;UDP</li><li>网络层：IP、ARP、NAT、RIP…</li></ul><p><strong>路由器、交换机位于哪一层？</strong></p><ul><li>路由器网络层，根据IP地址进行寻址；</li><li>交换机数据链路层，根据MAC地址进行寻址</li></ul><h3 id="什么是RIP-Routing-Information-Protocol-距离矢量路由协议-算法是什么？"><a href="#什么是RIP-Routing-Information-Protocol-距离矢量路由协议-算法是什么？" class="headerlink" title="什么是RIP (Routing Information Protocol, 距离矢量路由协议)? 算法是什么？"></a>什么是RIP (Routing Information Protocol, 距离矢量路由协议)? 算法是什么？</h3><p>每个路由器维护一张表，记录该路由器到其它网络的”跳数“，路由器到与其直接连接的网络的跳数是1，每多经过一个路由器跳数就加1；更新该表时和相邻路由器交换路由信息；路由器允许一个路径最多包含15个路由器，如果跳数为16，则不可达。交付数据报时优先选取距离最短的路径。</p><p><strong>优缺点</strong></p><ul><li>实现简单，开销小</li><li>随着网络规模扩大开销也会增大；</li><li>最大距离为15，限制了网络的规模；</li><li>当网络出现故障时，要经过较长的时间才能将此信息传递到所有路由器</li></ul><h3 id="IP地址的分类？"><a href="#IP地址的分类？" class="headerlink" title="IP地址的分类？"></a>IP地址的分类？</h3><p><img src="https://www.cmdbyte.com/2021/202111142238886.png" alt="IP address"></p><p>路由器仅根据网络号net-id来转发分组，当分组到达目的网络的路由器之后，再按照主机号host-id将分组交付给主机；同一网络上的所有主机的网络号相同。</p><h3 id="什么叫划分子网？"><a href="#什么叫划分子网？" class="headerlink" title="什么叫划分子网？"></a>什么叫划分子网？</h3><p>从主机号host-id借用若干个比特作为子网号subnet-id；子网掩码：网络号和子网号都为1，主机号为0；数据报仍然先按照网络号找到目的网络，发送到路由器，路由器再按照网络号和子网号找到目的子网：将子网掩码与目标地址逐比特与操作，若结果为某个子网的网络地址，则送到该子网。</p><h3 id="什么是ARP协议-Address-Resolution-Protocol-？"><a href="#什么是ARP协议-Address-Resolution-Protocol-？" class="headerlink" title="什么是ARP协议 (Address Resolution Protocol)？"></a>什么是ARP协议 (Address Resolution Protocol)？</h3><p><strong>ARP协议完成了IP地址与物理地址的映射</strong>。每一个主机都设有一个 ARP 高速缓存，里面有<strong>所在的局域网</strong>上的各主机和路由器的 IP 地址到硬件地址的映射表。当源主机要发送数据包到目的主机时，会先检查自己的ARP高速缓存中有没有目的主机的MAC地址，如果有，就直接将数据包发到这个MAC地址，如果没有，就向<strong>所在的局域网</strong>发起一个ARP请求的广播包（在发送自己的 ARP 请求时，同时会带上自己的 IP 地址到硬件地址的映射），收到请求的主机检查自己的IP地址和目的主机的IP地址是否一致，如果一致，则先保存源主机的映射到自己的ARP缓存，然后给源主机发送一个ARP响应数据包。源主机收到响应数据包之后，先添加目的主机的IP地址与MAC地址的映射，再进行数据传送。如果源主机一直没有收到响应，表示ARP查询失败。</p><p>如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。</p><h3 id="什么是NAT-Network-Address-Translation-网络地址转换-？"><a href="#什么是NAT-Network-Address-Translation-网络地址转换-？" class="headerlink" title="什么是NAT (Network Address Translation, 网络地址转换)？"></a>什么是NAT (Network Address Translation, 网络地址转换)？</h3><p>用于解决内网中的主机要和因特网上的主机通信。由NAT路由器将主机的本地IP地址转换为全球IP地址，分为静态转换（转换得到的全球IP地址固定不变）和动态NAT转换。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.csdn.net/justloveyou_/article/details/78303617">面试&#x2F;笔试第一弹 —— 计算机网络面试问题集锦</a></li><li><a href="https://blog.csdn.net/yjxsdzx/article/details/71937886">什么时候选TCP、UDP？</a></li><li><a href="https://blog.csdn.net/weixin_41047704/article/details/85340311">什么是TCP粘包？怎么解决这个问题</a></li></ul><h3 id="待完成"><a href="#待完成" class="headerlink" title="待完成"></a>待完成</h3><ul><li><input disabled="" type="checkbox"> 发送窗口的大小，如何最大利用带宽，假设延迟100ms，发送端10Mb&#x2F;s，接收端100Mb&#x2F;s. <a href="https://blog.csdn.net/bad_sheep/article/details/6158676">reference</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux重启网卡</title>
    <link href="/2021/11/05/Linux%E9%87%8D%E5%90%AF%E7%BD%91%E5%8D%A1/"/>
    <url>/2021/11/05/Linux%E9%87%8D%E5%90%AF%E7%BD%91%E5%8D%A1/</url>
    
    <content type="html"><![CDATA[<p>修改了IP之后，要使其生效，有几种方法<br>1、ifdown&#x2F;ifup<br>#ifdown eth0<br>#ifup eth0</p><p>2、ifconfig<br>#ifconfig eth0 down<br>#ifconfig eth0 up</p><p>3、network<br>#&#x2F;etc&#x2F;init.d&#x2F;network restart<br>这条命令是重启整个网络<br>重启之后需要重新登录服务器，比较麻烦<br>可使用 nohup &#x2F;etc&#x2F;init.d&#x2F;network restart &amp;</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS学习笔记</title>
    <link href="/2021/11/04/ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/11/04/ROS%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>官网: <a href="http://wiki.ros.org/cn/ROS/Tutorials">cn&#x2F;ROS&#x2F;Tutorials - ROS Wiki</a></p><p>首先要记住几点:</p><ol><li>ros与系统环境变量关系密切，所以要时刻注意当前终端的环境信息，比如要source工作空间下devel&#x2F;setup.sh</li><li>启动ros节点之前，必须先启动<code>roscore</code></li></ol><h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul><li><strong>软件包（Packages）：</strong>包是ROS代码的软件组织单元，每个软件包都可以包含程序库、可执行文件、脚本或其他构件。</li><li><strong>Manifests (<a href="http://wiki.ros.org/catkin/package.xml">package.xml</a>)：</strong> 清单（Manifest）是对软件包的描述。它用于定义软件包之间的依赖关系，并记录有关软件包的元信息，如版本、维护者、许可证等。</li></ul><h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="roscd-直接切换目录-cd-到某个软件包或者软件包集当中。"><a href="#roscd-直接切换目录-cd-到某个软件包或者软件包集当中。" class="headerlink" title="roscd: 直接切换目录(cd)到某个软件包或者软件包集当中。"></a>roscd: 直接切换目录(cd)到某个软件包或者软件包集当中。</h4><ul><li><code>roscd [locationname[/subdir]]</code></li><li>进入存储ROS日志文件的目录: <code>roscd log</code></li></ul><h4 id="rosls-直接按软件包的名称执行-ls-命令（而不必输入绝对路径）。"><a href="#rosls-直接按软件包的名称执行-ls-命令（而不必输入绝对路径）。" class="headerlink" title="rosls: 直接按软件包的名称执行(ls)命令（而不必输入绝对路径）。"></a>rosls: 直接按软件包的名称执行(ls)命令（而不必输入绝对路径）。</h4><h2 id="软件包-package"><a href="#软件包-package" class="headerlink" title="软件包(package)"></a>软件包(package)</h2><h3 id="软件包的结构"><a href="#软件包的结构" class="headerlink" title="软件包的结构"></a>软件包的结构</h3><ul><li>这个包必须有一个符合catkin规范的<a href="http://wiki.ros.org/catkin/package.xml">package.xml</a>文件，这个<code>package.xml</code>文件提供有关该软件包的元信息</li><li>这个包必须有一个<a href="http://wiki.ros.org/catkin/CMakeLists.txt">catkin版本的CMakeLists.txt</a>文件，如果它是个<a href="http://wiki.ros.org/catkin/package.xml#Metapackages">Catkin元包</a>的话，则需要有一个<code>CMakeList.txt</code>文件的相关样板</li><li>每个包必须有自己的目录，这意味着在同一个目录下不能有嵌套的或者多个软件包存在</li></ul><p>最简单的软件包看起来就像这样：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">my_package/<br>  CMakeLists.txt<br>  package.xml<br></code></pre></td></tr></table></figure><h3 id="catkin工作空间中的软件包"><a href="#catkin工作空间中的软件包" class="headerlink" title="catkin工作空间中的软件包"></a>catkin工作空间中的软件包</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs txt">workspace_folder/        -- WORKSPACE<br>  src/                   -- SOURCE SPACE<br>    CMakeLists.txt       -- &#x27;Toplevel&#x27; CMake file, provided by catkin<br>    package_1/<br>      CMakeLists.txt     -- CMakeLists.txt file for package_1<br>      package.xml        -- Package manifest for package_1<br>    ...<br>    package_n/<br>      CMakeLists.txt     -- CMakeLists.txt file for package_n<br>      package.xml        -- Package manifest for package_n<br></code></pre></td></tr></table></figure><h3 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h3><h4 id="catkin-create-pkg-创建-构建-软件包"><a href="#catkin-create-pkg-创建-构建-软件包" class="headerlink" title="catkin_create_pkg 创建(构建)软件包"></a>catkin_create_pkg 创建(构建)软件包</h4><p><code>catkin_create_pkg &lt;package_name&gt; &lt;dependence&gt;</code></p><h4 id="catkin-make-构建一个catkin工作区并生效配置文件"><a href="#catkin-make-构建一个catkin工作区并生效配置文件" class="headerlink" title="catkin_make 构建一个catkin工作区并生效配置文件"></a>catkin_make 构建一个catkin工作区并生效配置文件</h4><p>要将新工作区添加到ROS环境中，需要source工作空间内的<code>devel/setup.sh</code></p><p><strong>执行时机:</strong></p><ul><li>开启新终端的时候</li><li>增加工作区的时候</li></ul><h4 id="rospack-软件包信息查询"><a href="#rospack-软件包信息查询" class="headerlink" title="rospack: 软件包信息查询"></a>rospack: 软件包信息查询</h4><ul><li>返回软件包所在路径: <code>rospack find [package_name]</code></li><li>打印软件包依赖关系<ul><li>查看一级依赖: <code>rospack depends1 &lt;package_name&gt;</code></li><li>递归检测出所有嵌套的依赖包: <code>rospack depends &lt;package_name&gt;</code></li></ul></li></ul><h3 id="软件包内的package-xml"><a href="#软件包内的package-xml" class="headerlink" title="软件包内的package.xml"></a>软件包内的package.xml</h3><p>package.xml 包含：描述标签、维护者标签、许可证标签、依赖项标签。</p><p>通过package.xml可以自定义软件包，所以新软件包的诞生不一定非要通过<code>catkin_create_pkg</code>创建</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">format</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>beginner_tutorials<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>The beginner_tutorials package<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">maintainer</span> <span class="hljs-attr">email</span>=<span class="hljs-string">&quot;you@yourdomain.tld&quot;</span>&gt;</span>Your Name<span class="hljs-tag">&lt;/<span class="hljs-name">maintainer</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">license</span>&gt;</span>BSD<span class="hljs-tag">&lt;/<span class="hljs-name">license</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;website&quot;</span>&gt;</span>http://wiki.ros.org/beginner_tutorials<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">author</span> <span class="hljs-attr">email</span>=<span class="hljs-string">&quot;you@yourdomain.tld&quot;</span>&gt;</span>Jane Doe<span class="hljs-tag">&lt;/<span class="hljs-name">author</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">buildtool_depend</span>&gt;</span>catkin<span class="hljs-tag">&lt;/<span class="hljs-name">buildtool_depend</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build_depend</span>&gt;</span>roscpp<span class="hljs-tag">&lt;/<span class="hljs-name">build_depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build_depend</span>&gt;</span>rospy<span class="hljs-tag">&lt;/<span class="hljs-name">build_depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">build_depend</span>&gt;</span>std_msgs<span class="hljs-tag">&lt;/<span class="hljs-name">build_depend</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">exec_depend</span>&gt;</span>roscpp<span class="hljs-tag">&lt;/<span class="hljs-name">exec_depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">exec_depend</span>&gt;</span>rospy<span class="hljs-tag">&lt;/<span class="hljs-name">exec_depend</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">exec_depend</span>&gt;</span>std_msgs<span class="hljs-tag">&lt;/<span class="hljs-name">exec_depend</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="节点-node"><a href="#节点-node" class="headerlink" title="节点(node)"></a>节点(node)</h2><blockquote><p><strong>图概念</strong></p><p><a href="http://wiki.ros.org/cn/ROS/Concepts#ROS.2Bi6F7l1b.2BXEJrIQ-">计算图（Computation Graph）</a>是一个由ROS进程组成的点对点网络，它们能够共同处理数据。ROS的基本计算图概念有节点（Nodes）、主节点（Master）、参数服务器（Parameter Server）、消息（Messages）、服务（Services）、话题（Topics）和袋（Bags），它们都以不同的方式向图（Graph）提供数据。</p><ul><li><a href="http://wiki.ros.org/Nodes">节点（Nodes）</a>：节点是一个可执行文件，它可以通过ROS来与其他节点进行通信。</li><li><a href="http://wiki.ros.org/Messages">消息（Messages）</a>：订阅或发布话题时所使用的ROS数据类型。</li><li><a href="http://wiki.ros.org/Topics">话题（Topics）</a>：节点可以将消息<em>发布</em>到话题，或通过<em>订阅</em>话题来接收消息。</li><li><a href="http://wiki.ros.org/Master">主节点（Master）</a>：ROS的命名服务，例如帮助节点发现彼此。</li><li><a href="http://wiki.ros.org/rosout">rosout</a>：在ROS中相当于<code>stdout/stderr（标准输出/标准错误）</code>。</li><li><a href="http://wiki.ros.org/roscore">roscore</a>：主节点 + rosout + [参数服务器](<a href="http://wiki.ros.org/Parameter">http://wiki.ros.org/Parameter</a> Server)（会在以后介绍）。</li></ul></blockquote><p>ROS节点使用ROS[客户端库](<a href="http://wiki.ros.org/cn/Client">http://wiki.ros.org/cn/Client</a> Libraries)与其他节点通信。节点可以发布或订阅话题，也可以提供或使用<a href="http://wiki.ros.org/Services">服务</a>。</p><h3 id="工具-2"><a href="#工具-2" class="headerlink" title="工具"></a>工具</h3><h4 id="rosnode-显示当前正在运行的ROS节点信息"><a href="#rosnode-显示当前正在运行的ROS节点信息" class="headerlink" title="rosnode 显示当前正在运行的ROS节点信息"></a>rosnode 显示当前正在运行的ROS节点信息</h4><ul><li>列出当前活动的节点:  <code>rosnode list</code></li><li>查看某节点信息: <code>rosnode info &lt;node_name&gt;</code></li></ul><h4 id="rosrun-运行软件包内的节点"><a href="#rosrun-运行软件包内的节点" class="headerlink" title="rosrun 运行软件包内的节点"></a>rosrun 运行软件包内的节点</h4><p><code>rosrun [package_name] [node_name]</code></p><h2 id="话题-topic"><a href="#话题-topic" class="headerlink" title="话题(topic)"></a>话题(topic)</h2><p><strong>节点</strong>之间的通信通过<strong>话题</strong>实现。</p><p><strong>节点</strong>可以<strong>订阅</strong>与<strong>发布</strong>话题。</p><h3 id="工具-3"><a href="#工具-3" class="headerlink" title="工具"></a>工具</h3><h4 id="rat-graph-用动态的图显示了系统中正在发生的事情"><a href="#rat-graph-用动态的图显示了系统中正在发生的事情" class="headerlink" title="rat_graph 用动态的图显示了系统中正在发生的事情"></a>rat_graph 用动态的图显示了系统中正在发生的事情</h4><h4 id="rostopic-话题信息相关"><a href="#rostopic-话题信息相关" class="headerlink" title="rostopic 话题信息相关"></a>rostopic 话题信息相关</h4><ul><li><p><code>rostopic echo [topic]</code> 显示某个话题上发布的数据</p></li><li><p><code>rostopic list -v</code> 列出所有发布和订阅的主题及其类型的详细信息</p></li><li><p><code>rostopic type [topic]</code> 查看所发布话题的消息类型</p><p>  进而查看某消息类型的详细信息: <code>rosmsg show [msg_type]</code></p></li><li><p><code>rostopic pub [topic] [msg_type] [args]</code> 把数据发布到当前某个正在广播的话题上</p></li><li><p><code>rostopic hz [topic]</code> 报告话题上数据发布的速率</p></li></ul><h2 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h2><p><a href="http://wiki.ros.org/Services">服务（Services）</a>是节点之间通讯的另一种方式。服务允许节点发送一个<strong>请求（request）</strong>并获得一个<strong>响应（response）</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">rosservice list         输出活跃服务的信息<br>rosservice call         用给定的参数调用服务<br>rosservice type         输出服务的类型<br>rosservice find         按服务的类型查找服务<br>rosservice uri          输出服务的ROSRPC uri<br></code></pre></td></tr></table></figure><p>用法:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">rosservice type [service]<br><br>rosservice call [service] [args]<br><br>rosservice type [service] | rossrv show<br></code></pre></td></tr></table></figure><h3 id="参数服务器"><a href="#参数服务器" class="headerlink" title="参数服务器"></a>参数服务器</h3><p><code>rosparam</code>能让我们在ROS[参数服务器（Parameter Server）](<a href="http://wiki.ros.org/Parameter">http://wiki.ros.org/Parameter</a> Server)上存储和操作数据。参数服务器能够存储整型（integer）、浮点（float）、布尔（boolean）、字典（dictionaries）和列表（list）等数据类型。rosparam使用YAML标记语言的语法。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gams">rosparam <span class="hljs-keyword">set</span>            设置参数<br>rosparam <span class="hljs-comment">get</span>            获取参数<br>rosparam <span class="hljs-comment">load</span>           从文件中加载参数<br>rosparam <span class="hljs-comment">dump</span>           向文件中转储参数<br>rosparam <span class="hljs-comment">delete</span>         删除参数<br>rosparam <span class="hljs-comment">list</span>           列出参数名<br></code></pre></td></tr></table></figure><p>用法:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">rosparam set [param_name]<br>rosparam get [param_name]<br><br>rosparam dump [file_name] [namespace]<br>rosparam load [file_name] [namespace]<br></code></pre></td></tr></table></figure><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="工具-rqt-console和rqt-logger-level"><a href="#工具-rqt-console和rqt-logger-level" class="headerlink" title="工具 rqt_console和rqt_logger_level"></a>工具 rqt_console和rqt_logger_level</h3><p><code>rqt_console</code>连接到了ROS的日志框架，以显示节点的输出信息。<code>rqt_logger_level</code>允许我们在节点运行时改变输出信息的详细级别，包括<code>Debug</code>、<code>Info</code>、<code>Warn和</code>Error&#96;。</p><h3 id="日志级别"><a href="#日志级别" class="headerlink" title="日志级别"></a>日志级别</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">Fatal （致命）<br>Error （错误）<br>Warn  （警告）<br>Info  （信息）<br>Debug （调试）<br></code></pre></td></tr></table></figure><h2 id="roslaunch"><a href="#roslaunch" class="headerlink" title="roslaunch"></a>roslaunch</h2><p><code>roslaunch</code>可以用来启动定义在<code>launch（启动）</code>文件中的节点。</p><p>Eg:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">launch</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">group</span> <span class="hljs-attr">ns</span>=<span class="hljs-string">&quot;turtlesim1&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">group</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">group</span> <span class="hljs-attr">ns</span>=<span class="hljs-string">&quot;turtlesim2&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sim&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;turtlesim_node&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">group</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">pkg</span>=<span class="hljs-string">&quot;turtlesim&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mimic&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;mimic&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">remap</span> <span class="hljs-attr">from</span>=<span class="hljs-string">&quot;input&quot;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;turtlesim1/turtle1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">remap</span> <span class="hljs-attr">from</span>=<span class="hljs-string">&quot;output&quot;</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;turtlesim2/turtle1&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">node</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">launch</span>&gt;</span><br></code></pre></td></tr></table></figure><p>用法:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">roslaunch [package_name] [launch_file]<br></code></pre></td></tr></table></figure><h2 id="rosed"><a href="#rosed" class="headerlink" title="rosed"></a>rosed</h2><p>可以直接通过软件包名编辑包中的文件，而无需键入完整路径。（默认采用vim）</p><p>切换默认编辑器，只需在~&#x2F;.bashrc中加入:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到nano</span><br>export EDITOR=&#x27;nano -w&#x27;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者切换到emacs</span><br>export EDITOR=&#x27;emacs -nw&#x27;<br></code></pre></td></tr></table></figure><h2 id="消息与服务"><a href="#消息与服务" class="headerlink" title="消息与服务"></a>消息与服务</h2><ul><li><a href="http://wiki.ros.org/msg">msg</a>（消息）：msg文件就是文本文件，用于描述ROS消息的字段。它们用于为不同编程语言编写的消息生成源代码。</li><li><a href="http://wiki.ros.org/srv">srv</a>（服务）：一个srv文件描述一个服务。它由两部分组成：请求（request）和响应（response）。</li></ul><p>msg文件存放在软件包的<code>msg</code>目录下，srv文件则存放在<code>srv</code>目录下。</p><p>msg文件就是简单的文本文件，每行都有一个字段类型和字段名称。可以使用的类型为：</p><ul><li>int8, int16, int32, int64 (以及 uint*)</li><li>float32, float64</li><li>string</li><li>time, duration</li><li>其他msg文件</li><li>variable-length array[] 和 fixed-length array[C]</li></ul><p>ROS中还有一个特殊的数据类型：<code>Header</code>，它含有时间戳和ROS中广泛使用的坐标帧信息。在msg文件的第一行经常可以看到<code>Header header</code>。</p><p>下面是一个使用了Header、字符串原语和其他两个消息的示例： 下面是一个msg文件的样例，它使用了Header，string，和其他另外两个消息的类型：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">Header header<br>string child_frame_id<br>geometry_msgs/PoseWithCovariance pose<br>geometry_msgs/TwistWithCovariance twist<br></code></pre></td></tr></table></figure><p>srv文件和msg文件一样，只是它们包含两个部分：请求和响应。这两部分用一条<code>---</code>线隔开。下面是一个srv文件的示例：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">int64 A<br>int64 B<br>---<br>int64 Sum<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>A</code>和<code>B</code>是请求, <code>Sum</code>是响应。</p><h3 id="工具-4"><a href="#工具-4" class="headerlink" title="工具"></a>工具</h3><h4 id="rosmsg-消息相关"><a href="#rosmsg-消息相关" class="headerlink" title="rosmsg 消息相关"></a>rosmsg 消息相关</h4><p><code>rosmsg show [message type]</code>可以显示消息的定义信息，同时可以用来检查创建的消息能否被ROS识别。</p><h4 id="rossrv-服务相关"><a href="#rossrv-服务相关" class="headerlink" title="rossrv 服务相关"></a>rossrv 服务相关</h4><p><code>rossrv show &lt;service type&gt;</code> 类似rosmsg</p><h2 id="rosbag-数据的录制与回放"><a href="#rosbag-数据的录制与回放" class="headerlink" title="rosbag 数据的录制与回放"></a>rosbag 数据的录制与回放</h2><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs txt">$ rosbag -h<br><br>   check        Determine whether a bag is playable in the current system, or if it can be migrated.<br>   compress     Compress one or more bag files.<br>   decompress   Decompress one or more bag files.<br>   decrypt      Decrypt one or more bag files.<br>   encrypt      Encrypt one or more bag files.<br>   filter       Filter the contents of the bag.<br>   fix          Repair the messages in a bag file so that it can be played in the current system.<br>   help  <br>   info         Summarize the contents of one or more bag files.<br>   play         Play back the contents of one or more bag files in a time-synchronized fashion.<br>   record       Record a bag file with the contents of specified topics.<br>   reindex      Reindexes one or more bag files.<br></code></pre></td></tr></table></figure><p>rosbag不能完整的录制系统运行行为，因为对系统定时精度依赖比较大。</p><h3 id="为什么用ros-readbagfile而不是rostopic-echo-b呢？"><a href="#为什么用ros-readbagfile而不是rostopic-echo-b呢？" class="headerlink" title="为什么用ros_readbagfile而不是rostopic echo -b呢？"></a>为什么用ros_readbagfile而不是rostopic echo -b呢？</h3><ol><li><p>因为<code>rostopic</code><strong>极其地</strong>慢！ 举个例子，就算在高配计算机（4核8线程的奔腾i7和m.2固态硬盘）上运行这个命令，也需要<strong>11.5分钟</strong>才能读取一个18GB的bag文件！</p> <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">time rostopic echo -b large_bag_file.bag /topic1<br></code></pre></td></tr></table></figure><p> 而用<code>ros_readbagfile</code>脚本，在相同计算机上只要花费<strong>1分钟37秒</strong>就能读取同样的话题和18GB的bag文件！因此<code>ros_readbagfile</code>比<code>rostopic</code>快了11.5&#x2F;(1+37&#x2F;60) &#x3D; <strong>大约7倍</strong>！</p> <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">time ros_readbagfile large_bag_file.bag /topic1<br></code></pre></td></tr></table></figure></li><li><p>因为<code>rostopic</code>一次只能读取<strong>单个话题</strong>，而<code>ros_readbagfile</code>可以同时读取<strong>任意多的话题</strong>！</p> <figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">ros_readbagfile &lt;mybagfile.bag&gt; [topic1] [topic2] [topic3] [...] [topic1000]<br></code></pre></td></tr></table></figure></li></ol><h2 id="roswtf-查你的系统并尝试发现问题"><a href="#roswtf-查你的系统并尝试发现问题" class="headerlink" title="roswtf 查你的系统并尝试发现问题"></a>roswtf 查你的系统并尝试发现问题</h2>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ROS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux添加图形化程序自启动</title>
    <link href="/2021/11/03/Linux%E6%B7%BB%E5%8A%A0%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%90%AF%E5%8A%A8/"/>
    <url>/2021/11/03/Linux%E6%B7%BB%E5%8A%A0%E5%9B%BE%E5%BD%A2%E5%8C%96%E7%A8%8B%E5%BA%8F%E8%87%AA%E5%90%AF%E5%8A%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1-先拿到程序的启动命令"><a href="#1-先拿到程序的启动命令" class="headerlink" title="1.先拿到程序的启动命令"></a>1.先拿到程序的启动命令</h3><p>输入: <code>dpkg -L 程序名</code><br>在列表中找到能启动程序的命令，一般在bin下.</p><h3 id="2-添加到启动项中"><a href="#2-添加到启动项中" class="headerlink" title="2.添加到启动项中"></a>2.添加到启动项中</h3><p>输入: <code>gnome-session-properties</code><br>在打开的窗口中新增启动项</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes环境搭建</title>
    <link href="/2021/11/01/Kubernetes%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/11/01/Kubernetes%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/363978095">https://zhuanlan.zhihu.com/p/363978095</a></p>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Go几个流行Ridis包的选择</title>
    <link href="/2021/11/01/%E5%85%B3%E4%BA%8EGo%E5%87%A0%E4%B8%AA%E6%B5%81%E8%A1%8CRidis%E5%8C%85%E7%9A%84%E9%80%89%E6%8B%A9/"/>
    <url>/2021/11/01/%E5%85%B3%E4%BA%8EGo%E5%87%A0%E4%B8%AA%E6%B5%81%E8%A1%8CRidis%E5%8C%85%E7%9A%84%E9%80%89%E6%8B%A9/</url>
    
    <content type="html"><![CDATA[<p>我比较纠结go-redis&#x2F;redis与gomodules&#x2F;redigo的选择问题，现在我选择go-redis&#x2F;redis。</p><p>这里有一篇关于Go的几个流行Redis客户端的性能比较: <a href="https://levelup.gitconnected.com/fastest-redis-client-library-for-go-7993f618f5ab">Fastest Redis Client Library for Go | by Rizal Widyarta Gowandy | Level Up Coding</a></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Visual Studio Code设置</title>
    <link href="/2021/11/01/Tools/VSCode/Visual-Studio-Code%E8%AE%BE%E7%BD%AE/"/>
    <url>/2021/11/01/Tools/VSCode/Visual-Studio-Code%E8%AE%BE%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>最近一段时间由于涉及到有关ROS的开发，没有在自己电脑上搭建环境，在公司一台Linux机器上搭建了环境，需要的时候可以远程开发，刚开始考虑用Vim，但是感觉Vim的提示有点少，前期需要提示才能避免犯错，于是选择VS Code进行开发，之前一直听这个东西插件很丰富，但一直没有认真用过，也就打开个文档啥的用用，不得不说，Visual Studio Code打开文档方面挺快的，尤其是比较大的文档，电脑风扇也比较安静，对比Sublime Text好很多，我用Sublime Text时电脑风扇狂转。。。</p><p>废话不多说了，把我在配置过程中用到的配置简单分享下，现在处于回顾阶段，可能有些忘记了，欢迎补充👏👏</p><h3 id="调整左侧目录树父子层级的缩进大小："><a href="#调整左侧目录树父子层级的缩进大小：" class="headerlink" title="调整左侧目录树父子层级的缩进大小："></a>调整左侧目录树父子层级的缩进大小：</h3><blockquote><p>vs code 左侧的目录树是按照像素点缩进的，然后会发现它们视觉上挨得很近，越是分辨率高的电脑越为明显。</p></blockquote><p>打开设置（Settings）项，找到Workbench-&gt;Appearance节点，找到里面的tree: Indent一项，设置里面的数值，单位是像素，一般设置到原数值的2～3倍看着舒服一些。</p><h3 id="关闭右侧小地图"><a href="#关闭右侧小地图" class="headerlink" title="关闭右侧小地图"></a>关闭右侧小地图</h3><p>去设置(Settings)，在 Text Editor 找到 MiniMap，取消勾选 Enabled。</p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>VSCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VS Code在CPP文件中，无法发现ros/ros.h</title>
    <link href="/2021/10/31/VS-Code%E5%9C%A8CPP%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E6%97%A0%E6%B3%95%E5%8F%91%E7%8E%B0ros-ros-h/"/>
    <url>/2021/10/31/VS-Code%E5%9C%A8CPP%E6%96%87%E4%BB%B6%E4%B8%AD%EF%BC%8C%E6%97%A0%E6%B3%95%E5%8F%91%E7%8E%B0ros-ros-h/</url>
    
    <content type="html"><![CDATA[<p>ROS安装位置在: ‘&#x2F;opt&#x2F;ros&#x2F;bin’</p>]]></content>
    
    
    <categories>
      
      <category>Problems</category>
      
      <category>Visual Studio</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ROS</tag>
      
      <tag>Visual Studio</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ vector 及容器学习</title>
    <link href="/2021/10/31/CPP-vector/"/>
    <url>/2021/10/31/CPP-vector/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是-vector"><a href="#什么是-vector" class="headerlink" title="什么是 vector ?"></a>什么是 vector ?</h2><p>向量（Vector）是一个封装了动态大小数组的顺序容器（Sequence Container）。跟任意其它类型容器一样，它能够存放各种类型的对象。可以简单的认为，向量是一个能够存放任意类型的动态数组。</p><h2 id="容器特性"><a href="#容器特性" class="headerlink" title="容器特性"></a>容器特性</h2><ul><li><p>顺序序列</p><p>  顺序容器中的元素按照严格的线性顺序排序。可以通过元素在序列中的位置访问对应的元素。</p></li><li><p>动态数组</p><p>  支持对序列中的任意元素进行快速直接访问，甚至可以通过指针算述进行该操作。提供了在序列末尾相对快速地添加&#x2F;删除元素的操作。</p></li><li><p>能够感知内存分配器（Allocator-aware）</p><p>  容器使用一个内存分配器对象来动态地处理它的存储需求。</p></li></ul><h2 id="基本函数"><a href="#基本函数" class="headerlink" title="基本函数"></a>基本函数</h2><h3 id="1-构造函数"><a href="#1-构造函数" class="headerlink" title="1.构造函数"></a>1.构造函数</h3><ul><li>vector():创建一个空vector</li><li>vector(int nSize):创建一个vector,元素个数为nSize</li><li>vector(int nSize,const t&amp; t):创建一个vector，元素个数为nSize,且值均为t</li><li>vector(const vector&amp;):复制构造函数</li><li>vector(begin,end):复制[begin,end)区间内另一个数组的元素到vector中</li></ul><h3 id="2-增加函数"><a href="#2-增加函数" class="headerlink" title="2.增加函数"></a>2.增加函数</h3><ul><li>void push_back(const T&amp; x):向量尾部增加一个元素X</li><li>iterator insert(iterator it,const T&amp; x):向量中迭代器指向元素前增加一个元素x</li><li>iterator insert(iterator it,int n,const T&amp; x):向量中迭代器指向元素前增加n个相同的元素x</li><li>iterator insert(iterator it,const_iterator first,const_iterator last):向量中迭代器指向元素前插入另一个相同类型向量的[first,last)间的数据</li></ul><h3 id="3-删除函数"><a href="#3-删除函数" class="headerlink" title="3.删除函数"></a>3.删除函数</h3><ul><li>iterator erase(iterator it):删除向量中迭代器指向元素</li><li>iterator erase(iterator first,iterator last):删除向量中[first,last)中元素</li><li>void pop_back():删除向量中最后一个元素</li><li>void clear():清空向量中所有元素</li></ul><h3 id="4-遍历函数"><a href="#4-遍历函数" class="headerlink" title="4.遍历函数"></a>4.遍历函数</h3><ul><li>reference at(int pos):返回pos位置元素的引用</li><li>reference front():返回首元素的引用</li><li>reference back():返回尾元素的引用</li><li>iterator begin():返回向量头指针，指向第一个元素</li><li>iterator end():返回向量尾指针，指向向量最后一个元素的下一个位置</li><li>reverse_iterator rbegin():反向迭代器，指向最后一个元素</li><li>reverse_iterator rend():反向迭代器，指向第一个元素之前的位置</li></ul><h3 id="5-判断函数"><a href="#5-判断函数" class="headerlink" title="5.判断函数"></a>5.判断函数</h3><ul><li>bool empty() const:判断向量是否为空，若为空，则向量中无元素</li></ul><h3 id="6-大小函数"><a href="#6-大小函数" class="headerlink" title="6.大小函数"></a>6.大小函数</h3><ul><li>int size() const:返回向量中元素的个数</li><li>int capacity() const:返回当前向量所能容纳的最大元素值</li><li>int max_size() const:返回最大可允许的vector元素数量值</li></ul><h3 id="7-其他函数"><a href="#7-其他函数" class="headerlink" title="7.其他函数"></a>7.其他函数</h3><ul><li>void swap(vector&amp;):交换两个同类型向量的数据</li><li>void assign(int n,const T&amp; x):设置向量中前n个元素的值为x</li><li>void assign(const_iterator first,const_iterator last):向量中[first,last)中元素设置成当前向量元素</li></ul><h3 id="8-常用的函数"><a href="#8-常用的函数" class="headerlink" title="8.常用的函数"></a>8.常用的函数</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs txt">1.push_back 在数组的最后添加一个数据<br><br>2.pop_back 去掉数组的最后一个数据<br><br>3.at 得到编号位置的数据<br><br>4.begin 得到数组头的指针<br><br>5.end 得到数组的最后一个单元+1的指针<br><br>6.front 得到数组头的引用<br><br>7.back 得到数组的最后一个单元的引用<br><br>8.max_size 得到vector最大可以是多大<br><br>9.capacity 当前vector分配的大小<br><br>10.size 当前使用数据的大小<br><br>11.resize 改变当前使用数据的大小，如果它比当前使用的大，者填充默认值<br><br>12.reserve 改变当前vecotr所分配空间的大小<br><br>13.erase 删除指针指向的数据项<br><br>14.clear 清空当前的vector<br><br>15.rbegin 将vector反转后的开始指针返回(其实就是原来的end-1)<br><br>16.rend 将vector反转构的结束指针返回(其实就是原来的begin-1)<br><br>17.empty 判断vector是否为空<br><br>18.swap 与另一个vector交换数据<br></code></pre></td></tr></table></figure><h2 id="vector-语法"><a href="#vector-语法" class="headerlink" title="vector 语法"></a>vector 语法</h2><ol><li>Vector&lt;类型&gt;标识符</li><li>Vector&lt;类型&gt;标识符(最大容量)</li><li>Vector&lt;类型&gt;标识符(最大容量,初始所有值)</li><li>Int i[5]&#x3D;{1,2,3,4,5}<br> Vector&lt;类型&gt;vi(I,i+2);&#x2F;&#x2F;得到i索引值为3以后的值</li><li>Vector&lt; vector&lt; int&gt; &gt;v; 二维向量&#x2F;&#x2F;这里最外的&lt;&gt;要有空格。否则在比较旧的编译器下无法通过</li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><h3 id="1-pop-back-amp-push-back-elem-实例在容器最后移除和插入数据"><a href="#1-pop-back-amp-push-back-elem-实例在容器最后移除和插入数据" class="headerlink" title="1.pop_back()&amp;push_back(elem)实例在容器最后移除和插入数据"></a>1.pop_back()&amp;push_back(elem)实例在容器最后移除和插入数据</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;obj;<span class="hljs-comment">//创建一个向量存储容器 int</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++) <span class="hljs-comment">// push_back(elem)在数组最后添加数据 </span><br>    &#123;<br>        obj.<span class="hljs-built_in">push_back</span>(i);<br>        cout&lt;&lt;obj[i]&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>;    <br>    &#125;<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)<span class="hljs-comment">//去掉数组最后一个数据 </span><br>    &#123;<br>        obj.<span class="hljs-built_in">pop_back</span>();<br>    &#125;<br> <br>    cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>&lt;&lt;endl;<br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;obj.<span class="hljs-built_in">size</span>();i++)<span class="hljs-comment">//size()容器中实际数据个数 </span><br>    &#123;<br>        cout&lt;&lt;obj[i]&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>;<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">0,1,2,3,4,5,6,7,8,9,<br><br>0,1,2,3,4,<br></code></pre></td></tr></table></figure><h3 id="2-clear-清除容器中所有数据"><a href="#2-clear-清除容器中所有数据" class="headerlink" title="2.clear()清除容器中所有数据"></a>2.clear()清除容器中所有数据</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;obj;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<span class="hljs-comment">//push_back(elem)在数组最后添加数据 </span><br>    &#123;<br>        obj.<span class="hljs-built_in">push_back</span>(i);<br>        cout&lt;&lt;obj[i]&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>;<br>    &#125;<br> <br>    obj.<span class="hljs-built_in">clear</span>();<span class="hljs-comment">//清除容器中所以数据</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;obj.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        cout&lt;&lt;obj[i]&lt;&lt;endl;<br>    &#125;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">0,1,2,3,4,5,6,7,8,9,<br></code></pre></td></tr></table></figure><h3 id="3-排序"><a href="#3-排序" class="headerlink" title="3.排序"></a>3.排序</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt;obj;<br> <br>    obj.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">1</span>);<br>    obj.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">3</span>);<br>    obj.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br> <br>    <span class="hljs-built_in">sort</span>(obj.<span class="hljs-built_in">begin</span>(),obj.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//从小到大</span><br> <br>    cout&lt;&lt;<span class="hljs-string">&quot;从小到大:&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;obj.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        cout&lt;&lt;obj[i]&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>;  <br>    &#125; <br> <br>    cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>&lt;&lt;endl;<br> <br>    cout&lt;&lt;<span class="hljs-string">&quot;从大到小:&quot;</span>&lt;&lt;endl;<br>    <span class="hljs-built_in">reverse</span>(obj.<span class="hljs-built_in">begin</span>(),obj.<span class="hljs-built_in">end</span>());<span class="hljs-comment">//从大到小 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;obj.<span class="hljs-built_in">size</span>();i++)<br>    &#123;<br>        cout&lt;&lt;obj[i]&lt;&lt;<span class="hljs-string">&quot;,&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">从小到大:<br>0,1,3,<br><br>从大到小:<br>3,1,0,<br></code></pre></td></tr></table></figure><blockquote><p>1.注意 sort 需要头文件 <strong>#include <algorithm></strong></p><p>2.如果想 sort 来降序，可重写 sort</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">compare</span><span class="hljs-params">(<span class="hljs-type">int</span> a,<span class="hljs-type">int</span> b)</span> </span><br><span class="hljs-function"></span>&#123; <br>    <span class="hljs-keyword">return</span> a&lt; b; <span class="hljs-comment">//升序排列，如果改为return a&gt;b，则为降序 </span><br>&#125; <br><span class="hljs-type">int</span> a[<span class="hljs-number">20</span>]=&#123;<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">23</span>,<span class="hljs-number">5</span>,<span class="hljs-number">76</span>,<span class="hljs-number">0</span>,<span class="hljs-number">43</span>,<span class="hljs-number">24</span>,<span class="hljs-number">65</span>&#125;,i; <br><span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++) <br>    cout&lt;&lt; a[i]&lt;&lt; endl; <br><span class="hljs-built_in">sort</span>(a,a+<span class="hljs-number">20</span>,compare);<br></code></pre></td></tr></table></figure></blockquote><h3 id="4-访问（直接数组访问-amp-迭代器访问）"><a href="#4-访问（直接数组访问-amp-迭代器访问）" class="headerlink" title="4.访问（直接数组访问&amp;迭代器访问）"></a>4.访问（直接数组访问&amp;迭代器访问）</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//顺序访问</span><br>    vector&lt;<span class="hljs-type">int</span>&gt;obj;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<br>    &#123;<br>        obj.<span class="hljs-built_in">push_back</span>(i);   <br>    &#125; <br> <br>    cout&lt;&lt;<span class="hljs-string">&quot;直接利用数组：&quot;</span>; <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)<span class="hljs-comment">//方法一 </span><br>    &#123;<br>        cout&lt;&lt;obj[i]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br> <br>    cout&lt;&lt;endl; <br>    cout&lt;&lt;<span class="hljs-string">&quot;利用迭代器：&quot;</span> ;<br>    <span class="hljs-comment">//方法二，使用迭代器将容器中数据输出 </span><br>    vector&lt;<span class="hljs-type">int</span>&gt;::iterator it;<span class="hljs-comment">//声明一个迭代器，来访问vector容器，作用：遍历或者指向vector容器的元素 </span><br>    <span class="hljs-keyword">for</span>(it=obj.<span class="hljs-built_in">begin</span>();it!=obj.<span class="hljs-built_in">end</span>();it++)<br>    &#123;<br>        cout&lt;&lt;*it&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">直接利用数组：0 1 2 3 4 5 6 7 8 9 <br>利用迭代器：0 1 2 3 4 5 6 7 8 9<br></code></pre></td></tr></table></figure><h3 id="5-二维数组两种定义方法（结果一样）"><a href="#5-二维数组两种定义方法（结果一样）" class="headerlink" title="5.二维数组两种定义方法（结果一样）"></a>5.二维数组两种定义方法（结果一样）</h3><p><strong>方法一：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> N=<span class="hljs-number">5</span>, M=<span class="hljs-number">6</span>; <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">obj</span>(N); <span class="hljs-comment">//定义二维动态数组大小5行 </span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i =<span class="hljs-number">0</span>; i&lt; obj.<span class="hljs-built_in">size</span>(); i++)<span class="hljs-comment">//动态二维数组为5行6列，值全为0 </span><br>    &#123; <br>        obj[i].<span class="hljs-built_in">resize</span>(M); <br>    &#125; <br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt; obj.<span class="hljs-built_in">size</span>(); i++)<span class="hljs-comment">//输出二维动态数组 </span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;obj[i].<span class="hljs-built_in">size</span>();j++)<br>        &#123;<br>            cout&lt;&lt;obj[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>方法二:</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br> <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> N=<span class="hljs-number">5</span>, M=<span class="hljs-number">6</span>; <br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">obj</span>(N, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(M)); <span class="hljs-comment">//定义二维动态数组5行6列 </span><br> <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt; obj.<span class="hljs-built_in">size</span>(); i++)<span class="hljs-comment">//输出二维动态数组 </span><br>    &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;obj[i].<span class="hljs-built_in">size</span>();j++)<br>        &#123;<br>            cout&lt;&lt;obj[i][j]&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">0 0 0 0 0 0 <br>0 0 0 0 0 0 <br>0 0 0 0 0 0 <br>0 0 0 0 0 0 <br>0 0 0 0 0 0 <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim寄存器与系统剪切板</title>
    <link href="/2021/10/31/Tools/Vim/Vim%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%89%AA%E5%88%87%E6%9D%BF/"/>
    <url>/2021/10/31/Tools/Vim/Vim%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8E%E7%B3%BB%E7%BB%9F%E5%89%AA%E5%88%87%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>使用Vim比较爽的一点就是双手可以在小范围内运动就能实现光标的灵活移动以及内容的调整。由于我也是刚入手Vim，在编写文档的时候常常涉及到从Vim复制内容，到Vim外粘贴的情况，但是使用Vim自己的 y 命令复制后，却不能到外面粘贴，于是在搜索解决方案的时候，了解到了寄存器这个东西，所以记录一下。</p><h2 id="Vim寄存器"><a href="#Vim寄存器" class="headerlink" title="Vim寄存器"></a>Vim寄存器</h2><p>vim强大之处之一就是它自带一堆寄存器，每个寄存器独立使用，你可以在不同寄存器中存储不同数据，命令，你可以把这个想象成一个加强版的剪贴板，当然它的功能不止剪贴板这么简单。</p><p>Vim有9种寄存器：</p><ol><li><p>无名（unnamed）寄存器：””，缓存最后一次操作内容；</p></li><li><p>数字（numbered）寄存器：”0 ～”9，缓存最近操作内容，复制与删除有别, “0寄存器缓存最近一次复制的内容，”1-“9缓存最近9次删除内容</p></li><li><p>行内删除（small delete）寄存器：”-，缓存行内删除内容；</p></li><li><p>具名（named）寄存器：”a ～ “z或”A - “0Z，指定时可用；</p></li><li><p>只读（read-only）寄存器：”:,”.,”%,”#，分别缓存最近命令、最近插入文本、当前文件名、当前交替文件名；</p></li><li><p>表达式（expression）寄存器：”&#x3D;，只读，用于执行表达式命令；</p></li><li><p>选择及拖拽（selection and drop）寄存器：”*,”+,”~，存取GUI选择文本，可用于与外部应用交互，使用前提为系统剪切板（clipboard）可用；</p></li><li><p>黑洞（black hole）寄存器：”_，不缓存操作内容（干净删除）；</p></li><li><p>模式寄存器（last search pattern）：”&#x2F;，缓存最近的搜索模式。</p></li></ol><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h4 id="查看寄存器的状况"><a href="#查看寄存器的状况" class="headerlink" title="查看寄存器的状况"></a>查看寄存器的状况</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">:reg<br></code></pre></td></tr></table></figure><h3 id="访问特定的寄存器"><a href="#访问特定的寄存器" class="headerlink" title="访问特定的寄存器"></a>访问特定的寄存器</h3><p>通过在操作方式(y(复制), p(粘贴))前加上寄存器名称，便可操作特定寄存器。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">&quot;ap      粘贴字母a寄存器内容  <br>&quot;1y      把选取内容复制到数字寄存器1 <br></code></pre></td></tr></table></figure><h3 id="与系统剪切板交互"><a href="#与系统剪切板交互" class="headerlink" title="与系统剪切板交互"></a>与系统剪切板交互</h3><p>通过 <code>&quot;+</code> + 操作方式实现，例如：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">&quot;+y 复制选中内容到剪切板<br>&quot;+p 粘贴剪切板内容到Vim<br>&quot;+gp 粘贴剪切板到Vim，并将光标移到内容后<br></code></pre></td></tr></table></figure><p>如果想将这种命令的方式变成快捷键的方式，可以借助Vim的Map功能：</p><p>在<code>.vimrc</code>种增加：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">nmap &lt;c-v&gt; &quot;+gp  <br>nmap &lt;c-c&gt; &quot;+y  <br></code></pre></td></tr></table></figure><p>这样就能通过 <code>Ctrl + C</code> 实现复制，<code>Ctrl + V</code> 实现粘贴。</p><p>当然，如果不使用这种修饰键，也可以通过组合普通键的方式实现：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">nmap &lt;leader&gt;v &quot;+gp <br>nmap &lt;leader&gt;c &quot;+y <br></code></pre></td></tr></table></figure><p>&lt;leader&gt;由自己设置，比如设置成<code>,</code> :</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">let mapleader=&quot;,&quot; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Vim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中如何使用环境变量</title>
    <link href="/2021/10/31/Go%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/"/>
    <url>/2021/10/31/Go%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>环境变量（environment variables）一般是指在操作系统中用来指定操作系统运行环境的一些参数，如：临时文件夹位置和系统文件夹位置等。</p></blockquote><p>在 Go 语言中，和环境变量相关的 API 主要在 os 包中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Environ 以 key=value 的形式返回所有环境变量。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Environ</span><span class="hljs-params">()</span></span> []<span class="hljs-type">string</span><br><span class="hljs-comment">// ExpandEnv 根据当前环境变量的值替换字符串中的 $&#123;var&#125; 或 $var。</span><br><span class="hljs-comment">// 对未定义变量的引用将被空字符串替换。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExpandEnv</span><span class="hljs-params">(s <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span><br><span class="hljs-comment">// Getenv 检索 key 这个键对应的环境变量的值。</span><br><span class="hljs-comment">// 如果该环境变量不存在，返回空字符串。</span><br><span class="hljs-comment">// 要区分空值和未设置值，请使用 LookupEnv。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Getenv</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span><br><span class="hljs-comment">// LookupEnv 检索 key 这个键对应的环境变量的值。</span><br><span class="hljs-comment">// 如果该环境变量不存在，则返回对应的值(可能为空)，并且布尔值为 true。</span><br><span class="hljs-comment">// 否则，返回值将为空，布尔值将为 false。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LookupEnv</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">bool</span>)<br><span class="hljs-comment">// Setenv 设置 key 这个键对应的环境变量的值。</span><br><span class="hljs-comment">// 如果出错会返回错误。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Setenv</span><span class="hljs-params">(key, value <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span><br><span class="hljs-comment">// Unsetenv 取消设置单个环境变量。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Unsetenv</span><span class="hljs-params">(key <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">error</span><br><span class="hljs-comment">// Clearenv 将删除所有环境变量。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Clearenv</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure><p>此外，os&#x2F;exec 中有一个 LookPath 函数，和 PATH 环境变量有关：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 在 PATH 环境变量对应的目录中搜索名为 file 的可执行文件。</span><br><span class="hljs-comment">// 如果文件包含 /，则不会搜索 PATH，而是正常路径查找。</span><br><span class="hljs-comment">// 返回的结果可能是绝对路径或相对于当前目录的相对路径。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">LookPath</span><span class="hljs-params">(file <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p>现在，通过一个例子来看看这些API如何使用:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>name := os.Getenv(<span class="hljs-string">&quot;NAME&quot;</span>)<br>fmt.Println(name)<br>&#125;<br><br></code></pre></td></tr></table></figure><p>运行上面代码:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">NAME=<span class="hljs-string">&quot;mofan&quot;</span> go run main.go</span><br></code></pre></td></tr></table></figure><p>如果没有指定 <code>NAME</code> 则会输出一个空字符串，如果希望有默认值，可以借助 <code>LookupEnv</code> 实现:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//name := os.Getenv(&quot;NAME&quot;)</span><br>name := GetenvDefault(<span class="hljs-string">&quot;NAME&quot;</span>, <span class="hljs-string">&quot;Mofankk&quot;</span>)<br>fmt.Println(name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetenvDefault</span><span class="hljs-params">(key, defVal <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span> &#123;<br>val, ok := os.LookupEnv(key)<br><span class="hljs-keyword">if</span> ok &#123;<br><span class="hljs-keyword">return</span> val<br>&#125;<br><span class="hljs-keyword">return</span> defVal<br>&#125;<br></code></pre></td></tr></table></figure><p>由于进程会从父进程继承环境变量。这里最重要的就是 PATH 环境变量。有时候，我们通过 os&#x2F;exec 包执行外部程序时，可能会提示找不到命令，这时需要确认 PATH 是否正确。可能 Shell 下 PATH 包含了命令所在目录，但进程可能没包含，我们可以在程序中输出所有环境变量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">envs := os.Environ()<br><span class="hljs-keyword">for</span> _, env := <span class="hljs-keyword">range</span> envs &#123;<br>  fmt.Println(env)<br>&#125;<br></code></pre></td></tr></table></figure><p>一行是一个完整的环境变量，比如 <code>LANG=zh_CN.UTF-8</code>。</p><p>再看下 ExpandEnv() 函数。有以下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">host := os.ExpandEnv(<span class="hljs-string">&quot;127.0.0.1:$PORT&quot;</span>)<br>fmt.Println(host)<br></code></pre></td></tr></table></figure><p><code>IP:PORT</code> 的形式是常见的，通常，我们会做字符串拼接：<code>host + &quot;:&quot; + port</code>，有了 os.ExpandEnv，不需要进行拼接了，它会将 <code>$PORT</code> 替换为 <code>os.Getenv(&quot;PORT&quot;)</code> 的值。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac上的ControlCe进程</title>
    <link href="/2021/10/30/problems/Mac%E4%B8%8A%E7%9A%84ControlCe%E8%BF%9B%E7%A8%8B/"/>
    <url>/2021/10/30/problems/Mac%E4%B8%8A%E7%9A%84ControlCe%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>这几天刚换笔记本，于是迁移了一波环境，在跑代码的时候，发现5000端口竟然被占用，因为之前项目一直用的5000端口，所以我有点好奇Mac上的什么进程用了这样一个普普通通的端口。</p><p>通过 <code>sudo lsof -i tcp:5000</code> 命令发现是 <code>ControlCe</code> 进程在占用，于是查了一下这个进程，在<a href="https://developer.apple.com/forums/thread/682332">Why is Control Center on Monterey … | Apple Developer Forums</a>找到了答案，原来是 <code>AirPlay Receiver</code> 占用的。</p><p>关闭 <code>Airplay Receiver</code> 的方式很简单，到 <strong>系统偏好设置 -&gt; 共享</strong>，将左侧服务中的 <strong>隔空播放接收器</strong> 取消勾选即可。</p>]]></content>
    
    
    <categories>
      
      <category>Problems</category>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac使用命令查看SSD健康情况</title>
    <link href="/2021/10/30/problems/Mac%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8BSSD%E5%81%A5%E5%BA%B7%E6%83%85%E5%86%B5/"/>
    <url>/2021/10/30/problems/Mac%E4%BD%BF%E7%94%A8%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8BSSD%E5%81%A5%E5%BA%B7%E6%83%85%E5%86%B5/</url>
    
    <content type="html"><![CDATA[<p>本方式是借助命令行工具实现。</p><p>该工具使用 HomeBrew 进行安装，如果未安装 HomeBrew，请先到HomeBrew官方安装。</p><ol><li><p>打开终端工具，输入如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew install smartmontools<br></code></pre></td></tr></table></figure></li><li><p>获取硬盘设备标签代码，有两种方式，第一种较为简单(推荐)：</p><ul><li><p>一：通过图形化界面（推荐）：</p><p>打开Mac上的 <strong>磁盘工具</strong>，点击Mac硬盘，在右侧找到 <strong>设备</strong> 对应的值，例如：disk1s1。</p></li><li><p>二：通过命令行:</p><p>在终端中输入 <code>diskutil list</code>，找到 <strong>TYPE NAME</strong> 为 **APFS Volume ⁨Macintosh HD⁩ ** 的行所对应的 <strong>IDENTIFIER</strong> 的值。</p></li></ul></li><li><p>开始进行SSD检查，输入命令，后面的值就是第 2 步拿到的硬盘标识码:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">smartctl -a disk1s1<br></code></pre></td></tr></table></figure></li></ol><p>执行结束后，会输出一堆信息，可对照下面进行查看:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs txt">严重警告（Critical Warning）：会显示控制器状态警告讯息，如果都显示0x00 就表示没事<br><br>温度（Temperature）：会显示当前SSD 温度资讯<br><br>可用备用空间（Available Spare）：SSD 剩余空间百分比<br><br>可用备用临界值（Available Spare Threshold）：临界值全由厂商定义<br><br>寿命百分比（Percentage Used）：目前SSD 寿命百分比数值，具体取决于实际设备使用情况和厂商对设备寿命的预测。<br><br>资料读取（Data Units Read）：记录电脑从SSD读取512字节数据单元的总量，每1000个单元记录一次，即这项Raw数据1的值等于500KB。<br><br>资料写入（Data Units Read）：如上，就是写入总量。<br><br>主机读取命令（Host Read Commands）：主控收到的读取命令数量。<br><br>主机写入命令（Host Write Commands）：主控收到的写入命令数量。<br><br>控制器忙碌时间（Controller Busy Time）：主控忙于I/O命令的时间。<br><br>意外关机（Unsafe Shutdowns）：纪录不正常断电次数<br><br>媒体和资料完整性错误（Media and Data Integrity Errors）：主控检测得到的未恢复的数据完整性错误次数。<br><br>错误资料纪录（Number of Error Information Log Entries）：主控总共收到的错误信息日志数量.<br></code></pre></td></tr></table></figure><p>通常我们主要确认「寿命百分比（Percentage Used）」这项数值就好，通常达到90%以上就要额外注意。</p>]]></content>
    
    
    <categories>
      
      <category>Problems</category>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ohmyzsh自用主题推荐</title>
    <link href="/2021/10/29/Tools/OhMyZsh/ohmyzsh%E8%87%AA%E7%94%A8%E4%B8%BB%E9%A2%98%E6%8E%A8%E8%8D%90/"/>
    <url>/2021/10/29/Tools/OhMyZsh/ohmyzsh%E8%87%AA%E7%94%A8%E4%B8%BB%E9%A2%98%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<p>我用的主题是: murilasso, 将 .zshrc 里的 ZSH_THEME改成这个值即可.</p><p>同时，这个主题我认为有一个缺点，就是无法像Linux 那样普通用户模式下是 $ 开始，管理员账户下是 # 开始，于是我在这个基础上又进行了一些修改，具体很简单，编辑: <code>vim .oh-my-zsh/themes/murilasso.zsh-theme</code> ， 只需要关注下<code>$&#123;git_branch&#125; %&#123;$reset_color%&#125;%(!.#.$) &quot;</code> 这里即可.</p><p>我的主题文件为:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs txt">local return_code=&quot;%(?..%&#123;$fg[red]%&#125;%? ↵%&#123;$reset_color%&#125;)&quot;<br>local user_host=&#x27;%&#123;$terminfo[bold]$fg[green]%&#125;%n@%m%&#123;$reset_color%&#125;&#x27;<br>local current_dir=&#x27;%&#123;$terminfo[bold]$fg[blue]%&#125;%~%&#123;$reset_color%&#125;&#x27;<br>local rvm_ruby=&#x27;%&#123;$fg[red]%&#125;$(rvm_prompt_info || rbenv_prompt_info)%&#123;$reset_color%&#125;&#x27;<br>local git_branch=&#x27;%&#123;$fg[blue]%&#125;$(git_prompt_info)%&#123;$reset_color%&#125;&#x27;<br><br>PROMPT=&quot;$&#123;user_host&#125;:$&#123;current_dir&#125; $&#123;rvm_ruby&#125;<br>$&#123;git_branch&#125; %&#123;$reset_color%&#125;%(!.#.$) &quot;<br>RPS1=&quot;$&#123;return_code&#125;&quot;<br><br>ZSH_THEME_GIT_PROMPT_PREFIX=&quot;&quot;<br>ZSH_THEME_GIT_PROMPT_SUFFIX=&quot;&quot;<br>ZSH_THEME_GIT_PROMPT_DIRTY=&quot; %&#123;$fg[red]%&#125;✗%&#123;$reset_color%&#125;&quot;<br>ZSH_THEME_GIT_PROMPT_CLEAN=&quot; %&#123;$fg[green]%&#125;✔%&#123;$reset_color%&#125;&quot;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>ohmyzsh</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ohmyzsh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hyper的个人配置</title>
    <link href="/2021/10/29/Tools/Hyper/Hyper%E7%9A%84%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE/"/>
    <url>/2021/10/29/Tools/Hyper/Hyper%E7%9A%84%E4%B8%AA%E4%BA%BA%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>刚开始接触 Mac 的人，可能他的第二款终端软件就是 iTerm2，但是，用时间长了后，总感觉 iTerm2 不够纯粹，但好在 iTerm2 的功能还是挺多的，属于那种开箱就用也能体验良好的终端。<br>当我在思考替代 iTerm2 的终端的时候，我的需求渐渐清晰，一定要轻量，而且在好看的同时具有个性，于是我发现了 Hyper，看到的第一眼就喜欢上了这款终端，开启这个软件让人有一种眼前一亮的感觉.</p><p>说了这么多，就贴一份我的配置清单吧.<br>我使用的主题是: hyper-electron-highlighter, 需要通过 <code>hyper i hyper-electron-highlighter</code> 命令进行安装, 同时要注意该 plugins 要放到config下，因为后面还有我自定义的一些颜色，总之，注意顺序，别把修改的部分覆盖了.</p><blockquote><p>如果你安装时，提示 hyper 命令不可用，你可以点击菜单栏的 Tools -&gt; Install Hyper CLI command in PATH</p></blockquote><blockquote><p>另外，配合oh-my-zsh的主题使用效果更好，请参考: <a href="https://www.mofan.life/2021/10/29/oh-my-zsh%E8%87%AA%E7%94%A8%E4%B8%BB%E9%A2%98%E6%8E%A8%E8%8D%90/">https://www.mofan.life/2021/10/29/oh-my-zsh%E8%87%AA%E7%94%A8%E4%B8%BB%E9%A2%98%E6%8E%A8%E8%8D%90/</a></p></blockquote><blockquote><p>如果安装oh-my-zsh后，发现 .bash_profile 里的环境变量不能用了，请在 .zshrc 的文件上面加上一行: source ~&#x2F;.bash_profile</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&quot;use strict&quot;</span>;<br><span class="hljs-comment">// Future versions of Hyper may add additional config options,</span><br><span class="hljs-comment">// which will not automatically be merged into this file.</span><br><span class="hljs-comment">// See https://hyper.is#cfg for all currently supported options.</span><br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>    <span class="hljs-attr">config</span>: &#123;<br>        <span class="hljs-comment">// choose either `&#x27;stable&#x27;` for receiving highly polished,</span><br>        <span class="hljs-comment">// or `&#x27;canary&#x27;` for less polished but more frequent updates</span><br>        <span class="hljs-attr">updateChannel</span>: <span class="hljs-string">&#x27;stable&#x27;</span>,<br>        <span class="hljs-comment">// default font size in pixels for all tabs</span><br>        <span class="hljs-attr">fontSize</span>: <span class="hljs-number">14</span>,<br>        <span class="hljs-comment">// font family with optional fallbacks</span><br>        <span class="hljs-attr">fontFamily</span>: <span class="hljs-string">&#x27;Monaco, Menlo, &quot;DejaVu Sans Mono&quot;, Consolas, &quot;Lucida Console&quot;, monospace&#x27;</span>,<br>        <span class="hljs-comment">// default font weight: &#x27;normal&#x27; or &#x27;bold&#x27;</span><br>        <span class="hljs-attr">fontWeight</span>: <span class="hljs-string">&#x27;normal&#x27;</span>,<br>        <span class="hljs-comment">// font weight for bold characters: &#x27;normal&#x27; or &#x27;bold&#x27;</span><br>        <span class="hljs-attr">fontWeightBold</span>: <span class="hljs-string">&#x27;normal&#x27;</span>,<br>        <span class="hljs-comment">// line height as a relative unit</span><br>        <span class="hljs-attr">lineHeight</span>: <span class="hljs-number">1.1</span>,<br>        <span class="hljs-comment">// letter spacing as a relative unit</span><br>        <span class="hljs-attr">letterSpacing</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-comment">// terminal cursor background color and opacity (hex, rgb, hsl, hsv, hwb or cmyk)</span><br>        <span class="hljs-attr">cursorColor</span>: <span class="hljs-string">&#x27;rgba(248,28,229,0.8)&#x27;</span>,<br>        <span class="hljs-comment">// terminal text color under BLOCK cursor</span><br>        <span class="hljs-attr">cursorAccentColor</span>: <span class="hljs-string">&#x27;#000&#x27;</span>,<br>        <span class="hljs-comment">// `&#x27;BEAM&#x27;` for |, `&#x27;UNDERLINE&#x27;` for _, `&#x27;BLOCK&#x27;` for █</span><br>        <span class="hljs-attr">cursorShape</span>: <span class="hljs-string">&#x27;BLOCK&#x27;</span>,<br>        <span class="hljs-comment">// set to `true` (without backticks and without quotes) for blinking cursor</span><br>        <span class="hljs-attr">cursorBlink</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">// color of the text</span><br>        <span class="hljs-attr">foregroundColor</span>: <span class="hljs-string">&#x27;#fff&#x27;</span>,<br>        <span class="hljs-comment">// terminal background color</span><br>        <span class="hljs-comment">// opacity is only supported on macOS</span><br>        <span class="hljs-attr">backgroundColor</span>: <span class="hljs-string">&#x27;#000&#x27;</span>,<br>        <span class="hljs-comment">// terminal selection color</span><br>        <span class="hljs-attr">selectionColor</span>: <span class="hljs-string">&#x27;rgba(204, 51, 255,0.4)&#x27;</span>,<br>        <span class="hljs-comment">// border color (window, tabs)</span><br>        <span class="hljs-attr">borderColor</span>: <span class="hljs-string">&#x27;#333&#x27;</span>,<br>        <span class="hljs-comment">// custom CSS to embed in the main window</span><br>        <span class="hljs-attr">css</span>: <span class="hljs-string">&#x27;::selection &#123; background-color: rgba(233, 44, 108, 0.8); color: #fcfcfc; border-radius: 25px;&#125;&#x27;</span>,<br>        <span class="hljs-comment">// custom CSS to embed in the terminal window</span><br>        <span class="hljs-attr">termCSS</span>: <span class="hljs-string">&#x27;::selection &#123; background-color: rgba(233, 44, 108, 0.8); color: #fcfcfc; border-radius: 25px;&#125;&#x27;</span>,<br>        <span class="hljs-comment">// set custom startup directory (must be an absolute path)</span><br>        <span class="hljs-attr">workingDirectory</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-comment">// if you&#x27;re using a Linux setup which show native menus, set to false</span><br>        <span class="hljs-comment">// default: `true` on Linux, `true` on Windows, ignored on macOS</span><br>        <span class="hljs-attr">showHamburgerMenu</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-comment">// set to `false` (without backticks and without quotes) if you want to hide the minimize, maximize and close buttons</span><br>        <span class="hljs-comment">// additionally, set to `&#x27;left&#x27;` if you want them on the left, like in Ubuntu</span><br>        <span class="hljs-comment">// default: `true` (without backticks and without quotes) on Windows and Linux, ignored on macOS</span><br>        <span class="hljs-attr">showWindowControls</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-comment">// custom padding (CSS format, i.e.: `top right bottom left`)</span><br>        <span class="hljs-attr">padding</span>: <span class="hljs-string">&#x27;10px 12px&#x27;</span>,<br>        <span class="hljs-comment">// the full list. if you&#x27;re going to provide the full color palette,</span><br>        <span class="hljs-comment">// including the 6 x 6 color cubes and the grayscale map, just provide</span><br>        <span class="hljs-comment">// an array here instead of a color map object</span><br>        <span class="hljs-attr">plugins</span>: [<span class="hljs-string">&quot;hyper-electron-highlighter&quot;</span>],<br>        <span class="hljs-attr">colors</span>: &#123;<br>              <span class="hljs-attr">black</span>: <span class="hljs-string">&#x27;#ffffff&#x27;</span>,<br>        <span class="hljs-comment">//      red: &#x27;#66ff99&#x27;,</span><br>              <span class="hljs-attr">green</span>: <span class="hljs-string">&#x27;#00ff66&#x27;</span>,<br>            <span class="hljs-attr">yellow</span>: <span class="hljs-string">&#x27;#ffff33&#x27;</span>,<br>        <span class="hljs-comment">//     blue: &#x27;#0A2FC4&#x27;,</span><br>             <span class="hljs-attr">magenta</span>: <span class="hljs-string">&#x27;#ff66cc&#x27;</span>,<br>        <span class="hljs-comment">//     cyan: &#x27;#20C5C6&#x27;,</span><br>             <span class="hljs-attr">white</span>: <span class="hljs-string">&#x27;#00ff00&#x27;</span>,<br>        <span class="hljs-comment">//     lightBlack: &#x27;#686868&#x27;,</span><br>        <span class="hljs-comment">//     lightRed: &#x27;#FFFFFF&#x27;,</span><br>        <span class="hljs-comment">//     lightGreen: &#x27;#67F86F&#x27;,</span><br>        <span class="hljs-comment">//     lightYellow: &#x27;#009933&#x27;,</span><br>        <span class="hljs-comment">//     lightBlue: &#x27;#6A76FB&#x27;,</span><br>             <span class="hljs-attr">lightMagenta</span>: <span class="hljs-string">&#x27;#9900ff&#x27;</span>,<br>        <span class="hljs-comment">//     lightCyan: &#x27;#68FDFE&#x27;,</span><br>             <span class="hljs-attr">lightWhite</span>: <span class="hljs-string">&#x27;#00ff00&#x27;</span>,<br>        <span class="hljs-comment">//     limeGreen: &#x27;#32CD32&#x27;,</span><br>        <span class="hljs-comment">//     lightCoral: &#x27;#F08080&#x27;,</span><br>        &#125;,<br>        <span class="hljs-comment">// the shell to run when spawning a new session (i.e. /usr/local/bin/fish)</span><br>        <span class="hljs-comment">// if left empty, your system&#x27;s login shell will be used by default</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// Windows</span><br>        <span class="hljs-comment">// - Make sure to use a full path if the binary name doesn&#x27;t work</span><br>        <span class="hljs-comment">// - Remove `--login` in shellArgs</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// Windows Subsystem for Linux (WSL) - previously Bash on Windows</span><br>        <span class="hljs-comment">// - Example: `C:\\Windows\\System32\\wsl.exe`</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// Git-bash on Windows</span><br>        <span class="hljs-comment">// - Example: `C:\\Program Files\\Git\\bin\\bash.exe`</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// PowerShell on Windows</span><br>        <span class="hljs-comment">// - Example: `C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\powershell.exe`</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// Cygwin</span><br>        <span class="hljs-comment">// - Example: `C:\\cygwin64\\bin\\bash.exe`</span><br>        <span class="hljs-attr">shell</span>: <span class="hljs-string">&#x27;/bin/zsh&#x27;</span>,<br>        <span class="hljs-comment">// for setting shell arguments (i.e. for using interactive shellArgs: `[&#x27;-i&#x27;]`)</span><br>        <span class="hljs-comment">// by default `[&#x27;--login&#x27;]` will be used</span><br>        <span class="hljs-attr">shellArgs</span>: [<span class="hljs-string">&#x27;--login&#x27;</span>],<br>        <span class="hljs-comment">// for environment variables</span><br>        <span class="hljs-attr">env</span>: &#123;&#125;,<br>        <span class="hljs-comment">// Supported Options:</span><br>        <span class="hljs-comment">//  1. &#x27;SOUND&#x27; -&gt; Enables the bell as a sound</span><br>        <span class="hljs-comment">//  2. false: turns off the bell</span><br>        <span class="hljs-attr">bell</span>: <span class="hljs-string">&#x27;SOUND&#x27;</span>,<br>        <span class="hljs-comment">// An absolute file path to a sound file on the machine.</span><br>        <span class="hljs-comment">// bellSoundURL: &#x27;/path/to/sound/file&#x27;,</span><br>        <span class="hljs-comment">// if `true` (without backticks and without quotes), selected text will automatically be copied to the clipboard</span><br>        <span class="hljs-attr">copyOnSelect</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-comment">// if `true` (without backticks and without quotes), hyper will be set as the default protocol client for SSH</span><br>        <span class="hljs-attr">defaultSSHApp</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">// if `true` (without backticks and without quotes), on right click selected text will be copied or pasted if no</span><br>        <span class="hljs-comment">// selection is present (`true` by default on Windows and disables the context menu feature)</span><br>        <span class="hljs-attr">quickEdit</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-comment">// choose either `&#x27;vertical&#x27;`, if you want the column mode when Option key is hold during selection (Default)</span><br>        <span class="hljs-comment">// or `&#x27;force&#x27;`, if you want to force selection regardless of whether the terminal is in mouse events mode</span><br>        <span class="hljs-comment">// (inside tmux or vim with mouse mode enabled for example).</span><br>        <span class="hljs-attr">macOptionSelectionMode</span>: <span class="hljs-string">&#x27;vertical&#x27;</span>,<br>        <span class="hljs-comment">// Whether to use the WebGL renderer. Set it to false to use canvas-based</span><br>        <span class="hljs-comment">// rendering (slower, but supports transparent backgrounds)</span><br>        <span class="hljs-attr">webGLRenderer</span>: <span class="hljs-literal">false</span>,<br>        <span class="hljs-comment">// keypress required for weblink activation: [ctrl|alt|meta|shift]</span><br>        <span class="hljs-comment">// todo: does not pick up config changes automatically, need to restart terminal :/</span><br>        <span class="hljs-attr">webLinksActivationKey</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>        <span class="hljs-comment">// if `false` (without backticks and without quotes), Hyper will use ligatures provided by some fonts</span><br>        <span class="hljs-attr">disableLigatures</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-comment">// for advanced config flags please refer to https://hyper.is/#cfg</span><br>        <span class="hljs-attr">windowSize</span>: [<span class="hljs-number">900</span>, <span class="hljs-number">600</span>]<br><br>       <span class="hljs-comment">// verminal: &#123;</span><br>       <span class="hljs-comment">//   fontFamily: &#x27;&quot;My favourite font&quot;&#x27;,</span><br>       <span class="hljs-comment">//   fontSize: 16</span><br>       <span class="hljs-comment">// &#125;,</span><br><br>       <span class="hljs-comment">// Customize the theme</span><br>       <span class="hljs-comment">// themeSettings: &#123;</span><br>       <span class="hljs-comment">//     // Do not make background transparent (default is 0.9)</span><br>       <span class="hljs-comment">//     opacity: 1,</span><br>       <span class="hljs-comment">//     // Switch from luke&#x27;s orange uniform to master yoda (check the available styles above)</span><br>       <span class="hljs-comment">//     style: &#x27;luke&#x27;,</span><br>       <span class="hljs-comment">//     // Change the character that mars a tab active</span><br>       <span class="hljs-comment">//     tabActiveMarker: &#x27;💁&#x27;</span><br>       <span class="hljs-comment">// &#125;,</span><br><br>    &#125;,<br>    <span class="hljs-comment">// a list of plugins to fetch and install from npm</span><br>    <span class="hljs-comment">// format: [@org/]project[#version]</span><br>    <span class="hljs-comment">// examples:</span><br>    <span class="hljs-comment">//   `hyperpower`</span><br>    <span class="hljs-comment">//   `@company/project`</span><br>    <span class="hljs-comment">//   `project#1.0.1`</span><br>    <span class="hljs-comment">// &quot;hyper-ui&quot;, &quot;hyper-aura-theme&quot;, &quot;hyper-named-css-colors&quot;</span><br>    <span class="hljs-comment">//plugins: [</span><br>    <span class="hljs-comment">//     &quot;hyper-electron-highlighter&quot;,</span><br>    <span class="hljs-comment">//],</span><br>    <span class="hljs-comment">// in development, you can create a directory under</span><br>    <span class="hljs-comment">// `~/.hyper_plugins/local/` and include it here</span><br>    <span class="hljs-comment">// to load it and avoid it being `npm install`ed</span><br>    <span class="hljs-attr">localPlugins</span>: [],<br>    <span class="hljs-attr">keymaps</span>: &#123;<br>    <span class="hljs-comment">// Example</span><br>    <span class="hljs-comment">// &#x27;window:devtools&#x27;: &#x27;cmd+alt+o&#x27;,</span><br>        <span class="hljs-string">&quot;window:devtools&quot;</span>: <span class="hljs-string">&quot;command+alt+i&quot;</span>,<br>        <span class="hljs-string">&quot;window:reload&quot;</span>: <span class="hljs-string">&quot;command+shift+r&quot;</span>,<br>        <span class="hljs-string">&quot;window:reloadFull&quot;</span>: <span class="hljs-string">&quot;command+shift+f5&quot;</span>,<br>        <span class="hljs-string">&quot;window:preferences&quot;</span>: <span class="hljs-string">&quot;command+,&quot;</span>,<br>        <span class="hljs-string">&quot;zoom:reset&quot;</span>: <span class="hljs-string">&quot;command+0&quot;</span>,<br>        <span class="hljs-string">&quot;zoom:in&quot;</span>: [<br>          <span class="hljs-string">&quot;command+plus&quot;</span>,<br>          <span class="hljs-string">&quot;command+=&quot;</span><br>        ],<br>        <span class="hljs-string">&quot;zoom:out&quot;</span>: <span class="hljs-string">&quot;command+-&quot;</span>,  <br>        <span class="hljs-string">&quot;window:new&quot;</span>: <span class="hljs-string">&quot;command+n&quot;</span>,<br>        <span class="hljs-string">&quot;window:minimize&quot;</span>: <span class="hljs-string">&quot;command+m&quot;</span>,<br>        <span class="hljs-string">&quot;window:zoom&quot;</span>: <span class="hljs-string">&quot;command+enter&quot;</span>,<br>        <span class="hljs-string">&quot;window:toggleFullScreen&quot;</span>: <span class="hljs-string">&quot;command+ctrl+f&quot;</span>,<br>        <span class="hljs-string">&quot;window:close&quot;</span>: <span class="hljs-string">&quot;command+shift+w&quot;</span>,<br>        <span class="hljs-string">&quot;tab:new&quot;</span>: <span class="hljs-string">&quot;command+t&quot;</span>,<br>        <span class="hljs-string">&quot;tab:next&quot;</span>: [<br>          <span class="hljs-string">&quot;command+shift+]&quot;</span>,<br>          <span class="hljs-string">&quot;command+shift+right&quot;</span>,<br>          <span class="hljs-string">&quot;command+alt+right&quot;</span>,<br>          <span class="hljs-string">&quot;ctrl+tab&quot;</span><br>        ],<br>        <span class="hljs-string">&quot;tab:prev&quot;</span>: [<br>          <span class="hljs-string">&quot;command+shift+[&quot;</span>,<br>          <span class="hljs-string">&quot;command+shift+left&quot;</span>,<br>          <span class="hljs-string">&quot;command+alt+left&quot;</span>,<br>          <span class="hljs-string">&quot;ctrl+shift+tab&quot;</span><br>        ],<br>        <span class="hljs-string">&quot;tab:jump:prefix&quot;</span>: <span class="hljs-string">&quot;command&quot;</span>,<br>        <span class="hljs-string">&quot;pane:next&quot;</span>: <span class="hljs-string">&quot;command+j&quot;</span>, <br>        <span class="hljs-string">&quot;pane:prev&quot;</span>: <span class="hljs-string">&quot;command+k&quot;</span>, <br>        <span class="hljs-string">&quot;pane:splitRight&quot;</span>: <span class="hljs-string">&quot;command+d&quot;</span>,<br>        <span class="hljs-string">&quot;pane:splitDown&quot;</span>: <span class="hljs-string">&quot;command+shift+d&quot;</span>,<br>        <span class="hljs-string">&quot;pane:close&quot;</span>: <span class="hljs-string">&quot;command+w&quot;</span>,<br>        <span class="hljs-string">&quot;editor:undo&quot;</span>: <span class="hljs-string">&quot;command+z&quot;</span>,<br>        <span class="hljs-string">&quot;editor:redo&quot;</span>: <span class="hljs-string">&quot;command+y&quot;</span>,<br>        <span class="hljs-string">&quot;editor:cut&quot;</span>: <span class="hljs-string">&quot;command+x&quot;</span>,<br>        <span class="hljs-string">&quot;editor:copy&quot;</span>: <span class="hljs-string">&quot;command+c&quot;</span>,<br>        <span class="hljs-string">&quot;editor:paste&quot;</span>: <span class="hljs-string">&quot;command+v&quot;</span>,<br>        <span class="hljs-string">&quot;editor:selectAll&quot;</span>: <span class="hljs-string">&quot;command+a&quot;</span>,<br>        <span class="hljs-string">&quot;editor:search&quot;</span>: <span class="hljs-string">&quot;command+f&quot;</span>,<br>        <span class="hljs-string">&quot;editor:search-close&quot;</span>: <span class="hljs-string">&quot;esc&quot;</span>,<br>        <span class="hljs-string">&quot;editor:movePreviousWord&quot;</span>: <span class="hljs-string">&quot;alt+left&quot;</span>,<br>        <span class="hljs-string">&quot;editor:moveNextWord&quot;</span>: <span class="hljs-string">&quot;alt+right&quot;</span>,<br>        <span class="hljs-string">&quot;editor:moveBeginningLine&quot;</span>: <span class="hljs-string">&quot;command+left&quot;</span>,<br>        <span class="hljs-string">&quot;editor:moveEndLine&quot;</span>: <span class="hljs-string">&quot;command+right&quot;</span>,<br>        <span class="hljs-string">&quot;editor:deletePreviousWord&quot;</span>: <span class="hljs-string">&quot;alt+backspace&quot;</span>,<br>        <span class="hljs-string">&quot;editor:deleteNextWord&quot;</span>: <span class="hljs-string">&quot;alt+delete&quot;</span>,<br>        <span class="hljs-string">&quot;editor:deleteBeginningLine&quot;</span>: <span class="hljs-string">&quot;command+backspace&quot;</span>,<br>        <span class="hljs-string">&quot;editor:deleteEndLine&quot;</span>: <span class="hljs-string">&quot;command+delete&quot;</span>,<br>        <span class="hljs-string">&quot;editor:break&quot;</span>: <span class="hljs-string">&quot;ctrl+c&quot;</span>,<br>        <span class="hljs-string">&quot;plugins:update&quot;</span>: <span class="hljs-string">&quot;command+shift+u&quot;</span><br>      <br>    &#125;,<br>&#125;;<br><span class="hljs-comment">//# sourceMappingURL=config-default.js.map</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Hyper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hyper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用Vim进行Go开发环境搭建</title>
    <link href="/2021/10/29/Tools/Vim/%E4%BD%BF%E7%94%A8Vim%E8%BF%9B%E8%A1%8CGo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <url>/2021/10/29/Tools/Vim/%E4%BD%BF%E7%94%A8Vim%E8%BF%9B%E8%A1%8CGo%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<p>本文档假定你已经搭建好了Go开发环境，重点介绍如何配置Vim.</p><p>一般 Mac OS 或者 Linux 都内置了Vim, 所以，下面的插件都要用其安装方式描述中的 vim-plugin 的方式安装, 不过在此之前，需要首先为 Vim 安装 vim-plugin，安装方式请参考<a href="https://github.com/fatih/vim-go">fatih&#x2F;vim-go: Go development plugin for Vim</a>.</p><p>安装完 vim-plugin 后，可以使用下面各个插件提到的 vim-plugin 方式进行安装:</p><ul><li><a href="https://github.com/fatih/vim-go">fatih&#x2F;vim-go: Go development plugin for Vim</a></li><li><a href="https://github.com/neoclide/coc.nvim">neoclide&#x2F;coc.nvim: Nodejs extension host for vim &amp; neovim, load extensions like VSCode and host language servers.</a> 注意：如果已经安装过nodejs，且符合其要求，则不必再执行其安装nodejs的步骤.</li></ul><p>安装完coc vim 后，可以去安装他的extensions（<a href="https://github.com/neoclide/coc.nvim/wiki/Using-coc-extensions">Using coc extensions · neoclide&#x2F;coc.nvim Wiki</a>），找到coc-go进行安装，如果需要安装其他的拓展，也可以进行安装.</p><p>安装完上面连个必须插件后，可根据需要尝试其他的插件，比如:在左侧展示目录树的 NERDTree.</p><p>下面是我的一份 .vimrc 的配置文档，可进行参考，当然你也可以直接替换你的 .vimrc 文档，然后在文档里执行 :PlugInstall 的 vim 命令(注意一定要先安装 vim-plugin).</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br></pre></td><td class="code"><pre><code class="hljs shell">syntax on<br>colorscheme desert<br>set nu <br>set tabstop=4<br>set shiftwidth=4<br>set expandtab<br>set autoindent<br>set autochdir<br>set backspace=2<br>set foldmethod=indent<br>set foldlevelstart=99<br>set linespace=2<br>set noreadonly<br>set nocompatible<br>set mmp=2000<br>&quot;set clipboard=unnamed<br>let g:coc_node_path=&quot;/usr/local/bin/node&quot;<br><br>&quot;=================================<br>&quot; Vim-plug Start<br>&quot;=================================<br>call plug#begin(&#x27;~/.vim/plugged&#x27;)<br>&quot;======= Common ======<br>&quot;---- coc.nvim ----<br>Plug &#x27;neoclide/coc.nvim&#x27;, &#123;&#x27;branch&#x27;: &#x27;release&#x27;&#125;<br>&quot;---- golang ----<br>Plug &#x27;fatih/vim-go&#x27;, &#123;&#x27;tag&#x27;: &#x27;*&#x27;&#125;<br>&quot;---- undo ----<br>Plug &#x27;mbbill/undotree&#x27;<br>&quot;-----NERDTree ----<br>Plug &#x27;preservim/nerdtree&#x27;<br>&quot;-----CPP----------<br>Plug &#x27;bfrg/vim-cpp-modern&#x27;<br>&quot;-----Python-------<br>Plug &#x27;python-mode/python-mode&#x27;, &#123; &#x27;for&#x27;: &#x27;python&#x27;, &#x27;branch&#x27;: &#x27;develop&#x27; &#125;<br>call plug#end()<br>&quot;=================================<br>&quot; Vim-plug End<br>&quot;=================================<br><br><br>&quot;==============================================================================<br>&quot; vim-go plugin settings<br>&quot;==============================================================================<br>let g:go_fmt_command = &quot;goimports&quot;<br>let g:go_autodetect_gopath = 1<br>let g:go_list_type = &quot;quickfix&quot;<br><br>let g:go_version_warning = 1<br>let g:go_highlight_types = 1<br>let g:go_highlight_fields = 1<br>let g:go_highlight_functions = 1<br>let g:go_highlight_function_calls = 1<br>let g:go_highlight_operators = 1<br>let g:go_highlight_extra_types = 1<br>let g:go_highlight_methods = 1<br>let g:go_highlight_generate_tags = 1<br>let g:go_def_mode=&#x27;gopls&#x27;<br>let g:go_info_mode=&#x27;gopls&#x27;<br><br>let g:godef_split=2<br>let g:go_list_type = &quot;quickfix&quot;<br><br>map &lt;C-n&gt; :cnext&lt;CR&gt;<br>map &lt;C-m&gt; :cprevious&lt;CR&gt;<br>nnoremap &lt;leader&gt;a :cclose&lt;CR&gt;<br><br>&quot; autocmd FileType go nmap &lt;leader&gt;b  &lt;Plug&gt;(go-build)<br>&quot; autocmd FileType go nmap &lt;leader&gt;r  &lt;Plug&gt;(go-run)<br><br>&quot;==============================================================================<br>&quot; undotree plugin settings<br>&quot;==============================================================================<br>&quot;if has(&quot;persistent_undo&quot;)<br>&quot;    set undodir=$HOME/.vim/undo<br>&quot;    set undofile<br>&quot;endif<br><br>&quot;==============================================================================<br>&quot; Back to last eidt position.<br>&quot;==============================================================================<br>if has(&quot;autocmd&quot;)<br>au BufReadPost * if line(&quot;&#x27;\&quot;&quot;) &gt; 1 &amp;&amp; line(&quot;&#x27;\&quot;&quot;) &lt;= line(&quot;$&quot;) | exe &quot;normal! g&#x27;\&quot;&quot; | endif<br>endif<br><br>&quot;=================================<br>&quot; Coc-nvim Config Start<br>&quot;=================================<br>&quot; TextEdit might fail if hidden is not set.<br>set hidden<br><br>&quot; Some servers have issues with backup files, see #649.<br>set nobackup<br>set nowritebackup<br><br>&quot; Give more space for displaying messages.<br>set cmdheight=2<br><br>&quot; Having longer updatetime (default is 4000 ms = 4 s) leads to noticeable<br>&quot; delays and poor user experience.<br>set updatetime=300<br><br>&quot; Don&#x27;t pass messages to |ins-completion-menu|.<br>set shortmess+=c<br><br>&quot; Always show the signcolumn, otherwise it would shift the text each time<br>&quot; diagnostics appear/become resolved.<br>if has(&quot;patch-8.1.1564&quot;)<br>  &quot; Recently vim can merge signcolumn and number column into one<br>  set signcolumn=number<br>else<br>  set signcolumn=yes<br>endif<br><br>&quot; Use tab for trigger completion with characters ahead and navigate.<br>&quot; NOTE: Use command &#x27;:verbose imap &lt;tab&gt;&#x27; to make sure tab is not mapped by<br>&quot; other plugin before putting this into your config.<br>inoremap &lt;silent&gt;&lt;expr&gt; &lt;TAB&gt;<br>      \ pumvisible() ? &quot;\&lt;C-n&gt;&quot; :<br>      \ &lt;SID&gt;check_back_space() ? &quot;\&lt;TAB&gt;&quot; :<br>      \ coc#refresh()<br>inoremap &lt;expr&gt;&lt;S-TAB&gt; pumvisible() ? &quot;\&lt;C-p&gt;&quot; : &quot;\&lt;C-h&gt;&quot;<br><br>function! s:check_back_space() abort<br>  let col = col(&#x27;.&#x27;) - 1<br>  return !col || getline(&#x27;.&#x27;)[col - 1]  =~# &#x27;\s&#x27;<br>endfunction<br><br>&quot; Use &lt;c-space&gt; to trigger completion.<br>if has(&#x27;nvim&#x27;)<br>  inoremap &lt;silent&gt;&lt;expr&gt; &lt;c-space&gt; coc#refresh()<br>else<br>  inoremap &lt;silent&gt;&lt;expr&gt; &lt;c-@&gt; coc#refresh()<br>endif<br><br>&quot; Make &lt;CR&gt; auto-select the first completion item and notify coc.nvim to<br>&quot; format on enter, &lt;cr&gt; could be remapped by other vim plugin<br>inoremap &lt;silent&gt;&lt;expr&gt; &lt;cr&gt; pumvisible() ? coc#_select_confirm()<br>                              \: &quot;\&lt;C-g&gt;u\&lt;CR&gt;\&lt;c-r&gt;=coc#on_enter()\&lt;CR&gt;&quot;<br><br>&quot; <br>inoremap &lt;C-j&gt; &lt;Esc&gt;o<br>inoremap &lt;C-h&gt; &lt;Left&gt;<br>inoremap &lt;C-l&gt; &lt;Right&gt;<br>&quot; 复制到系统剪切板<br>inoremap &lt;C-y&gt; &quot;+y<br>&quot; inoremap &lt;C-p&gt; &quot;+p<br><br>&quot; NERDTree KeyMap<br>&quot; nnoremap &lt;leader&gt;n :NERDTreeFocus&lt;CR&gt;<br>nnoremap &lt;leader&gt;n :NERDTreeFocus&lt;CR&gt;<br>&quot; nnoremap &lt;C-n&gt; :NERDTree&lt;CR&gt;<br>nnoremap &lt;C-k&gt; :NERDTreeToggle&lt;CR&gt;<br>nnoremap &lt;C-l&gt; :NERDTreeFind&lt;CR&gt;<br><br>&quot; Use `[g` and `]g` to navigate diagnostics<br>&quot; Use `:CocDiagnostics` to get all diagnostics of current buffer in location list.<br>nmap &lt;silent&gt; [g &lt;Plug&gt;(coc-diagnostic-prev)<br>nmap &lt;silent&gt; ]g &lt;Plug&gt;(coc-diagnostic-next)<br><br>&quot; GoTo code navigation.<br>nmap &lt;silent&gt; gd &lt;Plug&gt;(coc-definition)<br>nmap &lt;silent&gt; gt &lt;Plug&gt;(coc-type-definition)<br>nmap &lt;silent&gt; gi &lt;Plug&gt;(coc-implementation)<br>nmap &lt;silent&gt; gr &lt;Plug&gt;(coc-references)<br>nmap &lt;silent&gt; gk &lt;Plug&gt;(go-implements)<br><br>&quot; Use K to show documentation in preview window.<br>nnoremap &lt;silent&gt; K :call &lt;SID&gt;show_documentation()&lt;CR&gt;<br><br>function! s:show_documentation()<br>  if (index([&#x27;vim&#x27;,&#x27;help&#x27;], &amp;filetype) &gt;= 0)<br>    execute &#x27;h &#x27;.expand(&#x27;&lt;cword&gt;&#x27;)<br>  elseif (coc#rpc#ready())<br>    call CocActionAsync(&#x27;doHover&#x27;)<br>  else<br>    execute &#x27;!&#x27; . &amp;keywordprg . &quot; &quot; . expand(&#x27;&lt;cword&gt;&#x27;)<br>  endif<br>endfunction<br><br>&quot; Highlight the symbol and its references when holding the cursor.<br>autocmd CursorHold * silent call CocActionAsync(&#x27;highlight&#x27;)<br><br>&quot; Symbol renaming.<br>nmap &lt;leader&gt;rn &lt;Plug&gt;(coc-rename)<br><br>&quot; Formatting selected code.<br>xmap &lt;leader&gt;f  &lt;Plug&gt;(coc-format-selected)<br>nmap &lt;leader&gt;f  &lt;Plug&gt;(coc-format-selected)<br><br>augroup mygroup<br>  autocmd!<br>  &quot; Setup formatexpr specified filetype(s).<br>  autocmd FileType typescript,json setl formatexpr=CocAction(&#x27;formatSelected&#x27;)<br>  &quot; Update signature help on jump placeholder.<br>  autocmd User CocJumpPlaceholder call CocActionAsync(&#x27;showSignatureHelp&#x27;)<br>augroup end<br><br>&quot; Applying codeAction to the selected region.<br>&quot; Example: `&lt;leader&gt;aap` for current paragraph<br>xmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)<br>nmap &lt;leader&gt;a  &lt;Plug&gt;(coc-codeaction-selected)<br><br>&quot; Remap keys for applying codeAction to the current buffer.<br>nmap &lt;leader&gt;ac  &lt;Plug&gt;(coc-codeaction)<br>&quot; Apply AutoFix to problem on the current line.<br>nmap &lt;leader&gt;qf  &lt;Plug&gt;(coc-fix-current)<br><br>&quot; Map function and class text objects<br>&quot; NOTE: Requires &#x27;textDocument.documentSymbol&#x27; support from the language server.<br>xmap if &lt;Plug&gt;(coc-funcobj-i)<br>omap if &lt;Plug&gt;(coc-funcobj-i)<br>xmap af &lt;Plug&gt;(coc-funcobj-a)<br>omap af &lt;Plug&gt;(coc-funcobj-a)<br>xmap ic &lt;Plug&gt;(coc-classobj-i)<br>omap ic &lt;Plug&gt;(coc-classobj-i)<br>xmap ac &lt;Plug&gt;(coc-classobj-a)<br>omap ac &lt;Plug&gt;(coc-classobj-a)<br><br>&quot; Remap &lt;C-f&gt; and &lt;C-b&gt; for scroll float windows/popups.<br>if has(&#x27;nvim-0.4.0&#x27;) || has(&#x27;patch-8.2.0750&#x27;)<br>  nnoremap &lt;silent&gt;&lt;nowait&gt;&lt;expr&gt; &lt;C-f&gt; coc#float#has_scroll() ? coc#float#scroll(1) : &quot;\&lt;C-f&gt;&quot;<br>  nnoremap &lt;silent&gt;&lt;nowait&gt;&lt;expr&gt; &lt;C-b&gt; coc#float#has_scroll() ? coc#float#scroll(0) : &quot;\&lt;C-b&gt;&quot;<br>  inoremap &lt;silent&gt;&lt;nowait&gt;&lt;expr&gt; &lt;C-f&gt; coc#float#has_scroll() ? &quot;\&lt;c-r&gt;=coc#float#scroll(1)\&lt;cr&gt;&quot; : &quot;\&lt;Right&gt;&quot;<br>  inoremap &lt;silent&gt;&lt;nowait&gt;&lt;expr&gt; &lt;C-b&gt; coc#float#has_scroll() ? &quot;\&lt;c-r&gt;=coc#float#scroll(0)\&lt;cr&gt;&quot; : &quot;\&lt;Left&gt;&quot;<br>  vnoremap &lt;silent&gt;&lt;nowait&gt;&lt;expr&gt; &lt;C-f&gt; coc#float#has_scroll() ? coc#float#scroll(1) : &quot;\&lt;C-f&gt;&quot;<br>  vnoremap &lt;silent&gt;&lt;nowait&gt;&lt;expr&gt; &lt;C-b&gt; coc#float#has_scroll() ? coc#float#scroll(0) : &quot;\&lt;C-b&gt;&quot;<br>endif<br><br>&quot; NeoVim-only mapping for visual mode scroll<br>&quot; Useful on signatureHelp after jump placeholder of snippet expansion<br>if has(&#x27;nvim&#x27;)<br>  vnoremap &lt;nowait&gt;&lt;expr&gt; &lt;C-f&gt; coc#float#has_scroll() ? coc#float#nvim_scroll(1, 1) : &quot;\&lt;C-f&gt;&quot;<br>  vnoremap &lt;nowait&gt;&lt;expr&gt; &lt;C-b&gt; coc#float#has_scroll() ? coc#float#nvim_scroll(0, 1) : &quot;\&lt;C-b&gt;&quot;<br>endif<br><br>&quot; Use CTRL-S for selections ranges.<br>&quot; Requires &#x27;textDocument/selectionRange&#x27; support of language server.<br>nmap &lt;silent&gt; &lt;C-s&gt; &lt;Plug&gt;(coc-range-select)<br>xmap &lt;silent&gt; &lt;C-s&gt; &lt;Plug&gt;(coc-range-select)<br><br>&quot; Add `:Format` command to format current buffer.<br>command! -nargs=0 Format :call CocAction(&#x27;format&#x27;)<br><br>&quot; Add `:Fold` command to fold current buffer.<br>command! -nargs=? Fold :call     CocAction(&#x27;fold&#x27;, &lt;f-args&gt;)<br><br>&quot; Add `:OR` command for organize imports of the current buffer.<br>command! -nargs=0 OR   :call     CocAction(&#x27;runCommand&#x27;, &#x27;editor.action.organizeImport&#x27;)<br><br>&quot; Add (Neo)Vim&#x27;s native statusline support.<br>&quot; NOTE: Please see `:h coc-status` for integrations with external plugins that<br>&quot; provide custom statusline: lightline.vim, vim-airline.<br>set statusline^=%&#123;coc#status()&#125;%&#123;get(b:,&#x27;coc_current_function&#x27;,&#x27;&#x27;)&#125;<br><br>&quot; Mappings for CoCList<br>&quot; Show all diagnostics.<br>nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;a  :&lt;C-u&gt;CocList diagnostics&lt;cr&gt;<br>&quot; Manage extensions.<br>nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;e  :&lt;C-u&gt;CocList extensions&lt;cr&gt;<br>&quot; Show commands.<br>nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;c  :&lt;C-u&gt;CocList commands&lt;cr&gt;<br>&quot; Find symbol of current document.<br>nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;o  :&lt;C-u&gt;CocList outline&lt;cr&gt;<br>&quot; Search workspace symbols.<br>nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;s  :&lt;C-u&gt;CocList -I symbols&lt;cr&gt;<br>&quot; Do default action for next item.<br>nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;j  :&lt;C-u&gt;CocNext&lt;CR&gt;<br>&quot; Do default action for previous item.<br>nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;k  :&lt;C-u&gt;CocPrev&lt;CR&gt;<br>&quot; Resume latest coc list.<br>&quot;nnoremap &lt;silent&gt;&lt;nowait&gt; &lt;space&gt;p  :&lt;C-u&gt;CocListResume&lt;CR&gt;<br>&quot;=================================<br>&quot; Coc-nvim Config End<br>&quot;=================================<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Vim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim常用命令Pro</title>
    <link href="/2021/10/25/Tools/Vim/Vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4Pro/"/>
    <url>/2021/10/25/Tools/Vim/Vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4Pro/</url>
    
    <content type="html"><![CDATA[<h2 id="启动Vim"><a href="#启动Vim" class="headerlink" title="启动Vim"></a>启动Vim</h2><ul><li>vim + file: 从文件末尾开始</li><li>vim +num file: 从文件第num行开始</li><li>vim +&#x2F;string file: 将光标停在文件中第一个匹配到的string上</li></ul><h2 id="多文档编辑"><a href="#多文档编辑" class="headerlink" title="多文档编辑"></a>多文档编辑</h2><ul><li>vim file1 file2 file3 同时打开多个文档</li><li>:e 文档名 进入vim后，可以直接去编辑别的文档，文档路径以开启vim的路径为根路径</li><li>在多文档模式下<ul><li>:n 编辑下一个文档</li><li>:2n 编辑下两个文档</li><li>:N 编辑上一个文档</li></ul></li><li>:e# 或 Ctrl+^ 编辑上一个文档,用于两个文档相互交换编辑时使用。?# 代表的是编辑前一次编辑的文档</li><li>:files 或 :buffers 或 :ls 列出当前 缓冲区 中的所有文档。加号 + 表示 缓冲区已经被修改过了。＃代表上一次编辑的文档，%是目前正在编辑中的文档</li><li>:ls 列出所有打开文档号和文档，可以配合下面的 :b &lt;文档号&gt; 实现文档跳转</li><li>:b &lt;文档名或编号&gt; 移至该文档，可以配合 e 使用，实现快速跳转</li><li>:bNext 移至下一个文档，在当前缓冲区环状循环</li><li>:wa 保存所有文档的改变</li><li>:xa 保存所有文档的改变并退出vim</li><li>:wqa 保存所有文档的改变并退出vim</li><li>:qa 关闭所有buffer并退出vim，如果有没保存的buffer，会提示</li><li>:qa! 关闭所有buffer并退出vim，不会保存buffer</li></ul><h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><ul><li>:pwd 显示当前文档所在路径（显示文档名）</li><li>:e 重新加载该文档</li><li>:e 文档名 进入vim后，可以直接去编辑别的文档，文档路径以开启vim的路径为根路径(可参考多文档编辑)</li><li>:e! 重新加载该文档,并忽略更改</li><li>:e#或Ctrl+^  回到刚才编辑的文档</li><li>:f 显示当前正在编辑的文档名</li><li>:f filename 重命名当前编辑的文档</li><li>:n1,n2w filename 选择性保存[n1,n2]行内容到指定文件文件中</li><li>:wq 或 ZZ 保存并退出，这种方式及时文档没有修改也会再保存一次</li><li>:x 保存并退出</li><li>:w filename 另存为，不加filename则保存到原文档中, 较多用于在保存时提示没有写入权限的场景</li><li>:qa 或 qa! 在多窗口下离开vim</li><li>按1,再按Ctrl+G，显示当前文件名与路径</li></ul><h2 id="多窗口"><a href="#多窗口" class="headerlink" title="多窗口"></a>多窗口</h2><ul><li>两次Ctrl+w 用于切换窗口（环状循环）</li><li>:Sex 水平分割一个窗口，浏览文件系统</li><li>:Vex 垂直分割一个窗口，浏览文件:n 移动到第n行。</li><li>:sp filename 水平分割窗口，在新窗口里显示新文档，如果未指定filename，则新窗口里仍是原文档内容</li><li>:vsp filename 同sp，不过是垂直分割窗口</li><li>Ctrl + w 进入切换窗口的模式<ul><li>Ctrl+w w 切换到下一个窗口</li><li>Ctrl+w h 切换至左窗口, h 可替换为 ⬅️</li><li>Ctrl+w l 切换至右窗口, l 可替换为 ➡️</li><li>Ctrl+w j 切换至上窗口, j 可替换为 ⬆️</li><li>Ctrl+w k 切换至下窗口, k 可替换为 ⬇️</li></ul></li></ul><p>关于分屏操作的详细用法，移步：<a href="https://mofan.life/2022/03/24/Tools/Vim/Vim%E5%88%86%E5%B1%8F%E6%93%8D%E4%BD%9C/">Vim分屏操作 - Mofan</a></p><h2 id="光标移动"><a href="#光标移动" class="headerlink" title="光标移动"></a>光标移动</h2><ul><li><p>:n 跳到第n行。</p></li><li><p>:$ 移动到最后一行。</p></li><li><p>H: 把光标移到屏幕最顶端一行。</p></li><li><p>M: 把光标移到屏幕中间一行。</p></li><li><p>L: 把光标移到屏幕最底端一行。系统</p></li><li><p>g$: 移动光标所在屏幕行行尾。</p></li><li><p>0: 移动到行首。</p></li><li><p>g0: 移到光标所在屏幕行行首。</p></li><li><p>[: 上一个方法</p></li><li><p>]: 下一个方法</p></li></ul><h2 id="翻屏"><a href="#翻屏" class="headerlink" title="翻屏"></a>翻屏</h2><ul><li>ctrl+f: 下翻一屏。</li><li>ctrl+b: 上翻一屏。</li><li>ctrl+d: 下翻半屏。</li><li>ctrl+u: 上翻半屏。</li><li>ctrl+e: 向下滚动一行。</li><li>ctrl+y: 向上滚动一行。</li><li>n%: 到文件n%的位置。</li><li>zz: 将当前行移动到屏幕中央。</li><li>zt: 将当前行移动到屏幕顶端。</li><li>zb: 将当前行移动到屏幕底端。</li></ul><h2 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h2><ul><li>i: 在光标前插入；一个小技巧：按8，再按i，进入插入模式，输入&#x3D;， 按esc进入命令模式，就会出现8个&#x3D;。 这在插入分割线时非常有用，如30i+就插入了36个+组成的分割线</li><li>A: 在当前行最后插入；</li><li>r filename在当前位置插入另一个文件的内容。</li><li>:[n]r filename在第n行插入另一个文件的内容。</li><li>:r !date 在光标处插入当前日期与时间。同理，:r !command可以将其它shell命令的输出插入当前文档。</li></ul><h2 id="剪切、复制、粘贴"><a href="#剪切、复制、粘贴" class="headerlink" title="剪切、复制、粘贴"></a>剪切、复制、粘贴</h2><ul><li>:m,nd 剪切m行到n行的内容。</li><li>d1G或dgg: 剪切光标以上的所有行。</li><li>dG: 剪切光标以下的所有行。</li><li>d0: 删除（剪切）当前位置到行首的内容</li></ul><h2 id="块操作"><a href="#块操作" class="headerlink" title="块操作"></a>块操作</h2><ul><li>块选中后，按c，再输入替换的内容，按ESC可实现块内内容替换</li></ul><h2 id="基本排版"><a href="#基本排版" class="headerlink" title="基本排版"></a>基本排版</h2><ul><li>&lt;&lt; 向左缩进一个shiftwidth</li><li>&gt;&gt; 向右缩进一个shiftwidth</li><li>n&gt;&gt; 光标以下的n行会向右缩进</li></ul><h2 id="命令行模式下"><a href="#命令行模式下" class="headerlink" title="命令行模式下"></a>命令行模式下</h2><ul><li>C-b： 移动到命令行开头。</li><li>C-e： 移动到命令行末尾。</li></ul><blockquote><p>注:在普通终端下也可以使用, C-b 逐字符向前移动， C-e 到达命令尾部</p></blockquote><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li>Ctrl-g: 显示当前位置的行与总行数，以及当前所在行数占总行数的比例。</li><li>Ctrl-r: 反撤销，用于还原u的操作。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Vim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux根据PID查找程序路径</title>
    <link href="/2021/10/21/Linux%E6%A0%B9%E6%8D%AEPID%E6%9F%A5%E6%89%BE%E7%A8%8B%E5%BA%8F%E8%B7%AF%E5%BE%84/"/>
    <url>/2021/10/21/Linux%E6%A0%B9%E6%8D%AEPID%E6%9F%A5%E6%89%BE%E7%A8%8B%E5%BA%8F%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<ol><li><p>拿到PID，假设为6666</p></li><li><p>进入到<code>/proc</code>目录下以该进程ID命名的文件夹下，即<code>/proc/6666</code></p></li><li><p>输入<code>ls -ail</code>,查看结果中<code>exe</code>链接到的文件路径信息</p></li><li><p>进入到此路径干掉程序。</p></li></ol><p>注：有时候<code>docker</code>里跑的程序，通过<code>exe</code>拿到的路径并不能找到对应程序，因为docker里的路径是相对于docker而言的，非系统路径而言，这时候可以通过 <code>find / -name xxx</code>,xxx为程序名，从系统根目录搜索程序的位置，一半这种程序位于docker的安装目录下，如果想节省时间可以直接去docker安装目录下搜索。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网站返回403 Forbidden的原因及排查思路</title>
    <link href="/2021/10/20/%E7%BD%91%E7%AB%99%E8%BF%94%E5%9B%9E403-Forbidden%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/"/>
    <url>/2021/10/20/%E7%BD%91%E7%AB%99%E8%BF%94%E5%9B%9E403-Forbidden%E7%9A%84%E5%8E%9F%E5%9B%A0%E5%8F%8A%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>导致403错误的主要原因</strong></p><p>　　403 Forbidden错误的原因和解决方法</p><p>　　1、你的IP被列入黑名单。</p><p>　　2、你在一定时间内过多地访问此网站(一般是用采集程序)，被防火墙拒绝访问了。</p><p>　　3、网站域名解析到了空间，但空间未绑定此域名。</p><p>　　4、你的网页脚本文件在当前目录下没有执行权限。</p><p>　　5、在不允许写&#x2F;创建文件的目录中执行了创建&#x2F;写文件操作。</p><p>　　6、以http方式访问需要ssl连接的网址。</p><p>　　7、浏览器不支持SSL 128时访问SSL 128的连接。</p><p>　　8、在身份验证的过程中输入了错误的密码。</p><p>　　9、DNS解析错误，手动更改DNS服务器地址。</p><p>　　10、连接的用户过多，可以过后再试。</p><p>　　11、服务器繁忙，同一IP地址发送请求过多，遭到服务器智能屏蔽。</p><p><strong>解决403 forbidden错误的方法</strong></p><p>　　1、重建dns缓存</p><p>　　对于一些常规的403 forbidden错误，马海祥建议大家首先要尝试的就是重建dns缓存，在运行中输入cmd，然后输入ipconfig &#x2F;flushdns即可。如果不行的话，就需要在hosts文件里把主页解析一下了。</p><p>　　2、修改文件夹安全属性</p><p>　　3、关于apache导致的403 forbidden错误，需设置Apache的配置文件。</p><p>　　4、关于HawkHost空间出现403 Forbidden错误需设置htaccess文件。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML学习</title>
    <link href="/2021/10/09/HTML%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/10/09/HTML%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h2 id="img-标签的-loading-属性"><a href="#img-标签的-loading-属性" class="headerlink" title="img 标签的 loading 属性"></a>img 标签的 loading 属性</h2><p>决定图片加载的时机，有两种值:</p><ul><li>eager 默认值，图片立即加载</li><li>lazy 延迟加载图像，直到满足某些条件，比如图片出现在可视窗口中</li></ul><h2 id="href-与-src-的区别"><a href="#href-与-src-的区别" class="headerlink" title="href 与 src 的区别"></a>href 与 src 的区别</h2><p>href 是 Hypertext Reference 的缩写，表示超文本引用。用来建立当前元素和文档之间的链接。常用的有：link、a。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;reset.css&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">”stylesheet“/</span>&gt;</span><br></code></pre></td></tr></table></figure><p>浏览器会识别该文档为 css 文档，并行下载该文档，并且不会停止对当前文档的处理。这也是建议使用 link，而不采用 @import 加载 css 的原因。 src 是 source 的缩写，src 的内容是页面必不可少的一部分，是引入。src 指向的内容会嵌入到文档中当前标签所在的位置。常用的有：img、script、iframe。例如:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;script.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当浏览器解析到该元素时，会暂停浏览器的渲染，直到该资源加载完毕。这也是将js脚本放在底部而不是头部得原因。</p><p>简而言之，src 用于替换当前元素；href 用于在当前文档和引用资源之间建立联系。</p><h2 id="标签的id-与-class"><a href="#标签的id-与-class" class="headerlink" title="标签的id 与 class"></a><code>标签的id 与 class</code></h2><ul><li><p>class 属性可以多用 <strong>class&#x3D;” “</strong> （引号里面可以填入多个class属性）</p></li><li><p>id 属性只能单独设置 **id&#x3D;” “**（只能填写一个，多个无效）</p></li></ul><p>HTML属性一览表：<a href="https://www.runoob.com/tags/html-reference.html">HTML 标签列表(字母排序) | 菜鸟教程</a></p><p>标签<code>&lt;hr&gt;</code>用于定义水平线</p><p>HTML文本格式化 <a href="https://www.runoob.com/html/html-links.html">https://www.runoob.com/html/html-links.html</a></p><h2 id="创建电子邮件链接发送内容"><a href="#创建电子邮件链接发送内容" class="headerlink" title="创建电子邮件链接发送内容"></a>创建电子邮件链接发送内容</h2><p>在进行邮件内容发送时，需要使用关键字：<strong>mailto</strong></p><p>eg：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;mailto:hello@example.com?cc=hello@example.com&amp;bcc=hello@example.com&amp;subject=hello,world&amp;body=world_hello&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;nofollow&quot;</span>&gt;</span>发送邮件<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>nofollow 是 HTML 页面中 a 标签的属性值。它的出现为网站管理员提供了一种方式，即告诉搜索引擎”不要追踪此网页上的链接”或”不要追踪此特定链接”。这个标签的意义是告诉搜索引擎这个链接不是经过作者信任的，所以这个链接不是一个信任票。</p></blockquote><p>参数说明：</p><table><thead><tr><th align="left">参数</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left">mailto:<em><a href="mailto:&#x6e;&#97;&#109;&#x65;&#64;&#x65;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;">&#x6e;&#97;&#109;&#x65;&#64;&#x65;&#x6d;&#97;&#105;&#108;&#46;&#99;&#x6f;&#x6d;</a></em></td><td align="left">邮件接收地址</td></tr><tr><td align="left">cc&#x3D;<em><a href="mailto:&#x6e;&#x61;&#109;&#101;&#64;&#x65;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;">&#x6e;&#x61;&#109;&#101;&#64;&#x65;&#109;&#97;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;</a></em></td><td align="left">抄送地址</td></tr><tr><td align="left">bcc&#x3D;<em><a href="mailto:&#110;&#x61;&#x6d;&#101;&#64;&#101;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;">&#110;&#x61;&#x6d;&#101;&#64;&#101;&#109;&#x61;&#105;&#x6c;&#46;&#99;&#x6f;&#x6d;</a></em></td><td align="left">密件抄送地址</td></tr><tr><td align="left">subject&#x3D;<em>subject text</em></td><td align="left">邮件主题</td></tr><tr><td align="left">body&#x3D;<em>body text</em></td><td align="left">邮件内容</td></tr><tr><td align="left">?</td><td align="left">第一个参数分隔符</td></tr><tr><td align="left">&amp;</td><td align="left">其他参数分隔符</td></tr></tbody></table><blockquote><p><strong>抄送：</strong></p><p>英文名称：Carbon Copy，又简称为 CC。在网络术语中，抄送就是将邮件同时发送给收信人以外的人，用户所写的邮件抄送一份给别人，对方可以看见该用户的 E-mail。同收件人地址栏一样，不可以超过 1024 个字符。一般来说，使用”抄送”服务时，多人抄送的电子邮件地址使用 <strong>;</strong> 分隔。</p><p><strong>密件抄送：</strong></p><p>英文名称：Blind Carbon Copy ，又称“盲抄送”，和抄送的唯一区别就是它能够让各个收件人无法查看到这封邮件同时还发送给了哪些人。密件抄送是个很实用的功能，假如一次向成百上千位收件人发送邮件，最好采用密件抄送方式，这样一来可以保护各个收件人的地址不被其他人轻易获得，二来可以使收件人节省下收取大量抄送的 E-mail 地址的时间。</p></blockquote><h2 id="定义页面在何处显示"><a href="#定义页面在何处显示" class="headerlink" title="定义页面在何处显示"></a>定义页面在何处显示</h2><p>使用 <code>&lt;a&gt; 的 target 属性</code>，用于告诉页面在何处显示，例如下面是让打开的URL在新标签页中显示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.runoob.com/&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;noopener noreferrer&quot;</span>&gt;</span>访问菜鸟教程!<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span> <br></code></pre></td></tr></table></figure><p>另外<code>&lt;a&gt;</code>中<code>rel=&quot;noopener noreferrer&quot;</code>的意思是不会打开其他的网站，因为恶意病毒可能会修改你的浏览器空白页地址。</p><p>target的值:</p><ul><li>_top 跳出框架，如果用在打开电子邮件的 href 上，可以避免页面闪动一下再调用默认邮件客户端</li><li>_blank 用一个新标签页打开URL</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WebSocket</title>
    <link href="/2021/10/09/WebSocket-0/"/>
    <url>/2021/10/09/WebSocket-0/</url>
    
    <content type="html"><![CDATA[<h2 id="WebSocket与HTTP的关系"><a href="#WebSocket与HTTP的关系" class="headerlink" title="WebSocket与HTTP的关系"></a>WebSocket与HTTP的关系</h2><p>首先HTTP有1.1和1.0之说，也就是所谓的keep-alive，把多个HTTP请求合并为一个，但是Websocket其实是一个新协议，跟HTTP协议基本没有关系，只是为了兼容现有浏览器的握手规范而已，也就是说它是HTTP协议上的一种补充可以通过这样一张图理解</p><p><img src="https://pic1.zhimg.com/50/6651f2f811ec133b0e6d7e6d0e194b4c_720w.jpg?source=1940ef5c" alt="img"></p><p>有交集，但是并不是全部。<br>另外Html5是指的一系列新的API，或者说新规范，新技术。Http协议本身只有1.0和1.1，而且跟Html本身没有直接关系。。<br>通俗来说，你可以用HTTP<strong>协议</strong>传输非Html<strong>数据</strong>，就是这样&#x3D;。&#x3D;<br>再简单来说，<strong>层级不一样</strong>。</p><h2 id="WebSocket是什么样的协议，具体有什么优点"><a href="#WebSocket是什么样的协议，具体有什么优点" class="headerlink" title="WebSocket是什么样的协议，具体有什么优点"></a>WebSocket是什么样的协议，具体有什么优点</h2><p>首先，Websocket是一个<strong>持久化</strong>的协议，相对于HTTP这种<strong>非持久</strong>的协议来说。<br>简单的举个例子吧，用目前应用比较广泛的PHP生命周期来解释。<br>\1) HTTP的生命周期通过Request来界定，也就是一个Request 一个Response，那么<strong>在</strong>HTTP1.0<strong>中</strong>，这次HTTP请求就结束了。<br>在HTTP1.1中进行了改进，使得有一个keep-alive，也就是说，在一个HTTP连接中，可以发送多个Request，接收多个Response。<br>但是请记住 Request &#x3D; Response ， 在HTTP中永远是这样，也就是说一个request只能有一个response。而且这个response也是<strong>被动</strong>的，不能主动发起。</p><h2 id="WebSocket的原理"><a href="#WebSocket的原理" class="headerlink" title="WebSocket的原理"></a>WebSocket的原理</h2><p>首先Websocket是基于HTTP协议的，或者说<strong>借用</strong>了HTTP的协议来完成一部分握手。<br>所以，在握手阶段是一样的。</p><p>首先我们来看个典型的Websocket握手</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs tex">GET /chat HTTP/1.1<br>Host: server.example.com<br>Upgrade: websocket<br>Connection: Upgrade<br>Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==<br>Sec-WebSocket-Protocol: chat, superchat<br>Sec-WebSocket-Version: 13<br>Origin: http://example.com<br></code></pre></td></tr></table></figure><p>熟悉HTTP的童鞋可能发现了，这段类似HTTP协议的握手请求中，多了几个东西。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">Upgrade: websocket<br>Connection: Upgrade<br></code></pre></td></tr></table></figure><p>这个就是Websocket的核心了，告诉Apache、Nginx等服务器：<strong>注意啦，窝发起的是Websocket协议，快点帮我找到对应的助理处理~不是那个老土的HTTP。</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tex">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==<br>Sec-WebSocket-Protocol: chat, superchat<br>Sec-WebSocket-Version: 13<br></code></pre></td></tr></table></figure><p>首先，Sec-WebSocket-Key 是一个Base64 encode的值，这个是浏览器随机生成的，告诉服务器：<strong>泥煤，不要忽悠窝，我要验证尼是不是真的是Websocket助理。</strong><br>然后，Sec_WebSocket-Protocol 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议。简单理解：<strong>今晚我要服务A，别搞错啦~</strong><br>最后，Sec-WebSocket-Version 是告诉服务器所使用的Websocket Draft（协议版本），在最初的时候，Websocket协议还在 Draft 阶段，各种奇奇怪怪的协议都有，而且还有很多期奇奇怪怪不同的东西，什么Firefox和Chrome用的不是一个版本之类的，当初Websocket协议太多可是一个大难题。。不过现在还好，已经定下来啦<del>大家都使用的一个东西</del> 脱水：<strong>服务员，我要的是13岁的噢→_→</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">HTTP/1.1 101 Switching Protocols<br>Upgrade: websocket<br>Connection: Upgrade<br>Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=<br>Sec-WebSocket-Protocol: chat<br></code></pre></td></tr></table></figure><p>这里开始就是HTTP最后负责的区域了，告诉客户，我已经成功切换协议啦~</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">Upgrade: websocket<br>Connection: Upgrade<br></code></pre></td></tr></table></figure><p>依然是固定的，告诉客户端即将升级的是Websocket协议，而不是mozillasocket，lurnarsocket或者shitsocket。<br>然后，Sec-WebSocket-Accept 这个则是经过服务器确认，并且加密过后的 Sec-WebSocket-Key。服务器：<strong>好啦好啦，知道啦，给你看我的ID CARD来证明行了吧。。</strong><br>后面的，Sec-WebSocket-Protocol 则是表示最终使用的协议。</p><p>至此，HTTP已经完成它所有工作了，接下来就是完全按照Websocket协议进行了。<br>具体的协议就不在这阐述了。</p><h2 id="WebSocket的作用"><a href="#WebSocket的作用" class="headerlink" title="WebSocket的作用"></a>WebSocket的作用</h2><p>作者：Ovear<br>链接：<a href="https://www.zhihu.com/question/20215561/answer/40316953">https://www.zhihu.com/question/20215561/answer/40316953</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p>在讲Websocket之前，我就顺带着讲下 long poll 和 ajax轮询 的原理。<br>首先是 ajax轮询 ，ajax轮询 的原理非常简单，让浏览器隔个几秒就发送一次请求，询问服务器是否有新信息。<br>场景再现：<br>客户端：啦啦啦，有没有新信息(Request)<br>服务端：没有（Response）<br>客户端：啦啦啦，有没有新信息(Request)<br>服务端：没有。。（Response）<br>客户端：啦啦啦，有没有新信息(Request)<br>服务端：你好烦啊，没有啊。。（Response）<br>客户端：啦啦啦，有没有新消息（Request）<br>服务端：好啦好啦，有啦给你。（Response）<br>客户端：啦啦啦，有没有新消息（Request）<br>服务端：。。。。。没。。。。没。。。没有（Response） —- loop</p><p>long poll<br>long poll 其实原理跟 ajax轮询 差不多，都是采用轮询的方式，不过采取的是阻塞模型（一直打电话，没收到就不挂电话），也就是说，客户端发起连接后，如果没消息，就一直不返回Response给客户端。直到有消息才返回，返回完之后，客户端再次建立连接，周而复始。<br>场景再现<br>客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request）<br>服务端：额。。   等待到有消息的时候。。来 给你（Response）<br>客户端：啦啦啦，有没有新信息，没有的话就等有了才返回给我吧（Request） -loop</p><p>从上面可以看出其实这两种方式，都是在不断地建立HTTP连接，然后等待服务端处理，可以体现HTTP协议的另外一个特点，<strong>被动性</strong>。<br>何为被动性呢，其实就是，服务端不能主动联系客户端，只能有客户端发起。<br>简单地说就是，服务器是一个很懒的冰箱（这是个梗）（不会、不能主动发起连接），但是上司有命令，如果有客户来，不管多么累都要好好接待。</p><p>说完这个，我们再来说一说上面的缺陷（原谅我废话这么多吧OAQ）<br>从上面很容易看出来，不管怎么样，上面这两种都是非常消耗资源的。<br>ajax轮询 需要服务器有很快的处理速度和资源。（速度）<br>long poll 需要有很高的并发，也就是说同时接待客户的能力。（场地大小）<br>所以ajax轮询 和long poll 都有可能发生这种情况。</p><p><strong>客户端：啦啦啦啦，有新信息么？</strong><br><strong>服务端：月线正忙，请稍后再试（503 Server Unavailable）</strong><br><strong>客户端：。。。。好吧，啦啦啦，有新信息么？</strong><br><strong>服务端：月线正忙，请稍后再试（503 Server Unavailable）</strong></p><p><strong>客户端：</strong></p><p><img src="https://pic2.zhimg.com/50/7c0cf075c7ee4cc6cf52f4572a4c1c10_720w.jpg?source=1940ef5c" alt="img"></p><p><strong>然后服务端在一旁忙的要死：冰箱，我要更多的冰箱！更多。。更多。。（我错了。。这又是梗。。）</strong></p><p>-————————-<br><strong>言归正传，我们来说Websocket吧</strong><br>通过上面这个例子，我们可以看出，这两种方式都不是最好的方式，需要很多资源。<br>一种需要更快的速度，一种需要更多的’电话’。这两种都会导致’电话’的需求越来越高。<br>哦对了，忘记说了HTTP还是一个无状态协议。（感谢评论区的各位指出OAQ）<br>通俗的说就是，服务器因为每天要接待太多客户了，是个<strong>健忘鬼</strong>，你一挂电话，他就把你的东西全忘光了，把你的东西全丢掉了。你第二次还得再告诉服务器一遍。</p><p>所以在这种情况下出现了，Websocket出现了。<br>他解决了HTTP的这几个难题。<br>首先，<strong>被动性</strong>，当服务器完成协议升级后（HTTP-&gt;Websocket），服务端就可以主动推送信息给客户端啦。<br>所以上面的情景可以做如下修改。<br>客户端：啦啦啦，我要建立Websocket协议，需要的服务：chat，Websocket协议版本：17（HTTP Request）<br>服务端：ok，确认，已升级为Websocket协议（HTTP Protocols Switched）<br>客户端：麻烦你有信息的时候推送给我噢。。<br>服务端：ok，有的时候会告诉你的。<br>服务端：balabalabalabala<br>服务端：balabalabalabala<br>服务端：哈哈哈哈哈啊哈哈哈哈<br>服务端：笑死我了哈哈哈哈哈哈哈</p><p>就变成了这样，只需要经过<strong>一次HTTP请求</strong>，就可以做到源源不断的信息传送了。（在程序设计中，这种设计叫做回调，即：你有信息了再来通知我，而不是我傻乎乎的每次跑来问你）<br>这样的协议解决了上面同步有延迟，而且还非常消耗资源的这种情况。<br>那么为什么他会解决服务器上消耗资源的问题呢？<br>其实我们所用的程序是要经过两层代理的，即<strong>HTTP协议在Nginx等服务器的解析下</strong>，然后再传送给相应的<strong>Handler（PHP等）</strong>来处理。<br>简单地说，我们有一个非常快速的接<strong>线员（Nginx）</strong>，他负责把问题转交给相应的<strong>客服（Handler）</strong>。<br>本身<strong>接线员基本上速度是足够的</strong>，但是每次都卡在<strong>客服（Handler）</strong>了，老有<strong>客服</strong>处理速度太慢。，导致客服不够。<br>Websocket就解决了这样一个难题，建立后，可以直接跟接线员建立持<strong>久连接</strong>，有信息的时候客服想办法通知接线员，然后<strong>接线员</strong>在统一转交给客户。<br>这样就可以解决客服处理速度过慢的问题了。</p><p>同时，在传统的方式上，要不断的建立，关闭HTTP协议，由于HTTP是非状态性的，每次都要<strong>重新传输identity info（鉴别信息）</strong>，来告诉服务端你是谁。<br>虽然接线员很快速，但是每次都要听这么一堆，效率也会有所下降的，同时还得不断把这些信息转交给客服，不但浪费客服的<strong>处理时间</strong>，而且还会在网路传输中消耗<strong>过多的流量&#x2F;时间。</strong><br>但是Websocket只需要<strong>一次HTTP握手，所以说整个通讯过程是建立在一次连接&#x2F;状态中</strong>，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。<br>同时由<strong>客户主动询问</strong>，转换为<strong>服务器（推送）有信息的时候就发送（当然客户端还是等主动发送信息过来的。。）</strong>，没有信息的时候就交给接线员（Nginx），不需要占用本身速度就慢的<strong>客服（Handler）</strong>了<br>-——————-<br>至于怎么在不支持Websocket的客户端上使用Websocket。。答案是：<strong>不能</strong><br>但是可以通过上面说的 long poll 和 ajax 轮询来 <strong>模拟出类似的效果</strong></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Golang参数校验包validator</title>
    <link href="/2021/10/08/Golang%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E5%8C%85validator/"/>
    <url>/2021/10/08/Golang%E5%8F%82%E6%95%B0%E6%A0%A1%E9%AA%8C%E5%8C%85validator/</url>
    
    <content type="html"><![CDATA[<p>发现一个通过struct的tag进行参数校验的包<code>https://github.com/go-playground/validator</code>，通过像json tag一样对struct字段定义一些描述信息，实现参数校验，可以避免在代码中写很多参数校验的代码。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于日志打印的15个建议</title>
    <link href="/2021/09/22/%E5%85%B3%E4%BA%8E%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E7%9A%8415%E4%B8%AA%E5%BB%BA%E8%AE%AE/"/>
    <url>/2021/09/22/%E5%85%B3%E4%BA%8E%E6%97%A5%E5%BF%97%E6%89%93%E5%8D%B0%E7%9A%8415%E4%B8%AA%E5%BB%BA%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="1-选择恰当的日志级别"><a href="#1-选择恰当的日志级别" class="headerlink" title="1. 选择恰当的日志级别"></a>1. 选择恰当的日志级别</h3><p>常见的日志级别有5种，分别是error、warn、info、debug、trace。日常开发中，我们需要选择恰当的日志级别，不要反手就是打印info</p><ul><li>error：错误日志，指比较严重的错误，对正常业务有影响，需要<strong>运维配置监控的</strong>；</li><li>warn：警告日志，一般的错误，对业务影响不大，但是需要<strong>开发关注</strong>；</li><li>info：信息日志，记录排查问题的关键信息，如调用时间、出参入参等等；</li><li>debug：用于开发DEBUG的，关键逻辑里面的运行时数据；</li><li>trace：最详细的信息，一般这些信息只记录到日志文件中。</li></ul><h3 id="2-日志要打印出方法的入参、出参"><a href="#2-日志要打印出方法的入参、出参" class="headerlink" title="2. 日志要打印出方法的入参、出参"></a>2. 日志要打印出方法的入参、出参</h3><p>我们并不需要打印很多很多日志，只需要打印可以<strong>快速定位问题的有效日志</strong>。</p><p>哪些算得的上<strong>有效关键</strong>的日志呢？比如说，方法进来的时候，打印<strong>入参</strong>。再然后呢，在方法返回的时候，就是<strong>打印出参，返回值</strong>。入参的话，一般就是<strong>userId或者bizSeq这些关键</strong>信息。正例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">testLogMethod</span><span class="hljs-params">(Document doc, Mode mode)</span>&#123;<br>   log.debug(“method enter param：&#123;&#125;”,userId);<br>   <span class="hljs-type">String</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;666&quot;</span>;<br>   log.debug(“method exit param：&#123;&#125;”,id);<br>   <span class="hljs-keyword">return</span> id;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-选择合适的日志格式"><a href="#3-选择合适的日志格式" class="headerlink" title="3. 选择合适的日志格式"></a>3. 选择合适的日志格式</h3><p>理想的日志格式，应当包括这些最基本的信息：如当<strong>前时间戳</strong>（一般毫秒精确度）、<strong>日志级别</strong>，<strong>线程名字</strong>等等。在logback日志里可以这么配置：</p><p>如果我们的日志格式，连当前时间都沒有记录，那<strong>连请求的时间点都不知道了</strong>？</p><h3 id="4-遇到if…else…等条件时，每个分支首行都尽量打印日志"><a href="#4-遇到if…else…等条件时，每个分支首行都尽量打印日志" class="headerlink" title="4. 遇到if…else…等条件时，每个分支首行都尽量打印日志"></a>4. 遇到if…else…等条件时，每个分支首行都尽量打印日志</h3><p>当你碰到<strong>if…else…或者switch</strong>这样的条件时，可以在分支的首行就打印日志，这样排查问题时，就可以通过日志，确定进入了哪个分支，代码逻辑更清晰，也更方便排查问题了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(user.isVip())&#123;<br>  log.info(<span class="hljs-string">&quot;该用户是会员,Id:&#123;&#125;,开始处理会员逻辑&quot;</span>,user,getUserId());<br>  <span class="hljs-comment">//会员逻辑</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  log.info(<span class="hljs-string">&quot;该用户是非会员,Id:&#123;&#125;,开始处理非会员逻辑&quot;</span>,user,getUserId())<br>  <span class="hljs-comment">//非会员逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-日志级别比较低时，进行日志开关判断"><a href="#5-日志级别比较低时，进行日志开关判断" class="headerlink" title="5.日志级别比较低时，进行日志开关判断"></a>5.日志级别比较低时，进行日志开关判断</h3><p>对于trace&#x2F;debug这些比较低的日志级别，必须进行日志级别的开关判断。</p><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">User</span> <span class="hljs-variable">user</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">User</span>(<span class="hljs-number">888</span>, <span class="hljs-string">&quot;site&quot;</span>, <span class="hljs-string">&quot;mofan.life&quot;</span>);<br><span class="hljs-keyword">if</span> (log.isDebugEnabled()) &#123;<br>    log.debug(<span class="hljs-string">&quot;userId is: &#123;&#125;&quot;</span>, user.getId());<br>&#125;<br></code></pre></td></tr></table></figure><p>如果这样写的话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">logger.debug(<span class="hljs-string">&quot;Processing trade with id: &quot;</span> + id + <span class="hljs-string">&quot; and symbol: &quot;</span> + symbol);<br></code></pre></td></tr></table></figure><p>当<strong>配置的日志级别是warn</strong>的话，上述日志不会打印，但是会执行字符串拼接操作，如果<code>symbol</code>是对象， 还会执行<code>toString()</code>方法，浪费了系统资源，执行了上述操作，最终日志却没有打印，因此建议<strong>加日志开关判断。</strong></p><h3 id="6-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API。"><a href="#6-不能直接使用日志系统（Log4j、Logback）中的-API，而是使用日志框架SLF4J中的API。" class="headerlink" title="6. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API。"></a>6. 不能直接使用日志系统（Log4j、Logback）中的 API，而是使用日志框架SLF4J中的API。</h3><p>SLF4J 是门面模式的日志框架，有利于维护和各个类的日志处理方式统一，并且可以在保证不修改代码的情况下，很方便的实现底层日志框架的更换。</p><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger; <br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(TianLuoBoy.class);<br></code></pre></td></tr></table></figure><h3 id="7-建议使用参数占位-，而不是用-拼接。"><a href="#7-建议使用参数占位-，而不是用-拼接。" class="headerlink" title="7. 建议使用参数占位{}，而不是用+拼接。"></a>7. 建议使用参数占位{}，而不是用+拼接。</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">logger.info(<span class="hljs-string">&quot;Processing trade with id: &quot;</span> + id + <span class="hljs-string">&quot; and symbol: &quot;</span> + symbol);<br></code></pre></td></tr></table></figure><p>上面的例子中，使用<code>+</code>操作符进行字符串的拼接，有一定的<strong>性能损耗</strong>。</p><p>正例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">logger.info(<span class="hljs-string">&quot;Processing trade with id: &#123;&#125; and symbol : &#123;&#125; &quot;</span>, id, symbol); <br></code></pre></td></tr></table></figure><p>我们使用了大括号<code>&#123;&#125;</code>来作为日志中的占位符，比于使用<code>+</code>操作符，更加优雅简洁。并且，<strong>相对于反例</strong>，使用占位符仅是替换动作，可以有效提升性能。</p><h3 id="8-建议使用异步的方式来输出日志。"><a href="#8-建议使用异步的方式来输出日志。" class="headerlink" title="8. 建议使用异步的方式来输出日志。"></a>8. 建议使用异步的方式来输出日志。</h3><ul><li>日志最终会输出到文件或者其它输出流中的，IO性能会有要求的。如果异步，就可以显著提升IO性能。</li><li>除非有特殊要求，要不然建议使用异步的方式来输出日志。以logback为例吧，要配置异步很简单，使用AsyncAppender就行</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;FILE_ASYNC&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;ASYNC&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="9-不要使用e-printStackTrace"><a href="#9-不要使用e-printStackTrace" class="headerlink" title="9. 不要使用e.printStackTrace()"></a>9. 不要使用e.printStackTrace()</h3><p>反例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-comment">// 业务代码处理</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>  e.printStackTrace();<br>&#125;<br></code></pre></td></tr></table></figure><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span>&#123;<br>  <span class="hljs-comment">// 业务代码处理</span><br>&#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>  log.error(<span class="hljs-string">&quot;你的程序有异常啦&quot;</span>,e);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>理由：</strong></p><ul><li>e.printStackTrace()打印出的堆栈日志跟业务代码日志是交错混合在一起的，通常排查异常日志不太方便。</li><li>e.printStackTrace()语句产生的字符串记录的是堆栈信息，如果信息太长太多，字符串常量池所在的内存块没有空间了,即内存满了，那么，用户的请求就卡住啦~</li></ul><h3 id="10-异常日志不要只打一半，要输出全部错误信息"><a href="#10-异常日志不要只打一半，要输出全部错误信息" class="headerlink" title="10. 异常日志不要只打一半，要输出全部错误信息"></a>10. 异常日志不要只打一半，要输出全部错误信息</h3><p>反例1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//业务代码处理</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-comment">// 错误</span><br>    LOG.error(<span class="hljs-string">&#x27;你的程序有异常啦&#x27;</span>);<br>&#125; <br></code></pre></td></tr></table></figure><ul><li>异常e都没有打印出来，所以压根不知道出了什么类型的异常。</li></ul><p>反例2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//业务代码处理</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-comment">// 错误</span><br>    LOG.error(<span class="hljs-string">&#x27;你的程序有异常啦&#x27;</span>, e.getMessage());<br>&#125; <br></code></pre></td></tr></table></figure><ul><li><code>e.getMessage()</code>不会记录详细的堆栈异常信息，只会记录错误基本描述信息，不利于排查问题。</li></ul><p>正例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">//业务代码处理</span><br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>    <span class="hljs-comment">// 错误</span><br>    LOG.error(<span class="hljs-string">&#x27;你的程序有异常啦&#x27;</span>, e);<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="11-禁止在线上环境开启-debug"><a href="#11-禁止在线上环境开启-debug" class="headerlink" title="11. 禁止在线上环境开启 debug"></a>11. 禁止在线上环境开启 debug</h3><p>禁止在线上环境开启debug，这一点非常重要。</p><p>因为一般系统的debug日志会很多，并且各种框架中也大量使用 debug的日志，线上开启debug不久可能会打满磁盘，影响业务系统的正常运行。</p><h3 id="12-不要记录了异常，又抛出异常"><a href="#12-不要记录了异常，又抛出异常" class="headerlink" title="12.不要记录了异常，又抛出异常"></a>12.不要记录了异常，又抛出异常</h3><p>反例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">log.error(<span class="hljs-string">&quot;IO exception&quot;</span>, e);<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyException</span>(e);<br></code></pre></td></tr></table></figure><ul><li>这样实现的话，通常会把栈信息打印两次。这是因为捕获了MyException异常的地方，还会再打印一次。</li><li>这样的日志记录，或者包装后再抛出去，不要同时使用！否则你的日志看起来会让人很迷惑。</li></ul><h3 id="13-避免重复打印日志"><a href="#13-避免重复打印日志" class="headerlink" title="13.避免重复打印日志"></a>13.避免重复打印日志</h3><p>避免重复打印日志，酱紫会浪费磁盘空间。如果你已经有一行日志清楚表达了意思，<strong>避免再冗余打印</strong>，反例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(user.isVip())&#123;<br>  log.info(<span class="hljs-string">&quot;该用户是会员,Id:&#123;&#125;&quot;</span>,user,getUserId());<br>  <span class="hljs-comment">//冗余，可以跟前面的日志合并一起</span><br>  log.info(<span class="hljs-string">&quot;开始处理会员逻辑,id:&#123;&#125;&quot;</span>,user,getUserId());<br>  <span class="hljs-comment">//会员逻辑</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>  <span class="hljs-comment">//非会员逻辑</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果你是使用log4j日志框架，务必在<code>log4j.xml</code>中设置 additivity&#x3D;false，因为可以避免重复打印日志</p><p>正例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.taobao.dubbo.config&quot;</span> <span class="hljs-attr">additivity</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span> <br></code></pre></td></tr></table></figure><h3 id="14-日志文件分离"><a href="#14-日志文件分离" class="headerlink" title="14.日志文件分离"></a>14.日志文件分离</h3><ul><li>我们可以把不同类型的日志分离出去，比如access.log，或者error级别error.log，都可以单独打印到一个文件里面。</li><li>当然，也可以根据不同的业务模块，打印到不同的日志文件里，这样我们排查问题和做数据统计的时候，都会比较方便啦。</li></ul><h3 id="15-核心功能模块，建议打印较完整的日志"><a href="#15-核心功能模块，建议打印较完整的日志" class="headerlink" title="15. 核心功能模块，建议打印较完整的日志"></a>15. 核心功能模块，建议打印较完整的日志</h3><ul><li>我们日常开发中，如果核心或者逻辑复杂的代码，建议添加详细的注释，以及较详细的日志。</li><li>日志要多详细呢？脑洞一下，如果你的核心程序哪一步出错了，通过日志可以定位到，那就可以啦。</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>哈夫曼树(Huffman Tree)构建过程</title>
    <link href="/2021/09/22/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91-Huffman-Tree-%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B/"/>
    <url>/2021/09/22/%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91-Huffman-Tree-%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>注意：哈夫曼树并不唯一，但带权路径长度一定是相同的。</strong></p><h3 id="构建描述"><a href="#构建描述" class="headerlink" title="构建描述"></a>构建描述</h3><p>对哈夫曼树的构造可以分一下几步，需要多做几个实验，才可以熟练的掌握。</p><p>假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：</p><p>(1) 将w1、w2、…，wn看成是有n 棵树的森林(每棵树仅有一个结点)；</p><p>(2) 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；</p><p>(3)从森林中删除选取的两棵树，并将新树加入森林；</p><p>(4)重复(2)、(3)步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。</p><h3 id="图文表述"><a href="#图文表述" class="headerlink" title="图文表述"></a>图文表述</h3><p>（1）8个结点的权值大小如下：</p><p><img src="https://www.cmdbyte.com/2021/20131121141853312"></p><p>（2）从19，21，2，3，6，7，10，32中选择两个权小结点。选中2，3。同时算出这两个结点的和5。</p><p><img src="https://www.cmdbyte.com/2021/20131121141926625"></p><p>（3）从19，21，6，7，10，32，5中选出两个权小结点。选中5，6。同时计算出它们的和11。</p><p><img src="https://www.cmdbyte.com/2021/20131121142020546"></p><p>（4）从19，21，7，10，32，11中选出两个权小结点。选中7，10。同时计算出它们的和17。<br>（BTW：这时选出的两个数字都不是已经构造好的二叉树里面的结点，所以要另外开一棵二叉树；或者说，如果两个数的和正好是下一步的两个最小数的其中的一个，那么这个树直接往上生长就可以了，如果这两个数的和比较大，不是下一步的两个最小数的其中一个，那么就并列生长。）</p><p><img src="https://www.cmdbyte.com/2021/20131121142406359"></p><p>（5）从19，21，32，11，17中选出两个权小结点。选中11，17。同时计算出它们的和28。</p><p><img src="https://www.cmdbyte.com/2021/20131121142711156"></p><p>（6）从19，21，32，28中选出两个权小结点。选中19，21。同时计算出它们的和40。另起一颗二叉树。</p><p><img src="https://www.cmdbyte.com/2021/20131121142858562"></p><p>（7）从32，28， 40中选出两个权小结点。选中28，32。同时计算出它们的和60。</p><p><img src="https://www.cmdbyte.com/2021/20131121143220250"></p><p>（8）从 40， 60中选出两个权小结点。选中40，60。同时计算出它们的和100。 好了，此时哈夫曼树已经构建好了。</p><p><img src="https://www.cmdbyte.com/2021/20131121143025218"></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>①、编写哈夫曼树中每个节点结构；</p><p>②、构造哈夫曼树的算法；</p><p>③、编写一个存放每个节点哈夫曼编码的类型；</p><p>④、编写哈夫曼树求对应的哈夫曼编码的算法；</p><p>⑤、编写主函数。</p><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;malloc.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-comment">//①：</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-type">char</span> data;<br><span class="hljs-type">float</span> weight;<br><span class="hljs-type">int</span> parent;<br><span class="hljs-type">int</span> lchild;<br><span class="hljs-type">int</span> rchild;<br>&#125;<br>HTNode;<br><span class="hljs-comment">//②：</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateHT</span><span class="hljs-params">(HTNode ht[],<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-type">int</span> i,j,k,lnode,rnode;<br><span class="hljs-type">float</span> min1,min2;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;i++)  <br>      ht[i].parent=ht[i].lchild=ht[i].rchild=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (i=n;i&lt;<span class="hljs-number">2</span>*n<span class="hljs-number">-1</span>;i++) &#123;<br>min1=min2=<span class="hljs-number">32767</span>;<br>lnode=rnode=<span class="hljs-number">-1</span>;<br><span class="hljs-keyword">for</span> (k=<span class="hljs-number">0</span>;k&lt;=i<span class="hljs-number">-1</span>;k++)<br>  <span class="hljs-keyword">if</span> (ht[k].parent==<span class="hljs-number">-1</span>) &#123;<br><span class="hljs-keyword">if</span> (ht[k].weight&lt;min1) &#123;<br>min2=min1;<br>rnode=lnode;<br>min1=ht[k].weight;<br>lnode=k;<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ht[k].weight&lt;min2) &#123;<br>min2=ht[k].weight;<br>rnode=k;<br>&#125;<br>&#125;<br>ht[lnode].parent=i;<br>ht[rnode].parent=i;<br>ht[i].weight=ht[lnode].weight+ht[rnode].weight;<br>ht[i].lchild=lnode;<br>ht[i].rchild=rnode;<br>&#125;<br>&#125;<br><span class="hljs-comment">//③：</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-type">char</span> cd[N];<br><span class="hljs-type">int</span> start;<br>&#125;<br>HCode;<br><span class="hljs-comment">//④：</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">CreateHCode</span><span class="hljs-params">(HTNode ht[],HCode hcd[],<span class="hljs-type">int</span> n)</span> </span>&#123;<br><span class="hljs-type">int</span> i,f,c;<br>HCode hc;<br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>hc.start=n;<br>c=i;<br>f=ht[i].parent;<br><span class="hljs-keyword">while</span> (f!=<span class="hljs-number">-1</span>) &#123;<br><span class="hljs-keyword">if</span> (ht[f].lchild==c)<br>      hc.cd[hc.start--]=<span class="hljs-string">&#x27;0&#x27;</span>; <span class="hljs-keyword">else</span>  <br>      hc.cd[hc.start--]=<span class="hljs-string">&#x27;1&#x27;</span>;<br>c=f;<br>f=ht[f].parent;<br>&#125;<br>hc.start++;<br>hcd[i]=hc;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>领域驱动设计</title>
    <link href="/2021/09/22/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/09/22/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>DDD 作为一套优秀的方法论，为什么在过去的那么多年里，真正运用领域驱动设计开发（DDD）的团队并不多？现在为啥又那么火了？</p></blockquote><p>今天我们就来聊聊这个问题～</p><h3 id="软件发展的规律：由简单软件向复杂软件转变"><a href="#软件发展的规律：由简单软件向复杂软件转变" class="headerlink" title="软件发展的规律：由简单软件向复杂软件转变"></a>软件发展的规律：由简单软件向复杂软件转变</h3><p>先让我们把时间“往前推”，中国的软件业在刚起步阶段时，软件系统其实没有很复杂，即使在过程中不好维护了，大不了选择重新开发。但伴随着中国软件行业的快速发展，<strong>软件规模越来越大，程序越来越乱，维护成本越来越高，</strong>推倒重新开发显然不可取。</p><p>而 DDD 则给我们了新的思考，在每次需求变更的时候，首先是回到领域模型，基于业务进行领域模型的变更。接着，再基于领域模型的变更，指导程序的变更，这样就使得在面临不断出现的新需求时，始终保持设计质量不退化。</p><h3 id="微服务-与DDD"><a href="#微服务-与DDD" class="headerlink" title="微服务 与DDD"></a>微服务 与DDD</h3><p>微服务架构应运而生是为了解决传统架构的痛点，旨在通过将功能分解到各个离散的服务中以实现对解决方案的解耦。</p><p>可是，微服务架构从提出到应用以来，很多团队发现本以为通过系统拆分便可实现目的，没想到微服务基础设施才是重点，脱离了微服务基础设施做支撑，拆分系统就是在给自己不断挖坑！</p><p>我们都知道，DDD 的兴起是由于很多熟悉领域驱动建模的工程师在进行微服务设计时，发现用 DDD 的思路进行业务梳理可以很好规划服务边界，可以很好实现微服务内部和外部的”高内聚、低耦合”，最为关键的是，<strong>DDD提供了切实可行的应对软件核心复杂性的方法。</strong></p><p><img src="https://www.cmdbyte.com/2021/640%20(16).webp"></p><p><em><strong>越来越多的人将 DDD 作为业务划分的指导思想</strong></em></p><p>现在越来越多的企业希望通过DDD 从业务领域视角划分领域边界，构建通用语言进行高效沟通，通过业务抽象，建立领域模型，维持业务和代码的逻辑一致性。因此，企业迫切需要懂得用技术怎么解决实际业务问题，用技术驱动业务发展，能够构建<strong>高质量领域模型的技术人才。</strong>所以，我也很是认同掌握 DDD 是一件让技术人员更具核心竞争力的事情。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>限流设计思想</title>
    <link href="/2021/09/22/%E9%99%90%E6%B5%81%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/"/>
    <url>/2021/09/22/%E9%99%90%E6%B5%81%E8%AE%BE%E8%AE%A1%E6%80%9D%E6%83%B3/</url>
    
    <content type="html"><![CDATA[<p>日常生活中,有哪些需要限流的地方?</p><p>像我旁边有一个国家景区,平时可能根本没什么人前往,但是一到五一或者春节就人满为患,这时候景区管理人员就会实行一系列的政策来限制进入人流量, 为什么要限流呢?假如景区能容纳一万人,现在进去了三万人,势必摩肩接踵,整不好还会有事故发生,这样的结果就是所有人的体验都不好,如果发生了事故景区可能还要关闭,导致对外不可用,这样的后果就是所有人都觉得体验糟糕透了。</p><p>限流的思想就是,在保证可用的情况下尽可能多增加进入的人数,其余的人在外面排队等待,保证里面的一万人可以正常游玩。</p><p>回到网络上,同样也是这个道理,例如某某明星公布了恋情,访问从平时的50万增加到了500万,系统最多可以支撑200万访问,那么就要执行限流规则,保证是一个可用的状态,不至于服务器崩溃导致所有请求不可用。</p><h2 id="限流思路"><a href="#限流思路" class="headerlink" title="限流思路"></a>限流思路</h2><p>对系统服务进行限流，一般有如下几个模式：</p><h3 id="熔断"><a href="#熔断" class="headerlink" title="熔断"></a>熔断</h3><p>系统在设计之初就把熔断措施考虑进去。当系统出现问题时，如果短时间内无法修复，系统要自动做出判断，开启熔断开关，拒绝流量访问，避免大流量对后端的过载请求。</p><p>系统也应该能够动态监测后端程序的修复情况，当程序已恢复稳定时，可以关闭熔断开关，恢复正常服务。常见的熔断组件有Hystrix以及阿里的Sentinel，两种互有优缺点，可以根据业务的实际情况进行选择。</p><p><img src="https://www.cmdbyte.com/2021/640%20(11).webp"></p><h3 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h3><p>将系统的所有功能服务进行一个分级，当系统出现问题需要紧急限流时，可将不是那么重要的功能进行降级处理，停止服务，这样可以释放出更多的资源供给核心功能的去用。</p><p>例如在电商平台中，如果突发流量激增，可临时将商品评论、积分等非核心功能进行降级，停止这些服务，释放出机器和CPU等资源来保障用户正常下单，而这些降级的功能服务可以等整个系统恢复正常后，再来启动，进行补单&#x2F;补偿处理。除了功能降级以外，还可以采用不直接操作数据库，而全部读缓存、写缓存的方式作为临时降级方案。</p><h3 id="延迟处理"><a href="#延迟处理" class="headerlink" title="延迟处理"></a>延迟处理</h3><p>这个模式需要在系统的前端设置一个流量缓冲池，将所有的请求全部缓冲进这个池子，不立即处理。然后后端真正的业务处理程序从这个池子中取出请求依次处理，常见的可以用队列模式来实现。这就相当于用异步的方式去减少了后端的处理压力，但是当流量较大时，后端的处理能力有限，缓冲池里的请求可能处理不及时，会有一定程度延迟。后面具体的漏桶算法以及令牌桶算法就是这个思路。</p><h3 id="特权处理"><a href="#特权处理" class="headerlink" title="特权处理"></a>特权处理</h3><p>这个模式需要将用户进行分类，通过预设的分类，让系统优先处理需要高保障的用户群体，其它用户群的请求就会延迟处理或者直接不处理。</p><h3 id="缓存、降级、限流区别"><a href="#缓存、降级、限流区别" class="headerlink" title="缓存、降级、限流区别"></a>缓存、降级、限流区别</h3><p>缓存，是用来增加系统吞吐量，提升访问速度提供高并发。</p><p>降级，是在系统某些服务组件不可用的时候、流量暴增、资源耗尽等情况下，暂时屏蔽掉出问题的服务，继续提供降级服务，给用户尽可能的友好提示，返回兜底数据，不会影响整体业务流程，待问题解决再重新上线服务</p><p>限流，是指在使用缓存和降级无效的场景。比如当达到阈值后限制接口调用频率，访问次数，库存个数等，在出现服务不可用之前，提前把服务降级。只服务好一部分用户。</p><h2 id="限流的算法"><a href="#限流的算法" class="headerlink" title="限流的算法"></a>限流的算法</h2><p>限流算法很多,常见的有三类,分别是计数器算法、漏桶算法、令牌桶算法,下面逐一讲解。</p><h3 id="计数器算法"><a href="#计数器算法" class="headerlink" title="计数器算法"></a>计数器算法</h3><p>简单粗暴,比如指定线程池大小，指定数据库连接池大小、nginx连接数等,这都属于计数器算法。</p><p>计数器算法是限流算法里最简单也是最容易实现的一种算法。举个例子,比如我们规定对于A接口，我们1分钟的访问次数不能超过100个。那么我们可以这么做：在一开 始的时候，我们可以设置一个计数器counter，每当一个请求过来的时候，counter就加1，如果counter的值大于100并且该请求与第一个请求的间隔时间还在1分钟之内，那么说明请求数过多,拒绝访问；如果该请求与第一个请求的间隔时间大于1分钟，且counter的值还在限流范围内，那么就重置 counter,就是这么简单粗暴。</p><p><img src="https://www.cmdbyte.com/2021/640%20(12).webp"></p><h3 id="漏桶算法"><a href="#漏桶算法" class="headerlink" title="漏桶算法"></a>漏桶算法</h3><p>漏桶算法思路很简单，水（请求）先进入到漏桶里，漏桶以一定的速度出水，当水流入速度过大会超过桶可接纳的容量时直接溢出，可以看出漏桶算法能强行限制数据的传输速率。</p><p><img src="https://www.cmdbyte.com/2021/640%20(13).webp"></p><p><strong>削峰:有大量流量进入时,会发生溢出,从而限流保护服务可用</strong></p><p><strong>缓冲:不至于直接请求到服务器,缓冲压力 消费速度固定 因为计算性能固定</strong></p><h3 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h3><p>令牌桶与漏桶相似,不同的是令牌桶桶中放了一些令牌,服务请求到达后,要获取令牌之后才会得到服务,举个例子,我们平时去食堂吃饭,都是在食堂内窗口前排队的,这就好比是漏桶算法,大量的人员聚集在食堂内窗口外,以一定的速度享受服务,如果涌进来的人太多,食堂装不下了,可能就有一部分人站到食堂外了,这就没有享受到食堂的服务,称之为溢出,溢出可以继续请求,也就是继续排队,那么这样有什么问题呢?</p><p>如果这时候有特殊情况,比如有些赶时间的志愿者啦、或者高三要高考啦,这种情况就是突发情况,如果也用漏桶算法那也得慢慢排队,这也就没有解决我们的需求,对于很多应用场景来说，除了要求能够限制数据的平均传输速率外，还要求允许某种程度的突发传输。这时候漏桶算法可能就不合适了，令牌桶算法更为适合。如图所示，令牌桶算法的原理是系统会以一个恒定的速度往桶里放入令牌，而如果请求需要被处理，则需要先从桶里获取一个令牌，当桶里没有令牌可取时，则拒绝服务。</p><p><img src="https://www.cmdbyte.com/2021/640%20(14).webp"></p><h2 id="并发限流"><a href="#并发限流" class="headerlink" title="并发限流"></a>并发限流</h2><p>简单来说就是设置系统阈值总的QPS个数,这些也挺常见的,就拿Tomcat来说,很多参数就是出于这个考虑,例如</p><p>配置的<code>acceptCount</code> 设置响应连接数, <code>maxConnections</code>设置瞬时最大连接数, <code>maxThreads</code> 设置最大线程数,在各个框架或者组件中,并发限流体现在下面几个方面:</p><ul><li>限制总并发数（如数据库连接池、线程池）</li><li>限制瞬时并发数（nginx的limit_conn模块，用来限制瞬时并发连接数）</li><li>限制时间窗口内的平均速率（如Guava的RateLimiter、nginx的limit_req模块，限制每秒的平均速率）</li><li>其他的还有限制远程接口调用速率、限制MQ的消费速率。</li><li>另外还可以根据网络连接数、网络流量、CPU或内存负载等来限流。</li></ul><p>有了并发限流，就意味着在处理高并发的时候多了一种保护机制，不用担心瞬间流量导致系统挂掉或雪崩，最终做到有损服务而不是不服务；但是限流需要评估好，不能乱用，否则一些正常流量出现一些奇怪的问题而导致用户体验很差造成用户流失。</p><h2 id="接口限流"><a href="#接口限流" class="headerlink" title="接口限流"></a>接口限流</h2><p>接口限流分为两个部分,一是限制一段时间内接口调用次数,参照前面限流算法的计数器算法, 二是设置滑动时间窗口算法。</p><h3 id="接口总数"><a href="#接口总数" class="headerlink" title="接口总数"></a>接口总数</h3><p>控制一段时间内接口被调用的总数量,可以参考前面的计数器算法,不再赘述。</p><h3 id="接口时间窗口"><a href="#接口时间窗口" class="headerlink" title="接口时间窗口"></a>接口时间窗口</h3><p>固定时间窗口算法(也就是前面提到的计数器算法)的问题是统计区间太大，限流不够精确，而且在第二个统计区间 时没有考虑与前一个统计区间的关系与影响（第一个区间后半段 + 第二个区间前半段也是一分钟）。为了解决上面我们提到的临界问题，我们试图把每个统计区间分为更小的统计区间，更精确的统计计数。</p><p><img src="https://www.cmdbyte.com/2021/640%20(15).webp"></p><p>在上面的例子中,假设QPS可以接受100次查询&#x2F;秒, 前一分钟前40秒访问很低,后20秒突增,并且这个持续了一段时间,直到第二分钟的第40秒才开始降下来,根据前面的计数方法,前一秒的QPS为94,后一秒的QPS为92,那么没有超过设定参数,但是!但是在中间区域,QPS达到了142,这明显超过了我们的允许的服务请求数目,所以固定窗口计数器不太可靠,需要滑动窗口计数器。</p><p>计数器算法其实就是固定窗口算法, 只是它没有对时间窗口做进一步地划分，所以只有1格；由此可见，当滑动窗口的格子划分的越多，也就是将秒精确到毫秒或者纳秒, 那么滑动窗口的滚动就越平滑，限流的统计就会越精确。</p><p>需要注意的是,消耗的空间就越多。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZIP压缩算法详细分析及解压实例解释</title>
    <link href="/2021/09/22/ZIP%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%8E%8B%E5%AE%9E%E4%BE%8B%E8%A7%A3%E9%87%8A/"/>
    <url>/2021/09/22/ZIP%E5%8E%8B%E7%BC%A9%E7%AE%97%E6%B3%95%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90%E5%8F%8A%E8%A7%A3%E5%8E%8B%E5%AE%9E%E4%BE%8B%E8%A7%A3%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://www.cnblogs.com/esingchan/p/3958962.html">https://www.cnblogs.com/esingchan/p/3958962.html</a></p></blockquote><p>最近自己实现了一个ZIP压缩数据的解压程序，觉得有必要把ZIP压缩格式进行一下详细总结，数据压缩是一门通信原理和计算机科学都会涉及到的学科，在通信原理中，一般称为信源编码，在计算机科学里，一般称为数据压缩，两者本质上没啥区别，在数学家看来，都是映射。一方面在进行通信的时候，有必要将待传输的数据进行压缩，以减少带宽需求；另一方面，计算机存储数据的时候，为了减少磁盘容量需求，也会将文件进行压缩，尽管现在的网络带宽越来越高，压缩已经不像90年代初那个时候那么迫切，但在很多场合下仍然需要，其中一个原因是压缩后的数据容量减小后，磁盘访问IO的时间也缩短，尽管压缩和解压缩过程会消耗CPU资源，但是CPU计算资源增长得很快，但是磁盘IO资源却变化得很慢，比如目前主流的SATA硬盘仍然是7200转，如果把磁盘的IO压力转化到CPU上，总体上能够提升系统运行速度。压缩作为一种非常典型的技术，会应用到很多很多场合下，比如文件系统、数据库、消息传输、网页传输等等各类场合。尽管压缩里面会涉及到很多术语和技术，但无需担心，博主尽量将其描述得通俗易懂。另外，本文涉及的压缩算法非常主流并且十分精巧，理解了ZIP的压缩过程，对理解其它相关的压缩算法应该就比较容易了。 </p><h2 id="1、引子"><a href="#1、引子" class="headerlink" title="1、引子"></a>1、引子</h2><p>压缩可以分为无损压缩和有损压缩，有损，指的是压缩之后就无法完整还原原始信息，但是压缩率可以很高，主要应用于视频、话音等数据的压缩，因为损失了一点信息，人是很难察觉的，或者说，也没必要那么清晰照样可以看可以听；无损压缩则用于文件等等必须完整还原信息的场合，ZIP自然就是一种无损压缩，在通信原理中介绍数据压缩的时候，往往是从信息论的角度出发，引出香农所定义的熵的概念，这方面的介绍实在太多，这里换一种思路，从最原始的思想出发，为了达到压缩的目的，需要怎么去设计算法。而ZIP为我们提供了相当好的案例。</p><p>尽管我们不去探讨信息论里面那些复杂的概念，不过我们首先还是要从两位信息论大牛谈起。因为是他们奠基了今天大多数无损数据压缩的核心，包括ZIP、RAR、GZIP、GIF、PNG等等大部分无损压缩格式。这两位大牛的名字分别是Jacob Ziv和Abraham Lempel，是两位以色列人，在1977年的时候发表了一篇论文《A Universal Algorithm for Sequential Data Compression》，从名字可以看出，这是一种通用压缩算法，所谓通用压缩算法，指的是这种压缩算法没有对数据的类型有什么限定。不过论文我觉得不用仔细看了，因为博主作为一名通信专业的PHD，看起来也焦头烂额，不过我们后面可以看到，它的思想还是很简单的，之所以看起来复杂，主要是因为IEEE的某些杂志就是这个特点，需要从数学上去证明，这种压缩算法到底有多优，比如针对一个各态历经的随机序列（不用追究什么叫各态历经随机序列），经过这样的压缩算法后，是否可以接近信息论里面的极限（也就是前面说的熵的概念）等等，不过在理解其思想之前，个人认为没必要深究这些东西，除非你要发论文。这两位大牛提出的这个算法称为LZ77，两位大牛过了一年又提了一个类似的算法，称为LZ78，思想类似，ZIP这个算法就是基于LZ77的思想演变过来的，但ZIP对LZ77编码之后的结果又继续进行压缩，直到难以压缩为止。除了LZ77、LZ78，还有很多变种的算法，基本都以LZ开头，如LZW、LZO、LZMA、LZSS、LZR、LZB、LZH、LZC、LZT、LZMW、LZJ、LZFG等等，非常多，LZW也比较流行，GIF那个动画格式记得用了LZW。我也写过解码程序，以后有时间可以再写一篇，但感觉跟LZ77这些类似，写的必要性不大。</p><p>ZIP的作者是一个叫Phil Katz的人，这个人算是开源界的一个具有悲剧色彩的传奇人物。虽然二三十年前，开源这个词还没有现在这样风起云涌，但是总有一些具有黑客精神的牛人，内心里面充满了自由，无论他处于哪个时代。Phil Katz这个人是个牛逼程序员，成名于DOS时代，我个人也没有经历过那个时代，我是从Windows98开始接触电脑的，只是从书籍中得知，那个时代网速很慢，拨号使用的是只有几十Kb（比特不是字节）的猫，56Kb实际上是这种猫的最高速度，在ADSL出现之后，这种技术被迅速淘汰。当时记录文件的也是硬盘，但是在电脑之间拷贝文件的是软盘，这个东西我大一还用过，最高容量记得是1.44MB，这还是200X年的软盘，以前的软盘容量具体多大就不知道了，Phil Katz上网的时候还不到1990年，WWW实际上就没出现，浏览器当然是没有的，当时上网干嘛呢？基本就是类似于网管敲各种命令，这样实际上也可以聊天、上论坛不是吗，传个文件不压缩的话肯定死慢死慢的，所以压缩在那个时代很重要。当时有个商业公司提供了一种称为ARC的压缩软件，可以让你在那个时代聊天更快，当然是要付费的，Phil Katz就感觉到不爽，于是写了一个PKARC，免费的，看名字知道是兼容ARC的，于是网友都用PKARC了，ARC那个公司自然就不爽，把哥们告上了法庭，说牵涉了知识产权等等，结果Phil Katz坐牢了。。。牛人就是牛人， 在牢里面冥思苦想，决定整一个超越ARC的牛逼算法出来，牢里面就是适合思考，用了两周就整出来的，称为PKZIP，不仅免费，而且这次还开源了，直接公布源代码，因为算法都不一样了，也就不涉及到知识产权了，于是ZIP流行开来，不过Phil Katz这个人没有从里面赚到一分钱，还是穷困潦倒，因为喝酒过多等众多原因，2000年的时候死在一个汽车旅馆里。英雄逝去，精神永存，现在我们用UE打开ZIP文件，我们能看到开头的两个字节就是PK两个字符的ASCII码。 </p><h2 id="2、一个案例的入门思考"><a href="#2、一个案例的入门思考" class="headerlink" title="2、一个案例的入门思考"></a>2、一个案例的入门思考</h2><p>好了，Phil Katz在牢里面到底思考了什么？用什么样的算法来压缩数据呢？我们想一个简单的例子：</p><p>生，容易。活，容易。生活，不容易。</p><p>上面这句话假如不压缩，如果使用Unicode编码，每个字会用2个字节表示。为什么是两个字节呢？Unicode是一种国际标准，把常见各国的字符，比如英文字符、日文字符、韩文字符、中文字符、拉丁字符等等全部制定了一个标准，显然，用2个字节可以最多表示2^16&#x3D;65536个字符，那么65536就够了吗？生僻字其实是很多的，比如光康熙字典里面收录的汉字就好几万，所以实际上是不够的，那么是不是扩到4个字节？也可以，这样空间倒是变大了，可以收录更多字符，但一方面扩到4个字节就一定保证够吗？另一方面，4个字节是不是太浪费空间了，就为了那些一般情况都不会出现的生僻字？所以，一般情况下，使用2个字节表示，当出现生僻字的时候，再使用4个字节表示。这实际上就体现了信息论中数据压缩基本思想，出现频繁的那些字符，表示得短一些；出现稀少的，可以表示得长些（反正一般情况下也不会出现），这样整体长度就会减小。除了Unicode，ASCII编码是针对英文字符的编码方案，用1个字节即可，除了这两种编码方案，还有很多地区性的编码方案，比如GB2312可以对中文简体字进行编码，Big5可以对中文繁体字进行编码。两个文件如果都使用一种编码方案，那是没有问题的，不过考虑到国际化，还是尽量使用Unicode这种国际标准吧。不过这个跟ZIP没啥关系，纯属背景介绍。</p><p>好了，回到我们前面说的例子，一共有17个字符（包括标点符号），如果用普通Unicode表示，一共是17*2&#x3D;34字节。可不可以压缩呢？所有人一眼都可以看出里面出现了很多重复的字符，比如里面出现了好多次容易（实际上是容易加句号三个字符）这个词，第一次出现的时候用普通的Unicode，第二次出现的“容易。”则可以用（距离、长度）表示，距离的意思是接下来的字符离前面重复的字符隔了几个，长度则表示有几个重复字符，上面的例子的第二个“容易。”就表示为（5,3），就是距离为5个字符，长度是3，在解压缩的时候，解到这个地方的时候，往前跳5个字符，把这个位置的连续3个字符拷贝过来就完成了解压缩，这实际上不就是指针的概念？没有错，跟指针很类似，不过在数据压缩领域，一般称为字典编码，为什么叫字典呢，当我们去查一个字的时候，我们总是先去目录查找这个字在哪一页，再翻到那一页去看，指针不也是这样，指针不就是内存的地址，要对一个内存进行操作，我们先拿到指针，然后去那块内存去操作。所谓的指针、字典、索引、目录等等术语，不同的背景可能称呼不同，但我们要理解他们的本质。如果使用（5,3）这种表示方法，原来需要用6个字节表示，现在只需要记录5和3即可。那么，5和3怎么记录呢？一种方法自然还是可以用Unicode，那么就相当于节省了2个字节，但是有两个问题，第一个问题是解压缩的时候怎么知道是正常的5和3这两个字符，还是这只是一个特殊标记呢？所以前面还得加一个标志来区分一下，到底接下来的Unicode码是指普通字符，还是指距离和长度，如果是普通Unicode，则直接查Unicode码表，如果是距离和长度，则往前面移动一段距离，拷贝即可。第二个问题，还是压缩程度不行，这么一弄，感觉压缩不了多少，如果重复字符比较长那倒是比较划算，因为反正“距离+长度”就够了，但比如这个例子，如果5和3前面加一个特殊字节，岂不是又是3个字节，那还不如不压缩。咋办呢？能不能对（5,3）这种整数进行再次压缩？这里就利用了我们前面说的一个基本原则：出现的少的整数多编一些比特，出现的多的整数少编一些比特。那么，比如3、4、5、6、7、8、9这些距离谁出现得多？谁出现的少呢？谁知道？</p><p>压缩之前当然不知道，不过扫描一遍不就知道了？比如，后面那个重复的字符串“容易。”按照前面的规则可以表示为（7,3）,即离前面重复的字符串距离为7，长度为3。（7,3）指着前面跟自己一样那个字符串。那么，为什么不指着第一个“容易。”要指着第二个“容易。”呢？如果指着第一个，那就不是（7,3）了，就是（12，3）了。当然，表示为（12,3）也可以解压缩，但是有一个问题，就是12这个值比7大，大了又怎么了？我们在生活中会发现一些普遍规律，重复现象往往具有局部性。比如，你跟一个人说话，你说了一句话以后，往往很快会重复一遍，但是你不会隔了5个小时又重复这句话，这种特点在文件里面也存在着，到处都是这种例子，比如你在编程的时候，你定义了一个变量int nCount，这个nCount一般你很快就会用到，不会离得很远。我们前面所说的距离代表了你隔了多久再说这句话，这个距离一般不大，既然如此，应该以离当前字符串距离最近的那个作为记录的依据（也就是指向离自己最近那个重复字符串），这样的话，所有的标记都是一些短距离，比如都是3、4、5、6、7而不会是3、5、78、965等等，如果大多数都是一些短距离，那么这些短距离就可以用短一些的比特表示，长一些的距离不太常见，则用一些长一些的比特表示。这样， 总体的表示长度就会减少。好了，我们前面得到了（5,3）、（7、3）这种记录重复的表示，距离有两种：5、7；长度只有1种：3。咋编码？越短越好。</p><p>既然表示的比特越短越好，3表示为0、5表示为10、7表示为11，行不行？这样（5,3）,（7,3）就只需要表示为100、110，这样岂不是很短？貌似可以，貌似很高效。</p><p>但解压缩遇到10这两个比特的时候，怎么知道10表示5呢？这种表示方法是一个映射表，称为码表。我们设计的上面这个例子的码表如下：</p><p>3–&gt;0</p><p>5–&gt;10</p><p>7–&gt;11</p><p>这个码表也得传过去或者记录在压缩文件里才行啊，否则无法解压缩，但会不会记录了码表以后整体空间又变大了，会不会起不到压缩的作用？而且一个码表怎么记录？码表记录下来也是一堆数据，是不是也需要编码？码表是否可以继续压缩？那岂不是又需要新的码表？压缩会不会是一个永无止境的过程？作为一个入门级的同学，大概想到这儿就不容易想下去了。</p><h2 id="3、ZIP中的LZ编码思想"><a href="#3、ZIP中的LZ编码思想" class="headerlink" title="3、ZIP中的LZ编码思想"></a>3、ZIP中的LZ编码思想</h2><p>上面我们说的重复字符串用指针标记记录下来，这种方法就是LZ这两个人提出来的，理解起来比较简单。后面分析（5,3）这种指针标记应该怎么编码的时候，就涉及到一种非常广泛的编码方式，Huffman编码，Huffman大致和香农是一个时代的人，这种编码方式是他在MIT读书的时候提出来的。接下来，我们来看看ZIP是怎么做的。</p><p>以上面的例子，一个很简单的示意图如下：</p><p><img src="https://www.cmdbyte.com/2021/052301509071245.png" alt="ZIP中的LZ编码思想"></p><p>可以看出，ZIP中使用的LZ77算法和前面分析的类似，当然，如果仔细对比的话，ZIP中使用的算法和LZ提出来的LZ77算法其实还是有差异的，不过我建议不用仔细去扣里面的差异，思想基本是相同的，我们后面会简要分析一下两者的差异。LZ77算法一般称为“滑动窗口压缩”，我们前面说过，该算法的核心是在前面的历史数据中寻找重复字符串，但如果要压缩的文件有100MB，是不是从文件头开始找？不是，这里就涉及前面提过的一个规律，重复现象是具有局部性的，它的基本假设是，如果一个字符串要重复，那么也是在附近重复，远的地方就不用找了，因此设置了一个滑动窗口，ZIP中设置的滑动窗口是32KB，那么就是往前面32KB的数据中去找，这个32KB随着编码不断进行而往前滑动。当然，理论上讲，把滑动窗口设置得很大，那样就有更大的概率找到重复的字符串，压缩率不就更高了？初看起来如此，找的范围越大，重复概率越大，不过仔细想想，可能会有问题，一方面，找的范围越大，计算量会增大，不顾一切地增大滑动窗口，甚至不设置滑动窗口，那样的软件可能不可用，你想想，现在这种方式，我们在压缩一个大文件的时候，速度都已经很慢了，如果增大滑动窗口，速度就更慢，从工程实现角度来说，设置滑动窗口是必须的；另一方面，找的范围越大，距离越远，出现的距离很多，也不利于对距离进行进一步压缩吧，我们前面说过，距离和长度最好出现的值越少越好，那样更好压缩，如果出现的很多，如何记录距离和长度可能也存在问题。不过，我相信滑动窗口设置得越大，最终的结果应该越好一些，不过应该不会起到特别大的作用，比如压缩率提高了5%，但计算量增加了10倍，这显然有些得不偿失。</p><p>在第一个图中，“容易。”是一个重复字符串，距离distance&#x3D;5，字符串长度length&#x3D;3。当对这三个字符压缩完毕后，接下来滑动窗口向前移动3个字符，要压缩的是“我…”这个字符串，但这个串在滑动窗口内没找到，所以无法使用distance+length的方式记录。这种结果称为literal。literal的中文含义是原义的意思，表示没有使用distance+length的方式记录的那些普通字符。literal是不是就用原始的编码方式，比如Unicode方式表示？ZIP里不是这么做的，ZIP把literal认为也是一个数，尽管不能用distance+length表示，但不代表不可以继续压缩。另外，如果“我”出现在了滑动窗口内，是不是就可以用distance+length的方式表示？也不是，因为一个字出现重复，不值得用这种方式表示，两个字呢？distance+length就是两个整数，看起来也不一定值得，ZIP中确实认为2个字节如果在滑动窗口内找到重复，也不管，只有3个字节以上的重复字符串，才会用distance+length表示，重复字符串的长度越长越好，因为不管多长，都用distance+length表示就行了。</p><p>这样的话，一段字符串最终就可以表示成literal、distance+length这两种形式了。LZ系列算法的作用到此为止，下面，Phil Katz考虑使用Huffman对上面的这些LZ压缩后的结果进行二次压缩。个人认为接下来的过程才是ZIP的核心，所以我们要熟悉一下Huffman编码。</p><h2 id="4、ZIP中的Huffman编码思想"><a href="#4、ZIP中的Huffman编码思想" class="headerlink" title="4、ZIP中的Huffman编码思想"></a>4、ZIP中的Huffman编码思想</h2><p>上面LZ压缩结果有三类（literal、distance、length），我们拿出distance一类来举例。distance代表重复字符串离前一个一模一样的字符串之间的距离，是一个大于0的整数。如何对一个整数进行编码呢？一种方法是直接用固定长度表示，比如采用计算机里面描述一个4字节整数那样去记录，这也是可以的，主要问题当然是浪费存储空间，在ZIP中，distance这个数表示的是重复字符串之间的距离，显然，一般而言，越小的距离，出现的数量可能越多，而越大的距离，出现的数量可能越少，那么，按照我们前面所说的原则，小的值就用较少比特表示，大的值就用较多比特表示，在我们这个场景里，distance当然也不会无限大，比如不会超过滑动窗口的最大长度，假如对一个文件进行LZ压缩后，得到的distance值为：</p><p>3、6、4、3、4、3、4、3、5</p><p>这个例子里，3出现了4次，4出现了3次，5出现了1次，6出现了1次。当然，不同的文件得到的结果不同，这里只是举一个典型的例子，因为只有4种值，所以我们没有必要对其它整数编码。只需要对这4个整数进行编码即可。</p><p>那么，怎么设计一个算法，符合3的编码长度最短？6的编码长度最长这种直观上可行的原则（我们并没有说这是理论上最优的方式）呢？</p><p>看起来似乎很难想出来。我们先来简化一下，用固定长度表示。这里有4个整数，只要使用2个比特表示即可。于是这样表示就很简单：</p><p>00–&gt;3； 01–&gt;4； 10–&gt;5; 11–&gt;6。</p><p>00、01这种编码结果称为码字，码字的平均长度是2。上面这个对应关系即为码表，在压缩时，需要将码表放在最前面，后面的数字就用码字表示，解码时，先把码表记录在内存里，比如用一个哈希表记录下来，解压缩时，遇到00，就解码为3等等。</p><p>因为出现了9个数，所以全部码字总长度为18个比特。（我们暂时不考虑记录码表到底要占多少空间）</p><p>想要编码结果更短，因为3出现的最多，所以考虑把3的码字缩短点，比如3是不是可以用1个比特表示，这样才算缩短吧，因为0和1只是二进制的一个标志，所以用0还是1没有本质区别，那么，我们暂定把3用比特0表示。那么，4、5、6还能用0开头的码字表示呢？</p><p>这样会存在问题，因为4、5、6的编码结果如果以0开头，那么，在解压缩的时候，遇到比特0，就不知道是表示3还是表示4、5、6了，就无法解码，当然，似乎理论上也不是不可以，比如可以往后解解看，比如假定0表示3的条件下往后解，如果无效则说明这个假设不对，但这种方式很容易出现两个字符串的编码结果是一样的，这个谁来保证？所以，4、5、6都得以1开头才行，那么，按照这个原则，4用1个比特也不行，因为5、6要么以0开头，要么以1开头，就无法编码了，所以我们将4的码字增加至2个比特，比如10，于是我们得到了部分码表:</p><p>0–&gt;3；10–&gt;4。</p><p>按照这个道理，5、6既不能以0开头，也不能以10开头了，因为同样存在无法解码的问题，所以5应该以11开头，就定为11行不行呢？也不行，因为6就不知道怎么编码了，6也不能以0开头，也不能以10、11开头，那就无法表示了，所以，迫不得已，我们必须把5扩展一位，比如110，那么，6显然就可以用111表示了，反正也没有其他数了。于是我们得到了最终的码表：</p><p>0–&gt;3；10–&gt;4；110–&gt;5；111–&gt;6。</p><p>看起来，编码结果只能是这样了，我们来算一下，码字的总长度减少了没有，原来的9个数是3、6、4、3、4、3、4、3、5，分别对应的码字是：</p><p>0、111、10、0、10、0、10、0、110</p><p>算一下，总共16个比特，果然比前面那种方式变短了。我们在前面的设计过程中，是按照这些值出现次数由高到底的顺序去找码字的，比如先确定3，再确定4、5、6等等。按照一个码字不能是另一个码字的前缀这一规则，逐步获得所有的码字。这种编码规则有一个专用术语，称为前缀码。Huffman编码基本上就是这么做的，把出现频率排个序，然后逐个去找，这个逐个去找的过程，就引入了二叉树。不过Huffman的算法一般是从频率由低到高排序，从树的下面依次往上合并，不过本质上没区别，理解思想即可。上面的结果可以用一颗二叉树表示为下图：</p><p><img src="https://www.cmdbyte.com/2021/060122501881755.png"></p><p>这棵树也称为码树，其实就是码表的一种形式化描述，每个节点（除了叶子节点）都会分出两个分支，左分支代表比特0，右边分支代表1，从根节点到叶子节点的一个比特序列就是码字。因为只有叶子节点可以是码字，所以这样也符合一个码字不能是另一个码字的前缀这一原则。说到这里，可以说一下另一个话题，就是一个映射表map在内存中怎么存储，没有相关经验的可以跳过，map实现的是key–&gt;value这样的一个表，map的存储一般有哈希表和树形存储两类，树形存储就可以采用上面这棵树，树的中间节点并没有什么含义，叶子节点的值表示value，从根节点到叶子节点上分支的值就是key，这样比较适合存储那些key由多个不等长字符组成的场合，比如key如果是字符串，那么把二叉树的分支扩展很多，成为多叉树，每个分支就是a,b,c,d这种字符，这棵树也就是Trie树，是一种很好使的数据结构。利用树的遍历算法，就实现了一个有序Map。</p><p>好了，我们理解了Huffman编码的思想，我们来看看distance的实际情况。ZIP中滑动窗口大小固定为32KB，也就是说，distance的值范围是1-32768。那么，通过上面的方式，统计频率后，就得到32768个码字，按照上面这种方式可以构建出来。于是我们会遇到一个最大的问题，那就是这棵树太大了，怎么记录呢？</p><p>好了，个人认为到了ZIP的核心了，那就是码树应该怎么缩小，以及码树怎么记录的问题。</p><h2 id="5、ZIP中Huffman码树的记录方式"><a href="#5、ZIP中Huffman码树的记录方式" class="headerlink" title="5、ZIP中Huffman码树的记录方式"></a>5、ZIP中Huffman码树的记录方式</h2><p>分析上面的例子，看看这个码表：</p><p>0–&gt;3；10–&gt;4；110–&gt;5；111–&gt;6。</p><p>我们之前提过，0和1就是二进制的一个标志，互换一下其实根本不影响编码长度，所以，下面的码表其实是一样的：</p><p>1–&gt;3；00–&gt;4；010–&gt;5；011–&gt;6。</p><p>1–&gt;3；01–&gt;4；000–&gt;5；001–&gt;6。</p><p>0–&gt;3；11–&gt;4；100–&gt;5；101–&gt;6。</p><p>。。。。。</p><p>这些都可以，而且编码长度完全一样，只是码字不同而已。</p><p>对比一下第一个和第二个例子，对应的码树是这个样子：</p><p><img src="https://www.cmdbyte.com/2021/060206060639066.png"></p><p>也就是说，我们把码树的任意节点的左右分支旋转（0、1互换），也可以称为树的左右互换，其实不影响编码长度，也就是说，这些码表其实都是一样好的，使用哪个都可以。</p><p>这个规律暗示了什么信息呢？暗示了码表可以怎么记录呢？Phil Katz当年在牢里也深深地思考了这一问题。</p><p>为了体会Phil Katz当时的心情，我们有必要盯着这两棵树思考几分钟：怎么把一颗树用最少的比特记录下来？</p><p>Phil Katz当时思考的逻辑我猜是这样的，既然这些树的压缩程度都一样，那干脆使用最特殊的那棵树，反正压缩程度都一样，只要ZIP规定了这棵树的特殊性，那么我记录的信息就可以最少，这种特殊化的思想在后面还会看到。不同的树当然有不同的特点，比如数据结构里面常见的平衡树也是一类特殊的树，他选的树就是左边那棵，这棵树有一个特点，越靠左边越浅，越往右边越深，是这些树中最不平衡的树。ZIP里的压缩算法称为Deflate算法，这棵树也称为Deflate树，对应的解压缩算法称为Inflate，Deflate的大致意思是把轮胎放气了，意为压缩；Inflate是给轮胎打气的意思，意为解压。那么，Deflate树的特殊性又带来什么了？</p><p>揭晓答案吧，Phil Katz认为换来换去只有码字长度不变，如果规定了一类特殊的树，那么就只需要记录码字长度即可。比如，一个有效的码表是0–&gt;3；10–&gt;4；110–&gt;5；111–&gt;6。但只需要记录这个对应关系即可：</p><p>3　　4　　5　　6</p><p>1　　2　　3　　3</p><p>也就是说，把1、2、3、3记录下来，解压一边照着左边那棵树的形状构造一颗树，然后只需要1、2、3、3这个信息自然就知道是0、10、110、111。这就是Phil Katz想出来的ZIP最核心的一点：这棵码树用码字长度序列记录下来即可。</p><p>当然，只把1、2、3、3这个序列记录下来还不行，比如不知道111对应5还是对应6？</p><p>所以，构造出树来只是知道了有哪些码字了，但是这些码字到底对应哪些整数还是不知道。</p><p>Phil Katz于是又出现了一个想法：记录1、2、3、3还是记录1、3、2、3，或者3、3、2、1，其实都能构造出这棵树来，那么，为什么不按照一个特殊的顺序记录呢？这个顺序就是整数的大小顺序，比如上面的3、4、5、6是整数大小顺序排列的，那么，记录的顺序就是1、2、3、3。而不是2、3、3、1。</p><p>好了，根据1、2、3、3这个信息构造出了码字，这些码字对应的整数一个比一个大，假如我们知道编码前的整数就是3、4、5、6这四个数，那就能对应起来了，不过到底是哪四个还是不知道啊？这个整数可以表示距离啊，距离不知道怎么去解码LZ？</p><p>Phil Katz又想了，既然distance的范围是1-32768，那么就按照这个顺序记录。上面的例子1和2没有，那就记录长度0。所以记录下来的码字长度序列为：</p><p>0、0、1、2、3、3、0、0、0、0、0、。。。。。。。。。。。。</p><p>这样就知道构造出来的码字对应哪个整数了吧，但因为distance可能的值很多（32768个），但实际出现的往往不多，中间会出现很多0（也就是根本就没出现这个距离），不过这个问题倒是可以对连续的0做个特殊标记，这样是不是就行了呢？还有什么问题？</p><p>我们还是要站在时代的高度来看待这个问题。我们明白，每个distance肯定对应唯一一个码字，使用Huffman编码可以得到所有码字，但是因为distance可能非常多，虽然一般不会有32768这么多，但对一个大些的文件进行LZ编码，distance上千还是很正常的，所以这棵树很大，计算量、消耗的内存都容易超越了那个时代的硬件条件，那么怎么办呢？这里再次体现了Phil Katz对Huffman编码掌握的深度，他把distance划分成多个区间，每个区间当做一个整数来看，这个整数称为Distance Code。当一个distance落到某个区间，则相当于是出现了那个Code，多个distance对应于一个Distance Code，Distance虽然很多，但Distance Code可以划分得很少，只要我们对Code进行Huffman编码，得到Code的编码后，Distance Code再根据一定规则扩展出来。那么，划分多少个区间？怎么划分区间呢？我们分析过，越小的距离，出现的越多；越大的距离，出现的越少，所以这种区间划分不是等间隔的，而是越来越稀疏的，类似于下面的划分：</p><p><img src="https://www.cmdbyte.com/2021/060258556575636.png"></p><p>1、2、3、4这四个特殊distance不划分，或者说1个Distance就是1个区间；5,6作为一个区间；7、8作为一个区间等等，基本上，区间的大小都是1、2、4、8、16、32这么递增的，越往后，涵盖的距离越多。为什么这么分呢？首先自然是距离越小出现频率越高，所以距离值小的时候，划分密一些，这样相当于一个放大镜，可以对小的距离进行更精细地编码，使得其编码长度与其出现次数尽量匹配；对于距离较大那些，因为出现频率低，所以可以适当放宽一些。另一个原因是，只要知道这个区间Code的码字，那么对于这个区间里面的所有distance，后面追加相应的多个比特即可，比如，17-24这个区间的Huffman码字是110，因为17-24这个区间有8个整数，于是按照下面的规则即可获得其distance对应的码字：</p><p>17–&gt;110 000</p><p>18–&gt;110 001</p><p>19–&gt;110 010</p><p>20–&gt;110 011</p><p>21–&gt;110 100</p><p>22–&gt;110 101</p><p>23–&gt;110 110</p><p>24–&gt;110 111</p><p>这样计算复杂度和内存消耗是不是很小了，因为需要进行Huffman编码的整数一下字变少了，这棵树不会多大，计算起来时间和空间复杂度降低，扩展起来也比较简单。当然，从理论上来说，这样的编码方式实际上将编码过程分为了两级，并不是理论上最优的，把所有distance当作一个大空间去编码才可能得到最优结果，不过还是那句话，工程实现的限制，在压缩软件实现上，我们不能用压缩率作为衡量一个算法优劣的唯一指标，其实耗费的时间和空间同样是指标，所以需要看综合指标。很多其他软件也一样，扩展性、时间空间复杂度、稳定性、移植性、维护的方便性等等是工程上很重要的东西。我没有看过RAR是如何压缩的，有可能是在类似的地方进行了改进，如果如此，那也是站在巨人的肩膀上，而且硬件条件不同，进行一些改进也并不奇怪。</p><p>具体来说，Phil Katz把distance划分为30个区间，如下图：</p><p><img src="https://www.cmdbyte.com/2021/060320202197696.png"></p><p>这个图是我从David Salomon的《Data Compression The Complete Reference》这本书（第四版）中拷贝出来的，下面的有些图也是，如果需要对数据压缩进行全面的了解，这本书几乎是最全的了，强烈推荐。</p><p>当然，你要问为什么是30个区间，我也没分析过，也许是复杂度和压缩率经过试验之后的一种折中吧。</p><p>其中，左边的Code表示区间的编号，是0-29，共30个区间，这只是个编号，没有特别的含义，但Huffman就是对0-29这30个Code进行编码的，得到区间的码字；</p><p>bits表示distance的码字需要在Code的码字基础上扩展几位，比如0就表示不扩展，最大的13表示要扩展13位，因此，最大的区间包含的distance数量为8192个。</p><p>Distance一列则表示这个区间涵盖的distance范围。</p><p>理解了码树如何有效记录，以及如何缩小码树的过程，我觉得就理解了ZIP的精髓。</p><h2 id="6、ZIP中literal和length的压缩方式"><a href="#6、ZIP中literal和length的压缩方式" class="headerlink" title="6、ZIP中literal和length的压缩方式"></a>6、ZIP中literal和length的压缩方式</h2><p>说完了distance，LZ编码结果还有两类：literal和length。这两类也利用了类似于distance的方式进行压缩。</p><p>前面分析过，literal表示未匹配的字符，我们前面之所以拿汉字来举例，完全是为了便于理解，ZIP之所以是通用压缩，它实际上是针对字节作为基本字符来编码的，所以一个literal至多有256种可能。</p><p>length表示重复字符串长度，length&#x3D;1当然不会出现，因为一个字符不值得用distance+length去记录，重复字符串当然越长越好，Phil Katz（下面还是简称PK了，拷贝太麻烦）认为，length&#x3D;2也不值得用这种方式记录，还是太短了，所以PK把length最小值认为是3，必须3个以上字符的字符串出现重复才用distance+length记录。那么，最大的length是多少呢？理论上当然可以很长很长，比如一个文件就是连续的0，这个重复字符串长度其实接近于这个文件的实际长度。但是PK把length的范围做了限制，限定length的个数跟literal一样，也只有256个，因为PK认为，一个重复字符串达到了256个已经很长了，概率非常小；另外，其实哪怕超过了256，我还是认为是一段256再加上另外一段，增加一个distance+length就行了嘛，并不影响结果。而且这样做，我想同样也考虑了硬件条件吧。</p><p>初看有点奇怪的在于，将literal和length二者合二为一，什么意思呢？就是对这两种整数（literal本质上是一个字节）共用一个Huffman码表，一会儿解释为什么。PK对Huffman的理解我觉得达到了炉火纯青的地步，前面已经看到，后面还会看到。他认为Huffman编码的输入反正说白了就是一个集合的元素就行，无论这个元素是啥，所以多个集合看做一个集合当作Huffman编码的输入没啥问题。literal用整数0-255表示，256是一个结束标志，解码以后结果是256表示解码结束；从257开始表示length，所以257这个数表示length&#x3D;3，258这个数表示length&#x3D;4等等，但PK也不是一直这么一一对应，和distance一样，也是把length（总共256个值）划分为29个区间，其结果如下图：</p><p><img src="https://www.cmdbyte.com/2021/060343553448800.png"></p><p>其中的含义和distance类似，不再赘述，所以literal&#x2F;length这个Huffman编码的输入元素一共285个，其中256表示解码结束标志。为什么要把二者合二为一呢？因为当解码器接收到一个比特流的时候，首先可以按照literal&#x2F;length这个码表来解码，如果解出来是0-255，就表示未匹配字符，如果是256，那自然就结束，如果是257-285之间，则表示length，把后面扩展比特加上形成length后，后面的比特流肯定就表示distance，因此，实际上通过一个Huffman码表，对各类情况进行了统一，而不是通过加一个什么标志来区分到底是literal还是重复字符串。</p><p>好了，理解了上面的过程，就理解了ZIP压缩的第二步，第一步是LZ编码，第二步是对LZ编码后结果（literal、distance、length）进行的再编码，因为literal&#x2F;length是一个码表，我称其为Huffman码表1，distance那个码表称为Huffman码表2。前面我们已经分析了，Huffman码树用一个码字长度序列表示，称为CL（Code Length），记录两个码表的码字长度序列分别记为CL1、CL2。码树记录下来，对literal&#x2F;length的编码比特流称为LIT比特流；对distance的编码比特流称为DIST比特流。</p><p>按照上面的方法，LZ的编码结果就变成四块：CL1、CL2、LIT比特流、DIST比特流。CL1、CL2是码字长度的序列，这个序列说白了就是一堆正整数，因此，PK继续深挖，认为这个序列还应该继续压缩，也就是说，对码表进行压缩。</p><h2 id="7、ZIP中对CL进行再次压缩的方法"><a href="#7、ZIP中对CL进行再次压缩的方法" class="headerlink" title="7、ZIP中对CL进行再次压缩的方法"></a>7、ZIP中对CL进行再次压缩的方法</h2><p>这里仍然沿用Huffman的想法，因为CL也是一堆整数，那么当然可以再次应用Huffman编码。不过在这之前，PK对CL序列进行了一点处理。这个处理也是很精巧的。</p><p>CL序列表示一系列整数对应的码字长度，对于literal&#x2F;length来说，总共有0-285这么多符号，所以这个序列长度为286，每个符号都有一个码字长度，当然，这里面可能会出现大段连续的0，因为某些字符或长度不存在，尤其是对英文文本编码的时候，非ASCII字符就根本不会出现，length较大的值出现概率也很小，所以出现大段的0是很正常的；对于distance也类似，也可能出现大段的0。PK于是先进行了一下游程编码。在说什么是游程编码之前，我们谈谈PK对CL序列的认识。</p><p>literal&#x2F;length的编码符号总共286个（回忆：256个Literal+1个结束标志+29个length区间），distance的编码符号总共30个（回忆：30个区间），所以这颗码树不会特别深，Huffman编码后的码字长度不会特别长，PK认为最长不会超过15，也就是树的深度不会超过15，这个是否是理论证明我还没有分析，有兴趣的同学可以分析一下。因此，CL1和CL2这两个序列的任意整数值的范围是0-15。0表示某个整数没有出现（比如literal&#x3D;0x12, length Code&#x3D;8, distance Code&#x3D;15等等）。</p><p>什么叫游程呢？就是一段完全相同的数的序列。什么叫游程编码呢？说起来原理更简单，就是对一段连续相同的数，记录这个数一次，紧接着记录出现了多少个即可。David的书中举了这个例子，比如CL序列如下：</p><p>4, 4, 4, 4, 4, 3, 3, 3, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 0, 0, 0, 0, 0, 0, 2, 2, 2, 2<br>那么，游程编码的结果为：</p><p>4, 16, 01（二进制）, 3, 3, 3, 6, 16, 11（二进制）, 16, 00（二进制）, 17,011（二进制）, 2, 16, 00（二进制）<br>这是什么意思呢？因为CL的范围是0-15，PK认为重复出现2次太短就不用游程编码了，所以游程长度从3开始。用16这个特殊的数表示重复出现3、4、5、6个这样一个游程，分别后面跟着00、01、10、11表示（实际存储的时候需要低比特优先存储，需要把比特倒序来存，博文的一些例子有时候会忽略这点，实际写程序的时候一定要注意，否则会得到错误结果）。于是4,4,4,4,4,这段游程记录为4,16,01，也就是说，4这个数，后面还会连续出现了4次。6,16,11,16,00表示6后面还连续跟着6个6，再跟着3个6；因为连续的0出现的可能很多，所以用17、18这两个特殊的数专门表示0游程，17后面跟着3个比特分别记录长度为3-10（总共8种可能）的游程；18后面跟着7个比特表示11-138（总共128种可能）的游程。17,011（二进制）表示连续出现6个0；18,0111110（二进制）表示连续出现62个0。总之记住，0-15是CL可能出现的值，16表示除了0以外的其它游程；17、18表示0游程。因为二进制实际上也是个整数，所以上面的序列用整数表示为：</p><p>4, 16, 1, 3, 3, 3, 6, 16, 3, 16, 0, 17, 3, 2, 16, 0</p><p>我们又看到了一串整数，这串整数的值的范围是0-18。这个序列称为SQ（Sequence的意思）。因为有两个CL1、CL2，所以对应的有两个SQ1、SQ2。</p><p>针对SQ1、SQ2，PK用了第三个Huffman码表来对这两个序列进行编码。通过统计各个整数（0-18范围内）的出现次数，按照相同的思路，对SQ1和SQ2进行了Huffman编码，得到的码流记为SQ1 bits和SQ2 bits。同时，这里又需要记录第三个码表，称为Huffman码表3。同理，这个码表也用相同的方法记录，也等效为一个码长序列，称为CCL，因为至多有0-18个，PK认为树的深度至多为7，于是CCL的范围是0-7。</p><p>当得到了CCL序列后，PK决定不再折腾，对这个序列用普通的3比特定长编码记录下来即可，即000代表0,111代表7。但实际上还有一点小折腾，就是最后这个序列如果全部记录，那就需要19*3&#x3D;57个比特，PK认为CL序列里面CL范围为0-15，特殊的几个值是16、17、18，如果把CCL序列位置置换一下，把16、17、18这些放前面，那么这个CCL序列就很可能最后面跟着一串0（因为CL&#x3D;14,15这些很可能没有），所以最后还引入了一个置换，其示意图如下，分别表示置换前的CCL序列和置换后的CCL。可以看出，16、17、18对应的CCL被放到了前面，这样如果尾部出现了一些0，就只需要记录CCL长度即可，后面的0不记录。可以继续节省一些比特，不过这个例子尾部置换后只有1个0：</p><p><img src="https://www.cmdbyte.com/2021/061527354536186.png"></p><p>不过粗看起来，这个置换效果并不好，我一开始接触这个置换的时候，我觉得应该按照16、17、18、0、1、2、3、。。。这样的顺序来存储，如果按照我理解的，那么置换后的结果如下：</p><p>2、4、0、4、5、5、1、5、0、6、0、0、0、0、0、0、0、0、0</p><p>这样后面的一大串0直接截断，比PK的方法更短。但PK却按照上面的顺序。我总是认为，我觉得牛人可能出错了的时候，往往是我自己错了，所以我又仔细想了一下，上面的顺序特点比较明显，直观上看，PK认为CL为0和中间的值出现得比较多（放在了前面），但CL比较小的和比较大的出现得比较少（1、15、2、14这些放在了后面，你看，后面交叉着放），在文件比较小的时候，这种方法效果不算好，上面就是一个典型的例子，但文件比较大了以后，CL1、CL2码树比较大，码字长度普遍比较长，大部分很可能接近于中间值，那么这个时候PK的方法可能就体现出优势了。不得不说，对一个算法或者数据结构的优化程度，简直完全取决于程序员对那个东西细节的理解的深度。当我仔细研究了ZIP压缩算法的过程之后，我对PK这种深夜埋头冥思苦想的大牛佩服得五体投地。</p><p>到此为止，ZIP压缩算法的结果已经完毕。这个算法命名为Deflate算法。总结一下其编码流程为：</p><p><img src="https://www.cmdbyte.com/2021/060435217505419.png"></p><h2 id="8、Deflate压缩数据格式"><a href="#8、Deflate压缩数据格式" class="headerlink" title="8、Deflate压缩数据格式"></a>8、Deflate压缩数据格式</h2><p>ZIP的格式实际上就是Deflate压缩码流外面套了一层文件相关的信息，这里先介绍Deflate压缩码流格式。其格式为：</p><p><img src="https://www.cmdbyte.com/2021/060437425949657.png"></p><p>Header：3个比特，第一个比特如果是1，表示此部分为最后一个压缩数据块；否则表示这是.ZIP文件的某个中间压缩数据块，但后面还有其他数据块。这是ZIP中使用分块压缩的标志之一；第2、3比特表示3个选择：压缩数据中没有使用Huffman、使用静态Huffman、使用动态Huffman，这是对LZ77编码后的literal&#x2F;length&#x2F;distance进行进一步编码的标志。我们前面分析的都是动态Huffman，其实Deflate也支持静态Huffman编码，静态Huffman编码原理更为简单，无需记录码表（因为PK自己定义了一个固定的码表），但压缩率不高，所以大多数情况下都是动态Huffman。</p><p>HLIT：5比特，记录literal&#x2F;length码树中码长序列（CL1）个数的一个变量。后面CL1个数等于HLIT+257（因为至少有0-255总共256个literal，还有一个256表示解码结束，但length的个数不定）。</p><p>HDIST：5比特，记录distance码树中码长序列（CL2）个数的一个变量。后面CL2个数等于HDIST+1。哪怕没有1个重复字符串，distance都为0也是一个CL。</p><p>HCLEN：4比特，记录Huffman码表3中码长序列（CCL）个数的一个变量。后面CCL个数等于HCLEN+4。PK认为CCL个数不会低于4个，即使对于整个文件只有1个字符的情况。</p><p>接下来是3比特编码的CCL，一共HCLEN+4个，用以构造Huffman码表3；</p><p>接下来是对CL1（码长）序列经过游程编码（SQ1：缩短的整数序列）后，并对SQ1继续用Huffman编码后的比特流。包含HLIT+257个CL1，其解码码表为Huffman码表3，用以构造Huffman码表1；</p><p>接下来是对CL2（码长）序列经过游程编码（SQ2：缩短的整数序列）后，并对SQ2继续用Huffman编码后的比特流。包含HDIST+1个CL2，其解码码表为Huffman码表3，用于构造Huffman码表2；</p><p>总之，上面的数据都是为了构造LZ解码需要的2个Huffman码表。</p><p>接下来才是经过Huffman编码的压缩数据，解码码表为Huffman码表1和码表2。<br>最后是数据块结束标志，即literal&#x2F;length这个码表输入符号位256的编码比特。<br>对倒数第1、2内容块进行解码时，首先利用Huffman码表1进行解码，如果解码所得整数位于0-255之间，表示literal未匹配字符，接下来仍然利用Huffman码表1解码；如果位于257-285之间，表示length匹配长度，之后需要利用Huffman码表2进行解码得到distance偏移距离；如果等于256，表示数据块解码结束。</p><h2 id="9、ZIP文件格式解析"><a href="#9、ZIP文件格式解析" class="headerlink" title="9、ZIP文件格式解析"></a>9、ZIP文件格式解析</h2><p> 上面各节对ZIP的原理进行了分析，这一节我们来看一个实际的例子，为了更好地描述，我们尽量把这个例子举得简单一些。下面是我随便从一本书拷贝出来的一段较短的待压缩的英文文本数据：</p><p>As mentioned above,there are many kinds of wireless systems other than cellular.</p><p>这段英文文本长度为80字节。经过ZIP压缩后，其内容如下：</p><p><img src="https://www.cmdbyte.com/2021/061434435788044.png"></p><p>可以看到，第1、2字节就是PK。看着怎么比原文还长，这怎么叫压缩？实际上，这里面大部分内容是ZIP的文件标记开销，真正压缩的内容（也就是我们前面提到的Deflate数据，划线部分都是ZIP文件开销）其实肯定要比原文短（否则ZIP不会启用压缩），我们这个例子是个短文本，但对于更长的文本而言，那ZIP文件总体长度肯定是要短于原始文本的。上面的这个ZIP文件，可以看到好几个以PK开头的区域，也就是不同颜色的划线区域，这些其实都是ZIP文件本身的开销。</p><p>所以，我们首先来看一看ZIP的格式，其格式定义为：</p><p>[local file header 1]<br>[file data 1]<br>[data descriptor 1]<br>……….<br>[local file header n]<br>[file data n]<br>[data descriptor n]<br>[archive decryption header]<br>[archive extra data record]<br>[central directory]<br>[zip64 end of central directory record]<br>[zip64 end of central directory locator]<br>[end of central directory record]<br>local file header+file data+data descriptor这是一段ZIP压缩数据，在一个ZIP文件里，至少有一段，至多那就不好说了，假如你要压缩的文件一共有10个，那这个地方至少会有10段，ZIP对每个文件进行了独立压缩，RAR在此进行了改进，将多个文件联合起来进行压缩，提高了压缩率。local file header的格式如下：</p><p><img src="https://www.cmdbyte.com/2021/061359166257241.png"></p><p>可见，起始的4个字节就是0x50（P）、0x4B（K）、0x03、0x04，因为是低字节优先，所以Signature&#x3D;0x03044B50.接下来的内容按照上面的格式解析，十分简单，这个区域在上面ZIP数据的那个图里面是红色划线区域，之后则是压缩后的Deflate数据。在文件的尾部，还有ZIP尾部数据，上面这个例子包含了central directory和end of central directory record，一般这两部分也是必须的。central directory以0x50、0x4B、0x01、0x02开头；end of central directory record以0x50、0x4B、0x05、0x06开头，其含义比较简单，分别对应于上面ZIP数据那个图的蓝色和绿色部分，下面是两者的格式：</p><p><img src="https://www.cmdbyte.com/2021/061423162666357.png"></p><p>end of central directory record格式：</p><p><img src="https://www.cmdbyte.com/2021/061423440169079.png"></p><p>这几张图是我从网上找的，写得比较清晰。对于其中的含义，解释起来也比较简单，我分析的结果如下：注意ZIP采用的低字节优先，在一个字节里面低位优先，需要反过来看。</p><p>Local File Header: (38B,304b)<br>00001010110100101100000000100000 (signature)<br>0000000000010100 (version:20)<br>0000000000000000 (generalBitFlag)<br>0000000000001000 (compressionMethod:8)<br>0100110110001110 (lastModTime:19854)<br>0100010100100101 (lastModDate:17701)<br>01010100101011010100001100111100 (CRC32)<br>00000000000000000000000001001000 (compressedSize:72)<br>00000000000000000000000001010000 (uncompressedSize:80)<br>0000000000001000 (filenameLength:8)<br>0000000000000000 (extraFieldLength:0)<br>0010101010100110110011100010111001110100001011100001111000101110 (fileName:Test.txt)<br> (extraField)</p><p>Central File Header: (54B,432b)<br>00001010110100101000000001000000 (signature)<br>0000000000010100 (versionMadeBy:20)<br>0000000000010100 (versionNeeded:20)<br>0000000000000000 (generalBitFlag)<br>0000000000001000 (compressionMethod:8)<br>0100110110001110 (lastModTime:19854)<br>0100010100100101 (lastModDate:17701)<br>01010100101011010100001100111100 (CRC32)<br>00000000000000000000000001001000 (compressedSize:72)<br>00000000000000000000000001010000 (uncompressedSize:80)<br>0000000000001000 (filenameLength:8)<br>0000000000000000 (extraFieldLength:0)<br>0000000000000000 (fileCommenLength:0)<br>0000000000000000 (diskNumberStart)<br>0000000000000001 (internalFileAttr)<br>10000001100000000000000000100000 (externalFileAttr)<br>00000000000000000000000000000000 (relativeOffsetLocalHeader)<br>0010101010100110110011100010111001110100001011100001111000101110 (fileName:Test.txt)<br> (extraField)<br> (fileComment)</p><p>end of Central Directory Record: (22B,176b)<br>00001010110100101010000001100000 (signature)<br>0000000000000000 (numberOfThisDisk:0)<br>0000000000000000 (numberDiskCentralDirectory:0)<br>0000000000000001 (EntriesCentralDirectDisk:1)<br>0000000000000001 (EntriesCentralDirect:1)<br>00000000000000000000000000110110 (sizeCentralDirectory:54)<br>00000000000000000000000001101110 (offsetStartCentralDirectory:110)<br>0000000000000000 (fileCommentLength:0)<br> (fileComment)</p><p>Local File Header Length:304<br>Central File Header Length:432<br>End Central Directory Record Length:176</p><p>可见，开销总的长度为38+54+22&#x3D;114字节，整个文件长度为186字节，因此Deflate压缩数据长度为72字节（576比特）。尽管这里看起来只是从80字节压缩到72字节，那是因为这是一段短文本，重复字符串出现较少，但如果文本较长，那压缩率就会增加，这里只是举个例子。</p><p>下面对其中的关键部分，也就是Deflate压缩数据进行解析。</p><h2 id="10、Deflate解码过程实例分析"><a href="#10、Deflate解码过程实例分析" class="headerlink" title="10、Deflate解码过程实例分析"></a>10、Deflate解码过程实例分析</h2><p>我们按照ZIP格式把Deflate压缩数据（72字节）提取出来，如下（每行8字节）：</p><p>1010100001010011100010111011000000000001000001000011000010100010<br>1000101110101010011110110000000001100011101110000011100010100101<br>0101001111001100000010001101001010010010000101101010101100001101<br>1011110100011111100011101111111001110010011101110110011100010101<br>0010110100010100101100110001100100000100110111101101111000011101<br>0010001001100110111001000010011001101010101000110110000001110101<br>0100011010010011100010110111001000111101101001011100101010010111<br>0111000011111000011110000011010111001011011111111100100010001001<br>1010001100001110000010101010111101101010100101111101011111100000</p><p>Deflate格式除了上面的介绍，也可以参考RFC1951，解析如下：</p><p>Header:101, 第一个比特是1，表示此部分为最后一个压缩数据块；后面的两个比特01表示采用动态哈夫曼、静态哈夫曼、或者没有编码的标志，01表示采用动态Huffman；在RFC1951里面是这么说明的：</p><p>00 - no compression</p><p>01 - compressed with fixed Huffman codes</p><p>10 - compressed with dynamic Huffman codes</p><p>11 - reserved (error)</p><p>注意，这里需要按照低比特在先的方式去看，否则会误以为是静态Huffman。</p><p>接下来：<br>HLIT:01000,记录literal&#x2F;length码树中码长序列个数的一个变量，表示HLIT&#x3D;2（低位在前），说明后面存在HLIT + 257&#x3D;259个CL1，CL1即0-258被编码后的长度，其中0-255表示Literal，256表示无效符号，257、258分别表示Length&#x3D;3、4（length从3开始）。因此，这里实际上只出现了两种重复字符串的长度，即3和4。回顾这个图可以更清楚：</p><p><img src="https://www.cmdbyte.com/2021/061456224852421.png"></p><p>继续：<br>HDIST:01010,记录distance码树中码长序列个数的一个变量，表示HDIST&#x3D;10，说明后面存在HDIST+1&#x3D;11个CL2，CL2即Distance Code&#x3D;0-10被编码的长度。</p><p>继续：</p><p>HCLEN:0111,记录Huffman码树3中码长序列个数的一个变量，表示HCLEN&#x3D;14（1110二进制），即说明紧接着跟着HCLEN+4&#x3D;18个CCL，前面已经分析过，CCL记录了一个Huffman码表，这个码表可以用一个码长序列表示，根据这个码长序列可以得到码表。于是接下来我们把后面的18*3&#x3D;54个比特拷贝出来，上面的码流目前解析为下面的结果：</p><p>101(Header) 01000(HLIT) 01010(HDIST) 0111(HCLEN)<br>000 101 110 110 000 000 000 010 000 010 000 110 000 101 000 101 000 101 (CCL)<br>110101010011110110000000001100011101110000011100010100101<br>0101001111001100000010001101001010010010000101101010101100001101<br>1011110100011111100011101111111001110010011101110110011100010101<br>0010110100010100101100110001100100000100110111101101111000011101<br>0010001001100110111001000010011001101010101000110110000001110101<br>0100011010010011100010110111001000111101101001011100101010010111<br>0111000011111000011110000011010111001011011111111100100010001001<br>1010001100001110000010101010111101101010100101111101011111100000</p><p>标准的CCL长度为19（回忆一下：CCL范围为0-18，按照整数大小排序记录各自的码字长度），因此最后一个补0。得到序列：</p><p>000 101 110 110 000 000 000 010 000 010 000 110 000 101 000 101 000 101 000</p><p>其长度分别为（低位在前）：<br>0、5、3、3、0、0、0、2、0、2、0、3、0、5、0、5、0、5、0<br>前面已经分析过，这个CCL序列实际上是经过一次置换操作得到的，需要进行相反的置换，置换后为：</p><p>3、5、5、5、3、2、2、0、0、0、0、0、0、0、0、0、0、5、3<br>这个就是对应于0-18的码字长度序列。<br>根据Deflate树的构造方式，得到下面的码表（Huffman码表3）：</p><p>00   &lt;–&gt;  5<br>01   &lt;–&gt;  6<br>100   &lt;–&gt; 0<br>101   &lt;–&gt; 4<br>110   &lt;–&gt; 18<br>11100  &lt;–&gt;1<br>11101  &lt;–&gt;2<br>11110  &lt;–&gt;3<br>11111  &lt;–&gt;17</p><p>接下来就是CL1序列，按照前面的指示，一共有259个，分别对应于literal&#x2F;length：0-258对应的码字长度序列，我们队跟着CCL后面的比特按照上面获得的码表进行逐步解码，在解码之前，实际上并不知道CL1的比特流长度有多少，需要根据259这个数字来判定，解完了259个整数，表明解析CL1完毕：</p><p>101(Header) 01000(HLIT) 01010(HDIST) 0111(HCLEN)<br>000 101 110 110 000 000 000 010 000 010 000 110 000 101 000 101 000 101 (CCL)</p><p>110（18）1010100（7比特，记录连续的11-138个0，此处一共0010101b&#x3D;21，即记录21+11&#x3D;32个0）</p><p>11110（3）110（18）0000000（7比特，记录连续的11-138个0，此处为全0，即记录0+11&#x3D;11个0）</p><p>01（6）100（0）01（6）110（18）1110000（7比特，记录连续的11-138个0，此处为111b&#x3D;7，即记录7+11&#x3D;18个0）</p><p>01（6）110（18）0010100（7比特，记录连续的11-138个0，此处为10100b&#x3D;20，即记录20+11&#x3D;31个0）</p><p>101（4）01（6）01（6）00（5）11110（3）01（6）100（0）00（5）00（5）100（0）01（6）101（4）</p><p>00（5）101（4）00（5）100（0）100（0）00（5）101（4）101（4）01（6）01（6）01（6）100（0）</p><p>00（5）110（18）1101111（7比特，记录连续的11-138个0，此处为1111011b&#x3D;123，即记录123+11&#x3D;134个0）</p><p>统计一下，上面已经解了32+11+18+31+134+30&#x3D;256个数了，因为总共259个，还差三个：</p><p>01（6）00（5）01（6）</p><p>好了，CL1比特流解析完毕了，得到的CL1码长序列为：</p><p>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 <strong>3</strong> 0 0 0 0 0 0 0<br>0 0 0 0 6 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 6 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 4 6 6 5 3 6 0 5 5 0 6 4 5 4 5 0 0 5 4 4 6 6 6<br>0 5 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 <strong>6 5 6</strong></p><p>总共259个，每行40个。根据这个序列，同样按照Deflate树构造方法，得到literal&#x2F;length码表（Huffman码表1）为：</p><p>000   –&gt; (System.Char)（看前面的CL1序列，空格对应的ASCII为0x20&#x3D;32，码字长度3，即上面序列中第一个3）<br>001   –&gt;e(System.Char)<br>0100  –&gt;a(System.Char)<br>0101  –&gt;l(System.Char)<br>0110  –&gt;n(System.Char)<br>0111  –&gt;s(System.Char)<br>1000  –&gt;t(System.Char)<br>10010  –&gt;d(System.Char)<br>10011  –&gt;h(System.Char)<br>10100  –&gt;i(System.Char)<br>10101  –&gt;m(System.Char)<br>10110  –&gt;o(System.Char)<br>10111  –&gt;r(System.Char)<br>11000  –&gt;y(System.Char)<br><strong>11001  –&gt;3(System.Int32)（看前面的CL1序列，对应257，码字长度5）</strong><br>110100 –&gt;,(System.Char)<br>110101 –&gt;.(System.Char)<br>110110 –&gt;A(System.Char)<br>110111 –&gt;b(System.Char)<br>111000 –&gt;c(System.Char)<br>111001 –&gt;f(System.Char)<br>111010 –&gt;k(System.Char)<br>111011 –&gt;u(System.Char)<br>111100 –&gt;v(System.Char)<br>111101 –&gt;w(System.Char)<br><strong>111110 –&gt;-1(System.Int32)（看前面的CL1序列，对应256，码字长度6）</strong><br><strong>111111 –&gt;4(System.Int32)（看前面的CL1序列，对应258，码字长度6）</strong></p><p>可以看出，码表里存在两个重复字符串长度3和4，当解码结果为-1（上面进行了处理，即256），或者说遇到111110的时候，表示Deflate码流结束。</p><p>按照同样的道理，对CL2序列进行解析，前面已经知道HDIST&#x3D;10，即有11个CL2整数序列：</p><p>11111（17）000（3比特，记录连续的3-10个0，此处为0，即记录3个0）</p><p>11101（2）11111（17）100（3比特，记录连续的3-10个0，此处为001b&#x3D;1，即记录4个0）</p><p>11100（1）100（0）11101（2）</p><p>已经结束，总共11个。</p><p>于是CL2序列为：</p><p>0 0 0 2 0 0 0 0 1 0 2</p><p>分别记录的是distance码为0-10的码字长度，根据下面的对应关系，需要进行扩展：</p><p><img src="https://www.cmdbyte.com/2021/061458263447816.png"></p><p>比如，第1个码长2记录的是Code&#x3D;3的长度，即Distance&#x3D;4对应的码字为：</p><p>10   –&gt;4(System.Int32)</p><p>第1个码长1记录的是Code&#x3D;8的长度（码字为0，扩展三位000-111），即Distance&#x3D;17-24对应的码字为（注意，低比特优先）：</p><p>0 000  –&gt;17(System.Int32)<br>0 100  –&gt;18(System.Int32)<br>0 010  –&gt;19(System.Int32)<br>0 110  –&gt;20(System.Int32)<br>0 001  –&gt;21(System.Int32)<br>0 101  –&gt;22(System.Int32)<br>0 011  –&gt;23(System.Int32)<br>0 111  –&gt;24(System.Int32)</p><p>注意，扩展的时候还是低比特优先。</p><p>最后1个码长2记录的是Code&#x3D;10的长度（其实是码字：11，扩展四位0000-1111），即Distance&#x3D;33-48对应的码字为：</p><p>11 0000 –&gt;33(System.Int32)<br>11 1000 –&gt;34(System.Int32)<br>11 0100 –&gt;35(System.Int32)<br>11 1100 –&gt;36(System.Int32)<br>11 0010 –&gt;37(System.Int32)<br>11 1010 –&gt;38(System.Int32)<br>11 0110 –&gt;39(System.Int32)<br>11 1110 –&gt;40(System.Int32)<br>11 0001 –&gt;41(System.Int32)<br>11 1001 –&gt;42(System.Int32)<br>11 0101 –&gt;43(System.Int32)<br>11 1101 –&gt;44(System.Int32)<br>11 0011 –&gt;45(System.Int32)<br>11 1011 –&gt;46(System.Int32)<br>11 0111 –&gt;47(System.Int32)<br>11 1111 –&gt;48(System.Int32)</p><p>至此为止，Huffman码表1、Huffman码表2已经还原出来，接下来是对LZ压缩所得到的literal、distance、length进行解码，目前剩余的比特流如下，先按照Huffman码表1解码，如果解码结果是长度（&gt;256），则接下来按照Huffman码表2解码，逐步解码即可：</p><p>[As ]：110110（A）0111（s）000（空格）</p><p>[mentioned ]：10101（m）001（e）0110（n）1000（t）10100（i）10110（o）0110（n）001（e）10010（d）000（空格）</p><p>[above,]：0100（a）110111（b）10110（o）111100（v）001（e）110100（,）</p><p>[there ]：1000（t）10011（h）001（e）10111（r）001（e）000（空格）</p><p>[are ]：0100（a）11001（长度3，表示下一个需要用Huffman解码）10（Distance&#x3D;4，即重复字符串为re空格）</p><p>[many ]：10101（m）0100（a）0110（n）11000（y）000（空格）</p><p>[kinds ]：111010（k）10100（i）0110（n）10010（d）0111（s）000（空格）</p><p>[of ]：10110（o）111001（f）000（空格）</p><p>[wireless ]：111101（w）10100（i）10111（r）001（e）0101（l）001（e）0111（s）0111（s）000（空格）</p><p>[systems o]：0111（s）11000（y）0111（s）1000（t）001（e）10101（m）11001（长度指示&#x3D;3，接下来根据distance解码）0110（Distance&#x3D;20,即重复字符串为s o）</p><p>[ther ]：111111（长度指示&#x3D;4，接下来根据distance解码）111001（Distance&#x3D;42,即重复字符串为ther）000（空格）</p><p>[than ]：1000（t）10011（h）0100（a）0110（n）000（空格）</p><p>[cellular.]：111000（c）001（e）0101（l）0101（l）111011（u）0101（l）0100（a）10111（r）110101（.）</p><p>[256，结束标志]111110（结束标志）0000（字节补齐的0）</p><p>于是解压缩结果为：</p><p>As mentioned above,there are many kinds of wireless systems other than cellular.</p><p>再来回顾我们的解码过程：</p><p>译码过程：<br>1、根据HCLEN得到截尾信息，并参照固定置换表，根据CCL比特流得到CCL整数序列；<br>2、根据CCL整数序列构造出等价于CCL的二级Huffman码表3；<br>3、根据二级Huffman码表3对CL1、CL2比特流进行解码，得到SQ1整数序列,SQ2整数序列；<br>4、根据SQ1整数序列,SQ2整数序列,利用游程编码规则得到等价的CL1整数序列、CL2整数序列；<br>5、根据CL1整数序列、CL2整数序列分别构造两个一级Huffman码表：literal&#x2F;length码表、distance码表；<br>6、根据两个一级Huffman码表对后面的LZ压缩数据进行解码得到literal&#x2F;length&#x2F;distance流；<br>7、根据literal&#x2F;length&#x2F;distance流按照LZ规则进行解码。</p><p>Deflate码流长度总共为72字节&#x3D;576比特，其中：</p><p>3比特Header；</p><p>5比特HLIT；</p><p>5比特HDIST；</p><p>4比特HCLEN；</p><p>54比特CCL序列码流；</p><p>133比特CL1序列码流；</p><p>34比特CL2序列码流；</p><p>338比特LZ压缩后的literal&#x2F;length&#x2F;distance码流。</p><h2 id="11、ZIP的其它说明"><a href="#11、ZIP的其它说明" class="headerlink" title="11、ZIP的其它说明"></a>11、ZIP的其它说明</h2><p>上面各个环节已经详细分析了ZIP压缩的过程以及解码流程，通过对一个实例的解压缩过程分析，可以彻底地掌握ZIP压缩和解压缩的原理和过程。还有一些情况需要说明：</p><p>（1）上面的算法复杂度主要在于压缩一端，因为需要统计literal&#x2F;length&#x2F;distance，创建动态Huffman码表，相反解压只需要还原码表后，逐比特解析即可，这也是压缩软件的一个典型特点，解压速度远快于压缩速度。</p><p>（2）上面我们分析了动态Huffman，对于LZ压缩后的literal&#x2F;length&#x2F;distance，也可以采用静态Huffman编码，这主要取决于ZIP在压缩中看哪种方式更节省空间，静态Huffman编码不需要记录码表，因为这个码表是固定的，在RFC1951里面也有说明。对于literal&#x2F;length码表来说，需要对0-285进行编码，其码表为：</p><p><img src="https://www.cmdbyte.com/2021/061716127827338.png"></p><p>对于Distance来说，需要对Code&#x3D;0-29的数进行编码，则直接采用5比特表示。Distance和动态Huffman一样，在此基础上进行扩展。</p><p>（3）ZIP中使用的LZ77算法是一种改进的LZ77。主要区别有两点：</p><p>1）标准LZ77在找到重复字符串时输出三元组(length, distance, 下一个未匹配的字符)（有兴趣可以关注LZ77那篇论文）；Deflate在找到重复字符串时仅输出双元组(length, distance)。<br>2）标准LZ77使用”贪婪“的方式解析，寻找的都是最长匹配字符串。Deflate中不完全如此。David Salomon的书里给了一个例子：</p><p><img src="https://www.cmdbyte.com/2021/061723147822682.png"></p><p>对于上面这个例子，标准LZ77在滑动窗口中查找最长匹配字符串，找到的是”the”与前面的there的前三个字符匹配，这种贪婪解析方式逻辑简单，但编码效率不一定最高。Deflate则不急于输出，跳过t继续往后查看，发现”th ne”这5个字符存在重复字符串，因此，Deflate算法会选择将t作为未匹配字符输出，而对后面的匹配字符串用(length, distance)编码输出。显然，这样就提高了压缩效率，因为标准的LZ77找到的重复字符串长度为3，而Deflate找到的是5。换句话说，Deflate算法并不是简单的寻找最长匹配后输出，而是会权衡几种可行的编码方式，用其中最高效的方式输出。</p><h2 id="12、总结"><a href="#12、总结" class="headerlink" title="12、总结"></a>12、总结</h2><p>本篇博文对ZIP中使用的压缩算法进行了详细分析，从一个简单地例子出发，一步步地分析了PK设计Deflate算法的思路。最后，通过一个实际例子，分析了其解压缩流程。总的来看，ZIP的核心在于如何对LZ压缩后的literal、length、distance进行Huffman编码，以及如何以最小空间记录Huffman码表。整个过程充满了对数据结构尤其是树的深入优化利用。按照上面的分析，如果要对ZIP进行进一步改进，可以考虑的地方也有不少，典型的有：</p><p>（1）扩大LZ编码的滑动窗口的大小；</p><p>（2）将Huffman编码改进为算术编码等压缩率更高的方法，毕竟，Huffman的码字长度必须为整数，这就从理论上限制了它的压缩率只能接近于理论极限，但难以达到。我记得在JPEG图像编码领域，以前的JPEG采用了DCT变换编码+Huffman的方式，现在JPEG2000将其改为小波变换+算数编码，所以数据压缩也可以尝试类似的思路；</p><p>（3）将多个文件进行合并压缩，ZIP中，不同的文件压缩过程没有关系，独立进行，如果将它们合并起来一起进行压缩，压缩率可以得到进一步提高。</p><p>描述分析有误的地方，敬请指正。针对数据压缩相关的话题，后续会对HBase列压缩等等进行分析，看看ZIP这种文件压缩和HBase这种数据库数据压缩的区别和联系。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>文件上传系统设计概要</title>
    <link href="/2021/09/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%A6%81/"/>
    <url>/2021/09/14/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%A6%81/</url>
    
    <content type="html"><![CDATA[<p>文件上传顾名思义就是将文件从一台机器传到另一台机器中。小文件的传输比较简单，对于大文件的传输有很多有意思的设计，这里围绕其设计思想进行简单介绍。</p><h3 id="文件分块"><a href="#文件分块" class="headerlink" title="文件分块"></a>文件分块</h3><p>文件分块是一个比较常用方式，在发送文件前，将一个大文件分成多个连续的小文件，然后一块一块的发送。当然，对于每一块文件，在发送时还要加入一些额外信息，方便接收端拼接还原文件，这些信息包括：当前文件块数、文件块总数、文件块大小、原文件标识(MD5)等。</p><img src="https://www.cmdbyte.com/2021/640%20(7).webp" alt="文件分块"  /><h3 id="并发上传"><a href="#并发上传" class="headerlink" title="并发上传"></a>并发上传</h3><p>并发上传是在文件分块的基础上进行的，可以提高文件整体的传输效率。不过要根据网络情况决定是否并发上传以及同时进行多少个文件块的上传。在技术上比顺序发送复杂些，因为不同线程传输的速度可能不同，接收端需要做缓存。</p><img src="https://www.cmdbyte.com/2021/640%20(8).webp" alt="并发上传"  /><h3 id="断点续传"><a href="#断点续传" class="headerlink" title="断点续传"></a>断点续传</h3><p>断点续传是为了解决因一些因素导致传输中断后，再次上传必须从0开始传的问题。</p><p>其原理是在文件分块的基础上，服务器记录一下原文件对应的上传进度，每接收到一个块，就更新一下进度。这样，即使网络故障导致上传失败，下次上传时，可以直接从失败的那个块开始上传，而不需要再从第 0 块上传。</p><img src="https://www.cmdbyte.com/2021/640%20(9).webp" alt="断点续传"  /><h3 id="秒传"><a href="#秒传" class="headerlink" title="秒传"></a>秒传</h3><p>提起秒传可能有些陌生，但在使用百度网盘时你可能接触过秒传技术。比如你从网上下载了一个文件（视频或图片），你想把它再放到网盘中，但是在上传时发现明明快一个G的文件竟直接上传成功了，按照你自己的网速可能需要十分钟时间，其实这就是秒传技术的一个应用。</p><p>在上传文件前，客户端首先根据文件内容计算出文件对应的MD5值，相同MD5值的文件必然相同，然后先发送该值到服务器中，服务器在数据库中检索该值是否已经存在，如果存在说明该文件已经上传过（可能是其他人上传的），那么直接提示文件上传成功，如果没上传过就走文件的上传逻辑，所以需要等待文件上传成功，上传成功后还会保存文件的MD5值，这样其他用户上传同样的文件时，也可以使用秒传技术了。</p><blockquote><p>不过要注意，不同内容文件的 MD5 值也可能会相同（碰撞），导致用户下载到不是自己上传的文件，所以检验重复时，还可以补充一些校验，比如针对文件前几位再生成一个 MD5、用其他 Hash 算法再生成一个校验值等。这里所说的MD5默认每个文件的MD5都是唯一的。</p></blockquote><h3 id="异步上传"><a href="#异步上传" class="headerlink" title="异步上传"></a>异步上传</h3><p>除了同步上传外，当我们要上传的文件不在本地而是已经存在对应 url 时，也可以采用 <strong>全异步上传</strong> 的方式，将文件上传变成一个 <strong>任务</strong> 。</p><p>用户输入要上传的文件 url，点击上传后，不需要一直在文件上传页面等着，而是只需要告诉后台 “我要执行文件上传”，并向后台新建一个文件上传任务，就可以快速响应用户了，比如 “文件上传中，请留意通知”。等后台取出并真正完成文件上传的任务后，给用户发送通知就可以了。</p><img src="https://www.cmdbyte.com/2021/640%20(10).webp" alt="异步上传"  />]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP状态码</title>
    <link href="/2021/09/02/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <url>/2021/09/02/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>来自 Go HTTP库：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// HTTP status codes, defined in RFC 2616.</span><br><span class="hljs-keyword">const</span> (<br>   StatusContinue           = <span class="hljs-number">100</span><br>   StatusSwitchingProtocols = <span class="hljs-number">101</span><br>   <br>   StatusOK                   = <span class="hljs-number">200</span><br>   StatusCreated              = <span class="hljs-number">201</span><br>   StatusAccepted             = <span class="hljs-number">202</span><br>   StatusNonAuthoritativeInfo = <span class="hljs-number">203</span><br>   StatusNoContent            = <span class="hljs-number">204</span><br>   StatusResetContent         = <span class="hljs-number">205</span><br>   StatusPartialContent       = <span class="hljs-number">206</span><br><br>   StatusMultipleChoices   = <span class="hljs-number">300</span><br>   StatusMovedPermanently  = <span class="hljs-number">301</span><br>   StatusFound             = <span class="hljs-number">302</span><br>   StatusSeeOther          = <span class="hljs-number">303</span><br>   StatusNotModified       = <span class="hljs-number">304</span><br>   StatusUseProxy          = <span class="hljs-number">305</span><br>   StatusTemporaryRedirect = <span class="hljs-number">307</span><br><br>   StatusBadRequest                   = <span class="hljs-number">400</span><br>   StatusUnauthorized                 = <span class="hljs-number">401</span><br>   StatusPaymentRequired              = <span class="hljs-number">402</span><br>   StatusForbidden                    = <span class="hljs-number">403</span><br>   StatusNotFound                     = <span class="hljs-number">404</span><br>   StatusMethodNotAllowed             = <span class="hljs-number">405</span><br>   StatusNotAcceptable                = <span class="hljs-number">406</span><br>   StatusProxyAuthRequired            = <span class="hljs-number">407</span><br>   StatusRequestTimeout               = <span class="hljs-number">408</span><br>   StatusConflict                     = <span class="hljs-number">409</span><br>   StatusGone                         = <span class="hljs-number">410</span><br>   StatusLengthRequired               = <span class="hljs-number">411</span><br>   StatusPreconditionFailed           = <span class="hljs-number">412</span><br>   StatusRequestEntityTooLarge        = <span class="hljs-number">413</span><br>   StatusRequestURITooLong            = <span class="hljs-number">414</span><br>   StatusUnsupportedMediaType         = <span class="hljs-number">415</span><br>   StatusRequestedRangeNotSatisfiable = <span class="hljs-number">416</span><br>   StatusExpectationFailed            = <span class="hljs-number">417</span><br>   StatusTeapot                       = <span class="hljs-number">418</span><br>    <br>   StatusInternalServerError     = <span class="hljs-number">500</span><br>   StatusNotImplemented          = <span class="hljs-number">501</span><br>   StatusBadGateway              = <span class="hljs-number">502</span><br>   StatusServiceUnavailable      = <span class="hljs-number">503</span><br>   StatusGatewayTimeout          = <span class="hljs-number">504</span><br>   StatusHTTPVersionNotSupported = <span class="hljs-number">505</span><br><br>   <span class="hljs-comment">// New HTTP status codes from RFC 6585. Not exported yet in Go 1.1.</span><br>   <span class="hljs-comment">// See discussion at https://codereview.appspot.com/7678043/</span><br>   statusPreconditionRequired          = <span class="hljs-number">428</span><br>   statusTooManyRequests               = <span class="hljs-number">429</span><br>   statusRequestHeaderFieldsTooLarge   = <span class="hljs-number">431</span><br>   statusNetworkAuthenticationRequired = <span class="hljs-number">511</span><br>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>脑力劳动者如何更好的休息</title>
    <link href="/2021/09/02/%E8%84%91%E5%8A%9B%E5%8A%B3%E5%8A%A8%E8%80%85%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BC%91%E6%81%AF/"/>
    <url>/2021/09/02/%E8%84%91%E5%8A%9B%E5%8A%B3%E5%8A%A8%E8%80%85%E5%A6%82%E4%BD%95%E6%9B%B4%E5%A5%BD%E7%9A%84%E4%BC%91%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<p>你写了一天的文案，主持了一天的会议，当一切都结束了，你叹到：太累了，这一天我要睡个好觉。我们的常识使得我们对疲劳的第一反应就是“去躺躺吧”。但这是一个陷阱。<br>睡眠的确是一种有效的休息方式，但它主要对睡眠不足着或体力劳动者适用。对体力劳动者来说，“疲劳”主要是由体内产生大量酸性物质引起，如果十分疲劳，应采取静的休息方式。通过睡觉，可以把失去的能量补充回来，把堆积的废物排除出去。如果不是很累，也可以在床上先躺一躺，闭目静息，让全身肌肉和神经完全放松后，再起来活动活动。<br><strong>但如果你是坐办公室的，大脑皮层极度兴奋，而身体却处于低兴奋状态，对待这种疲劳，睡眠能起到的作用不大</strong>，（除非你是熬夜加班，连正常睡眠时间都达不到）<strong>因为你需要的不是通过“静止”恢复体能，而是要找个事儿把神经放松下来。</strong>这样你可以理解为什么你周末两天不出门依旧无精打采，而只需下班后游泳半小时就神采奕奕。 </p><p>■<strong>不必停下来，只是换一下</strong> </p><p>既然睡觉不能帮助我们休息大脑，那什么办法才可以？答案是不停止活动，而只是改变活动的内容。大脑皮质的一百多亿神经细胞，功能都不一样，它们以不同的方式排列组合成各不相同的联合功能区，这一区域活动，另一区域就休息。所以，通过改换活动内容，就能使大脑的不同区域得到休息。心理生理学家谢切诺夫做过一个实验。为了消除右手的疲劳，他采取两种方式——一种是让两只手静止休息，另一种是在右手静止的同时又让左手适当活动，然后在疲劳测量器上对右手的握力进行测试。结果表明，在左手活动的情况下，右手的疲劳消除得更快。这证明变换人的活动内容确实是积极的休息方式。<br>比如你星期五写了5个小时的企划案， 最好第二天去给你的盆栽们剪枝而不是睡到太阳晒屁股。还有一点，当你无法选择由脑力劳动转入体力劳动时，你不妨在脑力劳动内部转换。法国杰出的启蒙思想家卢梭就讲过他的心得：“我本不是一个生来适于研究学问的人，<strong>因为我用功的时间稍长一些就感到疲倦，甚至我不能一连半小时集中精力于一个问题上。但是，我连续研究几个不同的问题，即使是不间断，我也能够轻松愉快地一个一个地寻思下去，这一个问题可以消除另一个问题所带来的疲劳，用不着休息一下脑筋。</strong>于是，我就在我的治学中充分利用我所发现的这一特点，对一些问题交替进行研究。这样，即使我整天用功也不觉得疲倦了。”所以，这天你要是有好几个问题要处理，最好交替进行，而不要处理完一个再开始的二个，那样会很快被耗尽。 </p><p>■**最好的休息，是让你重燃生活的热情 **</p><p>我们的疲惫主要来自对现有的一层不变的生活的厌倦。所以最好的休息项目就是那些让我们重新找到生活和工作热情的活动。如果你干完一件事，能够幸福地感叹“明天又是新的一天。”那这件事对你来说就是最好的恢复热情，调节情绪的方法。但可惜，我们缺乏对“休息”的想象力。我们能想出来的休息方法不是痴睡就是傻玩。<br>我们给你开了下面一些活动清单，基本思路是以“做”来解决“累”，用积极休息取代消极放纵。当然，最适合你的方法还是要你自己探索。事实上如果你觉得打扫卫生比坐过山车是更好的放松，那么就去吧，别管世界上的其他人都在玩什么。 </p><p>也许你可以：<br>●用看两小时让你开怀的漫画或小说代替去KTV唱那些一成不变的口水歌<br>●试着放弃在周六晚上去酒吧，10点入睡，然后在7点起床，去没有人的街上走走，或是看看你从来没有机会看到的早间剧场，你会发现这一天可以和过去的千万个周末都不相同。<br>●不要再去你已经去过无数次的度假村找乐子了。找一条你你从没去过的街道，把它走完。你会发现这个你感到腻味的城市结果你并没有完全体会到它的妙处。<br>●旅行，而不是换个地方消遣。去一个地方对那个地方本身心存好奇，对自己这趟行程心存美意，感受自己经验范围以外的人生样貌。而不是坐了5小时飞机，只是换个地方打麻将，换个地方游泳，换个地方打球……<br>●从这个周末起学习一项新的技艺，比如弹电子琴，打鼓……每周末练习1小时以上。<br>●去社交。不要以为它总是令人疲惫的。虽然和看书比起来，它稍有点令人紧张，但也能让你更兴奋，更有认同感。你必须每周有两三天是和工作圈子和亲戚外的人打交道。它让你在朝九晚五的机械运行中不至失去活泼的天性。女性朋友们尤为需要走出去和朋友聚会，这些时刻你不再是满脸写着“效率”的中性人，而是一个裙裾飞扬的魅力焦点。<br>●做点困难的事，如果你是精神超级紧张的人。心理学家发现解除神经紧张的方法，是去处理需要神经紧张才能解决的问题。曾经一位精神即将崩溃的总经理找到一位医师给出治疗建议，结果他得到的处方是去动物园当驯狮师。一个月以后完全康复。所以压力特别大的时候你可以为自己再找分工作，但不要是和你职业类似的。比如去孤儿院做义工，或者去一个复杂的机械工厂从学徒干起，或者做一道超级复杂的数学题。</p><blockquote><p>以上资料转载自豆瓣 作者 小兔</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>TODO</category>
      
      <category>杂文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>杂文</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kafka架构设计</title>
    <link href="/2021/09/02/Kafka%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <url>/2021/09/02/Kafka%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MjM1ODAyNQ==&mid=2247486544&idx=1&sn=856d9bc23c48de7a7c518e3721dd1262&chksm=ce085336f97fda200f84139e954adf29dd768874f0a36eb2e3d625a05920c74e5cea8da0e511&token=940474257&lang=zh_CN#rd">大话Kafka背后优秀的架构设计</a></p><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2MjM1ODAyNQ==&mid=2247487598&idx=1&sn=edf97d1380474704c8b3e216b26b7d6f&chksm=ce084f08f97fc61e12927bc1bf25c4541d5196e0a81ca9af8ef70a3e363a5fcbc9aa69cc1599&token=940474257&lang=zh_CN#rd">最新基准测试：Kafka、Pulsar 和 RabbitMQ 哪个最快？</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>TODO</category>
      
      <category>Kafka</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kafka</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Do you make these Go coding mistakes?</title>
    <link href="/2021/08/31/Do-you-make-these-Go-coding-mistakes/"/>
    <url>/2021/08/31/Do-you-make-these-Go-coding-mistakes/</url>
    
    <content type="html"><![CDATA[<p><img src="https://www.cmdbyte.com/2021/angry-man-with-computer.png" alt="angry-man-with-computer"></p><p><a href="https://yourbasic.org/golang/gotcha/">Do you make these Go coding mistakes? · YourBasic Go</a></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go []int to string</title>
    <link href="/2021/08/31/Go-int-to-string/"/>
    <url>/2021/08/31/Go-int-to-string/</url>
    
    <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/37532255/one-liner-to-transform-int-into-string">go - One-liner to transform []int into string - Stack Overflow</a></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go接口的理解</title>
    <link href="/2021/08/26/Go%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <url>/2021/08/26/Go%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>** 约束定义的对象具有一些特定的方法，这就是 interface 的本质 **</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis查看当前连接数及设置最大连接数</title>
    <link href="/2021/08/26/Redis%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E8%BF%9E%E6%8E%A5%E6%95%B0%E5%8F%8A%E8%AE%BE%E7%BD%AE%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0/"/>
    <url>/2021/08/26/Redis%E6%9F%A5%E7%9C%8B%E5%BD%93%E5%89%8D%E8%BF%9E%E6%8E%A5%E6%95%B0%E5%8F%8A%E8%AE%BE%E7%BD%AE%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="查看连接信息"><a href="#查看连接信息" class="headerlink" title="查看连接信息"></a>查看连接信息</h3><p>成功连接 redis server 后，使用 <code>info clients</code> 命令会打印以下信息:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-params">#</span> Clients<br>connected<span class="hljs-built_in">_</span>clients:5<br>cluster<span class="hljs-built_in">_</span>connections:0<br>maxclients:10000<br>client<span class="hljs-built_in">_</span>recent<span class="hljs-built_in">_</span>max<span class="hljs-built_in">_</span>input<span class="hljs-built_in">_</span>buffer:40<br>client<span class="hljs-built_in">_</span>recent<span class="hljs-built_in">_</span>max<span class="hljs-built_in">_</span>output<span class="hljs-built_in">_</span>buffer:0<br>blocked<span class="hljs-built_in">_</span>clients:0<br>tracking<span class="hljs-built_in">_</span>clients:0<br>clients<span class="hljs-built_in">_</span>in<span class="hljs-built_in">_</span>timeout<span class="hljs-built_in">_</span>table:0<br></code></pre></td></tr></table></figure><p>通过上面的信息可知, <code>connected_clients</code> 代表当前连接数，<code>maxclients</code> 代表该redis server 允许的最大连接数。</p><blockquote><p>也可以通过命令 <code>CONFIG GET maxclients</code> 获取最大连接数。</p></blockquote><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">1) &quot;maxclients&quot;<br>2) &quot;10000&quot;<br></code></pre></td></tr></table></figure><h3 id="设置最大连接数"><a href="#设置最大连接数" class="headerlink" title="设置最大连接数"></a>设置最大连接数</h3><p>有三种方式可以进行设置。</p><h4 id="通过配置文件"><a href="#通过配置文件" class="headerlink" title="通过配置文件"></a>通过配置文件</h4><p>在2.6之后的版本，允许通过配置文件修改最大连接数。<br>在配置文件中找到<code># maxclients 1000，取消注释，修改数值即可，修改完后要重启 </code>redis server&#96;。</p><h4 id="启动-redis-server-时加参数"><a href="#启动-redis-server-时加参数" class="headerlink" title="启动 redis server 时加参数"></a>启动 redis server 时加参数</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-server --maxclients 100000 -f /etc/redis.conf<br></code></pre></td></tr></table></figure><h4 id="通过redis客户端设置"><a href="#通过redis客户端设置" class="headerlink" title="通过redis客户端设置"></a>通过redis客户端设置</h4><p>成功连接redis server后，在终端使用下面命令设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">CONFIG SET maxclients 2000<br></code></pre></td></tr></table></figure><p>通过这种方式修改不需要重启Redis，但是在 redis server 重启后这种设置会失效。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git用错分支自救指南</title>
    <link href="/2021/08/16/Tools/Git/Git%E7%94%A8%E9%94%99%E5%88%86%E6%94%AF%E8%87%AA%E6%95%91%E6%8C%87%E5%8D%97/"/>
    <url>/2021/08/16/Tools/Git/Git%E7%94%A8%E9%94%99%E5%88%86%E6%94%AF%E8%87%AA%E6%95%91%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>有时候自己分支正在开发东西，但是中途切换到其他分支做了修复 bug 等事情，导致下次写代码时忘记切回自己分支。</p><h3 id="没有推送到远端"><a href="#没有推送到远端" class="headerlink" title="没有推送到远端"></a>没有推送到远端</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">把所有改动暂存</span><br>git add .<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">把暂存的改动提交到 git 的暂存栈</span><br>git stash<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到本该用来开发代码的分支（假设是xxx)</span><br>git checkout xxxx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将暂存栈中的代码取出来</span><br>git stash pop<br></code></pre></td></tr></table></figure><p>你会发现在其他分支上写的代码完美的回到了自己要用的分支上，这时候，是提交还是继续编写就看你了。</p><h3 id="推送到远端了"><a href="#推送到远端了" class="headerlink" title="推送到远端了"></a>推送到远端了</h3><p>出现这种情况一般是用 jetbrans 开发的工具了，因为它的代码提交实在方便，如果不是在 push 前看一眼那不太清晰的分支标识，真的不太容易发现自己用错了分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">切到提交了代码的分支，也就是你用错的分支（假设是xxx）</span><br>git checkout xxx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">把最近一次提交放到暂存区</span><br>git reset HEAD-1<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将修改放到暂存栈</span><br>git stash<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换到你想用的代码分支（假设是yyy）</span><br>git checkout yyy<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将修改从暂存栈取出来</span><br>git stash pop<br></code></pre></td></tr></table></figure><p>现在你可以在自己的分支上提交，但是别忘了要干掉推送到远端的那个错误分支的代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">切到用错的分支</span><br>git checkout xxx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">强制推送（因为上一步进行了回退，所以，这次提交的是你错误提交前的代码，以此将错误的提交信息干掉）</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">xxx 是你用错的分支，要指定一下</span><br>git push origin xxx -f <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gorm框架避坑指南</title>
    <link href="/2021/08/15/Gorm%E6%A1%86%E6%9E%B6%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <url>/2021/08/15/Gorm%E6%A1%86%E6%9E%B6%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>使用 Gorm 框架出问题，主要出在创建和更新的时候，其中更新要格外小心。</p><h3 id="创建-Create"><a href="#创建-Create" class="headerlink" title="创建(Create())"></a>创建(Create())</h3><h4 id="数据一致性问题"><a href="#数据一致性问题" class="headerlink" title="数据一致性问题"></a>数据一致性问题</h4><p>在日常开发过程中，可能会觉得创建是最简单的，因为不管是一层的struct结构还是嵌套的struct结构，往往一个 create 方法就搞定了。但是，对于嵌套的 struct 结构，如果你对数据一致性又要求，最好采用事务对每个表分别应用 create 方法，因为一个 create 情况下，如果第二层结构创建失败了，会出现第一层创建成功，而第二层创建失败的情况。</p><h3 id="更新-Update"><a href="#更新-Update" class="headerlink" title="更新(Update())"></a>更新(Update())</h3><h4 id="零值问题"><a href="#零值问题" class="headerlink" title="零值问题"></a>零值问题</h4><p>gorm 框架默认是不更新某类型数据对应的零值数据的，虽然很多人吐槽这一点，但gorm这样设计我觉得确实一个很好的设计，因为它有效的防止了数据误更新导致的数据丢失，但这样设计给刚开始使用的小伙伴一记重击。</p><p>如果在更新的时候想要更新零值，通常有两种方法，一种是将要更新的 struct 转成 map 形式去更新，另一种是使用它的 select 或 select 与 omit 组合的形式。问题出在第二种方法上：</p><h5 id="select-形式"><a href="#select-形式" class="headerlink" title="select(*) 形式"></a>select(*) 形式</h5><p>这种相当于取消 gorm 零值不更新的限制，所以对于 struct 中所有的值，都会更新到表中，乍一看好像没什么问题，但问题就出在我们认为的所有值都更新这点上，我先列出几个显而易见的坑：</p><ul><li>每次更新时，它会让数据库的自增主键变成0，导致下次更新别的数据时，报主键重复错误</li><li>每次更新时，它会将 created_at 字段变成0，从而丢失数据的创建时间</li></ul><p>另外，我再说一个逻辑上的错误：如果该条记录，我们用 0&#x2F;1 标识它未删除&#x2F;删除，那么，当它处于删除状态，即值为 1 时，这时，我们要更新这条记录，在提交记录中，一般不会提交该字段，所以它默认值是 0， 于是它被更新为 0，于是数据由删除状态变成未删除状态，引发业务逻辑上的bug。</p><h5 id="select-omit-的形式"><a href="#select-omit-的形式" class="headerlink" title="select(*).omit()的形式"></a>select(*).omit()的形式</h5><p>这种形式，可以解决上面那两个显而易见的坑，即不让主键和 created_at 字段更新，除此之外，其他字段都要被更新，还是有可能会出现那种逻辑上的问题。</p><p><strong>最好的方式是，用select(“字段1”, “字段2”) 明确指定哪些字段要更新，尽可能让数据保持在可控范围，同时也减少误更新导致数据丢失范围。</strong></p>]]></content>
    
    
    <categories>
      
      <category>开源项目</category>
      
      <category>Go</category>
      
      <category>Gorm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Gorm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在不对数据库建立外键的情况下使用gorm proload方法</title>
    <link href="/2021/08/13/%E5%9C%A8%E4%B8%8D%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E7%AB%8B%E5%A4%96%E9%94%AE%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8gorm-proload%E6%96%B9%E6%B3%95/"/>
    <url>/2021/08/13/%E5%9C%A8%E4%B8%8D%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E7%AB%8B%E5%A4%96%E9%94%AE%E7%9A%84%E6%83%85%E5%86%B5%E4%B8%8B%E4%BD%BF%E7%94%A8gorm-proload%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在很多情况下，通过 Gorm 框架提供的 AutoMigrate 方法，我们不需要编写 SQL 语句(这里指创建表结构的语句)，对于表字段的一些属性，也可以利用 Go Tag 特性，通过 Gorm 进行指定。</p><p>当我们想定义两个表之间的关系时(属于，多对多等)，使用 Gorm Tag 定义的 “foreignKey: xxx; references: xxx”，这些列属性会影响到数据库里表的结构，这点我们应该清楚，但指定了这种 Tag，便可以使用 Gorm 的Preload 方法，为进行多个具有关系的表的查找提供了便利。</p><p>但是，DBA建议我们尽量不要在数据库中使用外键约束，因为这种结构会对后续的一些操作（比如分库）遭成麻烦，同时，也会使对数据进行更细粒度的控制受限。</p><p>于是，有没有一种方法，既能享受 Gorm 的 Preload 带来的便利，又能不在实际的表结构中定义外键约束呢？</p><p><strong>可以用SQL语句定义表结构，在代码中虽然也要定义具有映射关系的struct，但是，不要对这个struct执行Gorm的AutoMigrate方法，也就是不要将gorm tag中的信息应用到实际表结构上。</strong></p><p>这样，你就可以通过gorm tag定义的”foreignKey: xxx; references: xxx” 信息使用gorm 的Preload 方法，从而不在实际的表中应用外键约束。但是，当增加新字段时需要改SQL语句和用SQL修改数据库表结构。</p>]]></content>
    
    
    <categories>
      
      <category>开源项目</category>
      
      <category>Go</category>
      
      <category>Gorm</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Gorm</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何自动删除Kubernetes的CronJob创建的Job</title>
    <link href="/2021/08/12/%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E5%88%A0%E9%99%A4Kubernetes%E7%9A%84CronJob%E5%88%9B%E5%BB%BA%E7%9A%84Job/"/>
    <url>/2021/08/12/%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E5%88%A0%E9%99%A4Kubernetes%E7%9A%84CronJob%E5%88%9B%E5%BB%BA%E7%9A%84Job/</url>
    
    <content type="html"><![CDATA[<p>kubernetes的文档里说，Job完成后不会删除创建的Pod， 保留这些 Pod 使得你可以查看已完成的 Pod 的日志输出，以便检查错误、警告 或者其它诊断性输出。但如果想在它完成后自动删除如何操作呢？</p><p>首先要知道，由Job创建的Pod会在Job删除后级联删除。</p><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><p>通过限制历史记录数量或者禁用历史记录，让CronJob产生的Job到达一定数量后自动删除旧的，或者干脆Job完成（成功或者失败）后直接删除。</p><blockquote><p>The <code>.spec.successfulJobsHistoryLimit</code> and <code>.spec.failedJobsHistoryLimit</code> fields are optional. These fields specify how many completed and failed jobs should be kept. By default, they are set to 3 and 1 respectively. Setting a limit to <code>0</code> corresponds to keeping none of the corresponding kind of jobs after they finish.</p></blockquote><p>把 limit 设置为 0 的例子如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1beta1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">CronJob</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">hello</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">schedule:</span> <span class="hljs-string">&quot;*/1 * * * *&quot;</span><br>  <span class="hljs-attr">successfulJobsHistoryLimit:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">failedJobsHistoryLimit:</span> <span class="hljs-number">0</span><br>  <span class="hljs-attr">jobTemplate:</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">template:</span><br>        <span class="hljs-attr">spec:</span><br>          <span class="hljs-attr">containers:</span><br>          <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">hello</span><br>            <span class="hljs-attr">image:</span> <span class="hljs-string">busybox</span><br>            <span class="hljs-attr">args:</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">/bin/sh</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">-c</span><br>            <span class="hljs-bullet">-</span> <span class="hljs-string">date;</span> <span class="hljs-string">echo</span> <span class="hljs-string">Hello</span> <span class="hljs-string">from</span> <span class="hljs-string">the</span> <span class="hljs-string">Kubernetes</span> <span class="hljs-string">cluster</span><br>          <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">OnFailure</span><br></code></pre></td></tr></table></figure><h3 id="方法二（不推荐）："><a href="#方法二（不推荐）：" class="headerlink" title="方法二（不推荐）："></a>方法二（不推荐）：</h3><p>官方文档提供了一种方法，通过TTL机制，但是你需要在特性门中开启这一特性，否则这项设置不生效，相关特性门的开启需要由管理员在指定的kubernetes组件上开启。</p><p>开启方式可参考文档：<a href="https://v1-20.docs.kubernetes.io/docs/reference/command-line-tools-reference/feature-gates/">Feature Gates | Kubernetes</a></p><p>设置TT L的例子如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">apiVersion:</span> <span class="hljs-string">batch/v1</span><br><span class="hljs-attr">kind:</span> <span class="hljs-string">Job</span><br><span class="hljs-attr">metadata:</span><br>  <span class="hljs-attr">name:</span> <span class="hljs-string">pi-with-ttl</span><br><span class="hljs-attr">spec:</span><br>  <span class="hljs-attr">ttlSecondsAfterFinished:</span> <span class="hljs-number">100</span><br>  <span class="hljs-attr">template:</span><br>    <span class="hljs-attr">spec:</span><br>      <span class="hljs-attr">containers:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">pi</span><br>        <span class="hljs-attr">image:</span> <span class="hljs-string">perl</span><br>        <span class="hljs-attr">command:</span> [<span class="hljs-string">&quot;perl&quot;</span>,  <span class="hljs-string">&quot;-Mbignum=bpi&quot;</span>, <span class="hljs-string">&quot;-wle&quot;</span>, <span class="hljs-string">&quot;print bpi(2000)&quot;</span>]<br>      <span class="hljs-attr">restartPolicy:</span> <span class="hljs-string">Never</span><br></code></pre></td></tr></table></figure><p><code>ttlSecondsAfterFinished</code>字段指定多长时间后删除Job，单位是秒。</p>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go runtime.Gosched()函数</title>
    <link href="/2021/08/10/Go-runtime-Gosched-%E5%87%BD%E6%95%B0/"/>
    <url>/2021/08/10/Go-runtime-Gosched-%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>代码定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Gosched yields the processor, allowing other goroutines to run. It does not</span><br><span class="hljs-comment">// suspend the current goroutine, so execution resumes automatically.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Gosched</span><span class="hljs-params">()</span></span> &#123;<br>checkTimeouts()<br>mcall(gosched_m)<br>&#125;<br></code></pre></td></tr></table></figure><p>翻译：这个函数的作用是让当前goroutine让出CPU，好让其它的goroutine获得执行的机会。但当前goroutine不会终止，将来会自动恢复。</p><p>例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">showNumber</span> <span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>    fmt.Println(i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> showNumber(i)<br>    &#125;<br><br>    fmt.Println(<span class="hljs-string">&quot;Mofan&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">Mofan<br></code></pre></td></tr></table></figure><p>没有打印出数字，因为goroutine没有获得机会运行。</p><p>修改代码：在main函数中加上runtime.Gosched()：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;runtime&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">showNumber</span> <span class="hljs-params">(i <span class="hljs-type">int</span>)</span></span> &#123;<br>    fmt.Println(i)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>        <span class="hljs-keyword">go</span> showNumber(i)<br>    &#125;<br><br>    runtime.Gosched()<br>    fmt.Println(<span class="hljs-string">&quot;Mofan&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs tex">0<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>Mofan<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx做前后端分离常见问题</title>
    <link href="/2021/08/10/Nginx%E5%81%9A%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <url>/2021/08/10/Nginx%E5%81%9A%E5%89%8D%E5%90%8E%E7%AB%AF%E5%88%86%E7%A6%BB%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="问题一：Nginx做Web服务器"><a href="#问题一：Nginx做Web服务器" class="headerlink" title="问题一：Nginx做Web服务器"></a>问题一：Nginx做Web服务器</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs tex"><span class="hljs-params">#</span>前端页面服务器<br>    server &#123;<br>        <span class="hljs-params">#</span>监听端口和域名<br>        listen       80; <br>        server<span class="hljs-built_in">_</span>name  172.18.58.31;<br> <br>        <span class="hljs-params">#</span>添加头部信息<br>        proxy<span class="hljs-built_in">_</span>set<span class="hljs-built_in">_</span>header Cookie <span class="hljs-built_in">$</span>http<span class="hljs-built_in">_</span>cookie;<br>        proxy<span class="hljs-built_in">_</span>set<span class="hljs-built_in">_</span>header X-Forwarded-Host <span class="hljs-built_in">$</span>host;<br>        proxy<span class="hljs-built_in">_</span>set<span class="hljs-built_in">_</span>header X-Forwarded-Server <span class="hljs-built_in">$</span>host;<br>        proxy<span class="hljs-built_in">_</span>set<span class="hljs-built_in">_</span>header X-Forwarded-For <span class="hljs-built_in">$</span>proxy<span class="hljs-built_in">_</span>add<span class="hljs-built_in">_</span>x<span class="hljs-built_in">_</span>forwarded<span class="hljs-built_in">_</span>for;<br>        <br>        <span class="hljs-params">#</span>添加拦截路径和根目录<br>        location / &#123;<br>               root   html/wanmor<span class="hljs-built_in">_</span>cloud<span class="hljs-built_in">_</span>platform<span class="hljs-built_in">_</span>frontend;  <br>               index  html/login/login.html;  <br>        &#125;           <br>        <br>    &#125;<br></code></pre></td></tr></table></figure><p>让nginx拦截80端口,然后直接去nginx根目录下的html&#x2F;wanmor_cloud_platform_frontend      wanmor_cloud_platform_frontend 就是前端项目名.</p><p>当然root也可以写绝对路径,  </p><p>root  &#x2F;home&#x2F;winnersoft&#x2F;server&#x2F;wanmo-soft&#x2F;wanmor_cloud_platform_frontend&#x2F; ;</p><p>index后面就是首页的路径.  </p><p>这样访问ip就可以访问web前端的静态页面了.</p><h3 id="问题二：跨域问题"><a href="#问题二：跨域问题" class="headerlink" title="问题二：跨域问题"></a>问题二：跨域问题</h3><blockquote><p>跨域问题：<em>如果前端资源和后端资源不在一个项目的话,浏览器会拦截前端对后台的请求</em></p></blockquote><p>基于问题一的设置，就会存在跨域问题，解决跨域问题可以利用 Nginx的转发。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs tex">server &#123;<br>        <span class="hljs-params">#</span>监听端口和域名<br>        listen       80; <br>        server<span class="hljs-built_in">_</span>name  172.18.58.31;<br> <br>        <span class="hljs-params">#</span>添加头部信息<br>        proxy<span class="hljs-built_in">_</span>set<span class="hljs-built_in">_</span>header Cookie <span class="hljs-built_in">$</span>http<span class="hljs-built_in">_</span>cookie;<br>        proxy<span class="hljs-built_in">_</span>set<span class="hljs-built_in">_</span>header X-Forwarded-Host <span class="hljs-built_in">$</span>host;<br>        proxy<span class="hljs-built_in">_</span>set<span class="hljs-built_in">_</span>header X-Forwarded-Server <span class="hljs-built_in">$</span>host;<br>        proxy<span class="hljs-built_in">_</span>set<span class="hljs-built_in">_</span>header X-Forwarded-For <span class="hljs-built_in">$</span>proxy<span class="hljs-built_in">_</span>add<span class="hljs-built_in">_</span>x<span class="hljs-built_in">_</span>forwarded<span class="hljs-built_in">_</span>for;<br> <br>        <span class="hljs-params">#</span>添加拦截路径和代理地址<br>        location /api/ &#123;              <br>               proxy<span class="hljs-built_in">_</span>pass http://172.18.58.31:4541/;  <span class="hljs-params">#</span>注意：使用代理地址时末尾记得加上斜杠&quot;/&quot;。    <br>        &#125;<br>           <br>        <br>        <span class="hljs-params">#</span>添加拦截路径和根目录<br>        location / &#123;<br>               root   html/wanmor<span class="hljs-built_in">_</span>cloud<span class="hljs-built_in">_</span>platform<span class="hljs-built_in">_</span>frontend;  <br>               index  html/login/login.html;  <span class="hljs-params">#</span>index表示首页 <br>        &#125;           <br>        <br>    &#125;<br></code></pre></td></tr></table></figure><p>让nginx拦截所有带&#x2F;api&#x2F;的请求,转发到后端服务器,就可以解决跨域的问题.</p><p>比如前端ajax 请求的url为<a href="http://172.18.58.31/api/login">http://172.18.58.31:80/api/login</a></p><p>经过nginx代理之后变成了</p><p><a href="http://172.168.58.31:4541/login">http://172.168.58.31:4541/login</a></p><p>这样配置之后,在前端所有的请求加上&#x2F;api&#x2F;</p><p>这样就可以欺骗浏览器和服务器,解决跨域的问题</p><h3 id="问题三：获取用户IP的问题"><a href="#问题三：获取用户IP的问题" class="headerlink" title="问题三：获取用户IP的问题"></a>问题三：获取用户IP的问题</h3><p>基于问题二，用Nginx转发后，后端获取的IP其实是Nginx的IP，所以，想获取用户的IP，还需要对配置做些修改：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs tex">server &#123;<br>        <span class="hljs-params">#</span>监听端口和域名<br>        listen       80; <br>        server<span class="hljs-built_in">_</span>name  172.18.58.31;<br> <br>        <span class="hljs-params">#</span>添加头部信息<br>        proxy<span class="hljs-built_in">_</span>set<span class="hljs-built_in">_</span>header Cookie <span class="hljs-built_in">$</span>http<span class="hljs-built_in">_</span>cookie;<br>        proxy<span class="hljs-built_in">_</span>set<span class="hljs-built_in">_</span>header X-Forwarded-Host <span class="hljs-built_in">$</span>host;<br>        proxy<span class="hljs-built_in">_</span>set<span class="hljs-built_in">_</span>header X-Forwarded-Server <span class="hljs-built_in">$</span>host;<br>        proxy<span class="hljs-built_in">_</span>set<span class="hljs-built_in">_</span>header X-Forwarded-For <span class="hljs-built_in">$</span>proxy<span class="hljs-built_in">_</span>add<span class="hljs-built_in">_</span>x<span class="hljs-built_in">_</span>forwarded<span class="hljs-built_in">_</span>for;<br>        proxy<span class="hljs-built_in">_</span>set<span class="hljs-built_in">_</span>header X-real-ip <span class="hljs-built_in">$</span>remote<span class="hljs-built_in">_</span>addr;<br> <br>        <span class="hljs-params">#</span>添加拦截路径和代理地址<br>        location /api/ &#123;    <br>          <span class="hljs-params">#</span>注意：使用代理地址时末尾记得加上斜杠&quot;/&quot;。    <br>               proxy<span class="hljs-built_in">_</span>pass http://172.18.58.31:4541/;  <br>        &#125;<br>          <br>        <br>        <span class="hljs-params">#</span>添加拦截路径和根目录<br>        location / &#123;<br>               root   html/wanmor<span class="hljs-built_in">_</span>cloud<span class="hljs-built_in">_</span>platform<span class="hljs-built_in">_</span>frontend;  <br>               index  html/login/login.html;  <span class="hljs-params">#</span>index表示首页 <br>        &#125;           <br>        <br>    &#125;<br></code></pre></td></tr></table></figure><p>在头部信息里添加</p><p>proxy_set_header X-real-ip $remote_addr; 这样nginx就会带着用户真实ip去访问后端服务器,</p><p>后端代码也需要修改</p><p>String userIp &#x3D; request.getHeader(“X-real-ip”);</p><p>这样就是获取nginx传过来的用户真实ip</p><h3 id="问题四：大文件上传失败问题"><a href="#问题四：大文件上传失败问题" class="headerlink" title="问题四：大文件上传失败问题"></a>问题四：大文件上传失败问题</h3><p>如果前端请求涉及到资源上传,资源大小过大的话nginx会拦截请求，并返回<code>413 (Request Entity Too Large)</code>的信息。</p><p>解决此问题需要修改Nginx对请求大小的限制。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs tex">http &#123;<br>    include       mime.types;<br>    default<span class="hljs-built_in">_</span>type  application/octet-stream;<br>    log<span class="hljs-built_in">_</span>format  main  &#x27;<span class="hljs-built_in">$</span>remote<span class="hljs-built_in">_</span>addr - <span class="hljs-built_in">$</span>remote<span class="hljs-built_in">_</span>user [<span class="hljs-built_in">$</span>time<span class="hljs-built_in">_</span>local] &quot;<span class="hljs-built_in">$</span>request&quot; &#x27;<br>                      &#x27;<span class="hljs-built_in">$</span>status <span class="hljs-built_in">$</span>body<span class="hljs-built_in">_</span>bytes<span class="hljs-built_in">_</span>sent &quot;<span class="hljs-built_in">$</span>http<span class="hljs-built_in">_</span>referer&quot; &#x27;<br>                       &#x27;&quot;<span class="hljs-built_in">$</span>http<span class="hljs-built_in">_</span>user<span class="hljs-built_in">_</span>agent&quot; &quot;<span class="hljs-built_in">$</span>http<span class="hljs-built_in">_</span>x<span class="hljs-built_in">_</span>forwarded<span class="hljs-built_in">_</span>for&quot;&#x27;;<br>    client<span class="hljs-built_in">_</span>max<span class="hljs-built_in">_</span>body<span class="hljs-built_in">_</span>size 100m;<br> <br>    sendfile        on;<br>    keepalive<span class="hljs-built_in">_</span>timeout  65;<br> <br>    <span class="hljs-params">#</span>前端页面服务器<br>    server &#123;<br>        <span class="hljs-params">#</span>监听端口和域名<br>        listen       80; <br>        server<span class="hljs-built_in">_</span>name  172.18.58.31;<br> <br>        <span class="hljs-params">#</span>添加头部信息<br>        proxy<span class="hljs-built_in">_</span>set<span class="hljs-built_in">_</span>header Cookie <span class="hljs-built_in">$</span>http<span class="hljs-built_in">_</span>cookie;<br>        proxy<span class="hljs-built_in">_</span>set<span class="hljs-built_in">_</span>header X-Forwarded-Host <span class="hljs-built_in">$</span>host;<br>        proxy<span class="hljs-built_in">_</span>set<span class="hljs-built_in">_</span>header X-Forwarded-Server <span class="hljs-built_in">$</span>host;<br>        proxy<span class="hljs-built_in">_</span>set<span class="hljs-built_in">_</span>header X-Forwarded-For <span class="hljs-built_in">$</span>proxy<span class="hljs-built_in">_</span>add<span class="hljs-built_in">_</span>x<span class="hljs-built_in">_</span>forwarded<span class="hljs-built_in">_</span>for;<br>        proxy<span class="hljs-built_in">_</span>set<span class="hljs-built_in">_</span>header X-real-ip <span class="hljs-built_in">$</span>remote<span class="hljs-built_in">_</span>addr;<br> <br>        <span class="hljs-params">#</span>添加拦截路径和代理地址<br>        location /api/ &#123;              <br>               proxy<span class="hljs-built_in">_</span>pass http://172.18.58.31:4541/;  <span class="hljs-params">#</span>注意：使用代理地址时末尾记得加上斜杠&quot;/&quot;。    <br>        &#125;<br>          <br>        <br>        <span class="hljs-params">#</span>添加拦截路径和根目录<br>        location / &#123;<br>               root   html/wanmor<span class="hljs-built_in">_</span>cloud<span class="hljs-built_in">_</span>platform<span class="hljs-built_in">_</span>frontend;  <br>               index  html/login/login.html;  <span class="hljs-params">#</span>index表示首页 <br>        &#125;           <br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>http下面添加</p><p>client_max_body_size 100m;</p><p>可以将请求大小最大值限制在100M,大家可以根据实际情况配置</p><h3 id="问题5-配置下载速率"><a href="#问题5-配置下载速率" class="headerlink" title="问题5: 配置下载速率"></a>问题5: 配置下载速率</h3><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs tex">http &#123;<br> <br>limit<span class="hljs-built_in">_</span>conn<span class="hljs-built_in">_</span>zone <span class="hljs-built_in">$</span>binary<span class="hljs-built_in">_</span>remote<span class="hljs-built_in">_</span>addr zone=one:10m; <span class="hljs-params">#</span>容器共使用10M的内存来对于IP传输开销<br> <br>    include       mime.types;<br>    default<span class="hljs-built_in">_</span>type  application/octet-stream;<br> <br>    <span class="hljs-params">#</span>log<span class="hljs-built_in">_</span>format  main  &#x27;<span class="hljs-built_in">$</span>remote<span class="hljs-built_in">_</span>addr - <span class="hljs-built_in">$</span>remote<span class="hljs-built_in">_</span>user [<span class="hljs-built_in">$</span>time<span class="hljs-built_in">_</span>local] &quot;<span class="hljs-built_in">$</span>request&quot; &#x27;<br>    <span class="hljs-params">#</span>                  &#x27;<span class="hljs-built_in">$</span>status <span class="hljs-built_in">$</span>body<span class="hljs-built_in">_</span>bytes<span class="hljs-built_in">_</span>sent &quot;<span class="hljs-built_in">$</span>http<span class="hljs-built_in">_</span>referer&quot; &#x27;<br>    <span class="hljs-params">#</span>                  &#x27;&quot;<span class="hljs-built_in">$</span>http<span class="hljs-built_in">_</span>user<span class="hljs-built_in">_</span>agent&quot; &quot;<span class="hljs-built_in">$</span>http<span class="hljs-built_in">_</span>x<span class="hljs-built_in">_</span>forwarded<span class="hljs-built_in">_</span>for&quot;&#x27;;<br> <br>    <span class="hljs-params">#</span>access<span class="hljs-built_in">_</span>log  logs/access.log  main;<br> <br>    sendfile        on;<br>    <span class="hljs-params">#</span>tcp<span class="hljs-built_in">_</span>nopush     on;<br> <br>    <span class="hljs-params">#</span>keepalive<span class="hljs-built_in">_</span>timeout  0;<br>    keepalive<span class="hljs-built_in">_</span>timeout  65;<br> <br>    <span class="hljs-params">#</span>gzip  on;<br> <br> <br>    server &#123;<br>        listen       8080;<br>        server<span class="hljs-built_in">_</span>name  localhost;<br> <br>        <span class="hljs-params">#</span>nginx下载文件指向本地服务<br>        location ~ <span class="hljs-keyword">\.</span>apk &#123;<br>            root   /usr/local/apache-tomcat-8.0.51/webapps/;  <br>            autoindex on;<br>        limit<span class="hljs-built_in">_</span>conn one 1; <br> limit<span class="hljs-built_in">_</span>rate 20k; <br> <span class="hljs-params">#</span>limit<span class="hljs-built_in">_</span>rate<span class="hljs-built_in">_</span>after 1m;   <br>        &#125;<br> <br>        error<span class="hljs-built_in">_</span>page   500 502 503 504  /50x.html;<br>        location = /50x.html &#123;<br>            root   html;<br>        &#125;<br> <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在http 下面添加</p><p>limit_conn_zone $binary_remote_addr zone&#x3D;one:10m;</p><p> 然后在service下面location 拦截.apk的请求</p><p>root 是静态.apk资源的文件路径</p><p>autoindex on; 表示可以访问目录列表</p><p>limit_conn one 1;表示拦截下载的每1个线程</p><p>limit_rate 20k; 表示下载速度限制 20kb;\</p><p>limit_rate_after 1m;  表示下载了1m之后才开始限速</p><p>这样如果下载的kehu客户端使用单线程下载,就是20kb&#x2F;s,如果客户端开启了3个线程 ,就是20kb&#x2F;s*3&#x3D;60kb&#x2F;s,</p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>栈(stack)的三种含义</title>
    <link href="/2021/08/10/%E6%A0%88-stack-%E7%9A%84%E4%B8%89%E7%A7%8D%E5%90%AB%E4%B9%89/"/>
    <url>/2021/08/10/%E6%A0%88-stack-%E7%9A%84%E4%B8%89%E7%A7%8D%E5%90%AB%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<blockquote><p>文章来源：<a href="https://www.ruanyifeng.com/blog/2013/11/stack.html">Stack的三种含义 - 阮一峰的网络日志</a></p><p>外文优质文档：<a href="http://www.itcsolutions.eu/2011/02/06/tutorial-java-8-understand-stack-and-heap/">Tutorial Java - #8 Understand Stack and Heap | IT&amp;C Solutions</a></p></blockquote><p>提起栈，我们很自然的知道它是一种后进先出(LIFO，Last in, first out)的数据结构，但在数据结构这层含义外，在代码运行方式和内存区域这里也有它的含义，下面在重温数据结构含义的同时，介绍另外两种含义。</p><h3 id="含义一：数据结构"><a href="#含义一：数据结构" class="headerlink" title="含义一：数据结构"></a>含义一：数据结构</h3><p>首先，栈是一种后进先出的数据结构。</p><blockquote><p>堆是后进后出(LILO)</p></blockquote><p>在栈这种结构中，数据像积木一样一层一层堆积起来，先放入的积木在下面，后放入的在上面，取的时候首先取上面的，所以形成了“后进先出”，如下图：</p><p><img src="https://www.cmdbyte.com/2021/bg2013112901.png" alt="堆"></p><p>与这种结构配套的方法主要有下面这些，可以理解为去掉U的CRUD：</p><ul><li>push：在最顶层加入数据。</li><li>pop：返回并移除最顶层的数据。</li><li>top：返回最顶层数据的值，但不移除它。</li><li>isempty：返回一个布尔值，表示当前stack是否为空栈。</li></ul><h3 id="含义二：代码运行方式"><a href="#含义二：代码运行方式" class="headerlink" title="含义二：代码运行方式"></a>含义二：代码运行方式</h3><p>在写代码的时候，你可能遇到过栈溢出(Stack overflow)问题，也可能听说过调用栈(call stack)这个词。没错，程序的调用栈即表示函数或子例程像堆积木一样存放，以实现层层调用。</p><p>下面以一段 Java 代码来表示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>&#123;<br>    <span class="hljs-type">int</span> age;              <br>    String name;      <br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">Student</span><span class="hljs-params">(<span class="hljs-type">int</span> Age, String Name)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.age = Age;<br>        setName(Name);<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setName</span><span class="hljs-params">(String Name)</span><br>    &#123;<br>        <span class="hljs-built_in">this</span>.name = Name;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Main</span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>            Student s;           <br>            s = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Student</span>(<span class="hljs-number">23</span>,<span class="hljs-string">&quot;Jonh&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面这段代码运行的时候，首先调用main方法，里面需要生成一个Student的实例，于是又调用Student构造函数。在构造函数中，又调用到setName方法。</p><p><img src="https://www.cmdbyte.com/2021/bg2013112902.gif"></p><p>这三次调用像积木一样堆起来，就叫做”调用栈”。程序运行的时候，总是先完成最上层的调用，然后将它的值返回到下一层调用，直至完成整个调用栈，返回最后的结果。</p><h3 id="含义三：内存区域"><a href="#含义三：内存区域" class="headerlink" title="含义三：内存区域"></a>含义三：内存区域</h3><p>程序运行的时候，需要内存空间存放数据。一般来说，系统会划分出两种不同的内存空间：一种叫做stack（栈），另一种叫做heap（堆）。</p><p>它们的主要区别是：stack是有结构的，每个区块按照一定次序存放，可以明确知道每个区块的大小；heap是没有结构的，数据可以任意存放。因此，stack的寻址速度要快于heap。</p><p><img src="https://www.cmdbyte.com/2021/bg2013112903.jpg" alt="栈"><img src="https://www.cmdbyte.com/2021/bg2013112904.jpg" alt="堆"></p><p>其他的区别还有，一般来说，每个线程分配一个stack，每个进程分配一个heap，也就是说，stack是线程独占的，heap是线程共用的。此外，stack创建的时候，大小是确定的，数据超过这个大小，就发生stack overflow错误，而heap的大小是不确定的，需要的话可以不断增加。</p><p>根据上面这些区别，数据存放的规则是：只要是局部的、占用空间确定的数据，一般都存放在stack里面，否则就放在heap里面。请看下面这段代码（<a href="http://www.codeproject.com/Articles/76153/Six-important-NET-concepts-Stack-heap-value-types">来源</a>）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">Method1</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> i=<span class="hljs-number">4</span>;<br><br>    <span class="hljs-type">int</span> y=<span class="hljs-number">2</span>;<br><br>    <span class="hljs-type">class1</span> <span class="hljs-variable">cls1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">class1</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码的Method1方法，共包含了三个变量：i, y 和 cls1。其中，i和y的值是整数，内存占用空间是确定的，而且是局部变量，只用在Method1区块之内，不会用于区块之外。cls1也是局部变量，但是类型为指针变量，指向一个对象的实例。指针变量占用的大小是确定的，但是对象实例以目前的信息无法确知所占用的内存空间大小。</p><p>这三个变量和一个对象实例在内存中的存放方式如下。</p><p><img src="https://www.cmdbyte.com/2021/bg2013112905.jpg"></p><p>从上图可以看到，i、y和cls1都存放在stack，因为它们占用内存空间都是确定的，而且本身也属于局部变量。但是，cls1指向的对象实例存放在heap，因为它的大小不确定。作为一条规则可以记住，所有的对象都存放在heap。</p><p>接下来的问题是，当Method1方法运行结束，会发生什么事？</p><p>回答是整个stack被清空，i、y和cls1这三个变量消失，因为它们是局部变量，区块一旦运行结束，就没必要再存在了。而heap之中的那个对象实例继续存在，直到系统的垃圾清理机制（garbage collector）将这块内存回收。因此，一般来说，内存泄漏都发生在heap，即某些内存空间不再被使用了，却因为种种原因，没有被系统回收。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务端性能测试-入门指南</title>
    <link href="/2021/08/09/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/"/>
    <url>/2021/08/09/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<blockquote><p>文章来源：<a href="https://testerhome.com/topics/27409">服务端性能测试 - 入门指南 (慎入: 6000 字长文) · TesterHome</a></p></blockquote><p>全文包括：</p><ul><li><a href="https://www.mofan.life/2021/08/09/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/#2%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E6%80%A7%E8%83%BD">什么是性能</a></li><li><a href="https://www.mofan.life/2021/08/09/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/#3-%E6%80%A7%E8%83%BD%E7%9A%84%E5%BD%B1%E5%93%8D">性能对用户和产品收入影响</a></li><li><a href="https://www.mofan.life/2021/08/09/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/#5%E3%80%81%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%92%8C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9">性能测试目的、性能关注指标、性能测试类型、性能测试流程</a></li><li><a href="https://www.mofan.life/2021/08/09/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95-%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97/#6-%E6%80%A7%E8%83%BD%E5%B7%A5%E5%85%B7%E6%80%A7%E8%83%BD%E5%AF%B9%E6%AF%94">常用的性能测试工具对比</a></li></ul><h2 id="1、前言"><a href="#1、前言" class="headerlink" title="1、前言"></a>1、前言</h2><p>随着 5G 时代的到来，以及万物互联时代的到来，云应用和云服务会越来越多，数据量会指数级增长。尤其是 2020 年全球疫情的时代意义，会导致各行各业开始上云。从而会催生出极具个性化的各类产品的诞生。</p><p>所有行业的生态会像鲸落效应一样，围绕若干个巨无霸公司衍生出满足人们各种需求的中小型产品。大部分产品的形态可能会变成重服务端、轻客户端。</p><p>所以，服务端性能测试的需求也有可能会出现井喷式增长。但是服务端性能测试需求对于中小型公司，尤其是大部分不关注用户体验的公司来说，性能测试需求特点是周期短、时间紧。</p><p>因此，对于大部分测试从业人员来说，了解并掌握常见的性能测试知识是必不可少的，虽然不会经常用到。</p><h2 id="2、什么是性能"><a href="#2、什么是性能" class="headerlink" title="2、什么是性能"></a>2、什么是性能</h2><p>不同角色关注的性能是不一样的，性能测试这项系统工程，需要各角色在其关注的纬度提供信息或帮助。</p><h3 id="用户眼中的性能"><a href="#用户眼中的性能" class="headerlink" title="用户眼中的性能"></a>用户眼中的性能</h3><p>性能对于用户来说，就是操作的响应速度、产品的崩溃是否影响自己的生活。比如滴滴之前在情人节当天打车服务的性能事故。</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2011.40.25.png" alt="用户眼中的性能"></p><h3 id="老板眼中的性能"><a href="#老板眼中的性能" class="headerlink" title="老板眼中的性能"></a>老板眼中的性能</h3><p>老板主要关心产品的收入、成本（用了多少钱服务了多少用户）、用户满意度（用户对产品是否满意）。</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2011.41.41.png" alt="老板眼中的性能"></p><h3 id="运维眼中的性能"><a href="#运维眼中的性能" class="headerlink" title="运维眼中的性能"></a>运维眼中的性能</h3><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2011.42.23.png" alt="运维眼中的性能"></p><h3 id="开发眼中的性能"><a href="#开发眼中的性能" class="headerlink" title="开发眼中的性能"></a>开发眼中的性能</h3><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2011.43.03.png" alt="开发眼中的性能"></p><h3 id="测试眼中的性能"><a href="#测试眼中的性能" class="headerlink" title="测试眼中的性能"></a>测试眼中的性能</h3><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2011.43.36.png" alt="测试眼中的性能"></p><h2 id="3-性能的影响"><a href="#3-性能的影响" class="headerlink" title="3.性能的影响"></a>3.性能的影响</h2><h3 id="3-1-性能对用户的影响"><a href="#3-1-性能对用户的影响" class="headerlink" title="3.1 性能对用户的影响"></a>3.1 性能对用户的影响</h3><p>对于大部分商业公司的 ToC 产品，性能关乎产品命运和增长。如下图所示，虽然现在阿里京东垄断不太容易更换应用，但是遇到性能很差的时候，心里还是忍不住问候几句。</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2011.44.42.png" alt="3.1 性能对用户的影响"></p><h3 id="3-2-性能对收入的影响"><a href="#3-2-性能对收入的影响" class="headerlink" title="3.2 性能对收入的影响"></a>3.2 性能对收入的影响</h3><p>大家都知道性能对产品收入有非常大的影响，但是很少公司有全面的运营分析来证明这件事。<br>以下是《2016 全球零售业数字化性能基准报告》中关于性能对收入影响的数据。<br>从图中可以看到，响应时间对转化率的影响非常大，比如沃尔玛够硬核了吧，沃尔玛的响应时间降低 0.1 秒，收入即可增加 1%，是非常大的收入提升。****</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2011.46.05.png" alt="3.2 性能对收入的影响"></p><h2 id="4-性能的组成"><a href="#4-性能的组成" class="headerlink" title="4.性能的组成"></a>4.性能的组成</h2><p>以中小型电商网站为例，如下图所示，性能基本组成：</p><ul><li>客户端 (Web、移动端、小程序) 性能</li><li>DNS 性能</li><li>负载均衡服务性能</li><li>Nginx 集群性能、折损率</li><li>CDN 缓存性能（回源率、穿透率）</li><li>应用服务器性能</li><li>DB 性能（Mysql&#x2F;Redis&#x2F;Memcache）</li></ul><p>由此可见，中大型项目的性能测试，从来都是一项系统工程，需要非常多人跨部门合作，且持续时间长，耗费资源大。</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2011.47.12.png" alt="性能的组成"></p><h2 id="5、性能测试基础知识和注意事项"><a href="#5、性能测试基础知识和注意事项" class="headerlink" title="5、性能测试基础知识和注意事项"></a>5、性能测试基础知识和注意事项</h2><p>熟悉性能测试之前，首先了解性能测试的目标是什么。带着目标去思考会更有利于理解下面的内容。</p><h3 id="5-1-性能测试目的"><a href="#5-1-性能测试目的" class="headerlink" title="5.1 性能测试目的"></a>5.1 性能测试目的</h3><p>性能测试的最终目的是为了最大限度的满足用户的需求，通常要达成以下目标：<br>（1）性能评估：测试中评估系统的 QPS、响应时间、成功率等；<br>（2）寻找系统瓶颈，进行系统调优；<br>（3）检测软件中的问题；<br>（4）验证稳定性和可靠性；</p><h3 id="5-2-性能应该关注的指标"><a href="#5-2-性能应该关注的指标" class="headerlink" title="5.2 性能应该关注的指标"></a>5.2 性能应该关注的指标</h3><p>一般来说，性能测试要统一考虑这么几个因素：Thoughput 吞吐量，Latency 响应时间，资源利用（CPU&#x2F;MEM&#x2F;IO&#x2F;Bandwidth…），成功率，系统稳定性。</p><p><strong>（1）响应时间</strong>：你得定义一个系统的响应时间 latency，建议是 TP95 或以上。响应时间具体要求多少，一般读不超过 200ms，写不超过 500ms。要是实在不知道，对标同行业竞品。<br><strong>（2）最高吞吐量</strong>：TPS（每秒事务请求数）或 QPS（每秒请求量），在目标响应时间要求下，系统可支撑的最高吞吐量。<br><strong>（3）成功率</strong>：在关注 QPS 和响应时间的同时，还要关注成功率。如果 QPS 和响应时间都满足性能要求时，请求成功率只有 50%，用户也是不会接收的。<br><strong>（4）性能拐点</strong>：一般服务都有性能临界点。当超过临界点时，吞吐量非线性下降，响应时间指数级增加，成功率降低。<br>找到出现性能拐点的主要原因：<br>基于性能拐点主要原因设置高危性能报警线。此为高风险注意事项，因为一旦达到性能拐点，有可能会出现雪崩现象，造成极其严重的事故。<br>观察超过性能拐点后，系统是否会出现假死、崩溃等高风险事件。<br><strong>（5）系统稳定性</strong>：保持最高吞吐量（目标响应时间下的最高吞吐量），持续运行 7*24 小时。然后收集 CPU，内存，硬盘&#x2F;网络 IO，等指标，查看系统是否稳定，比如，CPU 是平稳的，内存使用也是平稳的。那么，这个值就是系统的性能。<br><strong>（6）极限吞吐量</strong>：阶梯式增加并发压力，找到系统的极限值。比如：在成功率 100% 的情况下（不考虑响应时间的长短），系统能坚持 10 分钟的吞吐量。<br><strong>（7）系统健壮性：做 Burst Test。用第二步得到的吞吐量执行 5 分钟，然后在第四步得到的极限值执行 1 分钟，再回到第二步的吞吐量执行 5 钟，再到第四步的权限值执行 1 分钟，如此往复个一段时间，比如 2 天。</strong>收集系统数据：CPU、内存、硬盘&#x2F;网络 IO 等，观察他们的曲线，以及相应的响应时间，确保系统是稳定的。<br><strong>（8）低吞吐量和网络小包的测试</strong>：有时候，在低吞吐量的时候，可能会导致 latency 上升，比如 TCP_NODELAY 的参数没有开启会导致 latency 上升（<a href="https://coolshell.cn/articles/11564.html">详见 TCP 的那些事</a>），而网络小包会导致带宽用不满也会导致性能上不去，所以，性能测试还需要根据实际情况有选择的测试一下这两咱场景。</p><h3 id="5-3-性能测试类型"><a href="#5-3-性能测试类型" class="headerlink" title="5.3 性能测试类型"></a>5.3 性能测试类型</h3><p>首先简单分析性能测试的压力模型。<br>如下图所示，随着单位时间压力的不断增长，被测系统和服务器的压力不断增加，TPS 会因为这些因素而发生变化，而且通常符合一下规律。</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2011.51.14.png" alt="5.3 性能曲线"></p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2011.51.53.png" alt="5.3 性能区间"></p><p>为得到性能关注的指标，基本分为以下性能测试类型：</p><ul><li><strong>性能测试（狭义）</strong><ul><li>说明：性能测试方法是通过模拟生产运行的业务压力量和使用场景组合，测试系统的性能是否满足生产性能要求。通俗地说，这种方法就是要在特定的运行条件下验证系统的能力状态。</li><li>特点： 1、这种方法的主要目的是验证系统是否有系统宣称具有的能力。 2、这种方法要事先了解被测试系统经典场景，并具有确定的性能目标。 3、这种方法要求在已经确定的环境下运行。 也就是说，这种方法是对系统性能已经有了解的前提，并对需求有明确的目标，并在已经确定的环境下进行的。</li></ul></li><li><strong>负载测试 (Load Test)</strong><ul><li>说明：通过在被测系统上不断加压，直到性能指标达到极限（例如 “响应时间”）超过预定指标或都某种资源已经达到饱和状态。　　</li><li>特点： 1、这种性能测试方法的主要目的是找到系统处理能力的极限。 2、这种性能测试方法需要在给定的测试环境下进行，通常也需要考虑被测试系统的业务压力量和典型场景、使得测试结果具有业务上的意义。 3、这种性能测试方法一般用来了解系统的性能容量，或是配合性能调优来使用。 也就是说，这种方法是对一个系统持续不段的加压，看你在什么时候已经超出 “我的要求” 或系统崩溃。</li></ul></li><li><strong>压力测试（强度测试）(Stress Test)</strong><ul><li>说明：压力测试方法测试系统在一定饱和状态下，例如 cpu、内存在饱和使用情况下，系统能够处理的会话能力，以及系统是否会出现错误</li><li>特点： 1、这种性能测试方法的主要目的是检查系统处于压力性能下时应用的表现。 2、这种性能测试一般通过模拟负载等方法，使得系统的资源使用达到较高的水平。 3、这种性能测试方法一般用于测试系统的稳定性。 也就是说，这种测试是让系统处在很大强度的压力之下，看系统是否稳定，哪里会出问题。</li></ul></li><li><strong>并发测试（Concurrency Testing）</strong><ul><li>说明：并发测试方法通过模拟用户并发访问，测试多用户并发访问同一个应用、同一个模块或者数据记录时是否存在死锁或其者他性能问题。</li><li>特点： 1、这种性能测试方法的主要目的是发现系统中可能隐藏的并发访问时的问题。 2、这种性能测试方法主要关注系统可能存在的并发问题，例如系统中的内存泄漏、线程锁和资源争用方面的问题。 3、这种性能测试方法可以在开发的各个阶段使用需要相关的测试工具的配合和支持。 也就是说，这种测试关注点是多个用户同时（并发）对一个模块或操作进行加压。</li></ul></li><li><strong>配置测试（Configuration Testing）</strong><ul><li>说明：配置测试方法通过对被测系统的软\硬件环境的调整，了解各种不同对系统的性能影响的程度，从而找到系统各项资源的最优分配原则。</li><li>特点： 1、这种性能测试方法的主要目的是了解各种不同因素对系统性能影响的程度，从而判断出最值得进行的调优操作。 2、这种性能测试方法一般在对系统性能状况有初步了解后进行。 3、这种性能测试方法一般用于性能调优和规划能力。 也就是说，这种测试关注点是 “微调”，通过对软硬件的不段调整，找出这他们的最佳状态，使系统达到一个最强的状态。</li></ul></li><li><strong>可靠性测试</strong><ul><li>说明：通过给系统加载一定业务压力（例如资源在 70%-90% 的使用率），使系统运行一段时间，以此检测系统是否稳定运行。</li><li>特点： 1、这种性能测试方法的主要目的是验证是否支持长期稳定的运行。 2、这种性能测试方法需要在压力下持续一段时间的运行。（2~3 天）3、测试过程中需要关注系统的运行状况。 如果测试过程中发现，随着时间的推移，响应时间有明显的变化，或是系统资源使用率有明显波动，都可能是系统不稳定的征兆。 也就是说，这种测试的关注点是 “稳定”，不需要给系统太大的压力，只要系统能够长期处于一个稳定的状态。</li></ul></li><li><strong>失效恢复测试</strong><ul><li>说明：如果系统局部发生故障，用户是否能够继续使用系统，以及如果这种情况发生，用户将受到多大程度的影响。</li><li>特点： 1.这种性能测试方法的主要目的是验证在局部故障情况下，系统能否继续使用。 2.这种性能测试方法还需要指出，当问题发生时，“能支持多少用户访问” 的结论和 “采取何种应急措施” 的方案。 3.一般来说，只有对系统持续运行指标有明确要求的系统才需要进行这种类型的测试。</li></ul></li><li><strong>大数据量测试</strong>：针对某些系统存储、传输、统计查询等业务进行大数据量的测试。</li></ul><p>注意：在做性能测试时请忘掉分类。例如，运行 8 个小时来测试系统是否可靠，而这个测试极有可能包含了可靠性能测、强度测试、并发测试、负载测试，等等。因此，在实施性能测试时决不能割裂它们的内部联系去进行，而应该基于测试目标，分析它们之间的关系，以一种高效率的方式来设计性能测试。</p><h3 id="5-4-性能测试流程"><a href="#5-4-性能测试流程" class="headerlink" title="5.4 性能测试流程"></a>5.4 性能测试流程</h3><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2011.53.28.png" alt="5.4 性能测试基本过程"></p><h4 id="（1）性能需求分析"><a href="#（1）性能需求分析" class="headerlink" title="（1）性能需求分析"></a>（1）性能需求分析</h4><p>性能需求分析是整个性能测试工作开展的基础，如果连性能的需求都没弄清楚，后面的性能测试工具以及执行就无从谈起了。<br>在这一阶段，性能测试人员需要与 PM、DEV 及项目相关的人员进行沟通，同时收集各种项目资料，对系统进行分析，确认测试的目标。并将其转化为可衡量的具体性能指标。<br>测试需求分析阶段的主要任务是分析被测系统及其性能需求，建立性能测试数据模型，分析性能需求，确定合理性能目标，并进行评审；</p><h4 id="（2）性能测试准备"><a href="#（2）性能测试准备" class="headerlink" title="（2）性能测试准备"></a>（2）性能测试准备</h4><p>主要包括：设计场景，根据场景编写程序、编写脚本、准备测试环境，构造测试数据，环境预调优等；<br>设计场景：针对系统的特点设计出合理的测试场景。为了让测试结果更加准确，这里需要很细致的工作。如建立用户模型，只有知道真实的用户是如何对系统产生压力，才可以设计出有代表性的压力测试场景。这就涉及到很多信息，如用户群的分布、各类型用户用到的功能、用户的使用习惯、工作时间段、系统各模块压力分布等等。只有从多方面不断的积累这种数据，才会让压力场景更有意义。最后将设计场景转换成具体的用例。<br>测试数据：测试数据的设计也是一个重点且容易出问题的地方。生成测试数据量达到未来预期数量只是最基础的一步，更需要考虑的是数据的分布是否合理，需要仔细的确认程序中使用到的各种查询条件，这些重点列的数值要尽可能的模拟真实的数据分布， 否则测试的结果可能是无效的。测试数据最好使用线上脱敏后的数据，尽可能接近真实用户行为。<br>预调优：指根据系统的特点和团队的经验，提前对系统的各个方面做一些优化调整，避免测试执行过程中的无谓返工。比如一个高并发的系统，10000 人在线，连接池和线程池的配置还用默认的，显然是会测出问题的。</p><h4 id="（3）执行性能测试"><a href="#（3）执行性能测试" class="headerlink" title="（3）执行性能测试"></a>（3）执行性能测试</h4><p>执行阶段工作主要包含两个方面的内容：一是执行测试用例模型，包括执行脚本和场景；其次测试过程监控，包括测试结果、记录性能指标和性能计数器的值</p><h4 id="（4）结果分析与性能调优"><a href="#（4）结果分析与性能调优" class="headerlink" title="（4）结果分析与性能调优"></a>（4）结果分析与性能调优</h4><p>发现问题或者性能指标达不到预期，及时的分析定位，处理后重复测试过程。<br>性能问题通常是相互关联相互影响的，表面上看到的现象很可能不是根本问题，而是另一处出现问题后引起的反应。这就要求监控收集数据时要全面，从多方面多个角度去判断定位。调优的过程其实也是一种平衡的过程，在系统的多个方面达到一个平衡即可。</p><h4 id="（5）性能报告与总结"><a href="#（5）性能报告与总结" class="headerlink" title="（5）性能报告与总结"></a>（5）性能报告与总结</h4><p>编写性能测试报告，阐明性能测试目标、性能结果、测试环境、数据构造规则、遇到的问题和解决办法等。并对此次性能测试经验进行总结与沉淀。具体性能测试报告的编写可以参考《性能测试报告模板》。<br>上面所有内容中，如果排除技术上的问题，性能测试中最难做好的，就是用户模型的分析。它直接决定了压力测试场景是否能够有效的模拟真实世界压力，而正是这种对真实压力的模拟，才使性能测试有了更大的意义。可以说，性能测试做到一定程度，差距就体现在了模型建立上。</p><p>至于性能问题的分析、定位或者调优，很大程度是一种技术问题，需要多方面的专业知识。数据库、操作系统、网络、开发都是一个合格的性能测试人员需要拥有的技能，只有这样，才能从多角度全方位的去考虑分析问题。</p><h2 id="6-性能工具性能对比"><a href="#6-性能工具性能对比" class="headerlink" title="6 性能工具性能对比"></a>6 性能工具性能对比</h2><p>测试对象：Nginx index.html(612Byte)，CPU:16 核 &#x2F; 内存:16GB &#x2F; 磁盘:500GB<br>压力机：Ubuntu18.04, CPU: 8 核 &#x2F; 内存：8G &#x2F; 磁盘: 500GB</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.14.49.png" alt="性能测试工具对比"></p><p>在此只进行了最基础的性能对比测试，仅供基本的工具选择判断。</p><h3 id="6-1-性能工具介绍"><a href="#6-1-性能工具介绍" class="headerlink" title="6.1 性能工具介绍"></a>6.1 性能工具介绍</h3><h4 id="ngrinder（待补充）"><a href="#ngrinder（待补充）" class="headerlink" title="ngrinder（待补充）"></a>ngrinder（待补充）</h4><p>阿里京东也在用，天生为分布式开发的，易用性很好</p><h4 id="wrk-x2F-wrk2"><a href="#wrk-x2F-wrk2" class="headerlink" title="wrk &#x2F; wrk2"></a>wrk &#x2F; wrk2</h4><p>wrk 是一款针对 Http 协议的基准测试工具，它能够在单机多核 CPU 的条件下，使用系统自带的高性能 I&#x2F;O 机制，如 epoll，kqueue 等，通过多线程和事件模式，对目标机器产生大量的负载。<br>PS: 其实，wrk 是复用了 redis 的 ae 异步事件驱动框架，准确来说 ae 事件驱动框架并不是 redis 发明的, 它来至于 Tcl 的解释器 jim, 这个小巧高效的框架, 因为被 redis 采用而被大家所熟知。</p><h5 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h5><p>轻量级性能测试工具;<br>安装简单（相对 Apache ab 来说）;<br>学习曲线基本为零，几分钟就能学会咋用了；<br>基于系统自带的高性能 I&#x2F;O 机制，如 epoll, kqueue, 利用异步的事件驱动框架，通过很少的线程就可以压出很大的并发量；</p><h5 id="劣势："><a href="#劣势：" class="headerlink" title="劣势："></a>劣势：</h5><p>wrk 目前仅支持单机压测，后续也不太可能支持多机器对目标机压测，因为它本身的定位，并不是用来取代 JMeter, LoadRunner 等专业的测试工具，wrk 提供的功能，对后端开发人员来说，应付日常接口性能验证还是比较友好的。<br>之前在乐视我们的测试架构师基于 wrk2 主导开发并支持了分布式，开发成本还是略高的。</p><h5 id="基础使用："><a href="#基础使用：" class="headerlink" title="基础使用："></a>基础使用：</h5><p>子命令参数说明：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs tex">使用方法: wrk &lt;选项&gt; &lt;被测HTTP服务的URL&gt;                            <br>  Options:                                            <br>    -c, --connections &lt;N&gt;  跟服务器建立并保持的TCP连接数量  <br>    -d, --duration    &lt;T&gt;  压测时间           <br>    -t, --threads     &lt;N&gt;  使用多少个线程进行压测（为了减少现成的上下文切换，官方建议thread数量等同CPU核数）  <br><br>    -s, --script      &lt;S&gt;  指定Lua脚本路径       <br>    -H, --header      &lt;H&gt;  为每一个HTTP请求添加HTTP头      <br>        --latency          在压测结束后，打印延迟统计信息   <br>        --timeout     &lt;T&gt;  超时时间     <br>    -v, --version          打印正在使用的wrk的详细版本信息<br><br>  &lt;N&gt;代表数字参数，支持国际单位 (1k, 1M, 1G)<br>  &lt;T&gt;代表时间参数，支持时间单位 (2s, 2m, 2h)<br></code></pre></td></tr></table></figure><blockquote><p>PS: 关于线程数，并不是设置的越大，压测效果越好，线程设置过大，反而会导致线程切换过于频繁，效果降低，一般来说，推荐设置成压测机器 CPU 核心数的 2 倍到 4 倍就行了。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">示例</span><br>wrk -c400 -t24 -d30s --latency http://10.60.82.91/<br></code></pre></td></tr></table></figure><p><strong>报告解析：</strong></p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs tex">Running 30s test @ http://www.baidu.com （压测时间30s）<br>  12 threads and 400 connections （共12个测试线程，400个连接）<br>                          （平均值） （标准差）  （最大值）（正负一个标准差所占比例）<br>  Thread Stats   Avg      Stdev     Max   +/- Stdev<br>    （延迟）<br>    Latency   386.32ms  380.75ms   2.00s    86.66<span class="hljs-comment">%</span><br>    (每秒请求数)<br>    Req/Sec    17.06     13.91   252.00     87.89<span class="hljs-comment">%</span><br>  Latency Distribution （延迟分布）<br>     50<span class="hljs-comment">%  218.31ms</span><br>     75<span class="hljs-comment">%  520.60ms</span><br>     90<span class="hljs-comment">%  955.08ms</span><br>     99<span class="hljs-comment">%    1.93s </span><br>  4922 requests in 30.06s, 73.86MB read (30.06s内处理了4922个请求，耗费流量73.86MB)<br>  Socket errors: connect 0, read 0, write 0, timeout 311 (发生错误数)<br>Requests/sec:    163.76 (QPS 163.76,即平均每秒处理请求数为163.76)<br>Transfer/sec:      2.46MB (平均每秒流量2.46MB)<br><br><br>Running 30s test @ http://10.60.82.91/ （压测时间30s）<br>  32 threads and 400 connections （共32个测试线程，400个连接）<br>              （平均值） （标准差）  （最大值）（正负一个标准差所占比例）<br>  Thread Stats   Avg      Stdev     Max   +/- Stdev<br>  Latency(延迟)  10.31ms   40.13ms 690.32ms   98.33<span class="hljs-comment">%</span><br>  Req/Sec(每秒请求数) 2.14k   482.15     6.36k    77.39<span class="hljs-comment">%</span><br>  Latency Distribution<br>     50<span class="hljs-comment">%    5.11ms</span><br>     75<span class="hljs-comment">%    7.00ms</span><br>     90<span class="hljs-comment">%    9.65ms</span><br>     99<span class="hljs-comment">%  212.68ms</span><br><br>  (30.10s内处理了2022092个请求，耗费流量1.62GB)<br>  2022092 requests in 30.10s, 1.62GB read<br>Requests/sec:  67183.02  (QPS 67183.02,即平均每秒处理请求数为67183.02)<br>Transfer/sec:     55.03MB (平均每秒流量55.03MB)<br></code></pre></td></tr></table></figure><h4 id="Jmeter"><a href="#Jmeter" class="headerlink" title="Jmeter"></a>Jmeter</h4><p>Jmeter 是 Java 开发的、基于多线程并发模型的压测工具，也是目前最流行的开源压测工具，工作原理类似，如下图：</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.17.07.png" alt="Jmeter"></p><ul><li>其所谓的虚拟用户 (vuser) 就是对应一个线程</li><li>在单个线程中，每个请求（query）都是同步调用的，下一个请求要等待前一个请求完成才能进行</li><li>一个请求（query）分成三部分：<ul><li>send - 施压端发送开始，直到承压端接收完成</li><li>wait - 承压端接收完成开始，直至业务处理结束</li><li>recv - 承压端返回数据，直至施压端接收完成</li></ul></li><li>同一线程中连续的两个请求之间存在等待时间这种概念，即图中的空白处</li></ul><p><strong>在多线程并发模型下，是不是可以通过不断增加线程数量生产出更大的压力？</strong><br>答案是否定的。</p><p>事实上一个进程在一个时间点只能执行一个线程，而所谓的并发是指在进程里不断切换线程实现了看上去的多个任务的并发，但是线程上下文切换有很高的成本，过多的线程数反而会造成性能的严重下滑。</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.17.55.png" alt="阻塞I/O模型"></p><p>从应用角度来看，基于多线程的并发模型，往往需要设置最大并发数参数，而如果压测场景需要不断往上加压，那这类工具其实挺难应付的。</p><h4 id="Locust"><a href="#Locust" class="headerlink" title="Locust"></a>Locust</h4><p>Locust 是用 Python 开发的分布式压测工具，近年来在国内比较流行。Locust 并不是基于 Python 的多线程，而是 coroutine（协程，gevent 提供），gevent 使用了 libev 或者 libuv 作为 eventloop。<br>Locust 响应时间失真问题：<br>Locust 当压力机 CPU 达到瓶颈后，响应时间会严重失真。<br>比如当 Locust normal 模式下，8 进程，CPU 瓶颈后，90% 响应时间为 340ms。同时 wrk 获取的响应时间为 59.41ms.</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.19.26.png" alt="Locust"></p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.20.07.png"></p><h5 id="基本使用介绍："><a href="#基本使用介绍：" class="headerlink" title="基本使用介绍："></a>基本使用介绍：</h5><p>装饰器 task 可以设置压力比例</p><ul><li><p>HttpUser 示例:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> locust <span class="hljs-keyword">import</span> HttpUser, task<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickstartUser</span>(<span class="hljs-title class_ inherited__">HttpUser</span>):<br>    <span class="hljs-comment"># task为每个正在运行的用户创建一个greenlet(微线程)</span><br><span class="hljs-meta">    @task(<span class="hljs-params"><span class="hljs-number">1</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">detail</span>(<span class="hljs-params">self</span>):<br>        self.client.get(<span class="hljs-string">&quot;http://10.60.82.91/&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure></li><li><p>FastHttpUser 示例</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> locust <span class="hljs-keyword">import</span> task<br><span class="hljs-keyword">from</span> locust.contrib.fasthttp <span class="hljs-keyword">import</span> FastHttpUser<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">QuickstartUser</span>(<span class="hljs-title class_ inherited__">FastHttpUser</span>):<br>    <span class="hljs-comment"># task为每个正在运行的用户创建一个greenlet(微线程)</span><br><span class="hljs-meta">    @task(<span class="hljs-params"><span class="hljs-number">1</span></span>)</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">detail</span>(<span class="hljs-params">self</span>):<br>        self.client.get(<span class="hljs-string">&quot;http://10.60.82.91/&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">on_start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure></li><li><p>启动及分布式</p>  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">-c 并发用户数</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-r 每秒启动用户数</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">-t 持续运行时间</span><br>locust -f load_test.py --host=http://10.60.82.91 --no-web -c 10 -r 10 -t 1m<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">分布式</span><br>nohup locust -f locust_files/fast_http_user.py --master &amp;<br>nohup locust -f locust_files/fast_http_user.py --worker --master-host=10.60.82.90 &amp;<br></code></pre></td></tr></table></figure></li></ul><h3 id="6-2-测试记录"><a href="#6-2-测试记录" class="headerlink" title="6.2 测试记录"></a>6.2 测试记录</h3><h4 id="wrk-测试记录"><a href="#wrk-测试记录" class="headerlink" title="wrk 测试记录"></a>wrk 测试记录</h4><p><strong>2 线程： -c1000 -t1（因最少 2 线程）QPS: 35560.79</strong></p><p>wrk -c1000 -t1 -d30s –latency <a href="http://10.60.82.91/">http://10.60.82.91/</a></p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.23.14.png" alt="wrk 2线程"></p><p><strong>3 线程：（ -c1000 -t2 QPS: 66941.77 ）</strong></p><p>wrk -c1000 -t2 -d30s –latency <a href="http://10.60.82.91/">http://10.60.82.91/</a></p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.24.02.png" alt="wrk 3线程"></p><p><strong>8 线程: ( -c1000 -t8 QPS: 75579.30 ）</strong></p><p>wrk -c1000 -t8 -d30s –latency <a href="http://10.60.82.91/">http://10.60.82.91/</a><br>Nginx: 86% * 16 &#x3D; 1376% ， 达到 CPU 瓶颈</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.24.42.png" alt="wrk 8线程"></p><p>Wrk: CPU &#x3D; 40% * 8 &#x3D; 320%</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.25.34.png"></p><h4 id="Locust-HttpUser-记录"><a href="#Locust-HttpUser-记录" class="headerlink" title="Locust HttpUser 记录"></a>Locust HttpUser 记录</h4><p><strong>1 进程：（10 并发，QPS：512）</strong></p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.26.09.png"></p><p>Nginx:（CPU：8.6%）</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.26.36.png"></p><p>Locust:（CPU：100%， 单核 CPU 达到瓶颈）</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.27.00.png"></p><h4 id="Locust-FastHttpUser-记录"><a href="#Locust-FastHttpUser-记录" class="headerlink" title="Locust FastHttpUser 记录"></a>Locust FastHttpUser 记录</h4><p><strong>1 进程：（10 并发，QPS：1836, 90%RT: 5ms）</strong></p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.27.30.png"></p><p>Nginx:（CPU：24%）</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.27.55.png"></p><p>Locust:（CPU：100%， 单核 CPU 达到瓶颈）</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.28.16.png"></p><p><strong>8 进程：（100 并发，QPS：11000, 90%RT: 7ms）</strong></p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.28.54.png"></p><p>Nginx:（CPU：150%）</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.29.23.png"></p><p>locust：（CPU：800%， CPU 达到瓶颈）</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.29.47.png"></p><h4 id="Jmeter-测试记录"><a href="#Jmeter-测试记录" class="headerlink" title="Jmeter 测试记录"></a>Jmeter 测试记录</h4><p><strong>8 核 (100 并发，QPS：38500)</strong></p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.30.41.png"></p><p>Nginx：（CPU：397.3%）</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.31.17.png"></p><p>Jmeter：（CPU：681%）</p><p><img src="https://www.cmdbyte.com/2021/%E6%88%AA%E5%B1%8F2021-08-09%2014.31.43.png"></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://my.oschina.net/leichen/blog/4399759">性能测试之并发模型对比 (Jmeter&#x2F;Locust&#x2F;Gatling)</a></li><li><a href="https://coolshell.cn/articles/17381.html">左耳朵耗子 - 性能测试应该怎么做？</a></li><li><a href="https://download.csdn.net/download/u011608531/13991206">Dynatrace-2016 全球零售业数字化性能基准报告</a></li><li><a href="https://download.csdn.net/download/u011608531/12792649">支付宝性能测试实战 剑风</a></li><li><a href="https://download.csdn.net/download/u011608531/12792619">网银在线性能测试指南（京东金融）</a></li><li><a href="https://juejin.cn/post/6844904094054744072">聊聊 ab、wrk、JMeter、Locust 这些压测工具的并发模型差别</a></li><li><a href="https://www.cnblogs.com/quanxiaoha/p/10661650.html">性能工具 wrk 介绍</a></li><li><a href="https://docs.locust.io/en/stable/installation.html">Locust 官方文档</a></li><li><a href="https://www.jianshu.com/p/50b6771eb853">mac 安装 locust 问题：解决 MacOS 升级后出现 xcrun: error: invalid active developer path, missing xcrun 的问题</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go为何没有max/min(int,int)函数</title>
    <link href="/2021/08/01/Go%E4%B8%BA%E4%BD%95%E6%B2%A1%E6%9C%89max-min-int-int-%E5%87%BD%E6%95%B0/"/>
    <url>/2021/08/01/Go%E4%B8%BA%E4%BD%95%E6%B2%A1%E6%9C%89max-min-int-int-%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>官方解释：<a href="https://mrekucci.blogspot.com/2015/07/dont-abuse-mathmax-mathmin.html">Don’t abuse math.Max &#x2F; math.Min | mrekucci’s blog</a></p><p>Go提供了 float64 类型的计算最大&#x2F;最小值的函数，但没有提供 int 系列类型的函数，通过官方解释总结起来就是：</p><ol><li>由于float64类型要处理 infinity 和 not-a-number 这种值，而他们的处理非常复杂，一般用户没有能力，所有go需要为用户提供系统级别的解决办法。</li><li>对于int&#x2F;int64类型的数据，min&#x2F;max的实现非常简单直接，用户完全可以自己实现，例如：</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Min</span><span class="hljs-params">(x, y <span class="hljs-type">int64</span>)</span></span> <span class="hljs-type">int64</span> &#123;<br>    <span class="hljs-keyword">if</span> x &lt; y &#123;<br>        <span class="hljs-keyword">return</span> x<br>    &#125;<br>    <span class="hljs-keyword">return</span> y<br>&#125;<br></code></pre></td></tr></table></figure><p>结论就是，这种 int 类的实现太简单，就交给用户实现了。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器socket: too many open files问题排查</title>
    <link href="/2021/08/01/%E6%9C%8D%E5%8A%A1%E5%99%A8socket-too-many-open-files%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/"/>
    <url>/2021/08/01/%E6%9C%8D%E5%8A%A1%E5%99%A8socket-too-many-open-files%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5/</url>
    
    <content type="html"><![CDATA[<h2 id="错误描述"><a href="#错误描述" class="headerlink" title="错误描述"></a>错误描述</h2><p><code>socket: too many open files</code></p><p>从字面意思上看就是说程序打开的文件数过多，不过这里的files不单是文件的意思，也包括打开的通讯连接(比如socket)，正在监听的端口等等，所以有时候也可以叫做句柄(handle)，这个错误通常也可以叫做句柄数超出系统限制。</p><p><strong>因此应该重点检查进程在某个时刻是否打开了超过系统限制的文件数量以及通讯连接数。</strong></p><h2 id="排查"><a href="#排查" class="headerlink" title="排查"></a>排查</h2><p>查看当前系统设置的最大句柄数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">ulimit</span> -a</span><br>core file size          (blocks, -c) unlimited<br>data seg size           (kbytes, -d) unlimited<br>scheduling priority             (-e) 0<br>file size               (blocks, -f) unlimited<br>pending signals                 (-i) 64033<br>max locked memory       (kbytes, -l) 64<br>max memory size         (kbytes, -m) unlimited<br>open files                      (-n) 65535<br>pipe size            (512 bytes, -p) 8<br>POSIX message queues     (bytes, -q) 819200<br>real-time priority              (-r) 0<br>stack size              (kbytes, -s) 8192<br>cpu time               (seconds, -t) unlimited<br>max user processes              (-u) 64033<br>virtual memory          (kbytes, -v) unlimited<br>file locks                      (-x) unlimited<br></code></pre></td></tr></table></figure><p><code>lsof | wc -l</code> 命令可以查看系统当前打开的句柄数量，执行时间较长</p><p>查看某个进程打开的句柄数量，用于检测是否打开了过多的句柄，开启的连接以及打开的文件没有关闭，都会导致输出的数值比较大：</p><p><code>lsof -p pid | wc -l</code></p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><h3 id="1-增大系统允许打开的句柄数量"><a href="#1-增大系统允许打开的句柄数量" class="headerlink" title="1. 增大系统允许打开的句柄数量"></a>1. 增大系统允许打开的句柄数量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">临时（重启系统会失效）</span><br>ulimit -n 4096 (注：非root用户最大开启4096个，如果需要更多，请用root用户)<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">永久生效（需要重启系统）</span><br>vim /etc/security/limits.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在最后加入</span><br>* soft nofile 4096  <br>* hard nofile 4096<br></code></pre></td></tr></table></figure><h3 id="2-检查程序问题"><a href="#2-检查程序问题" class="headerlink" title="2. 检查程序问题"></a>2. 检查程序问题</h3><p>如果你对程序打开的连接数量有一定的估算，在排查阶段发现打开的数值异常，可以将程序打开的句柄详情重定向都文件中进行分析。</p><p><code>lsof -p pid &gt; openfiles.log</code></p><blockquote><p>对于代码的检查：</p><p>a. 是否有必要打开这些文件</p><p>b. 是否打开或写入文件没有关闭连接</p><p>c. 通讯相关的连接是否没有关闭，或者没有设置超时结束机制</p><p>d. 是否在循环中不小心创建了大量的连接</p></blockquote><p>题外话：</p><blockquote><p>对于代码中使用的一些方法特性最好充分了解，比如Java 中的 post.releaseConnection()关闭连接，字面意思可能是关闭，但实际上这种关闭并没有真正关闭连接，而是将该连接提交给 MultiThreadedHttpConnectionManager，等待复用。<br>Close_wate需要延迟几秒钟才能关闭连接，而每个Socket连接都需要等待几秒钟，压力过大时，开启的Socket连接超过了系统所能承受的最大连接数（ulimit -u 1024），所以抛出Too many open files异常。</p></blockquote><p>最后，提醒一点，<strong>写代码一定要规范谨慎，认真斟酌！！！</strong></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell脚本之引入外部脚本文件</title>
    <link href="/2021/07/31/Shell%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <url>/2021/07/31/Shell%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    
    <content type="html"><![CDATA[<p>和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。</p><p>Shell 文件包含的语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">. filename   # 注意点号(.)和文件名中间有一空格<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或</span><br>source filename<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建t1.sh</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">vim t1.sh</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入</span><br>url=&quot;https://www.mofan.life&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建 t2.sh</span><br>vim t2.sh<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">输入</span><br>. t1.sh<br>echo &quot;Welcomt to $&#123;url&#125; ！！！&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行结果</span><br>Welcome to https://www.mofan.life ！！！<br></code></pre></td></tr></table></figure><p><strong>注：</strong> <em>被包含的文件 test1.sh 不需要可执行权限。</em></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell脚本之输入输出重定向</title>
    <link href="/2021/07/31/Shell%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <url>/2021/07/31/Shell%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E9%87%8D%E5%AE%9A%E5%90%91/</url>
    
    <content type="html"><![CDATA[<p>一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p><p>重定向一般通过在命令间插入特定的符号来实现。</p><p><strong>重定向符号列表如下：</strong></p><table><thead><tr><th align="left">命令</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">command &gt; file</td><td align="left">将输出重定向到 file，注意 file 中已存在的内容会被覆盖。</td></tr><tr><td align="left">command &lt; file</td><td align="left">将输入重定向到 file。</td></tr><tr><td align="left">command &gt;&gt; file</td><td align="left">将输出以追加的方式重定向到 file。</td></tr><tr><td align="left">n &gt; file</td><td align="left">将文件描述符为 n 的文件重定向到 file。</td></tr><tr><td align="left">n &gt;&gt; file</td><td align="left">将文件描述符为 n 的文件以追加的方式重定向到 file。</td></tr><tr><td align="left">n &gt;&amp; m</td><td align="left">将输出文件 m 和 n 合并。</td></tr><tr><td align="left">n &lt;&amp; m</td><td align="left">将输入文件 m 和 n 合并。</td></tr><tr><td align="left">&lt;&lt; tag</td><td align="left">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td></tr></tbody></table><blockquote><p><em>文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</em></p></blockquote><h4 id="输出重定向"><a href="#输出重定向" class="headerlink" title="输出重定向"></a>输出重定向</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将 <span class="hljs-built_in">who</span> 命令执行结果输出到 <span class="hljs-built_in">users</span> 文件中</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt; 会覆盖 <span class="hljs-built_in">users</span> 中已有的内容</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">who</span> &gt; <span class="hljs-built_in">users</span></span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> <span class="hljs-built_in">users</span></span><br>输出结果：<br>cyp      console  Jul 31 15:50<br>cyp      ttys000  Jul 31 18:39<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&gt;&gt; 将 <span class="hljs-built_in">who</span> 命令执行结果 追加 到 <span class="hljs-built_in">users</span> 文件中（在最后一行的下一行追加）</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">who</span> &gt;&gt; <span class="hljs-built_in">users</span></span><br></code></pre></td></tr></table></figure><h4 id="输入重定向"><a href="#输入重定向" class="headerlink" title="输入重定向"></a>输入重定向</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">统计<span class="hljs-built_in">users</span>文件中的行数(注意我执行了上面的 <span class="hljs-built_in">who</span> &gt;&gt; <span class="hljs-built_in">users</span>, 所以这里是4)</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">默认使用标准输入</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">wc</span> -l <span class="hljs-built_in">users</span></span><br>       4 users<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">采用输入重定向</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">wc</span> -l &lt; <span class="hljs-built_in">users</span></span><br>       4<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>上面第一个输出有 users，第二个没有，原因是第一个是标准输入，读取的是 users整个文件本身，所以结果里带着文件的名称，第二个是出入重定向，输入的是文件内的内容，所以只输出了文件里内容的行数。</p><h4 id="同时使用输入重定向与输出重定向"><a href="#同时使用输入重定向与输出重定向" class="headerlink" title="同时使用输入重定向与输出重定向"></a>同时使用输入重定向与输出重定向</h4><p>格式：<code>command1 &lt; infile &gt; outfile</code></p><p>从 infile 中读取内容，将结果写入 outfile。注意 <code>&gt;</code> 也可以替换成<code>&gt;&gt;</code> 进行追加。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash"> 继续使用<span class="hljs-built_in">users</span>，读取<span class="hljs-built_in">users</span>内容，输出到nums</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">wc</span> -l &lt; <span class="hljs-built_in">users</span> &gt; nums</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> <span class="hljs-built_in">users</span></span><br>cyp      console  Jul 31 15:50<br>cyp      ttys000  Jul 31 18:39<br>cyp      console  Jul 31 15:50<br>cyp      ttys000  Jul 31 18:39<br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cat</span> nums</span><br>       4<br></code></pre></td></tr></table></figure><h4 id="重定向深入理解"><a href="#重定向深入理解" class="headerlink" title="重定向深入理解"></a>重定向深入理解</h4><p>一般情况下，每个 Unix&#x2F;Linux 命令运行时都会打开三个文件：</p><ul><li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li></ul><p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将 stderr 重定向到 err_file</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">command</span> 2&gt;err_file</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者追加</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">command</span> 2&gt;&gt;err_file</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将 stderr 与 stdout 合并后追加到 outfile</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">command</span> &gt; file 2&gt;&amp;1</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者追加</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">command</span> &gt;&gt; file 2&gt;&amp;1</span><br></code></pre></td></tr></table></figure><blockquote><p><em>这里的</em> <strong>2</strong> <em>和</em> <strong>&gt;</strong> <em>之间不可以有空格，</em><strong>2&gt;</strong> <em>是一体的时候才表示错误输出。</em></p></blockquote><h4 id="Here-Document"><a href="#Here-Document" class="headerlink" title="Here Document"></a>Here Document</h4><p>Here Document 是 Shell 中的一种特殊的重定向方式，用来将<strong>输入重定向到一个交互式 Shell 脚本或程序</strong>。</p><p>形式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">command &lt;&lt; delimiter<br>    document<br>delimiter<br></code></pre></td></tr></table></figure><p>作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。</p><blockquote><p><strong>注意：</strong></p><ul><li>shell脚本文件中结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。</li><li>开始的delimiter前后的空格会被忽略掉。</li></ul></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">把上面输入重定向那块的内容拷贝过来作为输入</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">wc</span> -l &lt;&lt; <span class="hljs-string">EOF</span></span><br><span class="hljs-meta prompt_">heredoc&gt; </span><span class="language-bash"><span class="hljs-string">cyp      console  Jul 31 15:50</span></span><br>cyp      ttys000  Jul 31 18:39<br>cyp      console  Jul 31 15:50<br>cyp      ttys000  Jul 31 18:39<br><span class="hljs-meta prompt_">heredoc&gt; </span><span class="language-bash"><span class="hljs-string">EOF</span></span><br>       4<br></code></pre></td></tr></table></figure><h4 id="x2F-dev-x2F-null-文件"><a href="#x2F-dev-x2F-null-文件" class="headerlink" title="&#x2F;dev&#x2F;null 文件"></a>&#x2F;dev&#x2F;null 文件</h4><p>&#x2F;dev&#x2F;null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 &#x2F;dev&#x2F;null 文件非常有用，将命令的输出重定向到它，会起到”禁止输出”的效果。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">不想在屏幕上显示输出结果</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">command</span> &gt; /dev/null</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">屏蔽 stdout 和 stderr</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">command</span> &gt; /dev/null 2&gt;&amp;1</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell脚本之函数</title>
    <link href="/2021/07/31/Shell%E5%87%BD%E6%95%B0/"/>
    <url>/2021/07/31/Shell%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<p>Shell中函数的定义如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ function ] funname [()]<br><br>&#123;<br><br>    action;<br><br>    [return int;]<br><br>&#125;<br></code></pre></td></tr></table></figure><p>说明：</p><ul><li>1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li><li>2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令<strong>运行结果</strong>，作为返回值。要特别注意这里的<strong>运行结果</strong>，不是执行后返回的结果，函数的返回值只能是 0～255 之间的值，因此，函数与命令的执行结果可以作为条件语句使用，要注意的是，和 C 语言不同，shell 语言中 0 代表 true，0 以外的值代表 false。</li></ul><h3 id="带有-return-的函数"><a href="#带有-return-的函数" class="headerlink" title="带有 return 的函数"></a>带有 return 的函数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">funWithReturn()&#123;<br>    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;<br>    echo &quot;输入第一个数字: &quot;<br>    read aNum<br>    echo &quot;输入第二个数字: &quot;<br>    read anotherNum<br>    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;<br>    return $(($aNum+$anotherNum))<br>&#125;<br>funWithReturn<br>echo &quot;输入的两个数字之和为 $? !&quot;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">这个函数会对输入的两个数字进行相加运算...<br>输入第一个数字: <br>1<br>输入第二个数字: <br>2<br>两个数字分别为 1 和 2 !<br>输入的两个数字之和为 3 !<br></code></pre></td></tr></table></figure><p>函数返回值在调用该函数后通过 <code>$?</code> 来获得。<code>$?</code> 仅对其上一条指令负责，一旦函数返回后其返回值没有立即保存入参数，那么其返回值将不再能通过 <code>$?</code> 获得。</p><blockquote><p>你可能对这两个数字的和有疑问，因为返回值显示的数字范围只能是 0~255，那是否意味着它只能计算结果为 255 以内的值呢，答案不是，对于结果超出 255 的值，它返回的值为: 结果 - 256 。</p></blockquote><p>注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 $n 的形式来获取参数的值，例如，$1表示第一个参数，$2表示第二个参数…，注意，当调用第10个及以上参数的时候，要加<code>&#123;&#125;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">funWithParam()&#123;<br>    echo &quot;第一个参数为 $1 !&quot;<br>    echo &quot;第二个参数为 $2 !&quot;<br>    echo &quot;第十个参数为 $10 !&quot;<br>    echo &quot;第十个参数为 $&#123;10&#125; !&quot;<br>    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;<br>    echo &quot;参数总数有 $# 个!&quot;<br>    echo &quot;作为一个字符串输出所有参数 $* !&quot;<br>&#125;<br>funWithParam 1 2 3 4 5 6 7 8 9 34 73<br></code></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">第一个参数为 1 !<br>第二个参数为 2 !<br>第十个参数为 10 !<br>第十个参数为 34 !<br>第十一个参数为 73 !<br>参数总数有 11 个!<br>作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !<br></code></pre></td></tr></table></figure><p>另外，还有几个特殊字符用来处理参数：</p><table><thead><tr><th align="left">参数处理</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">$#</td><td align="left">传递到脚本或函数的参数个数</td></tr><tr><td align="left">$*</td><td align="left">以一个单字符串显示所有向脚本传递的参数</td></tr><tr><td align="left">$$</td><td align="left">脚本运行的当前进程ID号</td></tr><tr><td align="left">$!</td><td align="left">后台运行的最后一个进程的ID号</td></tr><tr><td align="left">$@</td><td align="left">与$*相同，但是使用时加引号，并在引号中返回每个参数。</td></tr><tr><td align="left">$-</td><td align="left">显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td align="left">$?</td><td align="left">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell">function func() &#123;<br>    echo &quot;传入的参数个数为: $# &quot;<br>    echo &quot;用一个字符串显示传入的参数: $* &quot;<br>    echo &quot;脚本当前运行的进程ID为：$$ &quot;<br>    echo &quot;后台运行的最后一个进程ID为: $! &quot;<br>    echo &quot;传入的每个参数为: $&#123;@&#125; &quot;<br>    echo &quot;Shell当前使用的选项为: $- &quot;<br>&#125;<br><br>func 1 2 3 &quot;hello&quot; &quot;world&quot;<br>echo &quot;最后命令的退出状态为: $? &quot;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">传入的参数个数为: 5<br>用一个字符串显示传入的参数: 1 2 3 hello world<br>脚本当前运行的进程ID为：3377<br>后台运行的最后一个进程ID为:<br>传入的每个参数为: 1 2 3 hello world<br>Shell当前使用的选项为: hB<br>最后命令的退出状态为: 0<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell脚本之流程控制</title>
    <link href="/2021/07/31/Shell%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2021/07/31/Shell%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="if-条件语句"><a href="#if-条件语句" class="headerlink" title="if 条件语句"></a>if 条件语句</h2><p><code>if</code> 的语法结构为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">if condition1<br>then<br>    command1<br>elif condition2 <br>then <br>    command2<br>else<br>    commandN<br>fi<br></code></pre></td></tr></table></figure><p><strong>注意：</strong> if 的流程控制不可为空，即符合条件的区域必须有内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=10<br>b=20<br>if [ $a == $b ]<br>then<br>   echo &quot;a 等于 b&quot;<br>elif [ $a -gt $b ]<br>then<br>   echo &quot;a 大于 b&quot;<br>elif [ $a -lt $b ]<br>then<br>   echo &quot;a 小于 b&quot;<br>else<br>   echo &quot;没有符合的条件&quot;<br>fi<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">a 小于 b<br></code></pre></td></tr></table></figure><p><code>if</code> 语句常和 <code>test</code> 搭配使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">num1=$[2*3]<br>num2=$[1+5]<br>if test $[num1] -eq $[num2]<br>then<br>    echo &#x27;两个数字相等!&#x27;<br>else<br>    echo &#x27;两个数字不相等!&#x27;<br>fi<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tex">两个数字相等!<br></code></pre></td></tr></table></figure><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><h3 id="for-in-循环"><a href="#for-in-循环" class="headerlink" title="for in 循环"></a>for in 循环</h3><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">for var in item1 item2 ... itemN<br>do<br>    command1<br>    command2<br>    ...<br>    commandN<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">也可以写成一行</span><br>for var in item1 item2 ... itemN; do command1; command2… done;<br></code></pre></td></tr></table></figure><p>in 列表可选，如果省略，for 循环将使用命令行的位置参数。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">for loop in 1 2 3 4 5<br>do<br>    echo &quot;The value is: $loop&quot;<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">顺序输出字符串中的字串</span><br>for str in This is a string<br>do<br>    echo $str<br>done<br></code></pre></td></tr></table></figure><h3 id="for-循环-1"><a href="#for-循环-1" class="headerlink" title="for(()) 循环"></a>for(()) 循环</h3><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">for((初始值;条件;计算));do<br>    commnd<br>done;<br></code></pre></td></tr></table></figure><p>通常情况下 shell 变量调用需要加 $,但是 for 的 (()) 中不需要。</p><h2 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h2><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">while condition<br>do<br>    command<br>done<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">int=1<br>while(( $int&lt;=5 ))<br>do<br>    echo $int<br>    let &quot;int++&quot;<br>done<br></code></pre></td></tr></table></figure><blockquote><p>上面例子使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量</p></blockquote><p>while 可用于读取键盘信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;按下 &lt;CTRL-D&gt; 退出&#x27;<br>echo -n &#x27;输入你最喜欢的网站名: &#x27;<br>while read FILM<br>do<br>    echo &quot;是的！$FILM 是一个好网站&quot;<br>done<br></code></pre></td></tr></table></figure><h2 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h2><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">while :<br>do<br>    command<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">or</span><br><br>while true<br>do<br>    command<br>done<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">or</span><br>for (( ; ; ))<br></code></pre></td></tr></table></figure><h2 id="util-循环"><a href="#util-循环" class="headerlink" title="util 循环"></a>util 循环</h2><p>until 循环执行一系列命令直至条件为 true 时停止。用的较少，一般用 while 即可</p><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">until condition<br>do<br>    command<br>done<br></code></pre></td></tr></table></figure><p>输出 0 ～ 9 之间的数字：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=0<br><br>until [ ! $a -lt 10 ]<br>do<br>   echo $a<br>   a=`expr $a + 1`<br>done<br></code></pre></td></tr></table></figure><h2 id="case-多分支选择结构"><a href="#case-多分支选择结构" class="headerlink" title="case 多分支选择结构"></a>case 多分支选择结构</h2><p><strong>case … esac</strong> 为多选择语句，与其他语言中的 switch … case 语句类似，是一种多分枝选择结构。</p><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">case 值 in<br>模式1)<br>    command1<br>    command2<br>    ...<br>    commandN<br>    ;;<br>模式2）<br>    command1<br>    command2<br>    ...<br>    commandN<br>    ;;<br>esac<br></code></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><p>1.case 取值后面必须为单词 <strong>in</strong></p><p>2.每个 case 分支用<strong>右圆括号</strong>开始</p><p>3.用两个分号 <strong>;;</strong> 表示 break，即执行结束，跳出整个 case … esac 语句</p><p>4.esac（就是 case 反过来）作为结束标记。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;输入 1 到 4 之间的数字:&#x27;<br>echo &#x27;你输入的数字为:&#x27;<br>read aNum<br>case $aNum in<br>    1)  echo &#x27;你选择了 1&#x27;<br>    ;;<br>    2)  echo &#x27;你选择了 2&#x27;<br>    ;;<br>    3)  echo &#x27;你选择了 3&#x27;<br>    ;;<br>    4)  echo &#x27;你选择了 4&#x27;<br>    ;;<br>    *)  echo &#x27;你没有输入 1 到 4 之间的数字&#x27;<br>    ;;<br>esac<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入 1 到 4 之间的数字:<br>你输入的数字为:<br>3<br>你选择了 3<br></code></pre></td></tr></table></figure><h2 id="break-与-continue-循环控制语句"><a href="#break-与-continue-循环控制语句" class="headerlink" title="break 与 continue 循环控制语句"></a>break 与 continue 循环控制语句</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>break 终止整个循环。</p><p>开启一个死循环，直到用户输入数字大于 5，则结束循环。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">while :<br>do<br>    echo -n &quot;输入 1 到 5 之间的数字:&quot;<br>    read aNum<br>    case $aNum in<br>        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;<br>        ;;<br>        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;<br>            break<br>        ;;<br>    esac<br>done<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs tex">输入 1 到 5 之间的数字:3<br>你输入的数字为 3!<br>输入 1 到 5 之间的数字:7<br>你输入的数字不是 1 到 5 之间的! 游戏结束<br></code></pre></td></tr></table></figure><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>与 break 不同，continue 仅仅跳过当前循环中后面的语句，不会终止整个循环。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">while :<br>do<br>    echo -n &quot;输入 1 到 5 之间的数字: &quot;<br>    read aNum<br>    case $aNum in<br>        1|2|3|4) echo &quot;你输入的数字为 $aNum!&quot;<br>        ;;<br>        5) echo &quot;你输入的数字是5!&quot;<br>            continue<br>            echo &quot;游戏结束&quot;<br>        ;;<br>    esac<br>done<br></code></pre></td></tr></table></figure><p>你会发现，无论你输入什么数字，”游戏结束”这四个字都不会输出。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell脚本之变量</title>
    <link href="/2021/07/31/Shell%E5%8F%98%E9%87%8F/"/>
    <url>/2021/07/31/Shell%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>单行注释 <code>#</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">hello, world</span><br></code></pre></td></tr></table></figure><p>多行注释</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">:&lt;&lt;EOF<br>内容1...<br>内容2...<br>内容3...<br>EOF<br></code></pre></td></tr></table></figure><p>EOF 也可以只用别的符号代替。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="定义变量"><a href="#定义变量" class="headerlink" title="定义变量"></a>定义变量</h3><p>关于 Shell 的变量，首先记住两点：一是定义不加 <code>$</code>，使用才加；二是 <code>=</code> 两边没空格。</p><p>另外，只需稍加注意下变量名的命名规则：</p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线 <code>_</code>。</li><li>不能使用标点符号。</li><li>不能使用bash里的关键字（可用help命令查看保留关键字）。</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 有效变量</span><br>ABCD<br>A_B_C<br>_abcd<br>abc123<br><br><span class="hljs-comment"># 无效变量</span><br>?ABc<br>a*b=abc<br></code></pre></td></tr></table></figure><p>除了使用显示赋值，还可以使用语句给变量赋值：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下面是将 /etc 目录下的文件名循环出来，file 变量代表命令执行结果中的元素</span><br>for file in `ls /etc`<br>或<br>for file in $(ls /etc)<br></code></pre></td></tr></table></figure><h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3><p>变量的使用只需在变量前加上 <code>$</code> 即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">my_name=&quot;mofan&quot;<br><br>echo $my_name<br>或<br>echo $&#123;my_name&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">&#123;&#125;是可选的，主要是帮助解释器识别边界，例如下面，不加会引发错误。</span><br>for skill in Ada Coffe Action Java; do<br>    echo &quot;I am good at $&#123;skill&#125;Script&quot;<br>done<br></code></pre></td></tr></table></figure><h3 id="重新定义变量"><a href="#重新定义变量" class="headerlink" title="重新定义变量"></a>重新定义变量</h3><p>已定义变量可以重新定义，但要记住，定义变量不加 <code>$</code>，使用才加。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">your_name=&quot;baitong&quot;<br>echo $your_name<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">变量重新定义</span><br>your_name=&quot;geekbyte&quot;<br>echo $your_name<br></code></pre></td></tr></table></figure><h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3><p>通过<code>readonly var1 var2 var3</code>指定哪些变量只读。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">定义只读变量</span><br>my_name=&quot;mofan&quot;<br>readonly my_name<br>my_name=&quot;mofankk&quot;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">发生错误： /bin/sh: NAME: This variable is <span class="hljs-built_in">read</span> only.</span><br></code></pre></td></tr></table></figure><h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3><p>通过<code>unset var1 var2 var3</code>指定删除哪些变量。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">a=&quot;abc&quot;<br>b=&quot;bcd&quot;<br>unset a b<br>echo $a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出一个空行</span><br></code></pre></td></tr></table></figure><h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3><p>运行shell时，会同时存在三种变量：</p><ul><li><strong>局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li><li><strong>环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li><li><strong>shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>对于字符串的定义，可以用单引号、双引号，也可以不用引号。</p><p>单引号和双引号定义字符串存在一些区别：</p><ul><li>单引号对字符串的限制<ul><li>单引号中的<strong>任何字符</strong>都会<strong>原样输出</strong>，所以，单引号中的变量是无效的，会被原样输出。</li><li>单引号字符串中不能出现单独的单引号（使用转义字符也不行），但可出现成对的单引号。</li></ul></li><li>双引号<ul><li>双引号里可以有变量</li><li>双引号里可以出现转义字符</li></ul></li></ul><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">my_name=&quot;mofan&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用双引号拼接</span><br>str_a=&quot;hello, &quot;$my_name&quot;!&quot;<br>str_b=&quot;hello, $&#123;my_name&#125;!&quot;<br>echo $str_a $str_b<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用单引号拼接 （重点关注下这两个的输出结果）</span><br>str_c=&#x27;hello, &#x27;$my_name&#x27;!&#x27;<br>str_d=&#x27;hello, $&#123;my_name&#125;!&#x27;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tex">hello, mofan! hello, mofan!<br>hello, mofan! hello, <span class="hljs-built_in">$</span>&#123;my<span class="hljs-built_in">_</span>name&#125;!<br></code></pre></td></tr></table></figure><h3 id="获取字符串长度"><a href="#获取字符串长度" class="headerlink" title="获取字符串长度"></a>获取字符串长度</h3><p>注意，这里不是用<code>len</code> <code>length</code> 等获取，而是用 <code>#</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">str=&quot;hello,world&quot;<br>echo $&#123;#str&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出 11</span><br></code></pre></td></tr></table></figure><h3 id="提取子字符串"><a href="#提取子字符串" class="headerlink" title="提取子字符串"></a>提取子字符串</h3><p>格式：<code>$&#123;变量名:起始值:结束值&#125;</code></p><p>注意字符串字符的位置从<code>0</code>开始计算。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">str=&quot;hello,world&quot;<br>echo $&#123;str:6:11&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">输出 world</span><br></code></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>数组定义在一行的，要用 空格 分隔。形式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell">arr=(val0 val1 val2 val3)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或</span><br>arr=(<br>val0<br>val1<br>val2<br>val3<br>)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">或 单独定义数组的各个分量，下标可以不连续，而且没有范围</span><br>arr[0]=val0<br>arr[1]=val1<br>arr[n]=valn<br></code></pre></td></tr></table></figure><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;数组名[下标]&#125;</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">读取全部元素，用 @ 或 *</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;数组名[@]&#125;</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">or</span><br><span class="hljs-meta prompt_">$</span><span class="language-bash">&#123;数组名[*]&#125;</span><br></code></pre></td></tr></table></figure><h3 id="获取数组长度"><a href="#获取数组长度" class="headerlink" title="获取数组长度"></a>获取数组长度</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">len=$&#123;#数组名[@]&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">or</span><br>len=$&#123;#数组名[*]&#125;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">读取数组里单个元素的长度</span><br>len=$&#123;#数组名[下标]&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell脚本编程基本介绍</title>
    <link href="/2021/07/31/Shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/07/31/Shell%E8%84%9A%E6%9C%AC%E5%9F%BA%E6%9C%AC%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Shell 是一个用 C语言 编写的程序，它是我们使用 Linux 的桥梁。</p><p>Shell 既是一种命令语言，又是一种程序设计语言。</p><p>Shell 是指一个应用程序，这个应用程序提供了一个页面，用户通过这个页面访问操作系统内核服务。</p><p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p><h2 id="Shell-脚本"><a href="#Shell-脚本" class="headerlink" title="Shell 脚本"></a>Shell 脚本</h2><p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序。</p><p>业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。</p><p>由于习惯的原因，简洁起见，本文出现的 “shell编程” 都是指 shell 脚本编程，不是指开发 shell 自身。</p><h2 id="Shell-环境"><a href="#Shell-环境" class="headerlink" title="Shell 环境"></a>Shell 环境</h2><p>Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><p>Linux 的 Shell 种类众多，常见的有：</p><ul><li>Bourne Shell（&#x2F;usr&#x2F;bin&#x2F;sh或&#x2F;bin&#x2F;sh）</li><li>Bourne Again Shell（&#x2F;bin&#x2F;bash）</li><li>C Shell（&#x2F;usr&#x2F;bin&#x2F;csh）</li><li>K Shell（&#x2F;usr&#x2F;bin&#x2F;ksh）</li><li>Shell for Root（&#x2F;sbin&#x2F;sh）</li><li>……</li></ul><p>本教程关注的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。</p><p>在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 <strong>#!&#x2F;bin&#x2F;sh</strong>，它同样也可以改为 <strong>#!&#x2F;bin&#x2F;bash</strong>。</p><p><strong>#!</strong> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。</p><h2 id="第一个-Shell-脚本"><a href="#第一个-Shell-脚本" class="headerlink" title="第一个 Shell 脚本"></a>第一个 Shell 脚本</h2><p>打开文本编辑器(可以使用 vi&#x2F;vim 命令来创建文件)，新建一个文件 test.sh，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello World !&quot;</span><br></code></pre></td></tr></table></figure><p><strong>#!</strong> 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。</p><p>echo 命令用于向窗口输出文本。</p><h2 id="运行-Shell-脚本"><a href="#运行-Shell-脚本" class="headerlink" title="运行 Shell 脚本"></a>运行 Shell 脚本</h2><p>运行 Shell 脚本有两种方法。</p><p><strong>1、作为可执行程序</strong></p><p>将上面的代码保存为 test.sh，并 cd 到相应目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">chmod</span> +x ./test.sh  <span class="hljs-comment">#使脚本具有执行权限</span><br>./test.sh  <span class="hljs-comment">#执行脚本</span><br></code></pre></td></tr></table></figure><p>注意，一定要写成 <strong>.&#x2F;test.sh</strong>，而不是 <strong>test.sh</strong>，运行其它二进制的程序也一样，直接写 test.sh，linux 系统会去 PATH 里寻找有没有叫 test.sh 的，而只有 &#x2F;bin, &#x2F;sbin, &#x2F;usr&#x2F;bin，&#x2F;usr&#x2F;sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 test.sh 是会找不到命令的，要用 .&#x2F;test.sh 告诉系统说，就在当前目录找。</p><p><strong>2、作为解释器参数</strong></p><p>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/bin/</span>sh test.sh<br><span class="hljs-regexp">/bin/</span>php test.php<br></code></pre></td></tr></table></figure><p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP header中Content-type的值</title>
    <link href="/2021/07/30/HTTP-header%E4%B8%ADContent-type%E7%9A%84%E5%80%BC/"/>
    <url>/2021/07/30/HTTP-header%E4%B8%ADContent-type%E7%9A%84%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>HTTP header中的Content-type也称之为Media Types。</p><p>在返回体中，用于告诉客户端返回的数据类型，常见的类型比如JSON(“Content-type”:”application&#x2F;json”)</p><p>反之，在请求体中用于告诉服务端发送的数据类型。</p><p>在实际应用中，最好为传输的数据确定一个粒度最小的类型。比如在下载一个xxx.tar.gz文件时，我们可以使用”application&#x2F;octet-stream”，这个用于表示传输的是二进制数据，但是范围表示的太大，这个类型定义在RFC 1341，但是目前已经被移除了。对于这种gzip文件，我们可以指定”application&#x2F;gzip”。</p><p>下面是所有的Media Type类型，如果有需要可以查找具体的文件类型，粒度很细。</p><p><a href="https://www.iana.org/assignments/media-types/media-types.xhtml">Media Types</a><br><a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type">Content-Type - HTTP | MDN</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go执行Shell脚本或调用外部脚本文件</title>
    <link href="/2021/07/28/Go%E6%89%A7%E8%A1%8CShell%E8%84%9A%E6%9C%AC%E6%88%96%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6/"/>
    <url>/2021/07/28/Go%E6%89%A7%E8%A1%8CShell%E8%84%9A%E6%9C%AC%E6%88%96%E8%B0%83%E7%94%A8%E5%A4%96%E9%83%A8%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<p>在需要对文件进行操作的一些场景，比如文件合并，计算文件hash或大小，除了可以完全使用golang来处理，也可以借助外部shell或bash来完成。shell是应用程序和linux内核之间的接口程序，而bash可简单理解为shell的加强版，支持更多的命令；通过bash来完成运维相关的工作是比较常见的场景，设计到文件的处理更是常态。<br>因此大多数情况下，golang调用外部shell来处理文件也是合理的做法。以下是一个简单的例子，提供几个工具方法：计算文件sha1、大小、合并文件等。详细参考代码如下所示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> util<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os/exec&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;strings&quot;</span><br><span class="hljs-string">&quot;regexp&quot;</span><br>)<br><br><span class="hljs-comment">// 以下合并操作适用于linux平台</span><br><br><span class="hljs-keyword">const</span> (<br><span class="hljs-comment">// 通过shell合并分块文件</span><br>MERGE_FILE_CMD = <span class="hljs-string">`</span><br><span class="hljs-string">#!/bin/bash</span><br><span class="hljs-string"># 需要进行合并的分片所在的目录</span><br><span class="hljs-string">chunkDir=$1</span><br><span class="hljs-string"># 合并后的文件的完成路径(目录＋文件名)</span><br><span class="hljs-string">mergePath=$2</span><br><span class="hljs-string"></span><br><span class="hljs-string">echo &quot;分块合并，输入目录: &quot; $chunkDir</span><br><span class="hljs-string"></span><br><span class="hljs-string">if [ ! -f $mergePath ]; then</span><br><span class="hljs-string">echo &quot;$mergePath not exist&quot;</span><br><span class="hljs-string">else</span><br><span class="hljs-string">rm -f $mergePath</span><br><span class="hljs-string">fi</span><br><span class="hljs-string"></span><br><span class="hljs-string">for chunk in $(ls $chunkDir | sort -n)</span><br><span class="hljs-string">do</span><br><span class="hljs-string">cat $chunkDir/$&#123;chunk&#125; &gt;&gt; $&#123;mergePath&#125;</span><br><span class="hljs-string">done</span><br><span class="hljs-string"></span><br><span class="hljs-string">echo &quot;合并完成，输出：&quot; mergePath</span><br><span class="hljs-string">`</span><br><br><span class="hljs-comment">// 计算文件sha1值</span><br>FILE_SHA1SUM_CMD = <span class="hljs-string">`</span><br><span class="hljs-string">#!/bin/bash</span><br><span class="hljs-string">sha1sum $1 | awk &#x27;&#123;print $1&#125;&#x27;</span><br><span class="hljs-string">`</span><br><br><span class="hljs-comment">// 计算文件大小</span><br>FILE_SIZE_CMD = <span class="hljs-string">`</span><br><span class="hljs-string">#!/bin/bash</span><br><span class="hljs-string">ls -l $1 | awk &#x27;&#123;print $5&#125;&#x27;</span><br><span class="hljs-string">`</span><br>)<br><br><span class="hljs-comment">// ComputeFileSizeByShell: 通过调用shell来计算文件大小</span><br><span class="hljs-comment">// @return  (string, error): (文件hash, 错误信息)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ComputeFileSizeByShell</span><span class="hljs-params">(destPath <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>cmdStr := strings.Replace(FILE_SIZE_CMD, <span class="hljs-string">&quot;$1&quot;</span>, destPath, <span class="hljs-number">1</span>)<br>fSizeCmd := exec.Command(<span class="hljs-string">&quot;bash&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, cmdStr)<br><span class="hljs-keyword">if</span> fSizeStr, err := fSizeCmd.Output(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>, err<br>&#125;  <span class="hljs-keyword">else</span> &#123;<br>reg := regexp.MustCompile(<span class="hljs-string">&quot;\\s+&quot;</span>)<br>fSize, err := strconv.Atoi(reg.ReplaceAllString(<span class="hljs-type">string</span>(fSizeStr), <span class="hljs-string">&quot;&quot;</span>))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> fSize, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// ComputeSha1ByShell: 通过调用shell来计算文件sha1</span><br><span class="hljs-comment">// @return  (string, error): (文件hash, 错误信息)</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ComputeSha1ByShell</span><span class="hljs-params">(destPath <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">error</span>) &#123;<br>cmdStr := strings.Replace(FILE_SHA1SUM_CMD, <span class="hljs-string">&quot;$1&quot;</span>, destPath, <span class="hljs-number">1</span>)<br>hashCmd := exec.Command(<span class="hljs-string">&quot;bash&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, cmdStr)<br><span class="hljs-keyword">if</span> filehash, err := hashCmd.Output(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;  <span class="hljs-keyword">else</span> &#123;<br>reg := regexp.MustCompile(<span class="hljs-string">&quot;\\s+&quot;</span>)<br><span class="hljs-keyword">return</span> reg.ReplaceAllString(<span class="hljs-type">string</span>(filehash), <span class="hljs-string">&quot;&quot;</span>), <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br><br><span class="hljs-comment">// MergeChuncksByShell: 通过调用shell来合并文件分块，分块文件名须有序 (如分块名分别为: 1, 2, 3, ...)</span><br><span class="hljs-comment">// @return bool: 合并成功将返回true, 否则返回false</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MergeChuncksByShell</span><span class="hljs-params">(chunkDir <span class="hljs-type">string</span>, destPath <span class="hljs-type">string</span>, fileSha1 <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-comment">// 合并分块</span><br>cmdStr := strings.Replace(MERGE_FILE_CMD, <span class="hljs-string">&quot;$1&quot;</span>, chunkDir, <span class="hljs-number">1</span>)<br>cmdStr = strings.Replace(cmdStr, <span class="hljs-string">&quot;$2&quot;</span>, destPath, <span class="hljs-number">1</span>)<br>mergeCmd := exec.Command(<span class="hljs-string">&quot;bash&quot;</span>, <span class="hljs-string">&quot;-c&quot;</span>, cmdStr)<br><span class="hljs-keyword">if</span> _, err := mergeCmd.Output(); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125; <br><br><span class="hljs-comment">// 计算合并后的文件hash</span><br><span class="hljs-keyword">if</span> filehash, err := ComputeSha1ByShell(destPath); err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;  <span class="hljs-keyword">else</span><span class="hljs-keyword">if</span> <span class="hljs-type">string</span>(filehash) != fileSha1 &#123; <span class="hljs-comment">// 判断文件hash是否符合给定值</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;check sha1: &quot;</span>+destPath+ <span class="hljs-string">&quot; &quot;</span> + filehash+<span class="hljs-string">&quot; &quot;</span> + fileSha1)<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP断点续传与多线程下载原理</title>
    <link href="/2021/07/28/HTTP%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%8E%9F%E7%90%86/"/>
    <url>/2021/07/28/HTTP%E6%96%AD%E7%82%B9%E7%BB%AD%E4%BC%A0%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%8B%E8%BD%BD%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<p><img src="https://www.cmdbyte.com/2021/02/http_ranges.png" alt="http_ranges"></p><h2 id="1-HTTP断点续传多线程下载"><a href="#1-HTTP断点续传多线程下载" class="headerlink" title="1. HTTP断点续传多线程下载"></a>1. HTTP断点续传多线程下载</h2><p>一个比较常见的场景,就是断点续传&#x2F;下载,在网络情况不好的时候,可以在断开连接以后,仅继续获取部分内容. 例如在网上下载软件,已经下载了 95% 了,此时网络断了,如果不支持范围请求,那就只有被迫重头开始下载.但是如果有范围请求的加持,就只需要下载最后 5% 的资源,避免重新下载.</p><p>另一个场景就是多线程下载,对大型文件,开启多个线程, 每个线程下载其中的某一段,最后下载完成之后, 在本地拼接成一个完整的文件,可以更有效的利用资源.</p><p><img src="https://www.cmdbyte.com/2021/02/HTTP-Range-Request.png" alt="HTTP-Range-Request"></p><h2 id="2-Range-amp-Content-Range"><a href="#2-Range-amp-Content-Range" class="headerlink" title="2. Range &amp; Content-Range"></a>2. Range &amp; Content-Range</h2><p>HTTP1.1 协议（RFC2616）开始支持获取文件的部分内容,这为并行下载以及断点续传提供了技术支持. 它通过在 Header 里两个参数实现的,客户端发请求时对应的是 Range ,服务器端响应时对应的是 Content-Range.</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs txt">$ curl --location --head &#x27;https://download.jetbrains.com/go/goland-2020.2.2.exe&#x27;<br>date: Sat, 15 Aug 2020 02:44:09 GMT<br>content-type: text/html<br>content-length: 138<br>location: https://download-cf.jetbrains.com/go/goland-2020.2.2.exe<br>server: nginx<br>strict-transport-security: max-age=31536000; includeSubdomains;<br>x-frame-options: DENY<br>x-content-type-options: nosniff<br>x-xss-protection: 1; mode=block;<br>x-geocountry: United States<br>x-geocode: US<br><br>HTTP/1.1 200 OK<br>Content-Type: binary/octet-stream<br>Content-Length: 338589968<br>Connection: keep-alive<br>x-amz-replication-status: COMPLETED<br>Last-Modified: Wed, 12 Aug 2020 13:01:03 GMT<br>x-amz-version-id: p7a4LsL6K1MJ7UioW7HIz_..LaZptIUP<br>Accept-Ranges: bytes<br>Server: AmazonS3<br>Date: Fri, 14 Aug 2020 21:27:08 GMT<br>ETag: &quot;1312fd0956b8cd529df1100d5e01837f-41&quot;<br>X-Cache: Hit from cloudfront<br>Via: 1.1 8de6b68254cf659df39a819631940126.cloudfront.net (CloudFront)<br>X-Amz-Cf-Pop: PHX50-C1<br>X-Amz-Cf-Id: LF_ZIrTnDKrYwXHxaOrWQbbaL58uW9Y5n993ewQpMZih0zmYi9JdIQ==<br>Age: 19023<br></code></pre></td></tr></table></figure><h3 id="Range"><a href="#Range" class="headerlink" title="Range"></a>Range</h3><p>The Range 是一个请求首部,告知服务器返回文件的哪一部分. 在一个 Range 首部中,可以一次性请求多个部分,服务器会以 multipart 文件的形式将其返回. 如果服务器返回的是范围响应,需要使用 206 Partial Content 状态码. 假如所请求的范围不合法,那么服务器会返回 416 Range Not Satisfiable 状态码,表示客户端错误. 服务器允许忽略 Range 首部,从而返回整个文件,状态码用 200 .<code>Range:(unit=first byte pos)-[last byte pos]</code></p><p>Range 头部的格式有以下几种情况：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">Range: &lt;unit&gt;=&lt;range-start&gt;-<br>Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;<br>Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;<br>Range: &lt;unit&gt;=&lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;, &lt;range-start&gt;-&lt;range-end&gt;<br></code></pre></td></tr></table></figure><h3 id="Content-Range"><a href="#Content-Range" class="headerlink" title="Content-Range"></a>Content-Range</h3><p>假如在响应中存在 Accept-Ranges 首部（并且它的值不为 “none”）,那么表示该服务器支持范围请求(支持断点续传). 例如,您可以使用 cURL 发送一个 <code>HEAD</code> 请求来进行检测.<code>curl -I http://i.imgur.com/z4d4kWk.jpg</code></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">HTTP/1.1 200 OK<br>...<br>Accept-Ranges: bytes<br>Content-Length: 146515<br></code></pre></td></tr></table></figure><p>在上面的响应中, <code>Accept-Ranges: bytes</code> 表示界定范围的单位是 bytes . 这里 <code>Content-Length</code> 也是有效信息,因为它提供了要检索的图片的完整大小.</p><p>如果站点未发送 Accept-Ranges 首部,那么它们有可能不支持范围请求.一些站点会明确将其值设置为 “none”,以此来表明不支持.在这种情况下,某些应用的下载管理器会将暂停按钮禁用.</p><h2 id="3-Golang代码实现HTTP断点续传多线程下载"><a href="#3-Golang代码实现HTTP断点续传多线程下载" class="headerlink" title="3. Golang代码实现HTTP断点续传多线程下载"></a>3. Golang代码实现HTTP断点续传多线程下载</h2><p>通过以下代码您可以了解到多线程下载的原理, 同时给您突破百度网盘下载提供思路.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;crypto/sha256&quot;</span><br><span class="hljs-string">&quot;encoding/hex&quot;</span><br><span class="hljs-string">&quot;errors&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;mime&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br><span class="hljs-string">&quot;path/filepath&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br><span class="hljs-string">&quot;sync&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">parseFileInfoFrom</span><span class="hljs-params">(resp *http.Response)</span></span> <span class="hljs-type">string</span> &#123;<br>contentDisposition := resp.Header.Get(<span class="hljs-string">&quot;Content-Disposition&quot;</span>)<br><span class="hljs-keyword">if</span> contentDisposition != <span class="hljs-string">&quot;&quot;</span> &#123;<br>_, params, err := mime.ParseMediaType(contentDisposition)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br><span class="hljs-keyword">return</span> params[<span class="hljs-string">&quot;filename&quot;</span>]<br>&#125;<br>filename := filepath.Base(resp.Request.URL.Path)<br><span class="hljs-keyword">return</span> filename<br>&#125;<br><br><span class="hljs-comment">//FileDownloader 文件下载器</span><br><span class="hljs-keyword">type</span> FileDownloader <span class="hljs-keyword">struct</span> &#123;<br>fileSize       <span class="hljs-type">int</span><br>url            <span class="hljs-type">string</span><br>outputFileName <span class="hljs-type">string</span><br>totalPart      <span class="hljs-type">int</span> <span class="hljs-comment">//下载线程</span><br>outputDir      <span class="hljs-type">string</span><br>doneFilePart   []filePart<br>&#125;<br><br><span class="hljs-comment">//NewFileDownloader .</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewFileDownloader</span><span class="hljs-params">(url, outputFileName, outputDir <span class="hljs-type">string</span>, totalPart <span class="hljs-type">int</span>)</span></span> *FileDownloader &#123;<br><span class="hljs-keyword">if</span> outputDir == <span class="hljs-string">&quot;&quot;</span> &#123;<br>wd, err := os.Getwd() <span class="hljs-comment">//获取当前工作目录</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br>&#125;<br>outputDir = wd<br>&#125;<br><span class="hljs-keyword">return</span> &amp;FileDownloader&#123;<br>fileSize:       <span class="hljs-number">0</span>,<br>url:            url,<br>outputFileName: outputFileName,<br>outputDir:      outputDir,<br>totalPart:      totalPart,<br>doneFilePart:   <span class="hljs-built_in">make</span>([]filePart, totalPart),<br>&#125;<br><br>&#125;<br><br><span class="hljs-comment">//filePart 文件分片</span><br><span class="hljs-keyword">type</span> filePart <span class="hljs-keyword">struct</span> &#123;<br>Index <span class="hljs-type">int</span>    <span class="hljs-comment">//文件分片的序号</span><br>From  <span class="hljs-type">int</span>    <span class="hljs-comment">//开始byte</span><br>To    <span class="hljs-type">int</span>    <span class="hljs-comment">//解决byte</span><br>Data  []<span class="hljs-type">byte</span> <span class="hljs-comment">//http下载得到的文件内容</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>startTime := time.Now()<br><span class="hljs-keyword">var</span> url <span class="hljs-type">string</span> <span class="hljs-comment">//下载文件的地址</span><br>url = <span class="hljs-string">&quot;https://download.jetbrains.com/go/goland-2020.2.2.dmg&quot;</span><br>downloader := NewFileDownloader(url, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">10</span>)<br><span class="hljs-keyword">if</span> err := downloader.Run(); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// fmt.Printf(&quot;\n%s&quot;, err)</span><br>log.Fatal(err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;\n 文件下载完成耗时: %f second\n&quot;</span>, time.Now().Sub(startTime).Seconds())<br>&#125;<br><br><span class="hljs-comment">//head 获取要下载的文件的基本信息(header) 使用HTTP Method Head</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *FileDownloader)</span></span> head() (<span class="hljs-type">int</span>, <span class="hljs-type">error</span>) &#123;<br>r, err := d.getNewRequest(<span class="hljs-string">&quot;HEAD&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, err<br>&#125;<br>resp, err := http.DefaultClient.Do(r)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, err<br>&#125;<br><span class="hljs-keyword">if</span> resp.StatusCode &gt; <span class="hljs-number">299</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(fmt.Sprintf(<span class="hljs-string">&quot;Can&#x27;t process, response is %v&quot;</span>, resp.StatusCode))<br>&#125;<br><span class="hljs-comment">//检查是否支持 断点续传</span><br><span class="hljs-comment">//https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-Ranges</span><br><span class="hljs-keyword">if</span> resp.Header.Get(<span class="hljs-string">&quot;Accept-Ranges&quot;</span>) != <span class="hljs-string">&quot;bytes&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;服务器不支持文件断点续传&quot;</span>)<br>&#125;<br><br>d.outputFileName = parseFileInfoFrom(resp)<br><span class="hljs-comment">//https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Length</span><br><span class="hljs-keyword">return</span> strconv.Atoi(resp.Header.Get(<span class="hljs-string">&quot;Content-Length&quot;</span>))<br>&#125;<br><br><span class="hljs-comment">//Run 开始下载任务</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *FileDownloader)</span></span> Run() <span class="hljs-type">error</span> &#123;<br>fileTotalSize, err := d.head()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>d.fileSize = fileTotalSize<br><br>jobs := <span class="hljs-built_in">make</span>([]filePart, d.totalPart)<br>eachSize := fileTotalSize / d.totalPart<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> jobs &#123;<br>jobs[i].Index = i<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span> &#123;<br>jobs[i].From = <span class="hljs-number">0</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>jobs[i].From = jobs[i<span class="hljs-number">-1</span>].To + <span class="hljs-number">1</span><br>&#125;<br><span class="hljs-keyword">if</span> i &lt; d.totalPart<span class="hljs-number">-1</span> &#123;<br>jobs[i].To = jobs[i].From + eachSize<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//the last filePart</span><br>jobs[i].To = fileTotalSize - <span class="hljs-number">1</span><br>&#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-keyword">for</span> _, j := <span class="hljs-keyword">range</span> jobs &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(job filePart)</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>err := d.downloadPart(job)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(<span class="hljs-string">&quot;下载文件失败:&quot;</span>, err, job)<br>&#125;<br>&#125;(j)<br><br>&#125;<br>wg.Wait()<br><span class="hljs-keyword">return</span> d.mergeFileParts()<br>&#125;<br><br><span class="hljs-comment">//下载分片</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d FileDownloader)</span></span> downloadPart(c filePart) <span class="hljs-type">error</span> &#123;<br>r, err := d.getNewRequest(<span class="hljs-string">&quot;GET&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br>log.Printf(<span class="hljs-string">&quot;开始[%d]下载from:%d to:%d\n&quot;</span>, c.Index, c.From, c.To)<br>r.Header.Set(<span class="hljs-string">&quot;Range&quot;</span>, fmt.Sprintf(<span class="hljs-string">&quot;bytes=%v-%v&quot;</span>, c.From, c.To))<br>resp, err := http.DefaultClient.Do(r)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> resp.StatusCode &gt; <span class="hljs-number">299</span> &#123;<br><span class="hljs-keyword">return</span> errors.New(fmt.Sprintf(<span class="hljs-string">&quot;服务器错误状态码: %v&quot;</span>, resp.StatusCode))<br>&#125;<br><span class="hljs-keyword">defer</span> resp.Body.Close()<br>bs, err := ioutil.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(bs) != (c.To - c.From + <span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;下载文件分片长度错误&quot;</span>)<br>&#125;<br>c.Data = bs<br>d.doneFilePart[c.Index] = c<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><br>&#125;<br><br><span class="hljs-comment">// getNewRequest 创建一个request</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d FileDownloader)</span></span> getNewRequest(method <span class="hljs-type">string</span>) (*http.Request, <span class="hljs-type">error</span>) &#123;<br>r, err := http.NewRequest(<br>method,<br>d.url,<br><span class="hljs-literal">nil</span>,<br>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br>r.Header.Set(<span class="hljs-string">&quot;User-Agent&quot;</span>, <span class="hljs-string">&quot;mojocn&quot;</span>)<br><span class="hljs-keyword">return</span> r, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">//mergeFileParts 合并下载的文件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d FileDownloader)</span></span> mergeFileParts() <span class="hljs-type">error</span> &#123;<br>log.Println(<span class="hljs-string">&quot;开始合并文件&quot;</span>)<br>path := filepath.Join(d.outputDir, d.outputFileName)<br>mergedFile, err := os.Create(path)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">defer</span> mergedFile.Close()<br>hash := sha256.New()<br>totalSize := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> _, s := <span class="hljs-keyword">range</span> d.doneFilePart &#123;<br><br>mergedFile.Write(s.Data)<br>hash.Write(s.Data)<br>totalSize += <span class="hljs-built_in">len</span>(s.Data)<br>&#125;<br><span class="hljs-keyword">if</span> totalSize != d.fileSize &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;文件不完整&quot;</span>)<br>&#125;<br><span class="hljs-comment">//https://download.jetbrains.com/go/goland-2020.2.2.dmg.sha256?_ga=2.223142619.1968990594.1597453229-1195436307.1493100134</span><br><span class="hljs-keyword">if</span> hex.EncodeToString(hash.Sum(<span class="hljs-literal">nil</span>)) != <span class="hljs-string">&quot;3af4660ef22f805008e6773ac25f9edbc17c2014af18019b7374afbed63d4744&quot;</span> &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;文件损坏&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>log.Println(<span class="hljs-string">&quot;文件SHA-256校验成功&quot;</span>)<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs txt">Run go run main.go<br>2020/08/15 02:15:31 开始[9]下载from:376446150 to:418273495<br>2020/08/15 02:15:31 开始[0]下载from:0 to:41827349<br>2020/08/15 02:15:31 开始[1]下载from:41827350 to:83654699<br>2020/08/15 02:15:31 开始[5]下载from:209136750 to:250964099<br>2020/08/15 02:15:31 开始[6]下载from:250964100 to:292791449<br>2020/08/15 02:15:31 开始[7]下载from:292791450 to:334618799<br>2020/08/15 02:15:31 开始[2]下载from:83654700 to:125482049<br>2020/08/15 02:15:31 开始[8]下载from:334618800 to:376446149<br>2020/08/15 02:15:31 开始[4]下载from:167309400 to:209136749<br>2020/08/15 02:15:31 开始[3]下载from:125482050 to:167309399<br>2020/08/15 02:15:36 开始合并文件<br>2020/08/15 02:15:38 文件SHA-256校验成功<br><br> 文件下载完成耗时: 7.169149 second<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go struct拷贝</title>
    <link href="/2021/07/28/Go-struct%E6%8B%B7%E8%B4%9D/"/>
    <url>/2021/07/28/Go-struct%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<p>在用 Go 做 orm 相关操作的时候，经常会有 struct 之间的拷贝。比如下面两个struct之间要拷贝共同成员 B, C (类型一样)。这个在struct不是很大的时候从来都不是问题，直接成员拷贝即可。但是当struct的大小达到三四十个成员的时候，就要另辟蹊径了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> A <span class="hljs-keyword">struct</span> &#123;<br>    A   <span class="hljs-type">int</span><br>    B   <span class="hljs-type">int</span><br>    C   <span class="hljs-type">string</span><br>    E   <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">type</span> B <span class="hljs-keyword">struct</span> &#123;<br>    B   <span class="hljs-type">int</span><br>    C   <span class="hljs-type">string</span><br>    D   <span class="hljs-type">int</span><br>    E   <span class="hljs-type">string</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法一：json"><a href="#方法一：json" class="headerlink" title="方法一：json"></a>方法一：json</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    a := &amp;A&#123;<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>&#125;<br>    aj, _ := json.Marshal(a)<br>    b := <span class="hljs-built_in">new</span>(B)<br>    _ = json.Unmarshal(aj, b)<br><br>    fmt.Printf(<span class="hljs-string">&quot;%+v&quot;</span>, b)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法二：反射"><a href="#方法二：反射" class="headerlink" title="方法二：反射"></a>方法二：反射</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CopyStruct</span><span class="hljs-params">(src, dst <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>    sval := reflect.ValueOf(src).Elem()<br>    dval := reflect.ValueOf(dst).Elem()<br><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; sval.NumField(); i++ &#123;<br>        value := sval.Field(i)<br>        name := sval.Type().Field(i).Name<br><br>        dvalue := dval.FieldByName(name)<br>        <span class="hljs-keyword">if</span> dvalue.IsValid() == <span class="hljs-literal">false</span> &#123;<br>            <span class="hljs-keyword">continue</span><br>&#125;<br>        dvalue.Set(value) <span class="hljs-comment">//这里默认共同成员的类型一样，否则这个地方可能导致 panic，需要简单修改一下。</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Github Actions</title>
    <link href="/2021/07/24/Tools/CI-CD/Github-Actions/"/>
    <url>/2021/07/24/Tools/CI-CD/Github-Actions/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>大家知道，持续集成由很多操作组成，比如抓取代码、运行测试、登录远程服务器，发布到第三方服务等等。GitHub 把这些操作就称为 actions。</p><p>很多操作在不同项目里面是类似的，完全可以共享。GitHub 注意到了这一点，想出了一个很妙的点子，允许开发者把每个操作写成独立的脚本文件，存放到代码仓库，使得其他开发者可以引用。</p><p>如果你需要某个 action，不必自己写复杂的脚本，直接引用他人写好的 action 即可，整个持续集成过程，就变成了一个 actions 的组合。这就是 GitHub Actions 最特别的地方。</p><p>GitHub 做了一个官方市场，可以搜索到他人提交的 actions。另外，还有一个 awesome actions 的仓库，也可以找到不少 action。</p><p>上面说了，每个 action 就是一个独立脚本，因此可以做成代码仓库，使用userName&#x2F;repoName的语法引用 action。比如，actions&#x2F;setup-node就表示github.com&#x2F;actions&#x2F;setup-node这个仓库，它代表一个 action，作用是安装 Node.js。事实上，GitHub 官方的 actions 都放在 github.com&#x2F;actions 里面。</p><p>既然 actions 是代码仓库，当然就有版本的概念，用户可以引用某个具体版本的 action。下面都是合法的 action 引用，用的就是 Git 的指针概念，详见官方文档。</p><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>GitHub Actions 的配置文件叫做 workflow 文件，存放在代码仓库的.github&#x2F;workflows目录。</p><p>workflow 文件采用 YAML 格式，文件名可以任意取，但是后缀名统一为.yml，比如foo.yml。一个库可以有多个 workflow 文件。GitHub 只要发现.github&#x2F;workflows目录里面有.yml文件，就会自动运行该文件。</p><p>workflow 文件的配置字段非常多，详见官方文档。下面是一些基本字段。</p><p>（1）name</p><p>name字段是 workflow 的名称。如果省略该字段，默认为当前 workflow 的文件名。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">name: GitHub Actions Demo<br></code></pre></td></tr></table></figure><p>（2）on</p><p>on字段指定触发 workflow 的条件，通常是某些事件。</p><p>on: push<br>上面代码指定，push事件触发 workflow。</p><p>on字段也可以是事件的数组。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">on:</span> [<span class="hljs-string">push</span>, <span class="hljs-string">pull_request</span>]<br></code></pre></td></tr></table></figure><p>上面代码指定，push事件或pull_request事件都可以触发 workflow。</p><p>完整的事件列表，请查看官方文档。除了代码库事件，GitHub Actions 也支持外部事件触发，或者定时运行。</p><p>（3）on.&lt;push|pull_request&gt;.&lt;tags|branches&gt;</p><p>指定触发事件时，可以限定分支或标签。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure><p>上面代码指定，只有master分支发生push事件时，才会触发 workflow。</p><p>（4）jobs.<job_id>.name</p><p>workflow 文件的主体是jobs字段，表示要执行的一项或多项任务。</p><p>jobs字段里面，需要写出每一项任务的job_id，具体名称自定义。job_id里面的name字段是任务的说明。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">my_first_job:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">My</span> <span class="hljs-string">first</span> <span class="hljs-string">job</span><br>  <span class="hljs-attr">my_second_job:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">My</span> <span class="hljs-string">second</span> <span class="hljs-string">job</span><br></code></pre></td></tr></table></figure><p>上面代码的jobs字段包含两项任务，job_id分别是my_first_job和my_second_job。</p><p>（5）jobs.<job_id>.needs</p><p>needs字段指定当前任务的依赖关系，即运行顺序。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">job1:</span><br>  <span class="hljs-attr">job2:</span><br>    <span class="hljs-attr">needs:</span> <span class="hljs-string">job1</span><br>  <span class="hljs-attr">job3:</span><br>    <span class="hljs-attr">needs:</span> [<span class="hljs-string">job1</span>, <span class="hljs-string">job2</span>]<br></code></pre></td></tr></table></figure><p>上面代码中，job1必须先于job2完成，而job3等待job1和job2的完成才能运行。因此，这个 workflow 的运行顺序依次为：job1、job2、job3。</p><p>（6）jobs.<job_id>.runs-on</p><p>runs-on字段指定运行所需要的虚拟机环境。它是必填字段。目前可用的虚拟机如下。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">ubuntu-latest，ubuntu-18.04或ubuntu-16.04</span><br><span class="hljs-string">windows-latest，windows-2019或windows-2016</span><br><span class="hljs-string">macOS-latest或macOS-10.14</span><br></code></pre></td></tr></table></figure><p>下面代码指定虚拟机环境为ubuntu-18.04。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-18.04</span><br><span class="hljs-string">（7）jobs.&lt;job_id&gt;.steps</span><br></code></pre></td></tr></table></figure><p>steps字段指定每个 Job 的运行步骤，可以包含一个或多个步骤。每个步骤都可以指定以下三个字段。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">jobs.&lt;job_id&gt;.steps.name：步骤名称。</span><br><span class="hljs-string">jobs.&lt;job_id&gt;.steps.run：该步骤运行的命令或者</span> <span class="hljs-string">action。</span><br><span class="hljs-string">jobs.&lt;job_id&gt;.steps.env：该步骤所需的环境变量。</span><br></code></pre></td></tr></table></figure><p>下面是一个完整的 workflow 文件的范例。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Greeting</span> <span class="hljs-string">from</span> <span class="hljs-string">Mona</span><br><span class="hljs-attr">on:</span> <span class="hljs-string">push</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">my-job:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">My</span> <span class="hljs-string">Job</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Print</span> <span class="hljs-string">a</span> <span class="hljs-string">greeting</span><br>      <span class="hljs-attr">env:</span><br>        <span class="hljs-attr">MY_VAR:</span> <span class="hljs-string">Hi</span> <span class="hljs-string">there!</span> <span class="hljs-string">My</span> <span class="hljs-string">name</span> <span class="hljs-string">is</span><br>        <span class="hljs-attr">FIRST_NAME:</span> <span class="hljs-string">Mona</span><br>        <span class="hljs-attr">MIDDLE_NAME:</span> <span class="hljs-string">The</span><br>        <span class="hljs-attr">LAST_NAME:</span> <span class="hljs-string">Octocat</span><br>      <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br>        <span class="hljs-string">echo</span> <span class="hljs-string">$MY_VAR</span> <span class="hljs-string">$FIRST_NAME</span> <span class="hljs-string">$MIDDLE_NAME</span> <span class="hljs-string">$LAST_NAME.</span><br></code></pre></td></tr></table></figure><p>上面代码中，steps字段只包括一个步骤。该步骤先注入四个环境变量，然后执行一条 Bash 命令。</p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>CI/CD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CI/CD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD领域驱动设计基本概念</title>
    <link href="/2021/07/19/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <url>/2021/07/19/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="领域驱动设计适合的场景"><a href="#领域驱动设计适合的场景" class="headerlink" title="领域驱动设计适合的场景"></a>领域驱动设计适合的场景</h3><ul><li>业务不断迭代</li><li>技术快速更新</li><li>系统越来越庞大</li></ul><h3 id="领域模型建模思想包含的规则"><a href="#领域模型建模思想包含的规则" class="headerlink" title="领域模型建模思想包含的规则"></a>领域模型建模思想包含的规则</h3><ul><li>现实世界有什么事物，建模时就有什么对象</li><li>现实世界有什么行为，建模时就有什么方法</li><li>现实世界有什么关系，建模时就有什么关联</li></ul><h3 id="关于单一职责原则"><a href="#关于单一职责原则" class="headerlink" title="关于单一职责原则"></a>关于单一职责原则</h3><ul><li>任何一个软件模块都应该有且仅有一个被修改的原因</li><li>任何一个软件模块都应该只对一个用户或系统利益相关者负责</li><li>任何一个软件模块都应该只对某一类行为者负责</li></ul><h3 id="关于限界上下文"><a href="#关于限界上下文" class="headerlink" title="关于限界上下文"></a>关于限界上下文</h3><ul><li>限的意思就是划分、规定</li><li>界就是界限，或着一个边界</li><li>上下文就是业务的整个流程</li></ul><h3 id="聚合根、实体、值对象之间的关系"><a href="#聚合根、实体、值对象之间的关系" class="headerlink" title="聚合根、实体、值对象之间的关系"></a>聚合根、实体、值对象之间的关系</h3><ul><li>聚合根具有全局唯一的标识，而实体只有在聚合内部有唯一的本地标识，值对象没有标识</li><li>聚合根除了唯一标识外，其他所有状态信息都理论上可变，实习是可变的，值对象是只读的</li><li>聚合根有独立的生命周期，实体的生命周期从属于其所属的聚合，实体完全由其所属的聚合根负责管理维护，值对象没有生命周期</li><li>聚合根到聚合根，通过ID关联；聚合根到其内部的实体，直接对象引用；聚合根到值对象，直接对象引用</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go大文件读取与写入</title>
    <link href="/2021/07/19/Go%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/"/>
    <url>/2021/07/19/Go%E5%A4%A7%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8E%E5%86%99%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>参考资料：</p><p>块读取 流读取</p><p><a href="http://www.zzvips.com/article/84113.html">浅谈Golang是如何读取文件内容的(7种)_Golang_脚本之家</a></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go将目录下的文件打包成tar.gz</title>
    <link href="/2021/07/19/Go%E5%B0%86%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E6%88%90tar-gz/"/>
    <url>/2021/07/19/Go%E5%B0%86%E7%9B%AE%E5%BD%95%E4%B8%8B%E7%9A%84%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E6%88%90tar-gz/</url>
    
    <content type="html"><![CDATA[<p>这个代码是为了生成<code>Open Policy Agent</code> Bundle的压缩包的，根据传入的对象信息（可以理解为OPA的data.json）。</p><p>直接贴代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//GenerateBundle 生成bundler.tar.gz</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GenerateBundle</span><span class="hljs-params">(data <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">error</span> &#123;<br>path, fileName, tarballName := <span class="hljs-string">&quot;./bundle/&quot;</span>, <span class="hljs-string">&quot;data.json&quot;</span>, <span class="hljs-string">&quot;bundle.tar.gz&quot;</span><br><br>b, _ := json.Marshal(data)<br>os.Remove(path + fileName)<br>file, err := os.Create(path + fileName)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br>writer := bufio.NewWriter(file)<br>_, err = writer.Write(b)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br>writer.Flush()<br>    <br>    <span class="hljs-comment">// 如果仅仅打包，从这里开始看</span><br><br><span class="hljs-comment">// 读取目录下数据和规则文件</span><br>files, err := ioutil.ReadDir(path)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br><span class="hljs-comment">// 打包</span><br>fw, err := os.Create(tarballName)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">defer</span> fw.Close()<br>gw := gzip.NewWriter(fw)<br><span class="hljs-keyword">defer</span> gw.Close()<br>tw := tar.NewWriter(gw)<br><span class="hljs-keyword">defer</span> tw.Close()<br><br><span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> files &#123;<br>hdr := &amp;tar.Header&#123;<br>Name: f.Name(),<br>Mode: <span class="hljs-number">0600</span>,<br>Size: f.Size(),<br>&#125;<br><span class="hljs-keyword">if</span> err = tw.WriteHeader(hdr); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><br>pa := path + f.Name()<br>tf, err := ioutil.ReadFile(pa)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br><span class="hljs-keyword">if</span> _, err = tw.Write(tf); err != <span class="hljs-literal">nil</span> &#123;<br>log.Println(err)<br><span class="hljs-keyword">return</span> err<br>&#125;<br>tw.Flush()<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p>参考：</p><p><a href="https://www.cnblogs.com/golove/p/3454630.html">代码片段 - Golang 创建 .tar.gz 压缩包 - GoLove - 博客园</a></p><p><a href="https://www.jb51.net/article/61287.htm">Go语言压缩和解压缩tar.gz文件的方法_Golang_脚本之家</a></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go读取和写入文件</title>
    <link href="/2021/07/19/Go%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6/"/>
    <url>/2021/07/19/Go%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="读取指定目录下的文件列表"><a href="#读取指定目录下的文件列表" class="headerlink" title="读取指定目录下的文件列表"></a>读取指定目录下的文件列表</h2><p>如果仅仅是想获取一个目录下面的文件和文件夹的列表,有两个比较简单的方法</p><ul><li><p>利用ioutil的ReadDir方法</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;io/ioutil&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    files, _ := ioutil.ReadDir(<span class="hljs-string">&quot;./&quot;</span>)<br>    <span class="hljs-keyword">for</span> _, f := <span class="hljs-keyword">range</span> files &#123;<br>            fmt.Println(f.Name())<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>利用filepath的Glob方法</p><p>  filepath的walk会递归获取所有的文件</p>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Go"><span class="hljs-keyword">package</span> main    <br> <br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;path/filepath&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    files, _ := filepath.Glob(<span class="hljs-string">&quot;*&quot;</span>)<br>    fmt.Println(files) <span class="hljs-comment">// contains a list of all files in the current directory</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>转载:为什么选择Go-Kit</title>
    <link href="/2021/07/16/%E8%BD%AC%E8%BD%BD-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9Go-Kit/"/>
    <url>/2021/07/16/%E8%BD%AC%E8%BD%BD-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9Go-Kit/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>工作这些年，先后经历过两家公司，有参与过php语言框架的开发和主导过go语言技术栈的落地工作，在此过程中有一些感悟和总结。我想以之前我主导的go语言技术栈为线索，来陈述当时遇到的一些问题，以及分析问题和解决问题的思路。主要目的是想陈述go技术体系在团队中落地的过程，分析我们在各个阶段中，遇到的一些问题，并將分析问题的思路和解决问题的方法记录下来，以便让后来的同学了解go语言在团队的演进过程，吸取相关的经验，以便在今后的系统设计和开发上少走弯路。</p><p>在系统不断演进的过程中，有时候对框架的选型很随意，认为能满足现在功能就行，没有对其功能扩展性和性能进行考量，导致随着业务的发展，发现当时选型有误，但想转又很难。那么现在，我就来谈谈，我们是如何抉择这些事情的。</p><h3 id="我们为什么要由php转向go"><a href="#我们为什么要由php转向go" class="headerlink" title="我们为什么要由php转向go"></a>我们为什么要由php转向go</h3><p>最初，大约是在2015年时，平台内所有的业务系统均是由php语言构成的，上线没多久，平台的流量开始爆发性增长，并发量越来越大，晚高峰每秒请求由最初的几千QPS到现在的几十万QPS。当时，最快最有效的优化手段无外乎加机器和增加php－fpm的数量，但是，受限于php本身的网络模型，终究不适合这种高并发，大流量的场景。面对这种棘手的问题，再加上当时人手有限，业务任务重等因素，于是找其它部门借了一批写lua的外援，帮忙把一些逻辑简单且访问量大的接口，换成了lua，暂时扛过了晚高峰，因此，有相当长的一段时间，大部分项目是php＋lua共存的一个状态。但由于lua本身的一些局限性，不太适合做一些复杂的业务逻辑，所以最终，在业务有强烈的需求的前提下，同时伴随着技术发展的潮流，于2015年底，我们开始选择转向go语言。</p><h3 id="我们怎样由php转向go"><a href="#我们怎样由php转向go" class="headerlink" title="我们怎样由php转向go"></a>我们怎样由php转向go</h3><p>由于之前团队全部都是php栈，在go方面的积累并不多，所以在php转向go的过程中，面临了在转型过程中都会遇到的问题：</p><p>1 用什么框架；</p><p>2 在业务任务重，人员极其匮乏的情况下如何將php项目重构成go。</p><h3 id="用什么框架"><a href="#用什么框架" class="headerlink" title="用什么框架"></a>用什么框架</h3><p>之前团队有人仿造内部php框架开发过一个golang框架，有人提议将其直接拿过来用，有人说找个开源的如beego，gin，martini等这类流行的框架。我个人当时不太赞同使用自研的框架，主要有以下几点原因：1 文档少，漏洞多；2 需要投入人力去开发和维护，在当时人力极其紧缺的情况下是不现实的。另外，当时社区流行的框架也比较多，但是最终也没有选择那些流行的框架，主要是出于以下考虑：时间短，任务重，没有精力去辨别各个框架的优劣，适用场景以及性能如何。万一冒然使用一个还没有深入了解的框架，线上出问题咋办！尤其在当时系统频繁出问题，顶着各种压力的情况下。</p><p>虽说，我们无法在短时间内选一个合适的框架，但是能够确定的是：我们的需求是什么？</p><p>1 只做高性能的HTTP 接口；</p><p>2 需要完整的单元测试体系；</p><p>3 可扩展，组件化；</p><p>基于以上三点，可以发现，go语言自带的特性就可以满足这些需求。于是，我们开始决定裸写。</p><p>此外，还有一个裸写的原因就是：没想好将来想要什么！当然，每个团队的背景不一样，业务场景也不同，在人力和时间充裕的情况下，还是需要选择一个合适的框架比较好。</p><h3 id="裸写不是乱写"><a href="#裸写不是乱写" class="headerlink" title="裸写不是乱写"></a>裸写不是乱写</h3><p>裸写不是乱写。众说周知，用框架的其中一个好处就是保证团队代码风格的一致性，当然，目前市面上除了beego外的大多数框架，在代码风格上也并没有做约束。为了保证团队go代码的规范性和一致性，按照经典的分层架构和过往的经验，我们制定了一套go编程模版，由上向下：Router层，Service层，Dao层，还有贯穿这三层的Entity层，架构图如图1所示。其中，Router层负责处理与http handler逻辑,请求参数以及response格式相关的处理工作；Service层处理业务逻辑；Dao层处理数据访问逻辑；Entity层负责实体定义相关的逻辑，并贯穿Router，Service，Dao这三层。层与层之间不直接进行耦合，高层模块不直接依赖与低层模块，它们都依赖于所定义的抽象接口。</p><blockquote><p>Booch曾经说过：“所有结构良好的面向对象构架都具有清晰的层次定义，每个层次通过一个定义良好的，受控的接口向外提供了一组内聚的服务”。</p></blockquote><p>除此之外，我们还维护了一套常用的公共组件库，如：日志库，各种数据库driver等。</p><p><img src="https://www.cmdbyte.com/2021/02/5167807-448f5f3106d6cc89.webp" alt="5167807-448f5f3106d6cc89"></p><h3 id="如何重构"><a href="#如何重构" class="headerlink" title="如何重构"></a>如何重构</h3><p>当我们制定好编程模版后，我们就开始进行项目重构工作。由于，业务任务重，人手少，所以，重构的基本方向就是：根据业务需求，结合接口重要性进行重构。只有这样，才能保证在业务需求不停的情况下，进行系统重构。所以，在此期间，有相当长的一段时间是处于php＋go进行混合编程，混合部署的状态，如图2所示，重构完的接口，通过nginx代理到新接口，这种状态一直持续了一年。采取混合编程的思路在重构初期，可能会遇到一些问题，比如：同一段业务逻辑，需要用go写一遍，用php写一遍，无疑增加了一定的工作量，当然这也是避免不了的。</p><p>注意，有些同学在重构的时候容易走到一个误区：一口气把整个项目都重构了，或者说重构大部分内容。从时间成本和系统稳定性上来讲，这种方式风险比较大，不推荐。推荐的思路：一个接口一个接口进行重构。</p><p><img src="https://www.cmdbyte.com/2021/02/5167807-76e29ae60dba041e.webp" alt="PHP+Go混合架构"></p><h3 id="最终，为何想引入go-kit"><a href="#最终，为何想引入go-kit" class="headerlink" title="最终，为何想引入go-kit"></a>最终，为何想引入go-kit</h3><p>之前这套东西，基本上可以满足大部分的业务场景，但随着随着业务的发展，请求量越来越大，同时，有些请求的链路也变长了，为了继续保证接口的高并发和低时延特性，团队有少量业务开始尝试GRPC。根据测试，压测一个空接口，GRPC的性能大约是HTTP＋JSON的2～3倍，在这里推荐一个压测框架<a href="https://links.jianshu.com/go?to=https://github.com/shafreeck/fperf">fperf </a>。</p><p>但是，针对GRPC的使用，不要盲目“求新”。以本人经验，HTTP＋JSON的模式基本上可以满足大部分的业务开发场景了，针对小部分对接口时延和并发量要求极高的场景可以考虑使用GRPC。因为，GRPC本身还是不利于调试，且会在一定程度上增加调用方和服务方的耦合性，所以，最后的传输协议和格式建议还是以HTTP＋JSON为主，以GRPC为辅。</p><p>另外，我们还是需要标准化一些中间件的使用，如回路断流，rate limit等，来保障系统的稳定性。这次的思考，时间比较充分，所以有精力去研究一些新的东西。最后，框架抉择的思路和最初是一样的，就是，明确我们的需求是什么？</p><p>1 需要一个同时支持多种传输协议，不论是现在的http，thrift，grpc，还是将来出现的某种新协议，要有良好扩展性的框架；</p><p>2 框架本身和业务代码保持一种低耦合的状态；</p><p>3 需要一套通用的middleware，使之与http，grpc等传输协议无关。</p><p>目前市面上流行的框架都是围绕着http协议而展开的，包括gin，beego等。经调研，我们发现go-kit能够满足我们的需求。 go-kit本身不是一个框架，而是一套微服务工具集。其设计思想跟我们初期go编程模版制定的思想也算是不谋而合——分层设计，组件化，可扩展。go-kit的架构如图3所示，分为三层结构：Transport层，Endpoint层，Service层。Transport层主要负责与传输协议HTTP，GRPC，THRIFT等相关的逻辑，Endpoint层主要负责request／response格式的转换，以及公用拦截器相关的逻辑；Service层则专注于业务逻辑。go-kit除了经典的分层架构外，还在endpoint层提供了很多公用的拦截器，如log，metric，tracing，circuitbreaker，rate-limiter等，来保障业务系统的可用性。它们在设计上有一个共同特点：都是同传输协议无关的。在之前的一些http框架中，这些拦截器同传输协议是紧紧耦合在一起的，如果，此时我需要将某些HTTP接口改造成GRPC协议的接口，那么这些拦截器我还得再基于grpc再实现一遍，设计上存在一定的冗余。因此，借助go-kit这套工具集，我们就能很好的对transport协议，middleware进行扩展，且不会影响到业务本身的设计。</p><p><img src="https://www.cmdbyte.com/2021/02/5167807-42d352f9f790768e.webp" alt="Go Kit架构图"></p><h3 id="怎样將go-kit集成到现有的业务系统中"><a href="#怎样將go-kit集成到现有的业务系统中" class="headerlink" title="怎样將go-kit集成到现有的业务系统中"></a>怎样將go-kit集成到现有的业务系统中</h3><p>我们找到了心仪的开源工具后，那么我们怎样以较低的成本将其引入到我们业务系统中呢？之前我们有提到，我们的go模版是分为三层：router，service和dao。而go-kit也分为三层，我们可以根据每层职责的不同进行重新组合，如图4所示，从上到下依次为：transport层，endpoint层，service层，dao层。这样就能很轻易的將go-kit集成进来，当然你如果哪天因为某种原因，不想再继续使用go-kit这套东西，直接將endpoint层和Transport层移除即可。在集成的过程中，需要注意一点：之前的代码中router层不能包含任何业务逻辑，否则就无法集成。</p><p><img src="https://www.cmdbyte.com/2021/02/5167807-5811f7a0366bf155.webp"></p><h3 id="如何高效的使用go-kit"><a href="#如何高效的使用go-kit" class="headerlink" title="如何高效的使用go-kit"></a>如何高效的使用go-kit</h3><p>前面有提到，go-kit本身分为三层，针对这点有同学会提出：“每次新建项目，都需要手动写下go-kit的这三层逻辑，有点浪费时间，不够简洁”，这确实是一个共性问题，从go-kit的github的<a href="https://links.jianshu.com/go?to=https://github.com/go-kit/kit/pull/964">issue</a>中可以发现，也有不少人反馈过类似问题。很庆幸的是，有人给我们铺好了路，详见<a href="https://links.jianshu.com/go?to=https://github.com/GrantZheng/kit">GoKit CLi</a>，其主要功能如图5所示。</p><p><img src="https://www.cmdbyte.com/2021/02/5167807-4820098bc6f40225.webp" alt="GoKit CLi功能模块"></p><p>这个工具可以根据我们的需求自动生成service，transport和endpoint模版，以及生成供调用方的使用的client library，节省我们大量的时间，提高我们的生产效率。具体操作步骤，可以参考<a href="https://links.jianshu.com/go?to=https://github.com/GrantZheng/kit">GoKit CLi</a>的说明，这里不再赘述。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>不论是我之前的一篇文章《<a href="https://www.jianshu.com/p/98b8c97e2ce1">浅谈互联网业务系统设计</a>》所讲的系统设计，还是这篇文章所陈述的框架选型。我一直在强调的一点就是：需求是什么？如何在满足需求的同时，让框架和系统具有一定的弹性。无外乎使用经典的五大设计原则：单一职责原则，开放封闭原则，依赖倒置原则，接口隔离原则，为你的设计提供坚实的理论基础和方向指引。另外，在做选型的时候不要盲从，别人口中好的东西，不一定适合你，只有明确自身需求后，找到适合自己的才是最好的！</p><p>作者：郑渊<br>链接：<a href="https://www.jianshu.com/p/0c34a75569b1">https://www.jianshu.com/p/0c34a75569b1</a><br>来源：简书<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>]]></content>
    
    
    <categories>
      
      <category>开源项目</category>
      
      <category>Go</category>
      
      <category>Go-Kit</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Go-Kit</tag>
      
      <tag>Microservice</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes Pod Security Policies with Open Policy Agent</title>
    <link href="/2021/07/15/Kubernetes-Pod-Security-Policies-with-Open-Policy-Agent/"/>
    <url>/2021/07/15/Kubernetes-Pod-Security-Policies-with-Open-Policy-Agent/</url>
    
    <content type="html"><![CDATA[<h3 id="容器和安全简介"><a href="#容器和安全简介" class="headerlink" title="容器和安全简介"></a>容器和安全简介</h3><p>容器轻巧，轻便且易于管理。在同一主机上运行的容器没有单独的物理&#x2F;虚拟机。换句话说，容器共享运行它们的主机的资源，硬件和OS内核。因此，具有适当的安全性变得非常重要，这些安全性涉及容器中可以运行哪些进程，这些进程具有哪些特权，容器是否将允许特权升级，使用了什么镜像等等。</p><p>Pod是Kubernetes应用程序的基本执行单元，是您创建或部署的Kubernetes对象模型中最小和最简单的单元。它是一个或多个具有共享存储&#x2F;网络的容器的组，以及有关如何运行容器的规范。因此，在容器上实施安全策略时，我们将检查安全策略并将其应用于Pod规范。那么，这些策略如何执行？使用准入控制器。</p><h3 id="什么是Admission-Controllers"><a href="#什么是Admission-Controllers" class="headerlink" title="什么是Admission Controllers?"></a>什么是Admission Controllers?</h3><p>准入控制器是kube-apiserver的一部分。在配置存储在集群设置（etcd）中之前，它们拦截对Kubernetes API服务器的请求。准入控制器可以是正在验证（用于验证传入请求的一个）或正在变异（用于修改传入请求的一个）或两者都在进行。请参阅<a href="https://kubernetes.io/docs/reference/access-authn-authz/admission-controllers/#what-does-each-admission-controller-do">Kubernetes文档</a>以快速浏览各种准入控制器。</p><h3 id="Open-Policy-Agent-作为-admission-controller"><a href="#Open-Policy-Agent-作为-admission-controller" class="headerlink" title="Open Policy Agent 作为 admission controller"></a>Open Policy Agent 作为 admission controller</h3><p>Open Policy Agent（OPA）是一种开放源代码的通用策略引擎，可以将策略编写为代码。 OPA提供了一种高级声明性语言-Rego-以策略作为代码。使用OPA，我们可以跨微服务，CI &#x2F; CD管道，API网关等执行策略。 OPA最重要的用例之一是Kubernetes作为准入控制者的策略实施。</p><p>OPA作为准入控制器，您可以强制执行非root用户之类的策略，要求使用特定的资源标签，确保所有pod都指定了资源请求和限制等。基本上，OPA允许您使用Rego语言将任何自定义策略编写为代码。</p><p>这些策略以Rego编写并加载到OPA中，作为Kubernetes集群上的准入控制器运行。 OPA将根据Rego策略评估对Kubernetes API服务器的任何资源创建&#x2F;更新&#x2F;删除请求。如果请求满足所有策略，则允许该请求。但是，即使单个策略失败，请求也会被拒绝。</p><p><img src="https://www.cmdbyte.com/2021/02/opa-k8s.png" alt="opa-k8s"></p><p>Pod Security Policy<br>Pod安全策略（PSP）是实现为准入控制器的集群级别资源。 PSP允许用户将安全要求转换为管理Pod规范的特定策略。首先，创建PodSecurityPolicy资源时，它什么也不做。为了使用它，必须通过允许“使用”动词来授权请求​​用户或目标pod的服务帐户使用该策略。您可以参考Kubernetes文档上的启用Pod安全策略。</p><p>注意，PSP准入控制器既充当验证角色，又充当变异准入控制器。对于某些参数，PSP准入控制器使用默认值来更改传入的请求。此外，顺序始终是先突变然后验证。</p><p>参考地址：<a href="https://www.infracloud.io/blogs/kubernetes-pod-security-policies-opa/">Kubernetes Pod Security Policies with Open Policy Agent</a></p>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
      <tag>OPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rego笔记</title>
    <link href="/2021/07/14/Rego%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/07/14/Rego%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>字符串、布尔值等比较<code>=</code>和<code>==</code>相同</p><p>数字比较只能用<code>==</code></p><p>如果一个条件，则结果为<code>true</code>或者<code>false</code></p><p>如果有多个条件，当其中一个为<code>false</code>或者为<code>undefined decision</code>时，则结果为<code>undefined decision</code></p><p>在使用迭代时，如果没有值满足表达式，那么结果为<code>undefined decision</code></p><p>规则：</p><p>规则分为规则头和规则体</p><p>如果规则头是真，那么规则体必须为真。规则头可以省略<code>= &lt;value&gt;</code>的写法，这样规则头默认为真(类似 <code>= true</code>)。</p><p>可以只定义规则头，省略规则体，那么规则体默认为true，规则头为<code>true/defined</code>则为<code>true</code>或者<code>定义的值</code></p><p>可以将规则载入到OPA，通过绝对路径使用规则：<code>data.&lt;package-path&gt;.&lt;rule-name&gt;</code>.</p><p>substitute: 替代，代替</p><p>approach：方式，方法，走进，靠近</p><p>problematic：有问题的，有疑问的，不确定的</p><p>intermediate：中间，媒介，中间的，中间体</p><p>Conceptually：概念上，概念的</p><p>encapsulate：压缩，封装；概述；将…封装进内部</p><p>if-then：假设的；假定的</p><p>constants：常量，常数，物理常数</p><p>performance: 性能；绩效；表演；执行；表现</p><p>reference：参照；参考；涉及；提及；引用</p><p>philosophy：哲学；哲理；人生观；</p><p>verbose：详细的；啰嗦的；详细模式；详细信息</p><p>convention：约定；习俗；惯例</p><p>restricts：约束；制约</p><p>fundamental：基本的；根本的；基本原理；根本原理</p><p>whatsoever：无论怎样；无论什么；丝毫</p><p>relevance：关联；适当；中肯</p><p>reason：理由；理性；动机；推论；劝说；说服；由于</p><p>indicates：表明；指示；显示</p><p>probes：探索；试样；探查</p><p>variant：变体；转化；不同的；多样的</p><p>sensitive：敏感的；易受影响的；感觉到的</p><p>inspect：检查；视察；检阅</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL查看和设置最大连接数</title>
    <link href="/2021/07/12/PostgreSQL%E6%9F%A5%E7%9C%8B%E5%92%8C%E8%AE%BE%E7%BD%AE%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0/"/>
    <url>/2021/07/12/PostgreSQL%E6%9F%A5%E7%9C%8B%E5%92%8C%E8%AE%BE%E7%BD%AE%E6%9C%80%E5%A4%A7%E8%BF%9E%E6%8E%A5%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="查看最大连接数"><a href="#查看最大连接数" class="headerlink" title="查看最大连接数"></a>查看最大连接数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">show</span> max_connections;<br></code></pre></td></tr></table></figure><h3 id="查看当前连接数"><a href="#查看当前连接数" class="headerlink" title="查看当前连接数"></a>查看当前连接数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">select</span> <span class="hljs-built_in">count</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">from</span> pg_stat_activity;<br></code></pre></td></tr></table></figure><h3 id="修改最大连接数"><a href="#修改最大连接数" class="headerlink" title="修改最大连接数"></a>修改最大连接数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim /etc/postgresql/9.6/main/postgresql.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过/max 找到下面的配置,修改值</span><br>max_connections = 100<br><br></code></pre></td></tr></table></figure><h3 id="使配置生效"><a href="#使配置生效" class="headerlink" title="使配置生效"></a>使配置生效</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">service postgresql restart<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go写文件的四种方法</title>
    <link href="/2021/07/09/Go%E5%86%99%E6%96%87%E4%BB%B6%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <url>/2021/07/09/Go%E5%86%99%E6%96%87%E4%BB%B6%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Talk is cheap, show me the code!</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span> <span class="hljs-comment">//缓存IO</span><br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;io&quot;</span><br><span class="hljs-string">&quot;io/ioutil&quot;</span> <span class="hljs-comment">//io 工具包</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">check</span><span class="hljs-params">(e <span class="hljs-type">error</span>)</span></span> &#123;<br><span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(e)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 判断文件是否存在, 存在返回true, 不存在返回false</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">checkFileIsExist</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br><span class="hljs-keyword">if</span> _, err := os.Stat(filename); os.IsNotExist(err) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> wireteString = <span class="hljs-string">&quot;测试n&quot;</span><br><span class="hljs-keyword">var</span> filename = <span class="hljs-string">&quot;./output1.txt&quot;</span><br><span class="hljs-keyword">var</span> f *os.File<br><br><span class="hljs-comment">// 第一种方式: 使用io.WriteString写入文件</span><br><span class="hljs-keyword">var</span> err1 <span class="hljs-type">error</span><br><span class="hljs-keyword">if</span> checkFileIsExist(filename) &#123; <span class="hljs-comment">//如果文件存在</span><br>f, err1 = os.OpenFile(filename, os.O_APPEND, <span class="hljs-number">0666</span>) <span class="hljs-comment">//打开文件</span><br>fmt.Println(<span class="hljs-string">&quot;文件存在&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>f, err1 = os.Create(filename) <span class="hljs-comment">//创建文件</span><br>fmt.Println(<span class="hljs-string">&quot;文件不存在&quot;</span>)<br>&#125;<br>check(err1)<br>n, err1 := io.WriteString(f, wireteString) <span class="hljs-comment">//写入文件(字符串)</span><br>check(err1)<br>fmt.Printf(<span class="hljs-string">&quot;写入 %d 个字节n&quot;</span>, n)<br><br><span class="hljs-comment">// 第二种方式: 使用ioutil.WriteFile写入文件</span><br><span class="hljs-keyword">var</span> d1 = []<span class="hljs-type">byte</span>(wireteString)<br>err2 := ioutil.WriteFile(<span class="hljs-string">&quot;./output2.txt&quot;</span>, d1, <span class="hljs-number">0666</span>) <span class="hljs-comment">//写入文件(字节数组)</span><br>check(err2)<br><br><span class="hljs-comment">// 第三种方式: 使用File(Write,WriteString)写入文件</span><br>f, err3 := os.Create(<span class="hljs-string">&quot;./output3.txt&quot;</span>) <span class="hljs-comment">//创建文件</span><br>check(err3)<br><span class="hljs-keyword">defer</span> f.Close()<br>n2, err3 := f.Write(d1) <span class="hljs-comment">//写入文件(字节数组)</span><br>check(err3)<br>fmt.Printf(<span class="hljs-string">&quot;写入 %d 个字节n&quot;</span>, n2)<br>n3, err3 := f.WriteString(<span class="hljs-string">&quot;writesn&quot;</span>) <span class="hljs-comment">//写入文件(字节数组)</span><br>fmt.Printf(<span class="hljs-string">&quot;写入 %d 个字节n&quot;</span>, n3)<br>f.Sync()<br><br><span class="hljs-comment">// 第四种方式: 使用bufio.NewWriter写入文件</span><br>w := bufio.NewWriter(f) <span class="hljs-comment">//创建新的 Writer 对象</span><br>n4, err3 := w.WriteString(<span class="hljs-string">&quot;bufferedn&quot;</span>)<br>fmt.Printf(<span class="hljs-string">&quot;写入 %d 个字节n&quot;</span>, n4)<br>w.Flush()<br>f.Close()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派</title>
    <link href="/2021/07/08/%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    <url>/2021/07/08/%E6%A0%91%E8%8E%93%E6%B4%BE/</url>
    
    <content type="html"><![CDATA[<p><a href="https://learnku.com/articles/48579">树莓派如何通过FAN-4G-HAT访问互联网 | 树莓派论坛</a></p>]]></content>
    
    
    <categories>
      
      <category>TODO</category>
      
      <category>树莓派</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ROS相关</title>
    <link href="/2021/07/08/ROS%E7%9B%B8%E5%85%B3/"/>
    <url>/2021/07/08/ROS%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://docs.ros.org/en/galactic/Installation/Ubuntu-Development-Setup.html#get-ros-2-code">Building ROS 2 on Ubuntu Linux — ROS 2 Documentation: Galactic documentation</a></p><p><a href="https://blog.csdn.net/weixin_44504987/article/details/103483598">(17条消息) ROS操作系统基本命令汇总_探索者FXJ的博客-CSDN博客_ros系统命令</a></p><p>腾讯物联网系统<br><a href="https://github.com/Tencent/TencentOS-tiny">Tencent&#x2F;TencentOS-tiny: 腾讯物联网终端操作系统</a></p>]]></content>
    
    
    <categories>
      
      <category>ROS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ROS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OPA相关</title>
    <link href="/2021/07/08/OPA%E7%9B%B8%E5%85%B3/"/>
    <url>/2021/07/08/OPA%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p><a href="http://blog.newbmiao.com/2020/03/20/opa-comprehensions.html">OPA进阶-简洁的推导式 | 菜鸟Miao</a></p><p>datalog 与 rego：<a href="https://zh.wikipedia.org/wiki/Datalog">Datalog - 维基百科，自由的百科全书</a></p><p><a href="https://blog.csdn.net/qq_44586683/article/details/110942129">(17条消息) OPA：open policy agent简介_别码了别码了再码入傻了的博客-CSDN博客</a></p><p><a href="https://www.openpolicyagent.org/docs/latest/policy-reference/">Open Policy Agent | Policy Reference</a></p>]]></content>
    
    
    <categories>
      
      <category>开源项目</category>
      
      <category>Go</category>
      
      <category>OPA</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rust相关</title>
    <link href="/2021/07/08/Rust%E7%9B%B8%E5%85%B3/"/>
    <url>/2021/07/08/Rust%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<p>中文文档<br><a href="https://learnku.com/docs/rust-lang/2018/about-this-book/4591">关于本书 |《Rust 编程语言 2018》| Rust 技术论坛</a></p><p><a href="https://crates.io/">crates.io: Rust Package Registry</a></p><p><a href="https://doc.rust-lang.org/cargo/reference/config.html#netgit-fetch-with-cli">Configuration - The Cargo Book</a></p><p>在使用cargo引入依赖时，提示:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">Caused by:<br>  failed to authenticate when downloading repository<br>attempted ssh-agent authentication, but none of the usernames `git` succeeded<br></code></pre></td></tr></table></figure><p>解决:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs txt">DenisKolodin commented on 14 Jun 2017<br>Leave it here to help somebody...<br>I had a similar issue with ssh: dependency, but fixed it by starting ssh agent:<br><br>eval `ssh-agent -s`<br>ssh-add<br>cargo ...<br><br></code></pre></td></tr></table></figure><p><a href="https://cloud.tencent.com/developer/article/1428784">Rust今天4岁啦, 为什么越来越多的知名项目用Rust来开发？ - 云+社区 - 腾讯云</a></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB常用操作</title>
    <link href="/2021/07/08/MongoDB%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/07/08/MongoDB%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/xiongzaiabc/article/details/81186998">mongodb中比较级查询条件：（$lt $lte $gt $gte）（大于、小于）、查找条件_西门大盗 捉虫专家-CSDN博客</a></p><p><a href="https://blog.csdn.net/royzhang7/article/details/90377456">(18条消息) mongodb remove.deletemany批量删除效率比较_DBA小站-CSDN博客</a></p><p><a href="https://www.cnblogs.com/thewindkee/p/12873118.html">MongoDB中remove与deleteMany的区别？ - thewindkee - 博客园</a></p><p><a href="https://www.cnblogs.com/lz0925/p/11734050.html">mongodb启用auth，使用密码登录 - Eternity味道 - 博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BillGates病毒</title>
    <link href="/2021/07/08/BillGates%E7%97%85%E6%AF%92/"/>
    <url>/2021/07/08/BillGates%E7%97%85%E6%AF%92/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.codercto.com/">码农网官网_IT码农网_码农网站 | 码农网</a></p><p><a href="https://www.codercto.com/a/35888.html">BillGates僵尸网络依然活跃，警惕成为肉机 | 码农网</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Tmux用法</title>
    <link href="/2021/07/08/Tools/Tmux/Tmux%E7%94%A8%E6%B3%95/"/>
    <url>/2021/07/08/Tools/Tmux/Tmux%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="上下翻页，上下翻屏"><a href="#上下翻页，上下翻屏" class="headerlink" title="上下翻页，上下翻屏"></a>上下翻页，上下翻屏</h3><p>先按 Ctrl + B，再按 [<br>然后可以通过 pageUp, pageDown 实现上下翻页;<br>也可以通过上下方向键按行移动光标</p><h3 id="其他参考文档"><a href="#其他参考文档" class="headerlink" title="其他参考文档"></a>其他参考文档</h3><ul><li><p><a href="https://linuxize.com/post/getting-started-with-tmux/">Getting started with Tmux | Linuxize</a></p></li><li><p><a href="https://zhuanlan.zhihu.com/p/386085431">tmux使用指南：比screen好用n倍！ - 知乎</a></p></li><li><p><a href="https://www.hamvocke.com/blog/a-quick-and-easy-guide-to-tmux/">A Quick and Easy Guide to tmux</a></p></li><li><p><a href="https://github.com/tmux/tmux">tmux&#x2F;tmux: tmux source code</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Tmux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Tmux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>包管理工具npm yarn pnpm之间的区别</title>
    <link href="/2021/07/08/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7npm-yarn-pnpm%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/07/08/%E5%8C%85%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7npm-yarn-pnpm%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qiansg123/article/details/80129453">一文看懂npm、yarn、pnpm之间的区别_博客-CSDN博客</a></p><p><a href="https://www.baidu.com/s?ie=UTF-8&wd=pnpm">pnpm_百度搜索</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim错误</title>
    <link href="/2021/07/08/Tools/Vim/Vim%E9%94%99%E8%AF%AF/"/>
    <url>/2021/07/08/Tools/Vim/Vim%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.zhihu.com/question/60367881?sort=created">vim 提示 E363: uses more memory than ‘maxmempattern’? - 知乎</a></p><p><a href="https://github.com/vim/vim/issues/2049">E363: pattern uses more memory than ‘maxmempattern’ · Issue #2049 · vim&#x2F;vim</a></p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Vim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go编码规范</title>
    <link href="/2021/07/08/Go%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <url>/2021/07/08/Go%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/peteremperor/p/14609928.html">Golang编码规范指南 - Mr.peter - 博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Docker查看镜像日志</title>
    <link href="/2021/07/08/Docker/Docker%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F%E6%97%A5%E5%BF%97/"/>
    <url>/2021/07/08/Docker/Docker%E6%9F%A5%E7%9C%8B%E9%95%9C%E5%83%8F%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/1eb1d1d3f25e">docker logs－查看docker容器日志 - 简书</a></p>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux的find命令使用</title>
    <link href="/2021/07/08/Linux%E7%9A%84find%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/07/08/Linux%E7%9A%84find%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/mayou18/p/9552818.html">linux find-在指定目录下查找文件 - 码友 - 博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>dlv使用问题</title>
    <link href="/2021/07/08/dlv%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <url>/2021/07/08/dlv%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="问题一"><a href="#问题一" class="headerlink" title="问题一"></a>问题一</h2><blockquote><p>使用<code>dlv attach pid</code>时提示:<code>could not attach to pid 6976: decoding dwarf section info at offset 0x0: too short</code></p></blockquote><p>我的问题上直接<code>go run x.go</code>了，要先<code>go build x.go</code>，然后运行<code>x</code>。</p><p>如果<code>go build</code>后，仍有问题，可检查<code>go build</code>的参数是否有<code>-s</code> <code>-w</code>，这两个参数分别表示<code>去掉符号表</code> <code>去掉调试信息,不能gdb调试</code>。</p><p>如果仍没有解决，可以尝试升级下<code>dlv</code>版本。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go与reflect使用总结</title>
    <link href="/2021/07/07/Go%E8%AF%AD%E8%A8%80reflect%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <url>/2021/07/07/Go%E8%AF%AD%E8%A8%80reflect%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Docker使用</title>
    <link href="/2021/07/07/Docker/Docker%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/07/07/Docker/Docker%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="设置镜像在Dcoekr启动时启动-or-开机自启"><a href="#设置镜像在Dcoekr启动时启动-or-开机自启" class="headerlink" title="设置镜像在Dcoekr启动时启动(or 开机自启)"></a>设置镜像在Dcoekr启动时启动(or 开机自启)</h2><ul><li>如果镜像还没创建，只需要在<code>docker run</code>命令中加上<code>--restart=always</code>即可；</li><li>如果镜像已经创建，则可以通过<code>docker update --restart=always 镜像名称</code>进行添加。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go关于return的问题</title>
    <link href="/2021/06/30/Go%E5%85%B3%E4%BA%8Ereturn%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2021/06/30/Go%E5%85%B3%E4%BA%8Ereturn%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>当存在命名参数时，需要写return，如add所示.</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>fmt.Println(add(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>))<br><br>sub(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> (c <span class="hljs-type">int</span>) &#123;<br>c = a + b<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span><span class="hljs-params">(a, b <span class="hljs-type">int</span>)</span></span> &#123;<br>c := a - b<br>fmt.Println(c)<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go浮点型与字符串的转化</title>
    <link href="/2021/06/30/Go%E6%B5%AE%E7%82%B9%E5%9E%8B%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E5%8C%96/"/>
    <url>/2021/06/30/Go%E6%B5%AE%E7%82%B9%E5%9E%8B%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E8%BD%AC%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="FormatFloat-将浮点数转为字符串值"><a href="#FormatFloat-将浮点数转为字符串值" class="headerlink" title="FormatFloat 将浮点数转为字符串值"></a>FormatFloat 将浮点数转为字符串值</h3><p><strong>func FormatFloat(f float64, fmt byte, prec, bitSize int) string</strong></p><ul><li>f：要转换的浮点数</li><li>fmt：格式标记（b、e、E、f、g、G）</li><li>prec：精度（数字部分的长度，不包括指数部分）</li><li>bitSize：指定浮点类型（32:float32、64:float64）</li></ul><blockquote><p>格式标记：<br>‘b’ (-ddddp±ddd，二进制指数)<br>‘e’ (-d.dddde±dd，十进制指数)<br>‘E’ (-d.ddddE±dd，十进制指数)<br>‘f’  (-ddd.dddd，没有指数)<br>‘g’ (‘e’:大指数，‘f’:其它情况)<br>‘G’ (‘E’:大指数，‘f’:其它情况)</p></blockquote><ul><li>如果格式标记为 ‘e’, ‘E’ 或 ‘f’, 则 prec 表示小数点后的数字位数</li><li>如果格式标记为 ‘g’, ‘G’, 则 prec 表示总的数字位数（整数部分+小数部分）</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f := <span class="hljs-number">100.12345678901234567890123456789</span><br>fmt.Println(strconv.FormatFloat(f, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">32</span>))<br><span class="hljs-comment">// 13123382p-17</span><br>fmt.Println(strconv.FormatFloat(f, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">32</span>))<br><span class="hljs-comment">// 1.00123e+02</span><br>fmt.Println(strconv.FormatFloat(f, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">32</span>))<br><span class="hljs-comment">// 1.00123E+02</span><br>fmt.Println(strconv.FormatFloat(f, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">32</span>))<br><span class="hljs-comment">// 100.12346</span><br>fmt.Println(strconv.FormatFloat(f, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">32</span>))<br><span class="hljs-comment">// 100.12</span><br>fmt.Println(strconv.FormatFloat(f, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-number">5</span>, <span class="hljs-number">32</span>))<br><span class="hljs-comment">// 100.12</span><br>fmt.Println(strconv.FormatFloat(f, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">30</span>, <span class="hljs-number">32</span>))<br><span class="hljs-comment">// 13123382p-17</span><br>fmt.Println(strconv.FormatFloat(f, <span class="hljs-string">&#x27;e&#x27;</span>, <span class="hljs-number">30</span>, <span class="hljs-number">32</span>))<br><span class="hljs-comment">// 1.001234588623046875000000000000e+02</span><br>fmt.Println(strconv.FormatFloat(f, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-number">30</span>, <span class="hljs-number">32</span>))<br><span class="hljs-comment">// 1.001234588623046875000000000000E+02</span><br>fmt.Println(strconv.FormatFloat(f, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">30</span>, <span class="hljs-number">32</span>))<br><span class="hljs-comment">// 100.123458862304687500000000000000</span><br>fmt.Println(strconv.FormatFloat(f, <span class="hljs-string">&#x27;g&#x27;</span>, <span class="hljs-number">30</span>, <span class="hljs-number">32</span>))<br><span class="hljs-comment">// 100.1234588623046875</span><br>fmt.Println(strconv.FormatFloat(f, <span class="hljs-string">&#x27;G&#x27;</span>, <span class="hljs-number">30</span>, <span class="hljs-number">32</span>))<br><span class="hljs-comment">// 100.1234588623046875</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ParseFloat-将字符串转换为浮点数"><a href="#ParseFloat-将字符串转换为浮点数" class="headerlink" title="ParseFloat 将字符串转换为浮点数"></a>ParseFloat 将字符串转换为浮点数</h3><p><strong>func ParseFloat(s string, bitSize int) (f float64, err error)</strong></p><ul><li>s：要转换的字符串</li><li>bitSize：指定浮点类型（32:float32、64:float64）</li></ul><blockquote><p> 如果 s 是合法的格式，而且接近一个浮点值，则返回浮点数的四舍五入值（依据 IEEE754 的四舍五入标准）<br>如果 s 不是合法的格式，则返回“语法错误”<br>如果转换结果超出 bitSize 范围，则返回“超出范围”</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-string">&quot;0.12345678901234567890&quot;</span><br>f, err := strconv.ParseFloat(s, <span class="hljs-number">32</span>)<br>fmt.Println(f, err)          <span class="hljs-comment">// 0.12345679104328156</span><br>fmt.Println(<span class="hljs-type">float32</span>(f), err) <span class="hljs-comment">// 0.12345679</span><br>f, err = strconv.ParseFloat(s, <span class="hljs-number">64</span>)<br>fmt.Println(f, err) <span class="hljs-comment">// 0.12345678901234568</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go通过反射获取和设置结构体字段值</title>
    <link href="/2021/06/30/Go%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E5%80%BC/"/>
    <url>/2021/06/30/Go%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E5%92%8C%E8%AE%BE%E7%BD%AE%E7%BB%93%E6%9E%84%E4%BD%93%E5%AD%97%E6%AE%B5%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> M <span class="hljs-keyword">struct</span> &#123;<br>        N <span class="hljs-type">int</span><br>&#125;<br>m := M&#123; <span class="hljs-number">1</span> &#125;<br><br><span class="hljs-comment">// get</span><br>x := reflect.ValueOf(m)<br>val := x.FieldByName(<span class="hljs-string">&quot;N&quot;</span>).Int()<br>fmt.Printf(<span class="hljs-string">&quot;N=%d\n&quot;</span>, val) <span class="hljs-comment">// N=1</span><br><br><span class="hljs-comment">// set</span><br>y := reflect.ValueOf(&amp;m).Elem()<br>ok := y.FieldByName(<span class="hljs-string">&quot;N&quot;</span>).SetInt(<span class="hljs-number">7</span>)<br><span class="hljs-keyword">if</span> ok &#123;<br>    fmt.Println(<span class="hljs-string">&quot;设置成功&quot;</span>)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;N=%d\n&quot;</span>, n.N) <span class="hljs-comment">// N=7</span><br></code></pre></td></tr></table></figure><p>如果是interface{}转map[string]interface{} 可以直接转</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">User.(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)[<span class="hljs-string">&quot;username&quot;</span>]<br></code></pre></td></tr></table></figure><p>其实值类型的转换如下</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a <span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-keyword">var</span> b <span class="hljs-type">string</span><br>a = <span class="hljs-string">&quot;asdasdasdasd&quot;</span><br>b = a.(<span class="hljs-type">string</span>)<br>fmt.Println(a, b)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL设置自增序列起始值</title>
    <link href="/2021/06/29/PostgreSQL%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%A2%9E%E5%BA%8F%E5%88%97%E8%B5%B7%E5%A7%8B%E5%80%BC/"/>
    <url>/2021/06/29/PostgreSQL%E8%AE%BE%E7%BD%AE%E8%87%AA%E5%A2%9E%E5%BA%8F%E5%88%97%E8%B5%B7%E5%A7%8B%E5%80%BC/</url>
    
    <content type="html"><![CDATA[<p>注意传入的数据格式，不是传入表名称也不是传入字段名称，而是传入一个类似<code>表明称_字段名称_seq</code>的东西.</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 获取下一个自增值, 这会改变自增值的起点，即如果你一直执行该语句，你会看到返回的数字不断变大</span><br><span class="hljs-keyword">select</span> nextval(<span class="hljs-string">&#x27;mofan_info_id_seq&#x27;</span>);<br><br><span class="hljs-comment">-- 设置起始值起点，下一个值是1025</span><br><span class="hljs-keyword">select</span> setval(<span class="hljs-string">&#x27;mofan_info_id_seq&#x27;</span>, <span class="hljs-number">1024</span>);<br><span class="hljs-comment">-- 等价于</span><br><span class="hljs-keyword">select</span> setval(<span class="hljs-string">&#x27;mofan_info_id_seq&#x27;</span>, <span class="hljs-number">1024</span>, <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">-- 设置起始值起点，下一个值是1024</span><br><span class="hljs-keyword">select</span> setval(<span class="hljs-string">&#x27;mofan_info_id_seq&#x27;</span>, <span class="hljs-number">1024</span>, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure><table><thead><tr><th>函数</th><th>返回类型</th><th>描述</th></tr></thead><tbody><tr><td>nextval(regclass)</td><td>bigint</td><td>递增序列对象到它的下一个数值并且返回该值。这个动作是自动完成的。即使多个会话并发运行nextval，每个进程也会安全地收到一个唯一的序列值。</td></tr><tr><td>currval(regclass)</td><td>bigint</td><td>在当前会话中返回最近一次<code>nextval</code>抓到的该序列的数值。(如果在本会话中从未在该序列上调用过 <code>nextval</code>，那么会报告一个错误。)请注意因为此函数返回一个会话范围的数值，而且也能给出一个可预计的结果，因此可以用于判断其它会话是否执行过<code>nextval。</code></td></tr><tr><td>lastval()</td><td>bigint</td><td>返回当前会话里最近一次<code>nextval</code>返回的数值。这个函数等效于<code>currval</code>，只是它不用序列名为参数，它抓取当前会话里面最近一次<code>nextval</code>使用的序列。如果当前会话还没有调用过<code>nextval</code>，那么调用<code>lastval将</code>会报错。</td></tr><tr><td>setval(regclass, bigint)</td><td>bigint</td><td>重置序列对象的计数器数值。设置序列的<code>last_value</code>字段为指定数值并且将其<code>is_called</code>字段设置为<code>true</code>，表示下一次<code>nextval</code>将在返回数值之前递增该序列。</td></tr><tr><td>setval(regclass, bigint, boolean)</td><td>bigint</td><td>重置序列对象的计数器数值。功能等同于上面的setval函数，只是<code>is_called</code>可以设置为<code>true</code>或<code>false</code>。如果将其设置为<code>false</code>，那么下一次<code>nextval</code>将返回该数值，随后的<code>nextval</code>才开始递增该序列。</td></tr></tbody></table><p>参考：</p><ol><li><a href="https://www.postgresql.org/docs/9.6/datatype-numeric.html">PostgreSQL: Documentation: 9.6: Numeric Types</a>里面8.1.4. Serial Types 的 Note</li><li><a href="https://www.postgresql.org/docs/9.6/functions-sequence.html">PostgreSQL: Documentation: 9.6: Sequence Manipulation Functions</a></li></ol>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>有趣的Linux命令</title>
    <link href="/2021/06/28/%E6%9C%89%E8%B6%A3%E7%9A%84Linux%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/06/28/%E6%9C%89%E8%B6%A3%E7%9A%84Linux%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="新建文件夹并进入"><a href="#新建文件夹并进入" class="headerlink" title="新建文件夹并进入"></a>新建文件夹并进入</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir hello &amp;&amp; cd $_<br></code></pre></td></tr></table></figure><h3 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h3><p>-c按创建时间ctime排序，-t按修改时间mtime排序，-r可以实现逆序排序，按时间排序的默认是降序排序。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls -alrt # 按修改时间升序排序<br>ls --sort=time -lra # 等价于 ls -alrt<br>ls -alrc # 按创建时间升序排序<br>ls -alru # 按访问时间升序排序<br></code></pre></td></tr></table></figure><p>查询文件，将结果按时间排序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -name *.php|xargs ls -alt<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iterm2快捷键</title>
    <link href="/2021/06/28/Tools/iTerm2/iterm2%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2021/06/28/Tools/iTerm2/iterm2%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">新建标签：command + t<br> <br>关闭标签：command + w<br> <br>切换标签：command + 数字 command + 左右方向键<br> <br>切换全屏：command + enter<br> <br>查找：command + f<br></code></pre></td></tr></table></figure><h2 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">垂直分屏：command + d<br> <br>水平分屏：command + shift + d<br> <br>切换屏幕：command + option + 方向键 command + [ 或 command + ]<br> <br>查看历史命令：command + ;<br> <br>查看剪贴板历史：command + shift + h<br></code></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs text">清除当前行：ctrl + u<br> <br>到行首：ctrl + a<br> <br>到行尾：ctrl + e<br> <br>前进后退：ctrl + f/b (相当于左右方向键)<br> <br>上一条命令：ctrl + p<br> <br>搜索命令历史：ctrl + r<br> <br>删除当前光标的字符：ctrl + d<br> <br>删除光标之前的字符：ctrl + h<br> <br>删除光标之前的单词：ctrl + w<br> <br>删除到文本末尾：ctrl + k<br> <br>交换光标处文本：ctrl + t<br> <br>清屏1：command + r<br> <br>清屏2：ctrl + l<br> <br>自带有哪些很实用的功能/快捷键<br> <br>⌘ + 数字在各 tab 标签直接来回切换<br> <br>选择即复制 + 鼠标中键粘贴，这个很实用<br> <br>⌘ + f 所查找的内容会被自动复制<br> <br>⌘ + d 横着分屏 / ⌘ + shift + d 竖着分屏<br> <br>⌘ + r = clear，而且只是换到新一屏，不会想 clear 一样创建一个空屏<br> <br>ctrl + u 清空当前行，无论光标在什么位置<br> <br>输入开头命令后 按 ⌘ + ; 会自动列出输入过的命令<br> <br>⌘ + shift + h 会列出剪切板历史<br> <br>可以在 Preferences &gt; keys 设置全局快捷键调出 iterm，这个也可以用过 Alfred 实现<br></code></pre></td></tr></table></figure><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs text">⌘ + 1 / 2 左右 tab 之间来回切换，这个在 前面 已经介绍过了<br> <br>⌘← / ⌘→ 到一行命令最左边/最右边 ，这个功能同 C+a / C+e<br> <br>⌥← / ⌥→ 按单词前移/后移，相当与 C+f / C+b，其实这个功能在Iterm中已经预定义好了，⌥f / ⌥b，看个人习惯了<br> <br>好像就这几个<br> <br>设置方法如下<br> <br>当然除了这些可以自定义的也不能忘了 linux 下那些好用的组合<br> <br>C+a / C+e 这个几乎在哪都可以使用<br> <br>C+p / !! 上一条命令<br> <br>C+k 从光标处删至命令行尾 (本来 C+u 是删至命令行首，但iterm中是删掉整行)<br> <br>C+w A+d 从光标处删至字首/尾<br> <br>C+h C+d 删掉光标前后的自负<br> <br>C+y 粘贴至光标后<br> <br>C+r 搜索命令历史，这个较常用<br></code></pre></td></tr></table></figure><h3 id="选中即复制"><a href="#选中即复制" class="headerlink" title="选中即复制"></a>选中即复制</h3><p><strong>iterm2 有 2 种好用的选中即复制模式。</strong></p><ul><li>一种是用鼠标，在 iterm2 中，选中某个路径或者某个词汇，那么，iterm2 就自动复制了。 　　</li><li>另一种是无鼠标模式，<code>command+f</code>,弹出 iterm2 的查找模式，输入要查找并复制的内容的前几个字母，确认找到的是自己的内容之后，输入 <code>tab</code>，查找窗口将自动变化内容，并将其复制。如果输入的是 <code>shift+tab</code>，则自动将查找内容的左边选中并复制。</li></ul><h3 id="自动完成"><a href="#自动完成" class="headerlink" title="自动完成"></a>自动完成</h3><p>输入打头几个字母，然后输入 <code>command+</code>; iterm2 将自动列出之前输入过的类似命令。 　　</p><h3 id="剪切历史"><a href="#剪切历史" class="headerlink" title="剪切历史"></a>剪切历史</h3><p>输入 <code>command+shift+h</code>，iterm2 将自动列出剪切板的历史记录。如果需要将剪切板的历史记录保存到磁盘，在 <code>Preferences &gt; General &gt; Save copy/paste history to disk</code> 中设置。</p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>iTerm2</category>
      
    </categories>
    
    
    <tags>
      
      <tag>iTerm2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim快捷键</title>
    <link href="/2021/06/28/Tools/Vim/Vim%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2021/06/28/Tools/Vim/Vim%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<p>这是一个比较全面的快捷键，有很多没有实验，实验过的且我认为使用vim中经常用到的快捷键，我有做了个(Vim常用命令Pro)[<a href="https://www.mofan.life/2021/10/25/Vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4Pro/],%E8%BF%99%E9%87%8C%E9%9D%A2%E5%88%A0%E9%99%A4%E4%BA%86%E4%B8%80%E4%BA%9B%E6%9C%80%E5%9F%BA%E6%9C%AC%E7%9A%84%E6%8C%87%E4%BB%A4%EF%BC%8C%E5%BB%BA%E8%AE%AE%E5%AF%B9%E5%9F%BA%E6%9C%AC%E6%8C%87%E4%BB%A4%E7%86%9F%E6%82%89%E5%90%8E%E5%86%8D%E7%9C%8B%E8%BF%99%E4%B8%80%E7%AF%87%E3%80%82">https://www.mofan.life/2021/10/25/Vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4Pro/],这里面删除了一些最基本的指令，建议对基本指令熟悉后再看这一篇。</a></p><h2 id="Vim的几种模式"><a href="#Vim的几种模式" class="headerlink" title="Vim的几种模式"></a>Vim的几种模式</h2><ul><li>正常模式：可以使用快捷键命令，或按:输入命令行。</li><li>插入模式：可以输入文本，在正常模式下，按i、a、o等都可以进入插入模式。</li><li>可视模式：正常模式下按v可以进入可视模式， 在可视模式下，移动光标可以选择文本。按V进入可视行模式， 总是整行整行的选中。ctrl+v进入可视块模式，之后使用 j&#x2F;k&#x2F;h&#x2F;l键可以选中一块</li><li>替换模式：正常模式下，按R进入。</li></ul><h2 id="启动Vim"><a href="#启动Vim" class="headerlink" title="启动Vim"></a>启动Vim</h2><ul><li>vim -c cmd file: 在打开文件前，先执行指定的命令；</li><li>vim -r file: 恢复上次异常退出的文件；</li><li>vim -R file: 以只读的方式打开文件，但可以强制保存；</li><li>vim -M file: 以只读的方式打开文件，不可以强制保存；</li><li>vim -y num file: 将编辑窗口的大小设为num行；</li><li>vim + file: 从文件的末尾开始；</li><li>vim +num file: 从第num行开始；</li><li>vim +&#x2F;string file: 打开file，并将光标停留在第一个找到的string上。</li><li>vim –remote file: 用已有的vim进程打开指定的文件。 如果你不想启用多个vim会话，这个很有用。但要注意， 如果你用vim，会寻找名叫VIM的服务器；如果你已经有一个gvim在运行了， 你可以用gvim –remote file在已有的gvim中打开文件。</li></ul><h2 id="文档操作"><a href="#文档操作" class="headerlink" title="文档操作"></a>文档操作</h2><ul><li>:e file –关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi会警告。</li><li>:e! file –放弃对当前文件的修改，编辑新的文件。</li><li>:e+file – 开始新的文件，并从文件尾开始编辑。</li><li>:e+n file – 开始新的文件，并从第n行开始编辑。</li><li>:enew –编译一个未命名的新文档。(CTRL-W n)</li><li>:e – 重新加载当前文档。</li><li>:e! – 重新加载当前文档，并丢弃已做的改动。</li><li>:e#或ctrl+^ – 回到刚才编辑的文件，很实用。</li><li>:f或ctrl+g – 显示文档名，是否修改，和光标位置。</li><li>:f filename – 改变编辑的文件名，这时再保存相当于另存为。</li><li>gf – 打开以光标所在字符串为文件名的文件。</li><li>:w – 保存修改。</li><li>:n1,n2w filename – 选择性保存从某n1行到另n2行的内容。</li><li>:wq – 保存并退出。</li><li>ZZ – 保存并退出。</li><li>:x – 保存并退出。</li><li>:q[uit] ——退出当前窗口。(CTRL-W q或CTRL-W CTRL-Q)</li><li>:saveas newfilename – 另存为</li><li>:browse e – 会打开一个文件浏览器让你选择要编辑的文件。 如果是终端中，则会打开netrw的文件浏览窗口； 如果是gvim，则会打开一个图形界面的浏览窗口。 实际上:browse后可以跟任何编辑文档的命令，如sp等。 用browse打开的起始目录可以由browsedir来设置：<ul><li>:set browsedir&#x3D;last – 用上次访问过的目录（默认）；</li><li>:set browsedir&#x3D;buffer – 用当前文件所在目录；</li><li>:set browsedir&#x3D;current – 用当前工作目录；</li></ul></li><li>:Sex – 水平分割一个窗口，浏览文件系统；</li><li>:Vex – 垂直分割一个窗口，浏览文件系统；</li></ul><h2 id="光标的移动"><a href="#光标的移动" class="headerlink" title="光标的移动"></a>光标的移动</h2><h3 id="基本移动"><a href="#基本移动" class="headerlink" title="基本移动"></a>基本移动</h3><p>以下移动都是在normal模式下。</p><ul><li>h或退格: 左移一个字符；</li><li>l或空格: 右移一个字符；</li><li>j: 下移一行；</li><li>k: 上移一行；</li><li>gj: 移动到一段内的下一行；</li><li>gk: 移动到一段内的上一行；</li><li>+或Enter: 把光标移至下一行第一个非空白字符。</li><li>-: 把光标移至上一行第一个非空白字符。</li><li>w: 前移一个单词，光标停在下一个单词开头；</li><li>W: 移动下一个单词开头，但忽略一些标点；</li><li>e: 前移一个单词，光标停在下一个单词末尾；</li><li>E: 移动到下一个单词末尾，如果词尾有标点，则移动到标点；</li><li>b: 后移一个单词，光标停在上一个单词开头；</li><li>B: 移动到上一个单词开头，忽略一些标点；</li><li>ge: 后移一个单词，光标停在上一个单词末尾；</li><li>gE: 同 ge ，不过‘单词’包含单词相邻的标点。</li><li>(: 前移1句。</li><li>): 后移1句。</li><li>{: 前移1段。</li><li>}: 后移1段。</li><li>fc: 把光标移到同一行的下一个c字符处</li><li>Fc: 把光标移到同一行的上一个c字符处</li><li>tc: 把光标移到同一行的下一个c字符前</li><li>Tc: 把光标移到同一行的上一个c字符后</li><li>;: 配合f &amp; t使用，重复一次，比如fa后，再; 表示继续fa</li><li>,: 配合f &amp; t使用，反向重复一次</li></ul><p>上面的操作都可以配合n使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动3个字符。</p><ul><li>0: 移动到行首。</li><li>g0: 移到光标所在屏幕行行首。</li><li>^: 移动到本行第一个非空白字符。</li><li>g^: 同 ^ ，但是移动到当前屏幕行第一个非空字符处。</li><li>$: 移动到行尾。</li><li>g$: 移动光标所在屏幕行行尾。</li><li>n|: 把光标移到递n列上。</li><li>nG: 到文件第n行。</li><li>:n<cr> 移动到第n行。</li><li>:$<cr> 移动到最后一行。</li><li>H: 把光标移到屏幕最顶端一行。</li><li>M: 把光标移到屏幕中间一行。</li><li>L: 把光标移到屏幕最底端一行。</li><li>gg: 到文件头部。</li><li>G: 到文件尾部。</li></ul><h3 id="翻屏"><a href="#翻屏" class="headerlink" title="翻屏"></a>翻屏</h3><ul><li>ctrl+f: 下翻一屏。</li><li>ctrl+b: 上翻一屏。</li><li>ctrl+d: 下翻半屏。</li><li>ctrl+u: 上翻半屏。</li><li>ctrl+e: 向下滚动一行。</li><li>ctrl+y: 向上滚动一行。</li><li>n%: 到文件n%的位置。</li><li>zz: 将当前行移动到屏幕中央。</li><li>zt: 将当前行移动到屏幕顶端。</li><li>zb: 将当前行移动到屏幕底端。</li></ul><h3 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h3><p>使用标记可以快速移动。到达标记后，可以用Ctrl+o返回原来的位置。 Ctrl+o和Ctrl+i 很像浏览器上的 <em>后退</em> 和 <em>前进</em> 。</p><ul><li>m{a-z}: 标记光标所在位置，局部标记，只用于当前文件。</li><li>m{A-Z}: 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。</li><li>&#96;{a-z}: 移动到标记位置。</li><li>‘{a-z}: 移动到标记行的行首。</li><li>&#96;{0-9}：回到上[2-10]次关闭vim时最后离开的位置。</li><li><code>: 移动到上次编辑的位置。&#39;&#39;也可以，不过</code>精确到列，而’’精确到行 。如果想跳转到更老的位置，可以按C-o，跳转到更新的位置用C-i。</li><li>&#96;”: 移动到上次离开的地方。</li><li>&#96;.: 移动到最后改动的地方。</li><li>:marks 显示所有标记。</li><li>:delmarks a b – 删除标记a和b。</li><li>:delmarks a-c – 删除标记a、b和c。</li><li>:delmarks a c-f – 删除标记a、c、d、e、f。</li><li>:delmarks! – 删除当前缓冲区的所有标记。</li><li>:help mark-motions 查看更多关于mark的知识。</li></ul><h2 id="插入文本"><a href="#插入文本" class="headerlink" title="插入文本"></a>插入文本</h2><h3 id="基本插入"><a href="#基本插入" class="headerlink" title="基本插入"></a>基本插入</h3><ul><li>i: 在光标前插入；一个小技巧：按8，再按i，进入插入模式，输入&#x3D;， 按esc进入命令模式，就会出现8个&#x3D;。 这在插入分割线时非常有用，如30i+<esc>就插入了36个+组成的分割线。</li><li>I: 在当前行第一个非空字符前插入；</li><li>gI: 在当前行第一列插入；</li><li>a: 在光标后插入；</li><li>A: 在当前行最后插入；</li><li>o: 在下面新建一行插入；</li><li>O: 在上面新建一行插入；</li><li>:r filename在当前位置插入另一个文件的内容。</li><li>:[n]r filename在第n行插入另一个文件的内容。</li><li>:r !date 在光标处插入当前日期与时间。同理，:r !command可以将其它shell命令的输出插入当前文档。</li></ul><h3 id="改写插入"><a href="#改写插入" class="headerlink" title="改写插入"></a>改写插入</h3><ul><li>c[n]w: 改写光标后1(n)个词。</li><li>c[n]l: 改写光标后n个字母。</li><li>c[n]h: 改写光标前n个字母。</li><li>[n]cc: 修改当前[n]行。</li><li>[n]s: 以输入的文本替代光标之后1(n)个字符，相当于c[n]l。</li><li>[n]S: 删除指定数目的行，并以所输入文本代替之。</li></ul><p>注意，类似cnw,dnw,ynw的形式同样可以写为ncw,ndw,nyw。</p><h2 id="剪切复制和寄存器"><a href="#剪切复制和寄存器" class="headerlink" title="剪切复制和寄存器"></a>剪切复制和寄存器</h2><h3 id="剪切和复制、粘贴"><a href="#剪切和复制、粘贴" class="headerlink" title="剪切和复制、粘贴"></a>剪切和复制、粘贴</h3><ul><li>[n]x: 剪切光标右边n个字符，相当于d[n]l。</li><li>[n]X: 剪切光标左边n个字符，相当于d[n]h。</li><li>y: 复制在可视模式下选中的文本。</li><li>yy or Y: 复制整行文本。</li><li>y[n]w: 复制一(n)个词。</li><li>y[n]l: 复制光标右边1(n)个字符。</li><li>y[n]h: 复制光标左边1(n)个字符。</li><li>y$: 从光标当前位置复制到行尾。</li><li>y0: 从光标当前位置复制到行首。</li><li>:m,ny<cr> 复制m行到n行的内容。</li><li>y1G或ygg: 复制光标以上的所有行。</li><li>yG: 复制光标以下的所有行。</li><li>yaw和yas：复制一个词和复制一个句子，即使光标不在词首和句首也没关系。</li><li>d: 删除（剪切）在可视模式下选中的文本。</li><li>d$ or D: 删除（剪切）当前位置到行尾的内容。</li><li>d[n]w: 删除（剪切）1(n)个单词</li><li>d[n]l: 删除（剪切）光标右边1(n)个字符。</li><li>d[n]h: 删除（剪切）光标左边1(n)个字符。</li><li>d0: 删除（剪切）当前位置到行首的内容</li><li>[n] dd: 删除（剪切）1(n)行。</li><li>:m,nd<cr> 剪切m行到n行的内容。</li><li>d1G或dgg: 剪切光标以上的所有行。</li><li>dG: 剪切光标以下的所有行。</li><li>daw和das：剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。</li><li>dt字符           –删除本行内容，直到遇到第一个指定字符 [不包括该字符]</li><li>df字符           –删除本行内容，直到遇到第一个指定字符 [包括该字符]</li><li>p: 在光标之后粘贴。</li><li>P: 在光标之前粘贴。</li></ul><h3 id="文本对象"><a href="#文本对象" class="headerlink" title="文本对象"></a>文本对象</h3><ul><li>aw：一个词</li><li>as：一句。</li><li>ap：一段。</li><li>ab：一块（包含在圆括号中的）。</li></ul><p>y, d, c, v都可以跟文本对象。</p><h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><ul><li>a-z：都可以用作寄存器名。”ayy把当前行的内容放入a寄存器。</li><li>A-Z：用大写字母索引寄存器，可以在寄存器中追加内容。 如”Ayy把当前行的内容追加到a寄存器中。</li><li>:reg 显示所有寄存器的内容。</li><li>“”：不加寄存器索引时，默认使用的寄存器。</li><li>“*：当前选择缓冲区，”*yy把当前行的内容放入当前选择缓冲区。</li><li>“+：系统剪贴板。”+yy把当前行的内容放入系统剪贴板。</li></ul><h2 id="查找与替换"><a href="#查找与替换" class="headerlink" title="查找与替换"></a>查找与替换</h2><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><ul><li>&#x2F;something: 在后面的文本中查找something。</li><li>?something: 在前面的文本中查找something。</li><li>&#x2F;pattern&#x2F;+number: 将光标停在包含pattern的行后面第number行上。</li><li>&#x2F;pattern&#x2F;-number: 将光标停在包含pattern的行前面第number行上。</li><li>n: 向后查找下一个。</li><li>N: 向前查找下一个。</li></ul><p>可以用grep或vimgrep查找一个模式都在哪些地方出现过，</p><p>其中:grep是调用外部的grep程序，而:vimgrep是vim自己的查找算法。</p><p>用法为： :vim[grep]&#x2F;pattern&#x2F;[g] [j] files</p><p>g的含义是如果一个模式在一行中多次出现，则这一行也在结果中多次出现。</p><p>j的含义是grep结束后，结果停在第j项，默认是停在第一项。</p><p>vimgrep前面可以加数字限定搜索结果的上限，如</p><p>:1vim&#x2F;pattern&#x2F; % 只查找那个模式在本文件中的第一个出现。</p><p>其实vimgrep在读纯文本电子书时特别有用，可以生成导航的目录。</p><p>比如电子书中每一节的标题形式为：n. xxxx。你就可以这样：</p><p>:vim&#x2F;^d{1,}.&#x2F; %</p><p>然后用:cw或:copen查看结果，可以用C-w H把quickfix窗口移到左侧，</p><p>就更像个目录了。</p><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><ul><li>:s&#x2F;old&#x2F;new - 用new替换当前行第一个old。</li><li>:s&#x2F;old&#x2F;new&#x2F;g - 用new替换当前行所有的old。</li><li>:n1,n2s&#x2F;old&#x2F;new&#x2F;g - 用new替换文件n1行到n2行所有的old。</li><li>:%s&#x2F;old&#x2F;new&#x2F;g - 用new替换文件中所有的old。</li><li>:%s&#x2F;^&#x2F;xxx&#x2F;g - 在每一行的行首插入xxx，^表示行首。</li><li>:%s&#x2F;$&#x2F;xxx&#x2F;g - 在每一行的行尾插入xxx，$表示行尾。</li><li>所有替换命令末尾加上c，每个替换都将需要用户确认。 如：%s&#x2F;old&#x2F;new&#x2F;gc，加上i则忽略大小写(ignore)。</li></ul><p>还有一种比替换更灵活的方式，它是匹配到某个模式后执行某种命令，</p><p>语法为 :[range]g&#x2F;pattern&#x2F;command</p><p>例如 :%g&#x2F;^ xyz&#x2F;normal dd。</p><p>表示对于以一个空格和xyz开头的行执行normal模式下的dd命令。</p><p>关于range的规定为：</p><ul><li>如果不指定range，则表示当前行。</li><li>m,n: 从m行到n行。</li><li>0: 最开始一行（可能是这样）。</li><li>$: 最后一行</li><li>.: 当前行</li><li>%: 所有行</li></ul><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>高级的查找替换就要用到正则表达式。</p><ul><li>\d: 表示十进制数（我猜的）</li><li>\s: 表示空格</li><li>\S: 非空字符</li><li>\a: 英文字母</li><li>|: 表示 或</li><li>.: 表示.</li><li>{m,n}: 表示m到n个字符。这要和 \s与\a等连用，如 \a{m,n} 表示m 到n个英文字母。</li><li>{m,}: 表示m到无限多个字符。</li><li>**: 当前目录下的所有子目录。</li></ul><p>:help pattern得到更多帮助。</p><h2 id="排版"><a href="#排版" class="headerlink" title="排版"></a>排版</h2><h3 id="基本排版"><a href="#基本排版" class="headerlink" title="基本排版"></a>基本排版</h3><ul><li>&lt;&lt; 向左缩进一个shiftwidth</li><li>&gt;&gt; 向右缩进一个shiftwidth</li><li>:ce(nter) 本行文字居中</li><li>:le(ft) 本行文字靠左</li><li>:ri(ght) 本行文字靠右</li><li>gq 对选中的文字重排，即对过长的文字进行断行</li><li>gqq 重排当前行</li><li>gqnq 重排n行</li><li>gqap 重排当前段</li><li>gqnap 重排n段</li><li>gqnj 重排当前行和下面n行</li><li>gqQ 重排当前段对文章末尾</li><li>J 拼接当前行和下一行</li><li>gJ 同 J ，不过合并后不留空格。</li></ul><h3 id="拼写检查"><a href="#拼写检查" class="headerlink" title="拼写检查"></a>拼写检查</h3><ul><li>:set spell－开启拼写检查功能</li><li>:set nospell－关闭拼写检查功能</li><li>]s－移到下一个拼写错误的单词</li><li>[s－作用与上一命令类似，但它是从相反方向进行搜索</li><li>z&#x3D;－显示一个有关拼写错误单词的列表，可从中选择</li><li>zg－告诉拼写检查器该单词是拼写正确的</li><li>zw－与上一命令相反，告诉拼写检查器该单词是拼写错误的</li></ul><h3 id="统计字数"><a href="#统计字数" class="headerlink" title="统计字数"></a>统计字数</h3><p>g ^g可以统计文档字符数，行数。 将光标放在最后一个字符上，用字符数减去行数可以粗略统计中文文档的字数。 以上对 Mac 或 Unix 的文件格式适用。 如果是 Windows 文件格式（即换行符有两个字节），字数的统计方法为： 字符数 - 行数 * 2。</p><h2 id="编辑多个文件"><a href="#编辑多个文件" class="headerlink" title="编辑多个文件"></a>编辑多个文件</h2><h3 id="一次编辑多个文件"><a href="#一次编辑多个文件" class="headerlink" title="一次编辑多个文件"></a>一次编辑多个文件</h3><p>我们可以一次打开多个文件，如</p><blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">vi <span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.txt</span> <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.txt</span> c.txt<br></code></pre></td></tr></table></figure></blockquote><ul><li>使用:next(:n)编辑下一个文件。</li><li>:2n 编辑下2个文件。</li><li>使用:previous或:N编辑上一个文件。</li><li>使用:wnext，保存当前文件，并编辑下一个文件。</li><li>使用:wprevious，保存当前文件，并编辑上一个文件。</li><li>使用:args 显示文件列表。</li><li>:n filenames或:args filenames 指定新的文件列表。</li><li>vi -o filenames 在水平分割的多个窗口中编辑多个文件。</li><li>vi -O filenames 在垂直分割的多个窗口中编辑多个文件。</li></ul><h3 id="多标签编辑"><a href="#多标签编辑" class="headerlink" title="多标签编辑"></a>多标签编辑</h3><ul><li>vim -p files: 打开多个文件，每个文件占用一个标签页。</li><li>:tabe, tabnew – 如果加文件名，就在新的标签中打开这个文件， 否则打开一个空缓冲区。</li><li>^w gf – 在新的标签页里打开光标下路径指定的文件。</li><li>:tabn – 切换到下一个标签。Control + PageDown，也可以。</li><li>:tabp – 切换到上一个标签。Control + PageUp，也可以。</li><li>[n] gt – 切换到下一个标签。如果前面加了 n ， 就切换到第n个标签。第一个标签的序号就是1。</li><li>gT–切换到上一个。</li><li>:tab split – 将当前缓冲区的内容在新页签中打开。</li><li>:tabc[lose] – 关闭当前的标签页。</li><li>:tabo[nly] – 关闭其它的标签页。</li><li>:tabs – 列出所有的标签页和它们包含的窗口。</li><li>:tabm[ove] [N] – 移动标签页，移动到第N个标签页之后。 如 tabm 0 当前标签页，就会变成第一个标签页。</li></ul><h3 id="缓冲区"><a href="#缓冲区" class="headerlink" title="缓冲区"></a>缓冲区</h3><ul><li>:buffers或:ls或:files 显示缓冲区列表。</li><li>ctrl+^：在最近两个缓冲区间切换。</li><li>:bn – 下一个缓冲区。</li><li>:bp – 上一个缓冲区。</li><li>:bl – 最后一个缓冲区。</li><li>:b[n]或:[n]b – 切换到第n个缓冲区。</li><li>:nbw(ipeout) – 彻底删除第n个缓冲区。</li><li>:nbd(elete) – 删除第n个缓冲区，并未真正删除，还在unlisted列表中。</li><li>:ba[ll] – 把所有的缓冲区在当前页中打开，每个缓冲区占一个窗口。</li></ul><h2 id="分屏编辑"><a href="#分屏编辑" class="headerlink" title="分屏编辑"></a>分屏编辑</h2><ul><li>vim -o file1 file2:水平分割窗口，同时打开file1和file2</li><li>vim -O file1 file2:垂直分割窗口，同时打开file1和file2</li></ul><h3 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h3><ul><li>:split(:sp) – 把当前窗水平分割成两个窗口。(CTRL-W s 或 CTRL-W CTRL-S) 注意如果在终端下，CTRL-S可能会冻结终端，请按CTRL-Q继续。</li><li>让水平分割窗口同时滚动，在两个窗口中输入   ：set scb</li><li>:split filename – 水平分割窗口，并在新窗口中显示另一个文件。</li><li>:nsplit(:nsp) – 水平分割出一个n行高的窗口。</li><li>:[N]new – 水平分割出一个N行高的窗口，并编辑一个新文件。 (CTRL-W n或 CTRL-W CTRL-N)</li><li>ctrl+w f –水平分割出一个窗口，并在新窗口打开名称为光标所在词的文件 。</li><li>C-w C-^ – 水平分割一个窗口，打开刚才编辑的文件。</li></ul><h3 id="垂直分割"><a href="#垂直分割" class="headerlink" title="垂直分割"></a>垂直分割</h3><ul><li>:vsplit(:vsp) – 把当前窗口分割成水平分布的两个窗口。 (CTRL-W v或CTRL CTRL-V)</li><li>:[N]vne[w] – 垂直分割出一个新窗口。</li><li>:vertical 水平分割的命令： 相应的垂直分割。</li></ul><h3 id="关闭子窗口"><a href="#关闭子窗口" class="headerlink" title="关闭子窗口"></a>关闭子窗口</h3><ul><li>:qall – 关闭所有窗口，退出vim。</li><li>:wall – 保存所有修改过的窗口。</li><li>:only – 只保留当前窗口，关闭其它窗口。(CTRL-W o)</li><li>:close – 关闭当前窗口，CTRL-W c能实现同样的功能。 (象 :q :x同样工作 )</li></ul><h3 id="调整窗口大小"><a href="#调整窗口大小" class="headerlink" title="调整窗口大小"></a>调整窗口大小</h3><ul><li>ctrl+w + –当前窗口增高一行。也可以用n增高n行。</li><li>ctrl+w - –当前窗口减小一行。也可以用n减小n行。</li><li>ctrl+w _ –当前窗口扩展到尽可能的大。也可以用n设定行数。</li><li>:resize n – 当前窗口n行高。</li><li>ctrl+w &#x3D; – 所有窗口同样高度。</li><li>n ctrl+w _ – 当前窗口的高度设定为n行。</li><li>ctrl+w &lt; –当前窗口减少一列。也可以用n减少n列。</li><li>ctrl+w &gt; –当前窗口增宽一列。也可以用n增宽n列。</li><li>ctrl+w | –当前窗口尽可能的宽。也可以用n设定列数。</li></ul><h3 id="切换和移动窗口"><a href="#切换和移动窗口" class="headerlink" title="切换和移动窗口"></a>切换和移动窗口</h3><p>如果支持鼠标，切换和调整子窗口的大小就简单了。</p><ul><li>ctrl+w ctrl+w: 切换到下一个窗口。或者是ctrl+w w。</li><li>ctrl+w p: 切换到前一个窗口。</li><li>ctrl+w h(l,j,k):切换到左（右，下，上）的窗口。</li><li>ctrl+w t(b):切换到最上（下）面的窗口。<BR></li><li>ctrl+w H(L,K,J): 将当前窗口移动到最左（右、上、下）面。</li><li>ctrl+w r：旋转窗口的位置。</li><li>ctrl+w T: 将当前的窗口移动到新的标签页上。</li></ul><h2 id="快速编辑"><a href="#快速编辑" class="headerlink" title="快速编辑"></a>快速编辑</h2><h3 id="改变大小写"><a href="#改变大小写" class="headerlink" title="改变大小写"></a>改变大小写</h3><ul><li>~: 反转光标所在字符的大小写。</li><li>可视模式下的U或u：把选中的文本变为大写或小写。</li><li>gu(U)接范围（如$，或G），可以把从光标当前位置到指定位置之间字母全部 转换成小写或大写。如ggguG，就是把开头到最后一行之间的字母全部变为小 写。再如gu5j，把当前行和下面四行全部变成小写。</li></ul><h3 id="替换（normal模式）"><a href="#替换（normal模式）" class="headerlink" title="替换（normal模式）"></a>替换（normal模式）</h3><ul><li>r: 替换光标处的字符，同样支持汉字。</li><li>R: 进入替换模式，按esc回到正常模式。</li></ul><h3 id="撤消与重做（normal模式）"><a href="#撤消与重做（normal模式）" class="headerlink" title="撤消与重做（normal模式）"></a>撤消与重做（normal模式）</h3><ul><li>[n] u: 取消一(n)个改动。</li><li>:undo 5 – 撤销5个改变。</li><li>:undolist – 你的撤销历史。</li><li>ctrl + r: 重做最后的改动。</li><li>U: 取消当前行中所有的改动。</li><li>:earlier 4m – 回到4分钟前</li><li>:later 55s – 前进55秒</li></ul><h3 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h3><ul><li>. –重复上一个编辑动作</li><li>qa：开始录制宏a（键盘操作记录）</li><li>q：停止录制</li><li>@a：播放宏a</li></ul><h2 id="编辑特殊文件"><a href="#编辑特殊文件" class="headerlink" title="编辑特殊文件"></a>编辑特殊文件</h2><h3 id="文件加解密"><a href="#文件加解密" class="headerlink" title="文件加解密"></a>文件加解密</h3><ul><li>vim -x file: 开始编辑一个加密的文件。</li><li>:X – 为当前文件设置密码。</li><li>:set key&#x3D; – 去除文件的密码。</li></ul><p><a href="http://www.cnblogs.com/jiqingwu/admin/vim-quick-edit.html">这里是</a> 滇狐总结的比较高级的vi技巧。</p><h3 id="文件的编码"><a href="#文件的编码" class="headerlink" title="文件的编码"></a>文件的编码</h3><ul><li>:e ++enc&#x3D;utf8 filename, 让vim用utf-8的编码打开这个文件。</li><li>:w ++enc&#x3D;gbk，不管当前文件什么编码，把它转存成gbk编码。</li><li>:set fenc或:set fileencoding，查看当前文件的编码。</li><li>在vimrc中添加set fileencoding&#x3D;ucs-bom,utf-8,cp936，vim会根据要打开的文件选择合适的编码。 注意：编码之间不要留空格。 cp936对应于gbk编码。 ucs-bom对应于windows下的文件格式。</li></ul><p>让vim 正确处理文件格式和文件编码，有赖于 <a href="http://www.cnblogs.com/jiqingwu/admin/vimrc.html">~&#x2F;.vimrc的正确配置</a></p><h3 id="文件格式"><a href="#文件格式" class="headerlink" title="文件格式"></a>文件格式</h3><p>大致有三种文件格式：unix, dos, mac. 三种格式的区别主要在于回车键的编码：dos 下是回车加换行，unix 下只有 换行符，mac 下只有回车符。</p><ul><li>:e ++ff&#x3D;dos filename, 让vim用dos格式打开这个文件。</li><li>:w ++ff&#x3D;mac filename, 以mac格式存储这个文件。</li><li>:set ff，显示当前文件的格式。</li><li>在vimrc中添加set fileformats&#x3D;unix,dos,mac，让vim自动识别文件格式。</li></ul><h2 id="编程辅助"><a href="#编程辅助" class="headerlink" title="编程辅助"></a>编程辅助</h2><h3 id="一些按键"><a href="#一些按键" class="headerlink" title="一些按键"></a>一些按键</h3><ul><li>gd: 跳转到局部变量的定义处；</li><li>gD: 跳转到全局变量的定义处，从当前文件开头开始搜索；</li><li>g;: 上一个修改过的地方；</li><li>g,: 下一个修改过的地方；</li><li>[[: 跳转到上一个函数块开始，需要有单独一行的{。</li><li>]]: 跳转到下一个函数块开始，需要有单独一行的{。</li><li>[]: 跳转到上一个函数块结束，需要有单独一行的}。</li><li>][: 跳转到下一个函数块结束，需要有单独一行的}。</li><li>[{: 跳转到当前块开始处；</li><li>]}: 跳转到当前块结束处；</li><li>[&#x2F;: 跳转到当前注释块开始处；</li><li>]&#x2F;: 跳转到当前注释块结束处；</li><li>%: 不仅能移动到匹配的(),{}或[]上，而且能在#if，#else， #endif之间跳跃。</li></ul><p>下面的括号匹配对编程很实用的。</p><ul><li>ci’, di’, yi’：修改、剪切或复制’之间的内容。</li><li>ca’, da’, ya’：修改、剪切或复制’之间的内容，包含’。</li><li>ci”, di”, yi”：修改、剪切或复制”之间的内容。</li><li>ca”, da”, ya”：修改、剪切或复制”之间的内容，包含”。</li><li>ci(, di(, yi(：修改、剪切或复制()之间的内容。</li><li>ca(, da(, ya(：修改、剪切或复制()之间的内容，包含()。</li><li>ci[, di[, yi[：修改、剪切或复制[]之间的内容。</li><li>ca[, da[, ya[：修改、剪切或复制[]之间的内容，包含[]。</li><li>ci{, di{, yi{：修改、剪切或复制{}之间的内容。</li><li>ca{, da{, ya{：修改、剪切或复制{}之间的内容，包含{}。</li><li>ci&lt;, di&lt;, yi&lt;：修改、剪切或复制&lt;&gt;之间的内容。</li><li>ca&lt;, da&lt;, ya&lt;：修改、剪切或复制&lt;&gt;之间的内容，包含&lt;&gt;。</li></ul><h3 id="ctags"><a href="#ctags" class="headerlink" title="ctags"></a>ctags</h3><ul><li>ctags -R: 生成tag文件，-R表示也为子目录中的文件生成tags</li><li>:set tags&#x3D;path&#x2F;tags – 告诉ctags使用哪个tag文件</li><li>:tag xyz – 跳到xyz的定义处，或者将光标放在xyz上按C-]，返回用C-t</li><li>:stag xyz – 用分割的窗口显示xyz的定义，或者C-w ]， 如果用C-w n ]，就会打开一个n行高的窗口</li><li>:ptag xyz – 在预览窗口中打开xyz的定义，热键是C-w }。</li><li>:pclose – 关闭预览窗口。热键是C-w z。</li><li>:pedit abc.h – 在预览窗口中编辑abc.h</li><li>:psearch abc – 搜索当前文件和当前文件include的文件，显示包含abc的行。</li></ul><p>有时一个tag可能有多个匹配，如函数重载，一个函数名就会有多个匹配。 这种情况会先跳转到第一个匹配处。</p><ul><li>:[n]tnext – 下一[n]个匹配。</li><li>:[n]tprev – 上一[n]个匹配。</li><li>:tfirst – 第一个匹配</li><li>:tlast – 最后一个匹配</li><li>:tselect tagname – 打开选择列表</li></ul><p>tab键补齐</p><ul><li>:tag xyz<tab> – 补齐以xyz开头的tag名，继续按tab键，会显示其他的。</li><li>:tag &#x2F;xyz<tab> – 会用名字中含有xyz的tag名补全。</li></ul><h3 id="cscope"><a href="#cscope" class="headerlink" title="cscope"></a>cscope</h3><ul><li>cscope -Rbq: 生成cscope.out文件</li><li>:cs add &#x2F;path&#x2F;to&#x2F;cscope.out &#x2F;your&#x2F;work&#x2F;dir</li><li>:cs find c func – 查找func在哪些地方被调用</li><li>:cw – 打开quickfix窗口查看结果</li></ul><h3 id="gtags"><a href="#gtags" class="headerlink" title="gtags"></a>gtags</h3><p>Gtags综合了ctags和cscope的功能。 使用Gtags之前，你需要安装GNU Gtags。 然后在工程目录运行 gtags 。</p><ul><li>:Gtags funcname 定位到 funcname 的定义处。</li><li>:Gtags -r funcname 查询 funcname被引用的地方。</li><li>:Gtags -s symbol 定位 symbol 出现的地方。</li><li>:Gtags -g string Goto string 出现的地方。 :Gtags -gi string 忽略大小写。</li><li>:Gtags -f filename 显示 filename 中的函数列表。 你可以用 :Gtags -f % 显示当前文件。</li><li>:Gtags -P pattern 显示路径中包含特定模式的文件。 如 :Gtags -P .h$ 显示所有头文件， :Gtags -P &#x2F;vm&#x2F; 显示vm目录下的文件。</li></ul><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>vim提供了:make来编译程序，默认调用的是make， 如果你当前目录下有makefile，简单地:make即可。</p><p>如果你没有make程序，你可以通过配置makeprg选项来更改make调用的程序。 如果你只有一个abc.<a href="http://lib.csdn.net/base/17">Java</a>文件，你可以这样设置：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-built_in">set</span> <span class="hljs-attribute">makeprg</span>=javac\ abc.java<br></code></pre></td></tr></table></figure><p>然后:make即可。如果程序有错，可以通过quickfix窗口查看错误。 不过如果要正确定位错误，需要设置好errorformat，让vim识别错误信息。 如：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-meta">:setl efm=%A%f:%l:\</span> %m,%-Z%p^,%-C%.%#<br></code></pre></td></tr></table></figure><p>%f表示文件名，%l表示行号， %m表示错误信息，其它的还不能理解。 请参考 :help errorformat。</p><h3 id="快速修改窗口"><a href="#快速修改窗口" class="headerlink" title="快速修改窗口"></a>快速修改窗口</h3><p>其实是quickfix插件提供的功能， 对编译调试程序非常有用 :)</p><ul><li>:copen – 打开快速修改窗口。</li><li>:cclose – 关闭快速修改窗口。</li></ul><p>快速修改窗口在make程序时非常有用，当make之后：</p><ul><li>:cl – 在快速修改窗口中列出错误。</li><li>:cn – 定位到下一个错误。</li><li>:cp – 定位到上一个错误。</li><li>:cr – 定位到第一个错误。</li></ul><h3 id="自动补全"><a href="#自动补全" class="headerlink" title="自动补全"></a>自动补全</h3><ul><li>C-x C-s – 拼写建议。</li><li>C-x C-v – 补全vim选项和命令。</li><li>C-x C-l – 整行补全。</li><li>C-x C-f – 自动补全文件路径。弹出菜单后，按C-f循环选择，当然也可以按 C-n和C-p。</li><li>C-x C-p 和C-x C-n – 用文档中出现过的单词补全当前的词。 直接按C-p和C-n也可以。</li><li>C-x C-o – 编程时可以补全关键字和函数名啊。</li><li>C-x C-i – 根据头文件内关键字补全。</li><li>C-x C-d – 补全宏定义。</li><li>C-x C-n – 按缓冲区中出现过的关键字补全。 直接按C-n或C-p即可。</li></ul><p>当弹出补全菜单后：</p><ul><li>C-p 向前切换成员；</li><li>C-n 向后切换成员；</li><li>C-e 退出下拉菜单，并退回到原来录入的文字；</li><li>C-y 退出下拉菜单，并接受当前选项。</li></ul><h3 id="多行缩进缩出"><a href="#多行缩进缩出" class="headerlink" title="多行缩进缩出"></a>多行缩进缩出</h3><ul><li>正常模式下，按两下&gt;;光标所在行会缩进。</li><li>如果先按了n，再按两下&gt;;，光标以下的n行会缩进。</li><li>对应的，按两下&lt;;，光标所在行会缩出。</li><li>如果在编辑代码文件，可以用&#x3D;进行调整。</li><li>在可视模式下，选择要调整的代码块，按&#x3D;，代码会按书写规则缩排好。</li><li>或者n &#x3D;，调整n行代码的缩排。</li></ul><h3 id="折叠"><a href="#折叠" class="headerlink" title="折叠"></a>折叠</h3><ul><li>zf – 创建折叠的命令，可以在一个可视区域上使用该命令；</li><li>zd – 删除当前行的折叠；</li><li>zD – 删除当前行的折叠；</li><li>zfap – 折叠光标所在的段；</li><li>zo – 打开折叠的文本；</li><li>zc – 收起折叠；</li><li>za – 打开&#x2F;关闭当前折叠；</li><li>zr – 打开嵌套的折行；</li><li>zm – 收起嵌套的折行；</li><li>zR (zO) – 打开所有折行；</li><li>zM (zC) – 收起所有折行；</li><li>zj – 跳到下一个折叠处；</li><li>zk – 跳到上一个折叠处；</li><li>zi – enable&#x2F;disable fold;</li></ul><h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>normal模式下按:进入命令行模式</p><h3 id="命令行模式下的快捷键："><a href="#命令行模式下的快捷键：" class="headerlink" title="命令行模式下的快捷键："></a>命令行模式下的快捷键：</h3><ul><li>上下方向键：上一条或者下一条命令。如果已经输入了部分命令，则找上一 条或者下一条匹配的命令。</li><li>左右方向键：左&#x2F;右移一个字符。</li><li>C-w： 向前删除一个单词。</li><li>C-h： 向前删除一个字符，等同于Backspace。</li><li>C-u： 从当前位置移动到命令行开头。</li><li>C-b： 移动到命令行开头。</li><li>C-e： 移动到命令行末尾。</li><li>Shift-Left： 左移一个单词。</li><li>Shift-Right： 右移一个单词。</li><li>@： 重复上一次的冒号命令。</li><li>q： 正常模式下，q然后按’:’，打开命令行历史缓冲区， 可以像编辑文件一样编辑命令。</li><li>q&#x2F;和q? 可以打开查找历史记录。</li></ul><h2 id="执行外部命令"><a href="#执行外部命令" class="headerlink" title="执行外部命令"></a>执行外部命令</h2><ul><li>:! cmd 执行外部命令。</li><li>:!! 执行上一次的外部命令。</li><li>:sh 调用shell，用exit返回vim。</li><li>:r !cmd 将命令的返回结果插入文件当前位置。</li><li>:m,nw !cmd 将文件的m行到n行之间的内容做为命令输入执行命令。</li></ul><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><h3 id="工作目录"><a href="#工作目录" class="headerlink" title="工作目录"></a>工作目录</h3><ul><li>:pwd 显示vim的工作目录。</li><li>:cd path 改变vim的工作目录。</li><li>:set autochdir 可以让vim 根据编辑的文件自动切换工作目录。</li></ul><h3 id="一些快捷键（收集中）"><a href="#一些快捷键（收集中）" class="headerlink" title="一些快捷键（收集中）"></a>一些快捷键（收集中）</h3><ul><li>K: 打开光标所在词的manpage。</li><li>*: 向下查找光标所在词。</li><li>#：向上查找</li><li>g*: 同上，但部分符合即可。</li><li>#: 向上搜索光标所在词。</li><li>g#: 同上，但部分符合即可。</li><li>g C-g: 统计全文或统计部分的字数。</li></ul><h3 id="在线帮助"><a href="#在线帮助" class="headerlink" title="在线帮助"></a>在线帮助</h3><ul><li>:h(elp)或F1 打开总的帮助。</li><li>:help user-manual 打开用户手册。</li><li>命令帮助的格式为：第一行指明怎么使用那个命令； 然后是缩进的一段解释这个命令的作用，然后是进一步的信息。</li><li>:helptags somepath 为somepath中的文档生成索引。</li><li>:helpgrep 可以搜索整个帮助文档，匹配的列表显示在quickfix窗口中。</li><li>Ctrl+] 跳转到tag主题，Ctrl+t 跳回。</li><li>:ver 显示版本信息。</li></ul><h3 id="一些小功能"><a href="#一些小功能" class="headerlink" title="一些小功能"></a>一些小功能</h3><ul><li>简单计算器: 在插入模式下，输入C-r &#x3D;，然后输入表达式，就能在 光标处得到计算结果</li></ul>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Vim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>temp</title>
    <link href="/2021/06/08/temp/"/>
    <url>/2021/06/08/temp/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/qq_34276797/article/details/107816423">(12条消息) go func 闭包函数最后的参数_rabies的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_33204116/article/details/50835257?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-1.control">(12条消息) golang中函数闭包遇到的坑_白日梦想的博客-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_33204116/article/details/50700705">(12条消息) golang解析json格式_白日梦想的博客-CSDN博客</a></p><p><a href="https://www.cnblogs.com/vinsent/p/11222824.html">Golang理解-匿名函数 - 梧桐花落 - 博客园</a></p><p><a href="https://www.jianshu.com/p/bff8aa23fe4d">几张图让你看懂WebAssembly - 简书</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Go的时间格式</title>
    <link href="/2021/05/27/Go%E7%9A%84%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F/"/>
    <url>/2021/05/27/Go%E7%9A%84%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<p>在Go中进行时间格式化输出时，你一定离不开这个时间点:<code>2006-01-02 15:04:05 -0700</code>，很多人在这里陷入了坑，因为它不像其他语言一样使用<code>YYYY-MM-DD</code>这种格式化字符标识。</p><p>很多人或许去背这串字符，其实大可不必，我们转成英文表述的时间格式你就明白了: <code>01-02 15:04 06</code></p><p>，还不懂？把<code>15</code>换算成12小时制的<code>03</code>点，懂了吧，是不是很优雅？</p><p>那么问题来了，为什么这么设计呢？</p><p>有人猜测是 Go 项目启动的时间等。但仔细研究，发现 Go Team 还是用心良苦，目的是解决大家记忆问题。</p><p>比如常规的 ymd 格式，以 PHP 为例，一般这样 <code>Y-m-d H:i:s</code>，输出类似：2021-08-03 09:30:00，但如果我想输出：<code>21-8-4 9:30:00</code>，你不查手册，能写出来吗？你看看 PHP 文档中关于 date 格式化的说明，头有点大，竟然那么多，虽然常用的形式，大部分人都记得，但遇到不怎么常用的，就得查手册了。</p><p>反观 Go 语言，它直接使用一个具体的时间来当做格式化字符串，需要什么格式，改这个时间格式即可。比如上面的例子，常规方式：2006-01-02  15:04:05，而 21-8-4 9:30:00 这种格式，只需要对应的改变值即可：06-1-2 3:04:05。而且，我查了下，PHP 没法表示没有前导零的分钟数和秒数，而 Go 很容易实现。很显然，Go 的方式是更合理、更易用的，对于各种变化，也能够更自如的应对。</p><p>只不过，很多人对这个具体的时间觉得记不住。这一点，Go 官方也考虑到了。毕竟采用特殊的时间，目的就是为了解决大家记忆问题，因此要确保这个特殊时间也好记。Go 是这么设计的：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">1: month (January, Jan, 01, etc)<br>2: day<br>3: hour (15 is 3pm on a 24 hour clock)<br>4: minute<br>5: second<br>6: year (2006)<br>7: timezone (GMT-7 is MST)<br></code></pre></td></tr></table></figure><p>刚好是 1 2 3 4 5 6 7，据此进行变化即可。</p><p>比如官方定义的常量：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    ANSIC       = <span class="hljs-string">&quot;Mon Jan _2 15:04:05 2006&quot;</span><br>    UnixDate    = <span class="hljs-string">&quot;Mon Jan _2 15:04:05 MST 2006&quot;</span><br>    RubyDate    = <span class="hljs-string">&quot;Mon Jan 02 15:04:05 -0700 2006&quot;</span><br>    RFC822      = <span class="hljs-string">&quot;02 Jan 06 15:04 MST&quot;</span><br>    RFC822Z     = <span class="hljs-string">&quot;02 Jan 06 15:04 -0700&quot;</span> <span class="hljs-comment">// RFC822 with numeric zone</span><br>    RFC850      = <span class="hljs-string">&quot;Monday, 02-Jan-06 15:04:05 MST&quot;</span><br>    RFC1123     = <span class="hljs-string">&quot;Mon, 02 Jan 2006 15:04:05 MST&quot;</span><br>    RFC1123Z    = <span class="hljs-string">&quot;Mon, 02 Jan 2006 15:04:05 -0700&quot;</span> <span class="hljs-comment">// RFC1123 with numeric zone</span><br>    RFC3339     = <span class="hljs-string">&quot;2006-01-02T15:04:05Z07:00&quot;</span><br>    RFC3339Nano = <span class="hljs-string">&quot;2006-01-02T15:04:05.999999999Z07:00&quot;</span><br>    Kitchen     = <span class="hljs-string">&quot;3:04PM&quot;</span><br>)<br></code></pre></td></tr></table></figure><p>按 ANSIC 标准的日期格式，月、日、时、分、秒、年，最后加 MST 时区。对应就是 1 2 3 4 5 6 7。同时还可以随意加星期几。</p><p>发现没有？围绕着 1 2 3 4 5 6 7 随意变化，真的不要太爽。我相信你用习惯了会发现 Go 这个设计真的太好了。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux修改su密码及免密登陆</title>
    <link href="/2021/05/24/Linux%E4%BF%AE%E6%94%B9su%E5%AF%86%E7%A0%81%E5%8F%8A%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/"/>
    <url>/2021/05/24/Linux%E4%BF%AE%E6%94%B9su%E5%AF%86%E7%A0%81%E5%8F%8A%E5%85%8D%E5%AF%86%E7%99%BB%E9%99%86/</url>
    
    <content type="html"><![CDATA[<h3 id="修改su密码"><a href="#修改su密码" class="headerlink" title="修改su密码"></a>修改su密码</h3><p>在Linux终端输入命令，然后依次输入新密码即可.</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># sudo passwd root</span><br>输入新的 UNIX 密码：<br>重新输入新的 UNIX 密码：<br>passwd：已成功更新密码<br></code></pre></td></tr></table></figure><h3 id="使用ssh公钥实现免密登陆"><a href="#使用ssh公钥实现免密登陆" class="headerlink" title="使用ssh公钥实现免密登陆"></a>使用ssh公钥实现免密登陆</h3><p>使用<code>ssh-key-id</code>命令将公钥发给免密登陆的服务器，其中<code>-i</code>是指定公钥文件。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># ssh-key-id -i .ssh/id_rsa.pub root@192.168.8.88</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习参考资料</title>
    <link href="/2021/05/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"/>
    <url>/2021/05/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</url>
    
    <content type="html"><![CDATA[<p>时间以及学习路线:  <a href="https://www.zhihu.com/question/26006703/answer/536169538">https://www.zhihu.com/question/26006703/answer/536169538</a></p><p>相关机器学习框架介绍： <a href="https://zhuanlan.zhihu.com/p/225223709">https://zhuanlan.zhihu.com/p/225223709</a></p><h4 id="视频课程"><a href="#视频课程" class="headerlink" title="视频课程"></a>视频课程</h4><p>吴恩达机器学习课程：<a href="https://www.coursera.org/learn/machine-learning">Machine Learning by Stanford University | Coursera</a></p><p>3Blue 1 Brown课程：</p><blockquote><p>Bilibili: </p><p><a href="https://space.bilibili.com/88461692/#/">https://space.bilibili.com/88461692/#/</a></p><p>YouTube:</p><p><a href="https://www.youtube.com/watch?v=aircAruvnKk&list=PLZHQObOWTQDNU6R1_67000Dx_ZCJB-3pi">But what is a Neural Network? | Deep learning, chapter 1 - YouTube</a></p></blockquote><h4 id="书籍"><a href="#书籍" class="headerlink" title="书籍"></a>书籍</h4><p><a href="http://neuralnetworksanddeeplearning.com/">Neural networks and deep learning</a></p><p>翻译版本：</p><p><a href="https://tigerneil.gitbooks.io/neural-networks-and-deep-learning-zh/content/">引言 | 神经网络与深度学习</a></p><p>数学知识补充：</p><p><a href="https://github.com/janishar/mit-deep-learning-book-pdf/blob/master/complete-book-bookmarked-pdf/deeplearningbook.pdf">mit-deep-learning-book-pdf&#x2F;deeplearningbook.pdf at master · janishar&#x2F;mit-deep-learning-book-pdf</a></p><p>中文在线版：</p><p><a href="https://github.com/exacity/deeplearningbook-chinese">exacity&#x2F;deeplearningbook-chinese: Deep Learning Book Chinese Translation</a></p><h4 id="博客"><a href="#博客" class="headerlink" title="博客"></a>博客</h4><p><a href="http://colah.github.io/">Home - colah’s blog</a></p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>基于PyTorch，先做后学</p><p><a href="https://course.fast.ai/">Practical Deep Learning for Coders | Practical Deep Learning for Coders</a></p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>斯坦福大学CS231n，李飞飞主讲，计算机视觉</p><p><a href="http://cs231n.stanford.edu/">Stanford University CS231n: Convolutional Neural Networks for Visual Recognition</a></p><p>斯坦福大学CS231n，Richard Socher主讲，序列建模</p><p><a href="http://web.stanford.edu/class/cs224n/">Stanford CS 224N | Natural Language Processing with Deep Learning</a></p><h2 id="自动驾驶相关"><a href="#自动驾驶相关" class="headerlink" title="自动驾驶相关"></a>自动驾驶相关</h2><p>如何入门学习自动驾驶技术 <a href="https://zhuanlan.zhihu.com/p/94498746">https://zhuanlan.zhihu.com/p/94498746</a></p><p>无人驾驶，个人如何研究？<a href="https://www.zhihu.com/question/20210846">https://www.zhihu.com/question/20210846</a></p>]]></content>
    
    
    <categories>
      
      <category>TODO</category>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python面向对象编程知识回顾</title>
    <link href="/2021/05/20/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    <url>/2021/05/20/Python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h3><h4 id="类的定义"><a href="#类的定义" class="headerlink" title="类的定义"></a>类的定义</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>): <span class="hljs-comment">#object是被继承的类，类似Java，一切继承的起点</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        self.name = name<br>        self.__age = age <span class="hljs-comment"># 似有变量</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">print_age</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;%d&#x27;</span>, self.age)<br></code></pre></td></tr></table></figure><h4 id="对象的使用"><a href="#对象的使用" class="headerlink" title="对象的使用"></a>对象的使用</h4><p>和静态语言不同的是，运行时<code>Python</code>对象可以绑定任何数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">a = Student(<span class="hljs-string">&#x27;cui&#x27;</span>, <span class="hljs-number">22</span>)<br>b = Student(<span class="hljs-string">&#x27;hu&#x27;</span>, <span class="hljs-number">23</span>)<br><br>a.phone = <span class="hljs-string">&#x27;123&#x27;</span> <span class="hljs-comment">#动态绑定数据</span><br></code></pre></td></tr></table></figure><p>关于私有变量的访问问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">a.__age = <span class="hljs-number">20</span> <span class="hljs-comment"># 这种方式访问的不是原先的私有变量，而是新创建变量名为__age的公有变量</span><br>a._Student__age = <span class="hljs-number">20</span> <span class="hljs-comment"># 这是正确访问方法，但不要这么干，按规则办事</span><br></code></pre></td></tr></table></figure><h3 id="继承与多态"><a href="#继承与多态" class="headerlink" title="继承与多态"></a>继承与多态</h3><ul><li>继承: 继承父类的所有方法，子类对象可以直接使用</li><li>多态: 子类可以根据需要修改父类方法，或者在其基础上拓展</li></ul><h3 id="读取对象信息"><a href="#读取对象信息" class="headerlink" title="读取对象信息"></a>读取对象信息</h3><h4 id="type-判断对象类型"><a href="#type-判断对象类型" class="headerlink" title="type()判断对象类型"></a>type()判断对象类型</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;int&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-literal">None</span>)<br>&lt;<span class="hljs-built_in">type</span>(<span class="hljs-literal">None</span>) <span class="hljs-string">&#x27;NoneType&#x27;</span>&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-built_in">abs</span>)<br>&lt;<span class="hljs-keyword">class</span> <span class="hljs-string">&#x27;builtin_function_or_method&#x27;</span>&gt;<br><br><span class="hljs-comment"># 比较</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-number">456</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)==<span class="hljs-built_in">int</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;123&#x27;</span>)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">str</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)==<span class="hljs-built_in">type</span>(<span class="hljs-number">123</span>)<br><span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 使用types模板中定义的常量</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(fn)==types.FunctionType<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-built_in">abs</span>)==types.BuiltinFunctionType<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>(<span class="hljs-keyword">lambda</span> x: x)==types.LambdaType<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">type</span>((x <span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>)))==types.GeneratorType<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h4 id="instance-判断对象类型"><a href="#instance-判断对象类型" class="headerlink" title="instance()判断对象类型"></a>instance()判断对象类型</h4><p>能用type()判断的都可以用instance()判断，instance()的优势点在与判断对象的继承关系上。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 有继承关系: object -&gt; Animal -&gt; Dog -&gt; Husky</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>a = Animal()<br><span class="hljs-meta">&gt;&gt;&gt; </span>d = Dog()<br><span class="hljs-meta">&gt;&gt;&gt; </span>h = Husky()<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(h, Husky)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(h, Dog)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(h, Animal)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(d, Dog) <span class="hljs-keyword">and</span> <span class="hljs-built_in">isinstance</span>(d, Animal)<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>(d, Husky)<br><span class="hljs-literal">False</span><br><br><span class="hljs-comment"># 判断对象是不是某类型中的一种</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], (<span class="hljs-built_in">list</span>, <span class="hljs-built_in">tuple</span>))<br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">isinstance</span>((<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>), (<span class="hljs-built_in">list</span>, <span class="hljs-built_in">tuple</span>))<br><span class="hljs-literal">True</span><br></code></pre></td></tr></table></figure><h4 id="dir-获取对象的所有属性和方法"><a href="#dir-获取对象的所有属性和方法" class="headerlink" title="dir()获取对象的所有属性和方法"></a>dir()获取对象的所有属性和方法</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">dir</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>)<br>[<span class="hljs-string">&#x27;__add__&#x27;</span>, <span class="hljs-string">&#x27;__class__&#x27;</span>,..., <span class="hljs-string">&#x27;__subclasshook__&#x27;</span>, <span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-string">&#x27;casefold&#x27;</span>,..., <span class="hljs-string">&#x27;zfill&#x27;</span>]<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(<span class="hljs-string">&#x27;ABC&#x27;</span>) <span class="hljs-comment"># len()封装了__len__()特殊方法</span><br><span class="hljs-number">3</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-string">&#x27;ABC&#x27;</span>.__len__() <span class="hljs-comment"># 直接使用特殊方法</span><br><span class="hljs-number">3</span><br><br><span class="hljs-comment"># 可以在对象中自定义特殊方法拿来用</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDog</span>(<span class="hljs-title class_ inherited__">object</span>):<br><span class="hljs-meta">... </span>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__len__</span>(<span class="hljs-params">self</span>):<br><span class="hljs-meta">... </span>        <span class="hljs-keyword">return</span> <span class="hljs-number">100</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>dog = MyDog()<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">len</span>(dog)<br><span class="hljs-number">100</span><br></code></pre></td></tr></table></figure><h4 id="getattr-、setattr-、hasattr"><a href="#getattr-、setattr-、hasattr" class="headerlink" title="getattr()、setattr()、hasattr()"></a>getattr()、setattr()、hasattr()</h4><p>分别是获得属性(方法)、设置属性(方法)、有没有属性(方法)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;x&#x27;</span>) <span class="hljs-comment"># 有属性&#x27;x&#x27;吗？</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>obj.x<br><span class="hljs-number">9</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>) <span class="hljs-comment"># 有属性&#x27;y&#x27;吗？</span><br><span class="hljs-literal">False</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">setattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>, <span class="hljs-number">19</span>) <span class="hljs-comment"># 设置一个属性&#x27;y&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">hasattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>) <span class="hljs-comment"># 有属性&#x27;y&#x27;吗？</span><br><span class="hljs-literal">True</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;y&#x27;</span>) <span class="hljs-comment"># 获取属性&#x27;y&#x27;</span><br><span class="hljs-number">19</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>obj.y <span class="hljs-comment"># 获取属性&#x27;y&#x27;</span><br><span class="hljs-number">19</span><br><br><span class="hljs-comment"># 如果试图获取不存在的属性，会抛出AttributeError的错误：</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;z&#x27;</span>) <span class="hljs-comment"># 获取属性&#x27;z&#x27;</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>AttributeError: <span class="hljs-string">&#x27;MyObject&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;z&#x27;</span><br><br><span class="hljs-comment"># 通过设置default参数避免</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;z&#x27;</span>, <span class="hljs-number">404</span>) <span class="hljs-comment"># 获取属性&#x27;z&#x27;，如果不存在，返回默认值404</span><br><span class="hljs-number">404</span><br><br><span class="hljs-comment"># 获得对象的方法，并赋给别的变量</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>fn = <span class="hljs-built_in">getattr</span>(obj, <span class="hljs-string">&#x27;power&#x27;</span>) <span class="hljs-comment"># 获取属性&#x27;power&#x27;并赋值到变量fn</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>fn <span class="hljs-comment"># fn指向obj.power</span><br>&lt;bound method MyObject.power of &lt;__main__.MyObject <span class="hljs-built_in">object</span> at <span class="hljs-number">0x10077a6a0</span>&gt;&gt;<br><span class="hljs-meta">&gt;&gt;&gt; </span>fn() <span class="hljs-comment"># 调用fn()与调用obj.power()是一样的</span><br><span class="hljs-number">81</span><br></code></pre></td></tr></table></figure><h3 id="实例属性和类属性"><a href="#实例属性和类属性" class="headerlink" title="实例属性和类属性"></a>实例属性和类属性</h3><p>实例属性和类属性相同时，会屏蔽类属性，使用<code>del</code>删除实例属性后，才能访问到类属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br><span class="hljs-meta">... </span>    name = <span class="hljs-string">&#x27;Student&#x27;</span><br>...<br><span class="hljs-meta">&gt;&gt;&gt; </span>s = Student() <span class="hljs-comment"># 创建实例s</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(s.name) <span class="hljs-comment"># 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性</span><br>Student<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(Student.name) <span class="hljs-comment"># 打印类的name属性</span><br>Student<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.name = <span class="hljs-string">&#x27;Michael&#x27;</span> <span class="hljs-comment"># 给实例绑定name属性</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(s.name) <span class="hljs-comment"># 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性</span><br>Michael<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(Student.name) <span class="hljs-comment"># 但是类属性并未消失，用Student.name仍然可以访问</span><br>Student<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">del</span> s.name <span class="hljs-comment"># 如果删除实例的name属性</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(s.name) <span class="hljs-comment"># 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了</span><br>Student<br></code></pre></td></tr></table></figure><h3 id="限制实例绑定的属性-slots"><a href="#限制实例绑定的属性-slots" class="headerlink" title="限制实例绑定的属性: _slots_"></a>限制实例绑定的属性: _<em>slots</em>_</h3><p>Python允许再运行过程中给实例绑定属性和方法，但是，有时需要限制实例绑定的属性，就需要用到_<em>slots</em>_</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-keyword">pass</span><br><br><span class="hljs-comment"># 给实例绑定属性</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s = Student()<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.name = <span class="hljs-string">&#x27;Michael&#x27;</span> <span class="hljs-comment"># 动态给实例绑定一个属性</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(s.name)<br>Michael<br><br><span class="hljs-comment"># 实例绑定方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">def</span> <span class="hljs-title function_">set_age</span>(<span class="hljs-params">self, age</span>): <span class="hljs-comment"># 定义一个函数作为实例方法</span><br><span class="hljs-meta">... </span>    self.age = age<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">from</span> types <span class="hljs-keyword">import</span> MethodType<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.set_age = MethodType(set_age, s) <span class="hljs-comment"># 给实例绑定一个方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.set_age(<span class="hljs-number">25</span>) <span class="hljs-comment"># 调用实例方法</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.age <span class="hljs-comment"># 测试结果</span><br><span class="hljs-number">25</span><br></code></pre></td></tr></table></figure><p>限制实例绑定属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    __slots__ = (<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;age&#x27;</span>) <span class="hljs-comment"># 用tuple定义允许绑定的属性名称</span><br>    <br><span class="hljs-meta">&gt;&gt;&gt; </span>s = Student() <span class="hljs-comment"># 创建新的实例</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.name = <span class="hljs-string">&#x27;Michael&#x27;</span> <span class="hljs-comment"># 绑定属性&#x27;name&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.age = <span class="hljs-number">25</span> <span class="hljs-comment"># 绑定属性&#x27;age&#x27;</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.score = <span class="hljs-number">99</span> <span class="hljs-comment"># 绑定属性&#x27;score&#x27;</span><br>Traceback (most recent call last):<br>  File <span class="hljs-string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="hljs-number">1</span>, <span class="hljs-keyword">in</span> &lt;module&gt;<br>AttributeError: <span class="hljs-string">&#x27;Student&#x27;</span> <span class="hljs-built_in">object</span> has no attribute <span class="hljs-string">&#x27;score&#x27;</span><br></code></pre></td></tr></table></figure><p>对于类之间的继承关系，<code>__slots_</code>只作用于类的第一级子类实例，对于子类的实例不起作用，如果需要限制子类实例绑定的属性，需要在子类中单独定义<code>__slots__</code>，子类实例限制绑定的属性为子类和父类限制绑定属性的<code>并集</code>。</p><h3 id="把类方法当作类属性使用-properly"><a href="#把类方法当作类属性使用-properly" class="headerlink" title="把类方法当作类属性使用: @properly"></a>把类方法当作类属性使用: @properly</h3><p>通过实例直接对类的属性进行修改很方便但是没有参数检查，要想实现参数检查就需要在类中编写对属性进行操作的方法，但又出现一个问题，当实例操作属性时，通过调用方法的形式没有直接使用类属性的方法简洁，于是为了结合两者的优点，<code>@properly</code>装饰器出现了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">object</span>):<br><br><span class="hljs-meta">    @property </span><span class="hljs-comment"># 直接加@property类似get方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> self._score<br><br><span class="hljs-meta">    @score.setter </span><span class="hljs-comment"># @property.setter类似set方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">score</span>(<span class="hljs-params">self, value</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(value, <span class="hljs-built_in">int</span>):<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;score must be an integer!&#x27;</span>)<br>        <span class="hljs-keyword">if</span> value &lt; <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> value &gt; <span class="hljs-number">100</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;score must between 0 ~ 100!&#x27;</span>)<br>        self._score = value<br>        <br><span class="hljs-comment"># 实际使用</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s = Student()<br><span class="hljs-meta">&gt;&gt;&gt; </span>s.score = <span class="hljs-number">60</span> <span class="hljs-comment"># OK，实际转化为s.set_score(60)</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.score <span class="hljs-comment"># OK，实际转化为s.get_score()</span><br><span class="hljs-number">60</span><br><span class="hljs-meta">&gt;&gt;&gt; </span>s.score = <span class="hljs-number">9999</span> <span class="hljs-comment"># 参数检查起作用了</span><br>Traceback (most recent call last):<br>  ...<br>ValueError: score must between <span class="hljs-number">0</span> ~ <span class="hljs-number">100</span>!<br></code></pre></td></tr></table></figure><p><strong>注意：</strong>类属性名称不能和方法名称相同，因为调用实例属性时会被当作方法使用，调用方法时又被当作属性使用，造成无限递归，最终导致栈溢出报错<code>RecursionError</code>。</p><h3 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 直接使用Enum类实现</span><br><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum<br><br><span class="hljs-comment"># 枚举默认从1开始</span><br>Month = Enum(<span class="hljs-string">&#x27;Month&#x27;</span>, (<span class="hljs-string">&#x27;Jan&#x27;</span>, <span class="hljs-string">&#x27;Feb&#x27;</span>, <span class="hljs-string">&#x27;Mar&#x27;</span>, <span class="hljs-string">&#x27;Apr&#x27;</span>, <span class="hljs-string">&#x27;May&#x27;</span>, <span class="hljs-string">&#x27;Jun&#x27;</span>, <span class="hljs-string">&#x27;Jul&#x27;</span>, <span class="hljs-string">&#x27;Aug&#x27;</span>, <span class="hljs-string">&#x27;Sep&#x27;</span>, <span class="hljs-string">&#x27;Oct&#x27;</span>, <span class="hljs-string">&#x27;Nov&#x27;</span>, <span class="hljs-string">&#x27;Dec&#x27;</span>))<br><br><span class="hljs-keyword">for</span> name, member <span class="hljs-keyword">in</span> Month.__members__.items():<br>    <span class="hljs-built_in">print</span>(name, <span class="hljs-string">&#x27;=&gt;&#x27;</span>, member, <span class="hljs-string">&#x27;,&#x27;</span>, member.value)<br><br><span class="hljs-comment"># 打印结果</span><br>Jan =&gt; Month.Jan , <span class="hljs-number">1</span><br>Feb =&gt; Month.Feb , <span class="hljs-number">2</span><br>Mar =&gt; Month.Mar , <span class="hljs-number">3</span><br>....<br><br><br><span class="hljs-comment"># 自定义枚举类，用于需要控制枚举起点、枚举类型等场景</span><br><span class="hljs-keyword">from</span> enum <span class="hljs-keyword">import</span> Enum, unique<br><br><span class="hljs-meta">@unique </span><span class="hljs-comment"># @unique装饰器可以帮助我们检查枚举中有没有重复值</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Weekday</span>(<span class="hljs-title class_ inherited__">Enum</span>):<br>    Sun = <span class="hljs-number">0</span> <span class="hljs-comment"># Sun的value被设定为0</span><br>    Mon = <span class="hljs-number">1</span><br>    Tue = <span class="hljs-number">2</span><br>    Wed = <span class="hljs-number">3</span><br>    Thu = <span class="hljs-number">4</span><br>    Fri = <span class="hljs-number">5</span><br>    Sat = <span class="hljs-number">6</span><br><br></code></pre></td></tr></table></figure><p>对于枚举类型的访问方式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-meta">&gt;&gt;&gt; </span>day1 = Weekday.Mon<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(day1)<br>Weekday.Mon<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(Weekday[<span class="hljs-string">&#x27;Tue&#x27;</span>])<br>Weekday.Tue<br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(Weekday.Tue.value)<br><span class="hljs-number">2</span><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(day1 == Weekday.Mon)<br><span class="hljs-literal">True</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(Weekday(<span class="hljs-number">1</span>))<br>Weekday.Mon<br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-built_in">print</span>(day1 == Weekday(<span class="hljs-number">1</span>))<br><span class="hljs-literal">True</span><br><br><span class="hljs-meta">&gt;&gt;&gt; </span>Weekday(<span class="hljs-number">7</span>)<br>Traceback (most recent call last):<br>  ...<br>ValueError: <span class="hljs-number">7</span> <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> a valid Weekday<br>    <br><span class="hljs-meta">&gt;&gt;&gt; </span><span class="hljs-keyword">for</span> name, member <span class="hljs-keyword">in</span> Weekday.__members__.items():<br><span class="hljs-meta">... </span>    <span class="hljs-built_in">print</span>(name, <span class="hljs-string">&#x27;=&gt;&#x27;</span>, member)<br>...<br>Sun =&gt; Weekday.Sun<br>Mon =&gt; Weekday.Mon<br>Tue =&gt; Weekday.Tue<br>Wed =&gt; Weekday.Wed<br>Thu =&gt; Weekday.Thu<br>Fri =&gt; Weekday.Fri<br>Sat =&gt; Weekday.Sat<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大数据分析之OLTP与OLAP的区别</title>
    <link href="/2021/05/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BOLTP%E4%B8%8EOLAP%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/05/19/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B9%8BOLTP%E4%B8%8EOLAP%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>OLTP:联机事务处理OLTP（on-line transaction processing）</p><p>OLAP:联机分析处理OLAP（On-Line Analytical Processing）</p></blockquote><p>数据从何而来？</p><p>企业日常的各个环节都会产生数据，一个企业从小到大的过程中，最初建设IT系统的时刻是一个分隔点。</p><p>在此之前，数据零散分布在邮箱、发票、单据、APP等各种地方。</p><p><img src="https://www.cmdbyte.com/2021/02/u=2453084096,4005979002&fm=173&app=25&f=JPEG.jpeg" alt="零散的数据分布"></p><p>企业规模达到一定程度时则必须要建设IT系统，此时，数据开始在各种系统（ERP、CRM、MES等）中积累。</p><p><img src="https://www.cmdbyte.com/2021/02/u=1162874362,247668556&fm=173&app=25&f=JPEG.jpeg" alt="IT系统中的数据分布"></p><p>数据价值随着其体量不断的累积也在一直增加。</p><p>获取其中的知识，能够帮助企业发现问题与机遇并进行正确的决策，以达到赢得市场之目的。</p><p>数据分析则是实现以上目标的重要手段之一。</p><p>数据分析体系的建设往往是在初次进行信息化建设后某个时间开始。</p><p><img src="https://www.cmdbyte.com/2021/02/u=3118014053,2411848866&fm=173&app=25&f=JPEG.jpeg" alt="数据化后数据分析体系的建立"></p><p>数据分析体系与其他业务类系统有着显著的不同。</p><p>业务类系统主要供基层人员使用，进行一线业务操作，通常被称为OLTP（On-Line Transaction Processing，联机事务处理）。</p><p>数据分析的目标则是探索并挖掘数据价值，作为企业高层进行决策的参考，通常被称为OLAP（On-Line Analytical Processing，联机分析处理）。</p><p>从功能角度来看，OLTP负责基本业务的正常运转，而业务数据积累时所产生的价值信息则被OLAP不断呈现，企业高层通过参考这些信息会不断调整经营方针，也会促进基础业务的不断优化，这是OLTP与OLAP最根本的区别。</p><p><img src="https://www.cmdbyte.com/2021/02/u=1802595313,1865688217&fm=173&app=25&f=JPEG.jpeg" alt="OLTP与OLAP"></p><p>OLAP不应该对OLTP产生任何影响，（理想情况下）OLTP应该完全感觉不到OLAP的存在。</p><p>参考：</p><p><a href="https://baijiahao.baidu.com/s?id=1611554859260686629&wfr=spider&for=pc">大数据分析之OLTP与OLAP的区别</a></p><p><a href="https://www.cnblogs.com/hhandbibi/p/7118740.html">OLAP、OLTP的介绍和比较</a></p><p><a href="https://www.zhihu.com/question/24110442/answer/851671343">(OLTP与OLAP的关系是什么</a></p><p><a href="https://blog.csdn.net/weixin_43270493/article/details/103123490">OLAP和OLTP基本概念和主要区别</a></p>]]></content>
    
    
    <categories>
      
      <category>TODO</category>
      
      <category>大数据</category>
      
    </categories>
    
    
    <tags>
      
      <tag>大数据</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python函数知识回顾</title>
    <link href="/2021/05/14/Python%E5%87%BD%E6%95%B0%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    <url>/2021/05/14/Python%E5%87%BD%E6%95%B0%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<h3 id="常用内置函数"><a href="#常用内置函数" class="headerlink" title="常用内置函数"></a>常用内置函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 求绝对值</span><br><span class="hljs-built_in">abs</span>(-<span class="hljs-number">1</span>) <span class="hljs-comment">#1</span><br><span class="hljs-comment"># 最大值与最小值</span><br><span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">#3</span><br><span class="hljs-built_in">min</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>) <span class="hljs-comment">#1</span><br><br><span class="hljs-comment">#类型转换</span><br><span class="hljs-built_in">int</span>(<span class="hljs-string">&#x27;123&#x27;</span>)<br><span class="hljs-built_in">int</span>(<span class="hljs-number">13.14</span>)<br><span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;520.1314&#x27;</span>)<br><span class="hljs-built_in">str</span>(<span class="hljs-number">1.14</span>)<br><span class="hljs-built_in">bool</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">#True 注意True与False大小写</span><br><span class="hljs-built_in">bool</span>(<span class="hljs-string">&#x27;&#x27;</span>) <span class="hljs-comment">#False</span><br></code></pre></td></tr></table></figure><h3 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h3><p>一个函数可以是空函数，使用<code>pass</code>占位符</p><p>函数内可以有参数检查<code>not isinstance()</code></p><p>函数可以返回多个值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">loss</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(a, (<span class="hljs-built_in">int</span>, <span class="hljs-built_in">float</span>)):  <span class="hljs-comment"># 参数类型检查</span><br>        <span class="hljs-built_in">print</span>(a + <span class="hljs-string">&quot;不是数字&quot;</span>)<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(b)<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">isinstance</span>(b, (<span class="hljs-built_in">int</span>,)):  <span class="hljs-comment"># 注意第二个参数是一个tuple，单个值要有,</span><br>        <span class="hljs-keyword">return</span>  <span class="hljs-comment"># 等价于 return None</span><br>    <span class="hljs-keyword">return</span> a, a+b, b  <span class="hljs-comment"># 返回多个值</span><br></code></pre></td></tr></table></figure><h3 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h3><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">power(x)<br>power(x, y)<br></code></pre></td></tr></table></figure><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">power</span>(<span class="hljs-params">x, y=<span class="hljs-number">1</span>, z=<span class="hljs-number">2</span></span>):<br>    <span class="hljs-keyword">pass</span><br><br>power(<span class="hljs-number">0</span>)<br>power(<span class="hljs-number">0</span>, y=<span class="hljs-number">2</span>) <span class="hljs-comment"># 与默认参数值不符，需要带上默认参数名</span><br>power(<span class="hljs-number">0</span>, z=<span class="hljs-number">3</span>, y=<span class="hljs-number">3</span>) <span class="hljs-comment">#传入顺序可以不同，但要指定参数名</span><br></code></pre></td></tr></table></figure><p><strong>关于默认参数的坑:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_end</span>(<span class="hljs-params">L=[]</span>):<br>    L.append(<span class="hljs-string">&quot;END&quot;</span>)<br>    <span class="hljs-keyword">return</span> L<br><br>add_end() <span class="hljs-comment"># [ &quot;END&quot; ]</span><br>add_end() <span class="hljs-comment"># [ &quot;END&quot;, &quot;END&quot; ]</span><br><br><span class="hljs-comment"># 原因：Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。</span><br><br><span class="hljs-comment"># 定义默认参数要牢记一点：默认参数必须指向不变对象！</span><br><span class="hljs-comment"># 正确的定义方式：</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_end</span>(<span class="hljs-params">L=<span class="hljs-literal">None</span></span>):<br>    <span class="hljs-keyword">if</span> L <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        L = []<br>    L.append(<span class="hljs-string">&#x27;END&#x27;</span>)<br>    <span class="hljs-keyword">return</span> L<br><span class="hljs-comment"># 这样定义，无论调用多少次都没有问题.</span><br></code></pre></td></tr></table></figure><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个<code>tuple</code>。</p><p>函数定义时在参数前面加<code>*</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calc</span>(<span class="hljs-params">*num</span>):<br>    <span class="hljs-built_in">sum</span> = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> num:<br>        <span class="hljs-built_in">sum</span> = <span class="hljs-built_in">sum</span> + i * i<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span><br><br><span class="hljs-comment"># 调用</span><br>calc()<br>calc(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 调用时传入一个list或者tuple, 只需要在待传入变量前加上*即可</span><br>nums = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>]<br>calc(*nums)<br></code></pre></td></tr></table></figure><h4 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h4><p>而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个<code>dict</code>。</p><p>函数定义时在参数前加<code>**</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, **kw</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name:&#x27;</span>, name, <span class="hljs-string">&#x27;age:&#x27;</span>, age, <span class="hljs-string">&#x27;other:&#x27;</span>, kw)<br></code></pre></td></tr></table></figure><p><strong>调用</strong></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">&gt;&gt;&gt; person(&#x27;Michael&#x27;, 30)<br>name: Michael age: 30 other: &#123;&#125;<br>&gt;&gt;&gt; person(&#x27;Bob&#x27;, 35, city=&#x27;Beijing&#x27;)<br>name: Bob age: 35 other: &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;&#125;<br>&gt;&gt;&gt; person(&#x27;Adam&#x27;, 45, gender=&#x27;M&#x27;, job=&#x27;Engineer&#x27;)<br>name: Adam age: 45 other: &#123;&#x27;gender&#x27;: &#x27;M&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;    <br><br>直接传入一个dict变量，在变量前加**<br>extra = &#123;&#x27;city&#x27;: &#x27;Beijing&#x27;, &#x27;job&#x27;: &#x27;Engineer&#x27;&#125;<br>person(&#x27;Jack&#x27;, 24, **extra)<br></code></pre></td></tr></table></figure><p>注意它们采用的是值传递，即<strong>函数参数是传入变量的拷贝</strong>。</p><h4 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h4><p>对于关键字参数，你可以传入任意多个<code>key-value</code>值，但有时候只想传入确定的<code>key</code>值，就需要命名关键字参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, *, city, job</span>):<br>    <span class="hljs-built_in">print</span>(name, age, city, job)<br><br><span class="hljs-comment"># 如果函数定义中已经有了可变参数，后面的命名关键字参数不再需要*分隔符</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, *args, city, job</span>):<br>    <span class="hljs-built_in">print</span>(name, age, args, city, job)<br>    <br><span class="hljs-comment"># 带缺省值的命名关键字参数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">person</span>(<span class="hljs-params">name, age, *, city=<span class="hljs-string">&#x27;Beijing&#x27;</span>, job</span>):<br>    <span class="hljs-built_in">print</span>(name, age, city, job)<br></code></pre></td></tr></table></figure><h4 id="函数参数总结"><a href="#函数参数总结" class="headerlink" title="函数参数总结"></a>函数参数总结</h4><p>在Python函数定义中，可以有多种参数类型，但是<strong>参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</strong>因为在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。</p><p>在实际使用中，不要同时使用太多的组合，否则函数接口的可理解性很差。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang处理JSON问题</title>
    <link href="/2021/05/13/Golang%E5%A4%84%E7%90%86JSON%E9%97%AE%E9%A2%98/"/>
    <url>/2021/05/13/Golang%E5%A4%84%E7%90%86JSON%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><a href="https://stackoverflow.com/questions/15672556/handling-json-post-request-in-go">Handling JSON Post Request in Go - Stack Overflow</a></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基础知识回顾</title>
    <link href="/2021/05/12/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
    <url>/2021/05/12/Python%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<h2 id="数据类型和变量"><a href="#数据类型和变量" class="headerlink" title="数据类型和变量"></a>数据类型和变量</h2><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><ul><li>对于很大的数比如<code>10000000</code>，为了方便阅读可以写成<code>100_00_00_0</code>，解释器仍可以原数值解析</li><li>整数运算永远精确，包括整数的除法运算</li></ul><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><ul><li>科学计数法，eg：<code>1.234e10</code>, <code>1.234e-9</code></li><li>浮点数在运算上会有四舍五入的误差</li></ul><p><strong>注意：</strong></p><ul><li>Python中整数和浮点数没有大小限制，如果超过一定范围直接表示为<code>inf</code>(无穷大)</li><li>整数和浮点数的精确性问题是由于他们在计算机内部的存储方式不同造成的。</li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li><p>可以用<code>&#39;&#39;</code>或者<code>&quot;&quot;</code>表示</p></li><li><p>转义字符<code>\</code></p></li><li><p>代码分行写</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;&#x27;&#x27;Hello,</span><br><span class="hljs-string">Mofan&#x27;&#x27;&#x27;</span>)<br><br><span class="hljs-comment"># 或者在分行语句前加上个r</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">r&#x27;&#x27;&#x27;Hello,</span><br><span class="hljs-string">Baitong&#x27;&#x27;&#x27;</span>)<br></code></pre></td></tr></table></figure></li></ul><h4 id="字符串编码"><a href="#字符串编码" class="headerlink" title="字符串编码"></a>字符串编码</h4><p><code>Python3</code>默认使用<code>Unicode</code>编码</p><p>字符与整数的转化：<code>ord()</code>函数将字符转化成整数，<code>chr()</code>函数将整数转化成字符</p><p><code>Python</code>对比特类型数据表示：在<code>b&#39;&#39;</code>或<code>b&quot;&quot;</code>，eg：<code>x = b&#39;Mofan&#39;</code></p><p>使用<code>encode()</code>方法将<code>Unicode</code>表示的<code>str</code>转成<code>bytes</code>，反之用<code>decode()</code>，eg：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pyton">&#x27;ABC&#x27;.endcode(&#x27;ascii&#x27;)<br>&#x27;ABC&#x27;.decode(&#x27;ascii&#x27;)<br><br>&#x27;ABC&#x27;.encode(&#x27;utf-8&#x27;)<br>&#x27;ABC&#x27;.decode(&#x27;utf-8&#x27;)<br><br>&#x27;ABC&#x27;.encode(&#x27;gb2312)<br>&#x27;ABC&#x27;.decode(&#x27;gb2312&#x27;)<br></code></pre></td></tr></table></figure><p><code>len()</code>方法：计算<code>str</code>的字符数；计算<code>bytes</code>的字节数</p><p>一个<code>Python</code>文件开头通常有这两行，第一行在<code>Linux/OS X</code>中指定解释器(<code>Windows</code>系统会忽略)，第二行指定文本编码格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#!/usr/bin/env python3</span><br><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br></code></pre></td></tr></table></figure><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><ul><li><code>True</code> 与 <code>False</code>，注意大小写</li><li><code>not</code>运算 eg: <code>not True == False</code></li></ul><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>用<code>None</code>表示</p><h3 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h3><p>变量名必须是大小写英文、数字和<code>_</code>的组合，且不能用数字开头</p><h3 id="格式化"><a href="#格式化" class="headerlink" title="格式化"></a>格式化</h3><p>有三种格式化方法；使用占位符；<code>format()</code>；<code>f-string</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-comment"># 占位符</span><br><span class="hljs-string">&#x27;Hello, %s&#x27;</span> % <span class="hljs-string">&#x27;world&#x27;</span><br><span class="hljs-string">&#x27;Hello, world&#x27;</span><br><br><span class="hljs-comment"># format():用&#123;0&#125;,&#123;1&#125;这种顺序依次占位 </span><br><span class="hljs-string">&#x27;Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%&#x27;</span>.<span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;小明&#x27;</span>, <span class="hljs-number">17.125</span>)<br><span class="hljs-string">&#x27;Hello, 小明, 成绩提升了 17.1%&#x27;</span><br><br><span class="hljs-comment"># f-string：用&#123;&#125;包围变量名称</span><br>r = <span class="hljs-number">2.5</span><br>s = <span class="hljs-number">3.14</span> * r ** <span class="hljs-number">2</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;The area of a circle with radius <span class="hljs-subst">&#123;r&#125;</span> is <span class="hljs-subst">&#123;s:<span class="hljs-number">.2</span>f&#125;</span>&#x27;</span>)<br>The area of a circle <span class="hljs-keyword">with</span> radius <span class="hljs-number">2.5</span> <span class="hljs-keyword">is</span> <span class="hljs-number">19.62</span><br></code></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p><code>list</code>是一种有序的集合，可以随时添加和删除其中的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs Python">x = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>]<br><span class="hljs-built_in">len</span>(x) <span class="hljs-comment"># 3</span><br>x[<span class="hljs-number">0</span>] <span class="hljs-comment"># &#x27;a&#x27;</span><br>x[-<span class="hljs-number">1</span>] <span class="hljs-comment"># &#x27;c&#x27;</span><br>x.append(<span class="hljs-string">&#x27;d&#x27;</span>) <span class="hljs-comment"># x=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;]</span><br>x.insert(<span class="hljs-number">2</span>, <span class="hljs-string">&#x27;x&#x27;</span>) <span class="hljs-comment"># x = [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;x&#x27;, &#x27;c&#x27;, &#x27;d&#x27;],注意list从0开始</span><br>x.pop() <span class="hljs-comment"># x=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;x&#x27;, &#x27;c&#x27;]</span><br>x.pop(<span class="hljs-number">2</span>) <span class="hljs-comment"># x=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;]</span><br><br><span class="hljs-comment"># 嵌套，可以理解为多维数组</span><br>p = [<span class="hljs-string">&#x27;x&#x27;</span>, <span class="hljs-string">&#x27;y&#x27;</span>]<br>x.append(p) <span class="hljs-comment"># x=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, [&#x27;x&#x27;, &#x27;y&#x27;]]</span><br>x[<span class="hljs-number">3</span>][<span class="hljs-number">1</span>] <span class="hljs-comment"># &#x27;x&#x27;</span><br></code></pre></td></tr></table></figure><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>元组，特性与<code>list</code>类似，但是初始化后不能改变，这里的不能改变指的是Tuple的内存指向不能变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs Python">t = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-comment">#单个元素定义 &#x27;,&#x27;不能省略</span><br>t = (<span class="hljs-number">1</span>,)<br><span class="hljs-comment"># Tuple中可以包含List，适用于对List的所有操作</span><br>t = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>])<br></code></pre></td></tr></table></figure><p><strong>注意：</strong><code>tuple</code>与<code>list</code>的声明区别，<code>()</code>与<code>[]</code>。</p><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs Python">s = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;Plase input a number: &quot;</span>) <span class="hljs-comment"># 注意input()读取的数据是str，不能直接和int比较</span><br>x = <span class="hljs-built_in">int</span>(s)<br><span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">2021</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Mofan&quot;</span>)<br><span class="hljs-keyword">elif</span> x &lt; <span class="hljs-number">2021</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Baitong&quot;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Hello, World!&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># for</span><br>a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">for</span> x <span class="hljs-keyword">in</span> a:<br>    <span class="hljs-built_in">print</span>(x)<br>    <span class="hljs-keyword">if</span> x == <span class="hljs-number">3</span>:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">elif</span> x == <span class="hljs-number">2</span>:<br>        <span class="hljs-keyword">continue</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;are you ok?&quot;</span>)<br><br><span class="hljs-comment"># while</span><br>x = <span class="hljs-number">1</span><br><span class="hljs-keyword">while</span> x &lt; <span class="hljs-number">10</span>:<br>    x = x + <span class="hljs-number">1</span><br>    <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">5</span>:<br>        <span class="hljs-keyword">break</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang关于时间的加减法</title>
    <link href="/2021/05/11/Golang%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E5%8A%A0%E5%87%8F%E6%B3%95/"/>
    <url>/2021/05/11/Golang%E5%85%B3%E4%BA%8E%E6%97%B6%E9%97%B4%E7%9A%84%E5%8A%A0%E5%87%8F%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="时间日期"><a href="#时间日期" class="headerlink" title="时间日期"></a>时间日期</h2><ul><li><code>Now()</code>：当前<code>Time</code>对象。</li><li><code>Date()</code>：当前年月日。年和日为<code>int</code>类型，月为<code>Month</code>类型。</li><li><code>YearDay()</code>：当天是一年中的第几天。</li><li><code>Weekday()</code>：当天是星期几。</li><li><code>Unix()</code>：时间戳，秒。</li><li><code>UnixNano()</code>：时间戳，纳秒。</li><li><code>UnixNano() / 1e6</code>：时间戳，毫秒。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go">t := time.Now()<br>fmt.Println(<span class="hljs-string">&quot;time.Now()：&quot;</span>, t) <span class="hljs-comment">// 2020-10-24 22:10:53.328973 +0800 CST m=+0.006015101</span><br>year, month, day := t.Date()<br>fmt.Println(<span class="hljs-string">&quot;日期：&quot;</span>, year, month, day) <span class="hljs-comment">// 2020 October 24</span><br>fmt.Println(<span class="hljs-string">&quot;一年中的第几天：&quot;</span>, t.YearDay()) <span class="hljs-comment">// 298</span><br>fmt.Println(<span class="hljs-string">&quot;星期几：&quot;</span>, t.Weekday()) <span class="hljs-comment">// Saturday</span><br>fmt.Println(<span class="hljs-string">&quot;年：&quot;</span>, t.Year()) <span class="hljs-comment">// 2020</span><br>fmt.Println(<span class="hljs-string">&quot;月：&quot;</span>, t.Month()) <span class="hljs-comment">// October</span><br>fmt.Println(<span class="hljs-string">&quot;日：&quot;</span>, t.Day()) <span class="hljs-comment">// 24</span><br>fmt.Println(<span class="hljs-string">&quot;时：&quot;</span>, t.Hour()) <span class="hljs-comment">// 22</span><br>fmt.Println(<span class="hljs-string">&quot;分：&quot;</span>, t.Minute()) <span class="hljs-comment">// 10</span><br>fmt.Println(<span class="hljs-string">&quot;秒：&quot;</span>, t.Second()) <span class="hljs-comment">// 53</span><br>fmt.Println(<span class="hljs-string">&quot;纳秒：&quot;</span>, t.Nanosecond()) <span class="hljs-comment">// 328973000</span><br>fmt.Println(<span class="hljs-string">&quot;秒时间戳：&quot;</span>, t.Unix()) <span class="hljs-comment">// 1603548653</span><br>fmt.Println(<span class="hljs-string">&quot;纳秒时间戳：&quot;</span>, t.UnixNano()) <span class="hljs-comment">// 1603548653328973000</span><br>fmt.Println(<span class="hljs-string">&quot;毫秒时间戳：&quot;</span>, t.UnixNano() / <span class="hljs-number">1e6</span>) <span class="hljs-comment">// 1603548653328</span><br></code></pre></td></tr></table></figure><h2 id="线程睡眠"><a href="#线程睡眠" class="headerlink" title="线程睡眠"></a>线程睡眠</h2><p>可以使用<code>Duration</code>对象和指数<code>e</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">time.Sleep(<span class="hljs-number">2</span> * time.Second) <span class="hljs-comment">// 休眠2秒</span><br>time.Sleep(<span class="hljs-number">2e9</span>) <span class="hljs-comment">// 休眠2秒</span><br></code></pre></td></tr></table></figure><h2 id="计算耗时"><a href="#计算耗时" class="headerlink" title="计算耗时"></a>计算耗时</h2><p>使用<code>Sub()</code>计算两个<code>Time</code>间隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">t := time.Now()<br>time.Sleep(<span class="hljs-number">2e9</span>) <span class="hljs-comment">// 休眠2秒</span><br>delta := time.Now().Sub(t)<br>fmt.Println(<span class="hljs-string">&quot;时间差：&quot;</span>, delta) <span class="hljs-comment">// 2.0534341s</span><br></code></pre></td></tr></table></figure><h2 id="时间加减"><a href="#时间加减" class="headerlink" title="时间加减"></a>时间加减</h2><p>使用<code>Add</code>增加纳秒、微秒、毫秒、秒、分、时，接收<code>Duration</code>对象。</p><p>使用<code>AddDate</code>增加年、月、日，接收<code>int</code>参数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go">t := time.Now()<br>addOneHour := t.Add(time.Hour)<br>addTwoHour := t.Add(<span class="hljs-number">2</span> * time.Hour)<br>fmt.Println(<span class="hljs-string">&quot;增加1小时：&quot;</span>, addOneHour)<br>fmt.Println(<span class="hljs-string">&quot;增加2小时：&quot;</span>, addTwoHour)<br><br>subTwoHour := t.Add(<span class="hljs-number">-2</span> * time.Hour)<br>fmt.Println(<span class="hljs-string">&quot;减去2小时：&quot;</span>, subTwoHour)<br><br>addDate := t.AddDate(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>fmt.Println(<span class="hljs-string">&quot;增加1年：&quot;</span>, addDate) <span class="hljs-comment">// 2021-10-24 22:10:53.328973 +0800 CST</span><br><br>subDate := t.AddDate(<span class="hljs-number">-1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>)<br>fmt.Println(<span class="hljs-string">&quot;减去1年：&quot;</span>, subDate) <span class="hljs-comment">// 2019-10-24 22:10:53.328973 +0800 CST</span><br><br>before := t.Before(t.Add(time.Hour))<br>fmt.Println(<span class="hljs-string">&quot;before：&quot;</span>, before)<br><br>after := t.After(t.Add(time.Hour))<br>fmt.Println(<span class="hljs-string">&quot;after：&quot;</span>, after)<br></code></pre></td></tr></table></figure><h2 id="毫秒转换"><a href="#毫秒转换" class="headerlink" title="毫秒转换"></a>毫秒转换</h2><p>毫秒转换<code>Time</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">nanoSecondToTime := time.Unix(<span class="hljs-number">0</span>, <span class="hljs-number">1603546715761482000</span>)<br>fmt.Println(<span class="hljs-string">&quot;毫秒值转Time：&quot;</span>, nanoSecondToTime) <span class="hljs-comment">// 2020-10-24 21:38:35.761482 +0800 CST</span><br></code></pre></td></tr></table></figure><p>秒转换<code>Time</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">secondToTime := time.Unix(<span class="hljs-number">1603546715</span>, <span class="hljs-number">0</span>)<br>fmt.Println(<span class="hljs-string">&quot;秒值转Time：&quot;</span>, secondToTime) <span class="hljs-comment">// 2020-10-24 21:38:35 +0800 CST</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>布隆过滤器(Bloom Filter)详解</title>
    <link href="/2021/05/11/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-Bloom-Filter-%E8%AF%A6%E8%A7%A3/"/>
    <url>/2021/05/11/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8-Bloom-Filter-%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/liyulong1982/p/6013002.html">布隆过滤器(Bloom Filter)详解 - 李玉龙 - 博客园</a></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>缓存三大问题及解决方案</title>
    <link href="/2021/05/11/%E7%BC%93%E5%AD%98%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2021/05/11/%E7%BC%93%E5%AD%98%E4%B8%89%E5%A4%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<p>参考：<a href="https://blog.csdn.net/haoxin963/article/details/83245113?utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.vipsorttest&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromMachineLearnPai2~default-2.vipsorttest">(3条消息) redis(五)-缓存三大问题及解决方案_haoxin963的专栏-CSDN博客_redis缓存</a></p><p>在缓存系统中，有三类问题比较常见，分别是<strong>缓存穿透</strong>、<strong>缓存雪崩</strong>、<strong>缓存击穿</strong>，这三类问题在面试中也常常被问到，时间久了很容易将其混淆。</p><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>在常见的互联网应用中，有缓存的系统常用的架构像下面这样：</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>通过穿透我们知道，必然是请求的数据没有在缓存中找到，然后穿过了缓存系统，到了后面的数据库中查询了。可以简单理解为：只要请求的数据是从后面的数据库拿到的就是缓存穿透。</p><h4 id="危害"><a href="#危害" class="headerlink" title="危害"></a>危害</h4><p>对于少量的绕过缓存的请求，数据库还是可以应对的，但是当大量的请求都绕过了缓存，全部请求数据库，那数据库直接崩溃，造成整个系统的宕机</p><h4 id="发生缓存穿透的原因"><a href="#发生缓存穿透的原因" class="headerlink" title="发生缓存穿透的原因"></a>发生缓存穿透的原因</h4><p>主要有两种原因，首先，大量请求的数据都没在缓存中找到，这是巧合吗？当然不是，这很可能是恶意攻击；另外，就是代码逻辑问题了，讲个低级的错误，你要查找的key是”x_string”这种的，结果忘记了带“x_”这个前缀，然后缓存直接原地去世，所有的请求在缓存中找不到，就都去数据库查了。</p><p>所以，总结为：</p><ul><li>恶意攻击</li><li>代码逻辑错误</li></ul><h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><h3 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h3>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes常用命令</title>
    <link href="/2021/05/11/Kubernetes%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/05/11/Kubernetes%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p><strong>查看集群信息</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl cluster-info<br></code></pre></td></tr></table></figure><p><strong>获取集群中所有节点</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl get nodes<br></code></pre></td></tr></table></figure><p><strong>获取帮助</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl --<span class="hljs-built_in">help</span><br><br>kubectl get --<span class="hljs-built_in">help</span><br><br>kubectl get nodes --<span class="hljs-built_in">help</span><br></code></pre></td></tr></table></figure><p><strong>部署应用</strong></p><p>要提供实例名称和 app 镜像地址</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">kubectl create deployment kubernetes-bootcamp --image=gcr.io/google-samples/kubernetes-bootcamp:v1<br></code></pre></td></tr></table></figure><p><strong>列出部署的应用</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">kubectl <span class="hljs-built_in">get</span> deployments<br></code></pre></td></tr></table></figure><p><strong>获取Pod中容器的信息</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl describe pods<br></code></pre></td></tr></table></figure><blockquote><p>Pod的定义：一组一个或多个容器，同时定义其使用的资源</p></blockquote><blockquote><p>describe命令还可用于*node, pods, deployments.</p></blockquote><p><strong>获取Pod日志</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl logs $POD_NAME<br></code></pre></td></tr></table></figure><p><strong>在Pod中运行命令</strong>(单条命令)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl exec $POD_NAME -- env<br></code></pre></td></tr></table></figure><p><strong>与Pod通过bash交互</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kubectl exec -ti $POD_NAME -- bash<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes相关概念</title>
    <link href="/2021/05/11/Kubernetes%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/"/>
    <url>/2021/05/11/Kubernetes%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="Kubernetes集群"><a href="#Kubernetes集群" class="headerlink" title="Kubernetes集群"></a>Kubernetes集群</h3><p><strong>Kubernetes 协调一个高可用计算机集群，每个计算机作为独立单元互相连接工作。</strong> Kubernetes 中的抽象允许将容器化的应用部署到集群，而无需将它们绑定到某个特定的独立计算机。为了使用这种新的部署模型，应用需要以将应用与单个主机分离的方式打包：它们需要被容器化。与过去的那种应用直接以包的方式深度与主机集成的部署模型相比，容器化应用更灵活、更可用。 <strong>Kubernetes 以更高效的方式跨集群自动分发和调度应用容器。</strong> Kubernetes 是一个开源平台，并且可应用于生产环境。</p><p>一个 Kubernetes 集群包含两种类型的资源:</p><ul><li><strong>Master</strong> 调度整个集群</li><li><strong>Nodes</strong> 负责运行应用</li></ul><p><img src="https://www.cmdbyte.com/2021/02/module_01_cluster.svg" alt="集群图"></p><p><strong>Master 负责管理整个集群。</strong> Master 协调集群中的所有活动，例如调度应用、维护应用的所需状态、应用扩容以及推出新的更新。</p><p><strong>Node 是一个虚拟机或者物理机，它在 Kubernetes 集群中充当工作机器的角色</strong> 每个Node都有 Kubelet , 它管理 Node 而且是 Node 与 Master 通信的代理。 Node 还应该具有用于处理容器操作的工具，例如 Docker 或 rkt 。处理生产级流量的 Kubernetes 集群至少应具有三个 Node 。</p><p><em>Master 管理集群，Node 用于托管正在运行的应用。</em></p><p>在 Kubernetes 上部署应用时，只需告诉 Master 启动应用容器。 Master 就编排容器在集群的 Node 上运行。 <strong>Node 使用 Master 暴露的 Kubernetes API 与 Master 通信。</strong>终端用户也可以使用 Kubernetes API 与集群交互。</p>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go import cypcle问题</title>
    <link href="/2021/04/23/Go-import-cypcle%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/23/Go-import-cypcle%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>这是我第一次遇到这个问题，是在编译的时候直接抛出来的问题，但是编译器并不会告诉你哪里重复引入了，这与Go包的导入机制有关，发生在编译阶段，在编译时，Go会检查所有<code>import</code>的包，从中梳理出导入逻辑，如果存在<code>package A</code>和<code>package B</code>互相导入，即A中<code>import B</code>，B中<code>import A</code>，那么就会发生这个问题。</p><p>出现这个问题肯定是一脸懵的，因为没有提示出错的地方。</p><p>排查的思路也很简单，重新分析一下刚添加的新代码，理一理包的引入逻辑，基本就能发现。</p><p>这个问题也给我提了一个醒，Go的包的逻辑还是需要好好设计的，它不像Java那样随意。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Token多平台身份认证架构设计思路</title>
    <link href="/2021/04/22/Token%E5%A4%9A%E5%B9%B3%E5%8F%B0%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/"/>
    <url>/2021/04/22/Token%E5%A4%9A%E5%B9%B3%E5%8F%B0%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>文章来源：<a href="https://www.cnblogs.com/beer/p/6029861.html">基于token的多平台身份认证架构设计 - 一点一滴的Beer - 博客园</a></p></blockquote><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在存在账号体系的信息系统中，对身份的鉴定是非常重要的事情。</p><p>随着移动互联网时代到来，客户端的类型越来越多， 逐渐出现了 一个服务器，N个客户端的格局 。</p><p><img src="https://www.cmdbyte.com/2021/02/token_1.webp"></p><p>不同的客户端产生了不同的用户使用场景，这些场景：</p><ul><li>有不同的环境安全威胁</li><li>不同的会话生存周期</li><li>不同的用户权限控制体系</li><li>不同级别的接口调用方式</li></ul><p>综上所述，它们的身份认证方式也存在一定的区别。</p><p>本文将使用一定的篇幅对这些场景进行一些分析和梳理工作。</p><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>下面是一些在IT服务常见的一些使用场景:</p><ul><li>用户在web浏览器端登录系统,使用系统服务</li><li>用户在手机端（Android&#x2F;iOS）登录系统,使用系统服务</li><li>用户使用开放接口登录系统,调用系统服务</li><li>用户在PC处理登录状态时通过手机扫码授权手机登录（使用得比较少）</li><li>用户在手机处理登录状态进通过手机扫码授权PC进行登录（比较常见）</li></ul><p>通过对场景的细分,得到如下不同的认证token类别：</p><h4 id="原始账号密码类别"><a href="#原始账号密码类别" class="headerlink" title="原始账号密码类别"></a>原始账号密码类别</h4><ul><li>用户名和密码</li><li>API应用ID&#x2F;KEY</li></ul><h4 id="会话ID类别"><a href="#会话ID类别" class="headerlink" title="会话ID类别"></a>会话ID类别</h4><ul><li>浏览器端token</li><li>移动端token</li><li>API应用token</li></ul><h4 id="接口调用类别"><a href="#接口调用类别" class="headerlink" title="接口调用类别"></a>接口调用类别</h4><ul><li>接口访问token</li><li>身份授权类别</li><li>PC和移动端相互授权的token</li></ul><h3 id="token的类别"><a href="#token的类别" class="headerlink" title="token的类别"></a>token的类别</h3><p>不同场景的token进行如下几个维度的对比:</p><h4 id="天然属性对比"><a href="#天然属性对比" class="headerlink" title="天然属性对比:"></a>天然属性对比:</h4><h5 id="使用成本"><a href="#使用成本" class="headerlink" title="使用成本"></a>使用成本</h5><p>本认证方式在使用的时候,造成的不便性。比如:</p><ul><li>账号密码需要用户打开页面然后逐个键入</li><li>二维码需要用户掏出手机进行扫码操作</li></ul><h5 id="变化成本"><a href="#变化成本" class="headerlink" title="变化成本"></a>变化成本</h5><p>本认证方式,token发生变化时,用户需要做出的相应更改的成本:</p><ul><li>用户名和密码发生变化时,用户需要额外记忆和重新键入新密码</li><li>API应用ID&#x2F;KEY发生变化时,第三方应用需要重新在代码中修改并部署</li><li>授权二维码发生变化时,需要用户重新打开手机应用进行扫码</li></ul><p>环境风险</p><ul><li>被偷窥的风险</li><li>被抓包的风险</li><li>被伪造的风险</li></ul><h4 id="可调控属性对比"><a href="#可调控属性对比" class="headerlink" title="可调控属性对比:"></a>可调控属性对比:</h4><h5 id="使用频率"><a href="#使用频率" class="headerlink" title="使用频率"></a>使用频率</h5><p>在网路中传送的频率</p><h5 id="有效时间"><a href="#有效时间" class="headerlink" title="有效时间"></a>有效时间</h5><p>此token从创建到终结的生存时间</p><blockquote><p>最终的目标:安全和影响。</p></blockquote><p>安全和隐私性主要体现在:</p><ul><li>token 不容易被窃取和盗用（通过对传送频率控制）</li><li>token 即使被窃取,产生的影响也是可控的（通过对有效时间控制）</li></ul><p>关于隐私及隐私破坏后的后果,有如下的基本结论:</p><ul><li>曝光频率高的容易被截获</li><li>生存周期长的在被截获后产生的影响更严重和深远</li></ul><p>遵守如下原则:</p><ul><li>变化成本高的token不要轻易变化</li><li>不轻易变化的token要减少曝光频率（网络传输次数）</li><li>曝光频率高的token的生存周期要尽量短</li></ul><p>将各类token的固有特点及可控属性进行调控后, 对每个指标进行量化评分（1~5分），我们可以得到如下的对比表：</p><p><img src="https://www.cmdbyte.com/2021/02/token_2.jpeg"></p><blockquote><p>备注:user_name&#x2F;passwd 和 app_id&#x2F;app_key 是等价的效果</p></blockquote><h3 id="token的层级关系"><a href="#token的层级关系" class="headerlink" title="token的层级关系"></a>token的层级关系</h3><p>参考上一节的对比表，可以很容易对这些不同用途的token进行分层，主要可以分为4层：</p><ul><li>密码层：最传统的用户和系统之间约定的数字身份认证方式</li><li>会话层：用户登录后的会话生命周期的会话认证</li><li>调用层：用户在会话期间对应用程序接口的调用认证</li><li>应用层：用户获取了接口访问调用权限后的一些场景或者身份认证应用</li></ul><p>token的分层图如下：</p><p><img src="https://www.cmdbyte.com/2021/02/token_3.jpg" alt="token"></p><p>在一个多客户端的信息系统里面,这些token的产生及应用的内在联系如下:</p><ul><li>用户输入用户名和用户口令进行一次性认证</li><li>在 不同 的终端里面生成拥有 不同 生命周期的会话token</li><li>客户端会话token从服务端交换生命周期短但曝光 频繁 的接口访问token</li><li>会话token可以生成和刷新延长 access_token 的生存时间</li><li>access_token可以生成生存周期最短的用于授权的二维码的token</li></ul><p>使用如上的架构有如下的好处：</p><ul><li>良好的统一性。可以解决不同平台上认证token的生存周期的 归一化 问题</li><li>良好的解耦性。核心接口调用服务器的认证 access_token 可以完成独立的实现和部署</li><li>良好的层次性。不同平台的可以有完全不同的用户权限控制系统，这个控制可以在 会话层 中各平台解决掉</li></ul><h4 id="账号密码"><a href="#账号密码" class="headerlink" title="账号密码"></a>账号密码</h4><p>广义的 账号&#x2F;密码 有如下的呈现方式:</p><ul><li>传统的注册用户名和密码</li><li>应用程序的app_id&#x2F;app_key</li></ul><h5 id="它们的特点如下："><a href="#它们的特点如下：" class="headerlink" title="它们的特点如下："></a>它们的特点如下：</h5><h5 id="会有特别的意义"><a href="#会有特别的意义" class="headerlink" title="会有特别的意义"></a>会有特别的意义</h5><p>比如：用户自己为了方便记忆，会设置有一定含义的账号和密码。</p><p>搜索公众号后端架构师后台回复“架构整洁”，获取一份惊喜礼包。</p><h5 id="不常修改"><a href="#不常修改" class="headerlink" title="不常修改"></a>不常修改</h5><p>账号密码对用户有特别含义，一般没有特殊情况不会愿意修改。而app_id&#x2F;app_key则会写在应用程序中，修改会意味着重新发布上线的成本</p><h5 id="一旦泄露影响深远"><a href="#一旦泄露影响深远" class="headerlink" title="一旦泄露影响深远"></a>一旦泄露影响深远</h5><p>正因为不常修改，只要泄露了基本相当于用户的网络身份被泄露，而且只要没被察觉这种身份盗用就会一直存在</p><p>所以在认证系统中应该尽量减少传输的机会，避免泄露。</p><h4 id="客户端会话token"><a href="#客户端会话token" class="headerlink" title="客户端会话token"></a>客户端会话token</h4><h5 id="功能："><a href="#功能：" class="headerlink" title="功能："></a>功能：</h5><p>充当着session的角色，不同的客户端有不同的生命周期。</p><h5 id="使用步骤："><a href="#使用步骤：" class="headerlink" title="使用步骤："></a>使用步骤：</h5><p>用户使用账号密码，换取会话token</p><p>不同的平台的token有不同的特点：</p><h5 id="Web平台生存周期短"><a href="#Web平台生存周期短" class="headerlink" title="Web平台生存周期短"></a>Web平台生存周期短</h5><p>主要原因：</p><ul><li>环境安全性：由于web登录环境一般很可能是公共环境，被他人盗取的风险值较大</li><li>输入便捷性：在PC上使用键盘输入会比较便捷</li></ul><h5 id="移动端生存周期长"><a href="#移动端生存周期长" class="headerlink" title="移动端生存周期长"></a>移动端生存周期长</h5><p>主要原因：</p><ul><li>环境安全性：移动端平台是个人用户极其私密的平台，它人接触的机会不大</li><li>输入便捷性：在移动端上使用手指在小屏幕上触摸输入体验差，输入成本高</li></ul><h4 id="access-token"><a href="#access-token" class="headerlink" title="access_token"></a>access_token</h4><h5 id="功能：-1"><a href="#功能：-1" class="headerlink" title="功能："></a>功能：</h5><p>服务端应用程序api接口访问和调用的凭证。</p><h5 id="使用步骤：-1"><a href="#使用步骤：-1" class="headerlink" title="使用步骤："></a>使用步骤：</h5><p>使用具有较长生命周期的会话token来换取此接口访问token。</p><p>其曝光频率直接和接口调用频率有关，属于高频使用的凭证。为了照顾到隐私性，尽量减少其生命周期，即使被截取了，也不至于产生严重的后果。</p><blockquote><p>注意：在客户端token之下还加上一个access_token， 主要是为了让具有不同生命周期的客户端token最后在调用api的时候， 能够具有统一的认证方式。</p></blockquote><h4 id="pam-token"><a href="#pam-token" class="headerlink" title="pam_token"></a>pam_token</h4><h5 id="功能：-2"><a href="#功能：-2" class="headerlink" title="功能："></a>功能：</h5><p>由已经登录和认证的PC端生成的二维码的原始串号（Pc Auth Mobile）。</p><h5 id="主要步骤如下："><a href="#主要步骤如下：" class="headerlink" title="主要步骤如下："></a>主要步骤如下：</h5><ol><li>PC上用户已经完成认证，登录了系统</li><li>PC端生成一组和此用户相关联的pam_token</li><li>PC端将此pam_token的使用链接生成二维码</li><li>移动端扫码后，请求服务器，并和用户信息关联</li><li>移动端获取refresh_token(长时效的会话)</li><li>根据 refresh_token 获取 access_token</li><li>完成正常的接口调用工作</li></ol><blockquote><p>备注:</p><ul><li>生存周期为2分钟,2分钟后过期删除</li><li>没有被使用时,每1分钟变一次</li><li>被使用后,立刻删除掉</li><li>此种认证模式一般不会被使用到</li></ul></blockquote><h4 id="map-token"><a href="#map-token" class="headerlink" title="map_token"></a>map_token</h4><p>功能：</p><p>由已经登录的移动app来扫码认证PC端系统，并完成PC端系统的登录（Mobile Auth Pc）。</p><p>主要步骤：</p><ol><li>移动端完成用户身份的认证登录app</li><li>未登录的PC生成匿名的 map_token</li><li>移动端扫码后在db中生成 map_token 和用户关联（完成签名）</li><li>db同时针对此用户生成 web_token</li><li>PC端一直以 map_token 为参数查找此命名用户的 web_token</li><li>PC端根据 web_token 去获取 access_token</li><li>后续正常的调用接口调用工作</li></ol><blockquote><p>备注:</p><ul><li>生存周期为2分钟,2分钟后过期删除</li><li>没有被使用时,每1分钟变一次</li><li>被使用后,立刻删除掉</li></ul></blockquote><h3 id="小结与展望"><a href="#小结与展望" class="headerlink" title="小结与展望"></a>小结与展望</h3><p>本文所设计的基于token的身份认证系统，主要解决了如下的问题：</p><ul><li>token的分类问题</li><li>token的隐私性参数设置问题</li><li>token的使用场景问题</li><li>不同生命周期的token分层转化关系</li></ul><p>本文中提到的设计方法，在 应用层 中可以适用于且不限于如下场景中：</p><ul><li>用户登录</li><li>有时效的优惠券发放</li><li>有时效的邀请码发放</li><li>有时效的二维码授权</li><li>具有时效 手机&#x2F;邮件 验证码</li><li>多个不同平台调用同一套API接口</li><li>多个平台使用同一个身份认证中心</li></ul><p>至于更多的使用场景，就需要大家去发掘了。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Nginx常用配置清单</title>
    <link href="/2021/04/22/Nginx%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%B8%85%E5%8D%95/"/>
    <url>/2021/04/22/Nginx%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%E6%B8%85%E5%8D%95/</url>
    
    <content type="html"><![CDATA[<blockquote><p><em>Nginx</em> (engine x) 是一个高性能的<a href="https://baike.baidu.com/item/HTTP">HTTP</a>和<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理</a>web服务器，同时也提供了IMAP&#x2F;POP3&#x2F;SMTP服务。Nginx是由伊戈尔·赛索耶夫为<a href="https://baike.baidu.com/item/%E4%BF%84%E7%BD%97%E6%96%AF/125568">俄罗斯</a>访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。</p><p>其将<a href="https://baike.baidu.com/item/%E6%BA%90%E4%BB%A3%E7%A0%81/3814213">源代码</a>以类<a href="https://baike.baidu.com/item/BSD%E8%AE%B8%E5%8F%AF%E8%AF%81/10642412">BSD许可证</a>的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而<a href="https://baike.baidu.com/item/%E9%97%BB%E5%90%8D/2303308">闻名</a>。2011年6月1日，nginx 1.0.4发布。</p><p>Nginx是一款<a href="https://baike.baidu.com/item/%E8%BD%BB%E9%87%8F%E7%BA%A7/10002835">轻量级</a>的<a href="https://baike.baidu.com/item/Web/150564">Web</a> 服务器&#x2F;<a href="https://baike.baidu.com/item/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/7793488">反向代理</a>服务器及<a href="https://baike.baidu.com/item/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/111106">电子邮件</a>（IMAP&#x2F;POP3）代理服务器，在BSD-like 协议下发行。其特点是占有内存少，<a href="https://baike.baidu.com/item/%E5%B9%B6%E5%8F%91/11024806">并发</a>能力强，事实上nginx的并发能力在同类型的网页服务器中表现较好。</p></blockquote><h3 id="端口监听"><a href="#端口监听" class="headerlink" title="端口监听"></a>端口监听</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sh">server &#123;<br>  <span class="hljs-comment"># Standard HTTP Protocol</span><br>  listen 80;<br><br>  <span class="hljs-comment"># Standard HTTPS Protocol</span><br>  listen 443 ssl;<br><br>  <span class="hljs-comment"># For http2</span><br>  listen 443 ssl http2;<br><br>  <span class="hljs-comment"># Listen on 80 using IPv6</span><br>  listen [::]:80;<br><br>  <span class="hljs-comment"># Listen only on using IPv6</span><br>  listen [::]:80 ipv6only=on;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="访问日志"><a href="#访问日志" class="headerlink" title="访问日志"></a>访问日志</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh">server &#123;<br>  <span class="hljs-comment"># Relative or full path to log file</span><br>  access_log /path/to/file.log;<br><br>  <span class="hljs-comment"># Turn &#x27;on&#x27; or &#x27;off&#x27;</span><br>  access_log on;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>  <span class="hljs-comment"># Listen to yourdomain.com</span><br>  <span class="hljs-attribute">server_name</span> yourdomain.com;<br><br>  <span class="hljs-comment"># Listen to multiple domains</span><br>  <span class="hljs-attribute">server_name</span> yourdomain.com www.yourdomain.com;<br><br>  <span class="hljs-comment"># Listen to all domains</span><br>  <span class="hljs-attribute">server_name</span> <span class="hljs-regexp">*.yourdomain.com</span>;<br><br>  <span class="hljs-comment"># Listen to all top-level domains</span><br>  <span class="hljs-attribute">server_name</span> <span class="hljs-regexp">yourdomain.*</span>;<br><br>  <span class="hljs-comment"># Listen to unspecified Hostnames (Listens to IP address itself)</span><br>  <span class="hljs-attribute">server_name</span> <span class="hljs-string">&quot;&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="静态资源"><a href="#静态资源" class="headerlink" title="静态资源"></a>静态资源</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs sh">server &#123;<br>  <span class="hljs-comment"># Listen to yourdomain.com</span><br>  server_name yourdomain.com;<br><br>  <span class="hljs-comment"># Listen to multiple domains</span><br>  server_name yourdomain.com www.yourdomain.com;<br><br>  <span class="hljs-comment"># Listen to all domains</span><br>  server_name *.yourdomain.com;<br><br>  <span class="hljs-comment"># Listen to all top-level domains</span><br>  server_name yourdomain.*;<br><br>  <span class="hljs-comment"># Listen to unspecified Hostnames (Listens to IP address itself)</span><br>  server_name <span class="hljs-string">&quot;&quot;</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">server &#123;<br>  listen 80;<br>  server_name www.yourdomain.com;<br>  <span class="hljs-built_in">return</span> 301 http://yourdomain.com<span class="hljs-variable">$request_uri</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh">server &#123;<br>  listen 80;<br>  server_name www.yourdomain.com;<br><br>  location /redirect-url &#123;<br>     <span class="hljs-built_in">return</span> 301 http://otherdomain.com;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs sh">server &#123;<br>  listen 80;<br>  server_name yourdomain.com;<br><br>  location / &#123;<br>     proxy_pass http://0.0.0.0:3000;<br>     <span class="hljs-comment"># where 0.0.0.0:3000 is your application server (Ex: node.js) bound on 0.0.0.0 listening on port 3000</span><br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs sh">upstream node_js &#123;<br>  server 0.0.0.0:3000;<br>  server 0.0.0.0:4000;<br>  server 123.131.121.122;<br>&#125;<br><br>server &#123;<br>  listen 80;<br>  server_name yourdomain.com;<br><br>  location / &#123;<br>     proxy_pass http://node_js;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="SSL"><a href="#SSL" class="headerlink" title="SSL"></a>SSL</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs sh">server &#123;<br>  listen 443 ssl;<br>  server_name yourdomain.com;<br><br>  ssl on;<br><br>  ssl_certificate /path/to/cert.pem;<br>  ssl_certificate_key /path/to/privatekey.pem;<br><br>  ssl_stapling on;<br>  ssl_stapling_verify on;<br>  ssl_trusted_certificate /path/to/fullchain.pem;<br><br>  ssl_protocols TLSv1 TLSv1.1 TLSv1.2;<br>  ssl_session_timeout 1h;<br>  ssl_session_cache shared:SSL:50m;<br>  add_header Strict-Transport-Security max-age=15768000;<br>&#125;<br><br><span class="hljs-comment"># Permanent Redirect for HTTP to HTTPS</span><br>server &#123;<br>  listen 80;<br>  server_name yourdomain.com;<br>  <span class="hljs-built_in">return</span> 301 https://$host<span class="hljs-variable">$request_uri</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>原文：</strong><a href="https://vishnu.hashnode.dev/nginx-cheatsheet">Nginx Cheatsheet</a></p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于502 Bad Gateway问题的一些排查思路</title>
    <link href="/2021/04/22/%E5%85%B3%E4%BA%8E502-Bad-Gateway%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/"/>
    <url>/2021/04/22/%E5%85%B3%E4%BA%8E502-Bad-Gateway%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E6%8E%92%E6%9F%A5%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p><strong>查看一下接口有没有出现空指针问题，有可能空指针出现了，但是没有进行处理，导致程序卡在那里了。</strong></p><p>出现502的原因是：对用户访问请求的响应超时造成的</p><p>解决办法：</p><p>1.提高 Web 服务器的响应速度，也即减少内部的调用关系，可以把需要的页面、素材或数据，缓存在内存中，可以是专门的缓存服务器 ，也可以Web服务器自身的缓存，提高响应速度；</p><p>2.网络带宽的问题，则对传输的数据包进行压缩处理，或者向IDC申请增加带宽；</p><p>3.属于内部网络的故障或设置问题，也即内部网络拥塞，可能内部存在大量的数据调用或交互造成的，则需要优化内部网络传输或协议；</p><p>4.数据库的数据读取造成前端服务器 ，响应用户的请求变慢，那么必须提高数据库的处理能力，若是只读业务可以增加数据缓存的模式 或者增加数据库备机，分散读压力；</p><p>出现502的原因是：对用户访问请求的响应超时造成的</p><p>解决办法：</p><p>1.提高 Web 服务器的响应速度，也即减少内部的调用关系，可以把需要的页面、素材或数据，缓存在内存中，可以是专门的缓存服务器 ，也可以Web服务器自身的缓存，提高响应速度；</p><p>2.网络带宽的问题，则对传输的数据包进行压缩处理，或者向IDC申请增加带宽；</p><p>3.属于内部网络的故障或设置问题，也即内部网络拥塞，可能内部存在大量的数据调用或交互造成的，则需要优化内部网络传输或协议；</p><p>4.数据库的数据读取造成前端服务器 ，响应用户的请求变慢，那么必须提高数据库的处理能力，若是只读业务可以增加数据缓存的模式 或者增加数据库备机，分散读压力；</p><p> 若是写的压力，则可以考虑延迟写的模式，想这个时候做数据写分散肯定来不及</p><p>提问的朋友，给你从上述4个方面综合提出了解答，不过具体从那些方面着手必须分析你们内部的真实情况，这个我们热璞科技团队 提供这块的服务，尤其双十一的时候是最容易出现的</p><p>若是写的压力，则可以考虑延迟写的模式，想这个时候做数据写分散肯定来不及</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL查询</title>
    <link href="/2021/04/21/PostgreSQL%E6%9F%A5%E8%AF%A2/"/>
    <url>/2021/04/21/PostgreSQL%E6%9F%A5%E8%AF%A2/</url>
    
    <content type="html"><![CDATA[<p><strong>持续补充</strong></p><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><h4 id="在SELECT语句中使用"><a href="#在SELECT语句中使用" class="headerlink" title="在SELECT语句中使用"></a>在SELECT语句中使用</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> column_name [, column_name ]<br><span class="hljs-keyword">FROM</span>   table1 [, table2 ]<br><span class="hljs-keyword">WHERE</span>  column_name OPERATOR<br>      (<span class="hljs-keyword">SELECT</span> column_name [, column_name ]<br>      <span class="hljs-keyword">FROM</span> table1 [, table2 ]<br>      [<span class="hljs-keyword">WHERE</span>])<br></code></pre></td></tr></table></figure><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> company <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> company <span class="hljs-keyword">WHERE</span> salary <span class="hljs-operator">&gt;</span> <span class="hljs-number">20000</span>);<br></code></pre></td></tr></table></figure><h4 id="在INSERT语句中使用"><a href="#在INSERT语句中使用" class="headerlink" title="在INSERT语句中使用"></a>在INSERT语句中使用</h4><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> table_name [ (column1 [, column2 ]) ]<br>   <span class="hljs-keyword">SELECT</span> [ <span class="hljs-operator">*</span><span class="hljs-operator">|</span>column1 [, column2 ] ]<br>   <span class="hljs-keyword">FROM</span> table1 [, table2 ]<br>   [ <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">VALUE</span> OPERATOR ]<br></code></pre></td></tr></table></figure><h5 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h5><p><code>company_bkp</code>要和<code>company</code>表结构相同</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> company_bkp <span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> company  <span class="hljs-keyword">WHERE</span> id <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> id <span class="hljs-keyword">FROM</span> company) ;<br></code></pre></td></tr></table></figure><h4 id="在UPDATE中使用"><a href="#在UPDATE中使用" class="headerlink" title="在UPDATE中使用"></a>在UPDATE中使用</h4><h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> <span class="hljs-keyword">table</span><br><span class="hljs-keyword">SET</span> column_name <span class="hljs-operator">=</span> new_value<br>[ <span class="hljs-keyword">WHERE</span> OPERATOR [ <span class="hljs-keyword">VALUE</span> ]<br>   (<span class="hljs-keyword">SELECT</span> COLUMN_NAME<br>   <span class="hljs-keyword">FROM</span> TABLE_NAME)<br>   [ <span class="hljs-keyword">WHERE</span>) ]<br></code></pre></td></tr></table></figure><h5 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">UPDATE</span> company <span class="hljs-keyword">SET</span> salary <span class="hljs-operator">=</span> salary <span class="hljs-operator">*</span> <span class="hljs-number">0.50</span> <span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> age <span class="hljs-keyword">FROM</span> company_bkp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;=</span> <span class="hljs-number">27</span>);<br></code></pre></td></tr></table></figure><h4 id="在DELETE中使用"><a href="#在DELETE中使用" class="headerlink" title="在DELETE中使用"></a>在DELETE中使用</h4><h5 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> TABLE_NAME<br>[ <span class="hljs-keyword">WHERE</span> OPERATOR [ <span class="hljs-keyword">VALUE</span> ]<br>   (<span class="hljs-keyword">SELECT</span> COLUMN_NAME<br>   <span class="hljs-keyword">FROM</span> TABLE_NAME)<br>   [ <span class="hljs-keyword">WHERE</span>) ]<br></code></pre></td></tr></table></figure><h5 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DELETE</span> <span class="hljs-keyword">FROM</span> company <span class="hljs-keyword">WHERE</span> age <span class="hljs-keyword">IN</span> (<span class="hljs-keyword">SELECT</span> age <span class="hljs-keyword">FROM</span> company_bkp <span class="hljs-keyword">WHERE</span> age <span class="hljs-operator">&gt;</span> <span class="hljs-number">27</span> );<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go的数据类型interface</title>
    <link href="/2021/04/21/Go%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Binterface/"/>
    <url>/2021/04/21/Go%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Binterface/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考：<a href="https://research.swtch.com/interfaces">research!rsc: Go Data Structures: Interfaces</a></p><p><a href="https://blog.csdn.net/yihuliunian/article/details/104784523">怎么理解go的interface</a></p><p><a href="https://blog.csdn.net/justaipanda/article/details/43155949">golang interface</a></p></blockquote><h2 id="概念补充"><a href="#概念补充" class="headerlink" title="概念补充"></a>概念补充</h2><p><code>Go</code>的<code>interface</code>是由两种类型来实现的：<code>iface</code>和 <code>eface</code></p><p><code>iface</code>指的是接口中申明有方法（至少1个），<code>eface</code>表示接口中没有申明方法</p><p>后面会讲到这两个到底是什么，所以这里需要先不用关心。</p><h2 id="深入理解"><a href="#深入理解" class="headerlink" title="深入理解"></a>深入理解</h2><p>下面是一个简单的Demo，Binary实现了fmt.Stringer接口，我们调用<code>ToString()</code>方法，会调用接口的<code>String()</code>方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Binary <span class="hljs-type">uint64</span><br><br><span class="hljs-comment">// 实现String方法，实现fmt.Stringer接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(i Binary)</span></span> String() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> strconv.FormatUint(<span class="hljs-type">uint64</span>(i), <span class="hljs-number">10</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>b := Binary(<span class="hljs-number">200</span>)<br>    <span class="hljs-comment">// var b Binary = Binary(200)</span><br>ToString(b)<span class="hljs-comment">// 02</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ToString</span><span class="hljs-params">(value <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">string</span> &#123;<br>newValue, ok := value.(fmt.Stringer)<br><span class="hljs-keyword">if</span> ok &#123;<br><span class="hljs-keyword">return</span> newValue.String()<br>&#125;<br><span class="hljs-built_in">panic</span>(<span class="hljs-string">&quot;The value  is not implement fmt.Stringer func&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>大致的执行流程图下所示：</p><p>&#x2F;&#x2F;01 执行的是，在内存中开辟一块内存，存放200这个值</p><p><img src="https://www.cmdbyte.com/2021/02/%E6%88%AA%E5%B1%8F2021-04-21%2007.22.44.png" alt="1"></p><p>&#x2F;&#x2F; 02 调用ToString方法，首先方法传递过程中需要隐式将b转换成interface{}类型，实际上做的就是以下：</p><p><img src="https://www.cmdbyte.com/2021/02/%E6%88%AA%E5%B1%8F2021-04-21%2007.23.38.png" alt="2"></p><p>首先大家可能会关心，我就没见过这个结构，你是不是骗人的，其实有这个结构体，是在<code>runtime/runtime2.go</code> 中</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">type</span> <span class="hljs-title class_">eface</span> <span class="hljs-keyword">struct</span> &#123;<br>_<span class="hljs-keyword">type</span> *_<span class="hljs-keyword">type</span> <span class="hljs-comment">// 类型</span><br>data  <span class="hljs-keyword">unsafe</span>.Pointer <span class="hljs-comment">//值</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>那么如何转换的呢？</p><p><code>type</code> 指得是 Binary的类型，包含了Binary类型的所有信息（后面会介绍到）</p><p><code>data</code> 指向的真实数据，由于我们传递的不是指针，所以这种情况下其实是做了一次内存拷贝(<strong>所以也就是尽可能的别使用interface{}</strong>)，data其实存的是拷贝的数据，如果换做是指针，其实也是拷贝了一份指针地址(这也就是reflect.Elem方法的作用)</p><blockquote><p> 以下这几段代码全部来自于 <code>runtime/iface.go</code></p></blockquote><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 关于 unsafe.Pointer，unsafe包学习的时候介绍过</span><br>func <span class="hljs-built_in">convT2E</span>(t *_type, elem unsafe.Pointer) (e eface) &#123;<br><span class="hljs-keyword">if</span> raceenabled &#123;<br><span class="hljs-built_in">raceReadObjectPC</span>(t, elem, <span class="hljs-built_in">getcallerpc</span>(), <span class="hljs-built_in">funcPC</span>(convT2E))<br>&#125;<br><span class="hljs-keyword">if</span> msanenabled &#123;<br><span class="hljs-built_in">msanread</span>(elem, t.size)<br>&#125;<br>  <span class="hljs-comment">// 首先会分配一块内存，内存大小为类型t的大小,下面这段话是mallocgc的介绍</span><br>  <span class="hljs-comment">// Allocate an object of size bytes.</span><br>  <span class="hljs-comment">// Small objects are allocated from the per-P cache&#x27;s free lists.</span><br>  <span class="hljs-comment">// Large objects (&gt; 32 kB) are allocated straight from the heap.</span><br>x := <span class="hljs-built_in">mallocgc</span>(t<span class="hljs-selector-class">.size</span>, t, true)<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> We allocate a zeroed object only to overwrite it with actual data.</span><br><span class="hljs-comment">// Figure out how to avoid zeroing. Also below in convT2Eslice, convT2I, convT2Islice.</span><br>  <span class="hljs-comment">// 将elem拷贝到x </span><br><span class="hljs-built_in">typedmemmove</span>(t, x, elem)<br>  <span class="hljs-comment">// eface 的类型为t，值为x</span><br>e._type = t<br>e<span class="hljs-selector-class">.data</span> = x<br>return<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>&#x2F;&#x2F;3 其次就是到了断言的部分，那么断言到底执行了什么呢？</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// inter 指的是fmt.Stringer接口类型信息</span><br><span class="hljs-comment">// e 就是我们上面的的interface&#123;&#125; 的真实类型eface</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">assertE2I2</span><span class="hljs-params">(inter *interfacetype, e eface)</span></span> (r iface, b <span class="hljs-type">bool</span>) &#123;<br>t := e._type<br><span class="hljs-keyword">if</span> t == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>  <span class="hljs-comment">// 获取tab，其实大家有可能不太理解</span><br>tab := getitab(inter, t, <span class="hljs-literal">true</span>)<br><span class="hljs-keyword">if</span> tab == <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br>r.tab = tab<br>r.data = e.data<br>b = <span class="hljs-literal">true</span><br><span class="hljs-keyword">return</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>那么这里就需要理解什么是 <code>iface</code></p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gauss"><span class="hljs-built_in">type</span> iface <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-built_in">tab</span>  *itab<span class="hljs-comment">//table</span><br>data unsafe.Pointer <span class="hljs-comment">//值</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p><code>tab</code> 又是什么？</p><blockquote><p> tab的意思是table的意思，关于table的概念，大家可以去找找资料</p><p> 具有方法的语言通常属于以下两种阵营之一：为所有方法调用静态地准备表（如在C ++和Java中），或在每次调用时进行方法查找（如在Smalltalk及其许多模仿程序中，包括JavaScript和Python）以及添加奇特的缓存以提高调用效率。Go位于两者的中间：它具有方法表，但在运行时对其进行计算。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> itab <span class="hljs-keyword">struct</span> &#123;<br>inter *interfacetype<span class="hljs-comment">// 接口类型,这里就是Stringer</span><br>_type *_type<span class="hljs-comment">// 值类型,这里就是Binary</span><br>hash  <span class="hljs-type">uint32</span> <span class="hljs-comment">// copy of _type.hash. Used for type switches.</span><br>_     [<span class="hljs-number">4</span>]<span class="hljs-type">byte</span><br>fun   [<span class="hljs-number">1</span>]<span class="hljs-type">uintptr</span> <span class="hljs-comment">// variable sized. fun[0]==0 means _type does not implement inter.</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>其实上面这段代码的流程如下：</p><p>data就是 eface.data</p><p><code>tab</code>其实就是 : <code>inter</code> 指的是接口类型(也就是fmt.Stringer接口)，<code>type</code>是Binary类型，<code>fun[0]</code>是(Binary)String方法 ，其他几个先不用care</p><p><img src="https://static.studygolang.com/200620/7560d94fd55ff8286bf552e69f43464b.png" alt="image-20200619132703793"></p><p>&#x2F;&#x2F;4 <code>newValue.String()</code>到底做了啥，其实根据上面我们很容易知道，无法就是<code>newValue.tab.fun[0].(newValue.data)</code> ，所以就是这么简单。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、go的 interface{} 转换过程中至少做一次内存拷贝，所以传递指针是最好的选择。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>Age  <span class="hljs-type">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-keyword">var</span> empty <span class="hljs-keyword">interface</span>&#123;&#125; = User&#123;&#125; <span class="hljs-comment">//这里会拷贝一次，将user转换成interface&#123;&#125;，所以函数传递过程中也别直接使用结构体传递</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>正确写法</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">func <span class="hljs-title">main</span>()</span> &#123;<br><span class="hljs-keyword">var</span> empty <span class="hljs-keyword">interface</span>&#123;&#125; = &amp;User&#123;&#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>2、有人会问到字符串传递是否内存拷贝，回答否，因为字符串底层是一个<code>byte[]</code> 数组，他的结构组成是</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> StringHeader <span class="hljs-keyword">struct</span> &#123;<br>Data <span class="hljs-type">uintptr</span> <span class="hljs-comment">//数据，是一个二进制数组</span><br>Len  <span class="hljs-type">int</span><span class="hljs-comment">// 长度</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure><p>所以64位计算机，字符串的长度是128位，占用16个字节</p><p>3、减少使用<code>interface&#123;&#125;</code> ，因为会有不必要的开销，其次Golang本身是一个强类型语言，静态语言，申明式是最好的方式。</p><p>4、<code>interface&#123;&#125;</code>是反射的核心，后期我会讲解反射</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git的描述信息</title>
    <link href="/2021/04/20/Tools/Git/Git%E7%9A%84commit%E6%8F%8F%E8%BF%B0%E4%BF%A1%E6%81%AF/"/>
    <url>/2021/04/20/Tools/Git/Git%E7%9A%84commit%E6%8F%8F%E8%BF%B0%E4%BF%A1%E6%81%AF/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来源于：<a href="https://mp.weixin.qq.com/s/vYQcG8yzHjZiuazqOPpFsA">80%的程序员，不会写commit记录！</a></p></blockquote><blockquote><p>据说，80%的程序员，不会写commit记录。这个比例在无规范的小公司，比例会更高一些，可以看到这是一个多么普遍的问题。</p></blockquote><p>程序员应该写出简洁明了的<code>commit log</code>，否则对别人和自己来说就是一种困扰。最近代码review多了，总有一股想笑的感觉。就像下图这满屏的ok，永远无法从中得知提交人的意图。</p><p><img src="https://www.cmdbyte.com/2021/02/commit_1.png" alt="commit_1"></p><p><code>commit log</code>将如何提交？都有哪些约定？其实是有答案的。对于Java程序员，尤其幸福。IDEA有一个非常好用的插件，可以用来辅助你进行代码提交，辅助你进行团队规范建设。接下来，我将带大家看一看它的使用方法。</p><h2 id="安装插件"><a href="#安装插件" class="headerlink" title="安装插件"></a>安装插件</h2><p>在IDEA的<code>Marketplace</code>中，搜索<code>Git Commit Template</code>，就可以安装这个插件。插件很小，很快就能下载下来。</p><p><img src="https://www.cmdbyte.com/2021/02/commit_2.webp" alt="commit_2"></p><p>正常从IDEA提交代码的时候。我们发现多了一个小按钮。</p><p><img src="https://www.cmdbyte.com/2021/02/commit_3.webp" alt="commit_3"></p><p>点击之后，将弹出一个窗口。让你去设计提交模板。</p><p><img src="https://www.cmdbyte.com/2021/02/commit_4.webp" alt="commit_4"></p><p>这么多信息，真的让人头晕。怪不得程序员们都不喜欢写提交记录。</p><p>其实，在插件的安装界面，就已经说明了这个提交记录的格式。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tex">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;<br>&lt;BLANK LINE&gt;<br>&lt;body&gt;<br>&lt;BLANK LINE&gt;<br>&lt;footer&gt;<br></code></pre></td></tr></table></figure><p>从描述中，可以肯容易的看到一个提交记录中，应该包含哪些东西。其中类型最多的，当然是提交类型。</p><h2 id="提交类型Type"><a href="#提交类型Type" class="headerlink" title="提交类型Type"></a>提交类型Type</h2><p>我们按照插件显示的顺序来说明一下。</p><ul><li><code>feat</code> 功能<code>feature</code>的意思，也是最常用的。当你的功能有变更的时候，都可以采用这种类型的type</li><li><code>fix</code> 当然指的是bug修复</li><li><code>docs</code> 更新了文档，或者更新了注释</li><li><code>style</code> 代码格式调整，比如执行了format、更改了tab显示等</li><li><code>refactor</code> 重构代码。指的是代码结构的调整，比如使用了一些设计模式重新组织了代码</li><li><code>perf</code> 对项目或者模块进行了性能优化。比如一些jvm的参数改动，把stringbuffer改为stringbuilder等</li><li><code>test</code> 这个简单，就是增加了单元测试和自动化相关的代码</li><li><code>build</code> 影响编译的一些更改，比如更改了maven插件、增加了npm的过程等</li><li><code>ci</code> 持续集成方面的更改。现在有些build系统喜欢把ci功能使用yml描述。如有这种更改，建议使用ci</li><li><code>chore</code> 其他改动。比如一些注释修改或者文件清理。不影响src和test代码文件的，都可以放在这里</li><li><code>revert</code> 回滚了一些前面的代码</li></ul><p>除了这些预设的，团队还可以按照自己的需求，增加新的<code>type</code>。比如专门处理线上工单，就可以创造一个叫做<code>ticket</code>的类型。</p><h2 id="范围scope"><a href="#范围scope" class="headerlink" title="范围scope"></a>范围scope</h2><p>scope是范围的意思，主要指的是代码的影响面。scope并没有要求强制，但团队可以按照自己的理解进行设计。通常由技术维度和业务维度两种划分方式。比如按照技术分为：<code>controller</code>、<code>dto</code>、<code>service</code>、<code>dao</code>等。但因为一个功能提交，会涉及到多个scope（都不喜欢非常细粒度的提交），所以按照技术维度分的情况比较少。</p><p>按照业务模块进行划分，也是比较不错的选择。比如分为<code>user</code>、<code>order</code>等划分，可以很容易看出是影响用户模块还是order模块。</p><p>如果你实在不知道怎么填，那就留空。</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="主题subject"><a href="#主题subject" class="headerlink" title="主题subject"></a>主题subject</h3><p>这个体现的是总结概括能力，没得跑。一句话能够说明主要的提交是什么。subject也是众多git管理工具默认显示的一行。如果你写的标准，那么提交记录看起来就很漂亮很规整。</p><h3 id="正文Body"><a href="#正文Body" class="headerlink" title="正文Body"></a>正文Body</h3><p>主要填写详细的改动记录。我一般习惯列上1234，但如果你的subject写的非常好，正文可以直接弱化。但如果时间充裕，填写上重要记录的前因后果，需求背景，是一个好的习惯。</p><h3 id="尾部Footer"><a href="#尾部Footer" class="headerlink" title="尾部Footer"></a>尾部Footer</h3><p>添加一些额外的hook，比如提交记录之后，自动关闭jira的工单（JIRA和gitlab等是可以联动的）。在比如触发一些文档编译或者其他动作。</p><p>这部分自定义行也是比较强的。</p><h3 id="Skip-CI"><a href="#Skip-CI" class="headerlink" title="Skip CI"></a>Skip CI</h3><p>最后还有一个skip CI选项。一般的ci工具，都可以设置提交代码时自动触发编译。但你可以告诉它忽略本次提交。这可能是因为你提前预判到了一些构建风险，或者就是不想编译。</p><h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>最后，看一个典型的提交记录，有了工具的支持，我们的瞎扯也看得正经起来。</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs tex">fix(order): 修复了1分钱买汽车的bug<br><br>商务反馈可以1分钱买汽车，目前已经卖出了100w量<br><br>Closes <span class="hljs-params">#2</span>455<br><br>[skip ci]<br></code></pre></td></tr></table></figure><p>其实，提交的核心是<code>type</code>和<code>subject</code>。一个用来表示它的提交类型，一个用来对提交进行概括性总结，写好了这两点，就能轻轻松松秒杀80%的程序员了。</p><p>有了这些基础，从<code>commit log</code>，自动生成<code>change log</code>，就变的非常的容易。配合持续集成平台，自动生成发版的变更记录，也是可行的，这也是为什么团队管理，都在一直强调git的提交规范。因为它确实非常有用。</p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用sshfs挂载服务器目录</title>
    <link href="/2021/04/20/%E4%BD%BF%E7%94%A8sshfs%E6%8C%82%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%AE%E5%BD%95/"/>
    <url>/2021/04/20/%E4%BD%BF%E7%94%A8sshfs%E6%8C%82%E8%BD%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9B%AE%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>因为我的开发环境是<code>Mac</code>和<code>Ubuntu</code>，所以有时候传输文件的时候，都是用的<code>scp</code>，但用<code>scp</code>传输文件的意图太明显了，我想让传输变得就像在本地移动文件一样，更加的自然，于是就有了本文。</p><p>我做的是把<code>Ubuntu</code>的工作目录放到了我的<code>Mac</code>上，用的工具就是<code>sshfs</code>，操作很简单，这里简单介绍一下安装和简单的使用。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>你想在哪台电脑上访问远程目录，你就在哪台电脑上安装。我这里是在<code>Mac</code>上进行安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">首先安装一个插件</span><br>brew install Caskroom/cask/osxfuse<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装sshfs</span><br>brew install sshfs<br></code></pre></td></tr></table></figure><h3 id="挂载"><a href="#挂载" class="headerlink" title="挂载"></a>挂载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">sshfs -C -o reconnect user@hostname:remote_dir local_dir<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">user与hostname和ssh命令的一样</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">remote_dir 你要挂载服务器文件夹路径</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">local_dir 你本地要和服务器文件夹建立关系的文件夹，最好新建一个空的</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">挂在完成后，可以使用mount命令查看挂载的目录</span><br>mount<br></code></pre></td></tr></table></figure><h3 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h3><p>当我们的 mac 网络断开或者休眠或重启, 回来时发现挂载的失败了, 进入目录会提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$ls</span> local_dir <br><span class="hljs-built_in">ls</span>: local_dir: Input/output error<br></code></pre></td></tr></table></figure><p>如果我们想取消挂载, 又会提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-variable">$umount</span> local_dir<br>umount: local_dir: not currently mounted<br></code></pre></td></tr></table></figure><p>这个时候, 我们不得不关闭进程了, 可以先通过命令查看进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">pgrep -lf sshfs<br></code></pre></td></tr></table></figure><p>然后杀掉相应的挂载进程, 或者直接杀掉所有挂载进程</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs undefined">pkill -9 sshfs <br></code></pre></td></tr></table></figure><p>之后重新挂载响应的目录即可</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>sshfs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB创建用户时角色指定问题</title>
    <link href="/2021/04/20/MongoDB%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E6%97%B6%E8%A7%92%E8%89%B2%E6%8C%87%E5%AE%9A%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/20/MongoDB%E5%88%9B%E5%BB%BA%E7%94%A8%E6%88%B7%E6%97%B6%E8%A7%92%E8%89%B2%E6%8C%87%E5%AE%9A%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p><code>MongoDB</code>是基于角色来分配用户权限的。</p><p>现在又这样一个场景，我要在<code>MongoDB</code>里为一个数据库创建一个用户，并让这个用户对于这个数据库有读写权限。于是就有了下面的语句。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 选择数据库，如果数据库不存在就创建<br>use mo<br><br># 为mo数据库创建用户mofan,并分配读写权限<br>db.createUser(&#123;<span class="hljs-keyword">user</span>:&quot;mofan&quot;, pwd:&quot;nihao&quot;, roles[&#123;role:&quot;readWrite&quot;, db:&quot;mo&quot;&#125;]&#125;)<br><br># 如果是新创建的数据库，为了让其可见，要插入条记录<br>db.mo.insert(&#123;&quot;a&quot;:&quot;b&quot;&#125;)<br></code></pre></td></tr></table></figure><p>在分配角色的时候，有些角色只能在<code>admin</code>数据库里使用，所以，都有什么角色，这些角色又是对谁用的呢？</p><h3 id="MongoDB提供的角色有下面这几种"><a href="#MongoDB提供的角色有下面这几种" class="headerlink" title="MongoDB提供的角色有下面这几种"></a>MongoDB提供的角色有下面这几种</h3><ul><li>数据库用户角色：read、readWrite;</li><li>数据库管理角色：dbAdmin、dbOwner、userAdmin；</li><li>集群管理角色：clusterAdmin、clusterManager、clusterMonitor、hostManager；</li><li>备份恢复角色：backup、restore；</li><li>所有数据库角色：readAnyDatabase、readWriteAnyDatabase、userAdminAnyDatabase、dbAdminAnyDatabase</li><li>超级用户角色：root ，这里还有几个角色间接或直接提供了系统超级用户的访问（dbOwner 、userAdmin、userAdminAnyDatabase）</li><li>内部角色：__system</li></ul><h3 id="对于常用角色的一些描述"><a href="#对于常用角色的一些描述" class="headerlink" title="对于常用角色的一些描述"></a>对于常用角色的一些描述</h3><ul><li>Read：允许用户读取指定数据库</li><li>readWrite：允许用户读写指定数据库</li><li>dbAdmin：允许用户在指定数据库中执行管理函数，如索引创建、删除，查看统计或访问system.profile</li><li>userAdmin：允许用户向system.users集合写入，可以找指定数据库里创建、删除和管理用户</li><li>clusterAdmin：只在admin数据库中可用，赋予用户所有分片和复制集相关函数的管理权限。</li><li>readAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读权限</li><li>readWriteAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的读写权限</li><li>userAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的userAdmin权限</li><li>dbAdminAnyDatabase：只在admin数据库中可用，赋予用户所有数据库的dbAdmin权限。</li><li>root：只在admin数据库中可用。超级账号，超级权限。</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MongoDB</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>今日头条技术架构分析</title>
    <link href="/2021/04/20/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/"/>
    <url>/2021/04/20/%E4%BB%8A%E6%97%A5%E5%A4%B4%E6%9D%A1%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<blockquote><p>文章来源：<a href="https://mp.weixin.qq.com/s/5p5saNiKRrGNsajVq_QY0Q">今日头条技术架构分析，看这篇就对了！</a></p></blockquote><p>今日头条创立于2012年3月，到目前仅几年时间。从十几个工程师开始研发，到上百人，再到200余人。产品线由内涵段子，到今日头条，今日特卖，今日电影等产品线。</p><h2 id="一、产品背景"><a href="#一、产品背景" class="headerlink" title="一、产品背景"></a>一、产品背景</h2><p>今日头条是为用户提供个性化资讯客户端。下面就和大家分享一下当前今日头条的数据（据内部与公开数据综合）：</p><p><strong>5****亿注册用户</strong></p><p>2014年5月1.5亿，2015年5月3亿，2016年5月份为5亿。几乎为成倍增长。</p><p><strong>日活4800万用户</strong></p><p>2014年为1000万日活，2015年为3000万日活。</p><p><strong>日均5亿PV</strong></p><p>5亿文章浏览，视频为1亿。页面请求量超过30亿次。</p><p>用户停留时长超过65分钟以上</p><h3 id="1、文章抓取与分析"><a href="#1、文章抓取与分析" class="headerlink" title="1、文章抓取与分析"></a><strong>1、文章抓取与分析</strong></h3><p>我们日常产生原创新闻在1万篇左右，包括各大新闻网站和地方站，另外还有一些小说，博客等文章。这些对于工程师来讲，写个Crawler并非困难的事。</p><p>接下来，今日头条会用人工方式对敏感文章进行审核过滤。此外，今日头条头条号目前也有为数不少的原创文章加入到了内容遴选队列中。</p><p>接下来我们会对文章进行文本分析，比如分类，标签、主题抽取，按文章或新闻所在地区，热度，权重等计算。</p><h3 id="2、用户建模"><a href="#2、用户建模" class="headerlink" title="2、用户建模"></a><strong>2、用户建模</strong></h3><p>当用户开始使用今日头条后，对用户动作的日志进行实时分析。使用的工具如下：</p><p>- Scribe</p><p>- Flume</p><p>- Kafka</p><p>我们对用户的兴趣进行挖掘，会对用户的每个动作进行学习。主要使用：</p><p>- Hadoop</p><p>- Storm</p><p>产生的用户模型数据和大部分架构一样，保存在MySQL&#x2F;MongoDB（读写分离）以及Memcache&#x2F;Redis中。</p><p>随着用户量的不断扩展大，用户模型处理的机器集群数量较大。2015年前为7000台左右。其中，用户推荐模型包括以下维度：</p><p>1 用户订阅</p><p>2 标签</p><p>3 部分文章打散推送</p><p>此时，需要每时每刻做推荐。</p><h3 id="3、新用户的“冷启动”"><a href="#3、新用户的“冷启动”" class="headerlink" title="3、新用户的“冷启动”"></a><strong>3、新用户的“冷启动”</strong></h3><p>今日头条会通过用户使用的手机，操作系统，版本等“识别”。另外，比如用户通过社交帐号登录，如新浪微博，头条会对其好友，粉丝，微博内容及转发、评论等维度进行对用户做初步“画像”。</p><p>分析用户的主要参数如下：</p><p>- 关注、粉丝关系</p><p>- 关系</p><p>- 用户标签</p><p>除了手机硬件，今日头条还会对用户安装的APP进行分析。例如机型和APP结合分析，用小米，用三星的和用苹果的不同，另外还有用户浏览器的书签。头条会实时捕捉用户对APP频道的动作。另外还包括用户订阅的频道，比如电影，段子，商品等。</p><h3 id="4、推荐系统"><a href="#4、推荐系统" class="headerlink" title="4、推荐系统"></a><strong>4、推荐系统</strong></h3><p>推荐系统，也称推荐引擎。它是今日头条技术架构的核心部分。包括自动推荐与半自动推荐系统两种类型：</p><p>1 自动推荐系统</p><p>-  自动候选</p><p>-  自动匹配用户，如用户地址定位，抽取用户信息</p><p>-  自动生成推送任务</p><p>这时需要高效率，大并发的推送系统，上亿的用户都要收到。</p><p>2 半自动推荐系统</p><p>-  自动选择候选文章</p><p>-  根据用户站内外动作</p><p>头条的频道，在技术侧划分的包括分类频道、兴趣标签频道、关键词频道、文本分析等，这些都分成相对独立的开发团队。目前已经有300+个分类器，仍在不断增加新的用户模型，原来的用户模型不用撤消，仍然发挥作用。</p><p>在还没有推出头条号时，内容主要是抓取其它平台的文章，然后去重，一年几百万级，并不太大。主要是用户动作日志收集，兴趣收集，用户模型收集。</p><p>资讯App的技术指标，比如屏幕滑动，用户是不是对一篇都看完，停留时间等都需要我们特别关注</p><img src="https://www.cmdbyte.com/2021/02/640.webp" alt="640" style="zoom:67%;" /><h3 id="5、数据存储"><a href="#5、数据存储" class="headerlink" title="5、数据存储"></a><strong>5、数据存储</strong></h3><p>今日头条使用MySQL或Mongo持久化存储+Memched（Redis），分了很多库（一个大内存库），亦尝试使用了SSD的产品。</p><p>搜索公众号后端架构师后台回复“架构整洁”，获取一份惊喜礼包。</p><p>今日头条的图片存储，直接放在数据库中，分布式保存文件，读取的时候采用CDN。</p><h3 id="6、消息推送"><a href="#6、消息推送" class="headerlink" title="6、消息推送"></a><strong>6、消息推送</strong></h3><p>消息推送，对于用户: 及时获取信息。对运营来讲，能够 提⾼⽤用户活跃度。比如在今日头条推送后能够提升20%左右的DAU，如果没有推送，会影响10%左右 DAU（2015年数据）。</p><p>推送后要关注的ROI：点击率，点击量。能够监测到App卸载和推送禁用数量。</p><p>今日头条推送的主要内容包括突发与热点咨讯，有人评论回复，站外好友注册加入。</p><p>在头条，推送也是个性化：</p><p>-  频率个性化</p><p>-  内容个性化</p><p>-  地域</p><p>-  兴趣</p><p>比如：</p><p>按照城市：辽宁朝阳发生的某个新闻事件，发给朝阳本地的用户。</p><p>按照兴趣：比如京东收购一号店，发给互联网兴趣的用户。</p><p>推送平台的工具和选择，需要具备如下的标准：</p><p>-  通道，首先速度要快，但是要可控，可靠，并且节省资源</p><p>-  推送的速度要快，有不同维度的策略支持，可跟踪，开发接口要友好</p><p>-  推送运营的后台，反馈也要快，包括时效性，热度，工具操作方便</p><p>-  对于运营侧，清晰是否确定推荐，包括推送的文案处理</p><p>因此，推送后台应该提供日报，完整的数据后台，提供A&#x2F;B Test方案支持。</p><p>推送系统一部分使用自有IDC，在发送量特别大，消耗带宽较严重。可以使用类似阿里云的服务，可有效节省成本。</p><h2 id="二、今日头条系统架构"><a href="#二、今日头条系统架构" class="headerlink" title="二、今日头条系统架构"></a>二、今日头条系统架构</h2><p><img src="https://www.cmdbyte.com/2021/02/640%20(1).webp" alt="系统架构"></p><p><img src="https://www.cmdbyte.com/2021/02/640%20(2).webp" alt="流式计算"></p><p><img src="https://www.cmdbyte.com/2021/02/640%20(3).webp" alt="在线存储-abase_1"></p><p><img src="https://www.cmdbyte.com/2021/02/640%20(4).webp" alt="在线存储-abase_2"></p><h2 id="三、头条微服务架构"><a href="#三、头条微服务架构" class="headerlink" title="三、头条微服务架构"></a>三、头条微服务架构</h2><p>今日头条通过拆分子系统，大的应用拆成小应用，抽象通用层做代码复用。</p><p><img src="https://www.cmdbyte.com/2021/02/640%20(5).webp" alt="微服务架构"></p><p>系统的分层比较典型。重点在基础设施，希望通过基础设施提高快速迭代、容灾和一系列的工作，希望各个业务团队能更快做业务上的迭代以及架构上的调整。</p><h2 id="四、今日头条的虚拟化PaaS平台规划"><a href="#四、今日头条的虚拟化PaaS平台规划" class="headerlink" title="四、今日头条的虚拟化PaaS平台规划"></a>四、今日头条的虚拟化PaaS平台规划</h2><p>通过三层实现，通过 PaaS 平台统一管理。提供通用 SaaS 服务，同时提供通用的 App 执行引擎。最底层是 IaaS 层。</p><p><img src="https://www.cmdbyte.com/2021/02/640%20(6).webp" alt="虚拟化PaaS平台规划"></p><p>IaaS 管理所有的机器，把公有云整合起来，头条有一些热点事件会全国推广推送，对网络带宽比较高，我们借助公有云，需要哪一种类型计算资源，统一抽象起来。基础设施结合服务化的思路，比如日志，监控等等功能，业务不需要关注细节就可以享受到基础设施提供的能力。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p><strong>今日头条重要的部分在于</strong>：</p><ul><li>数据生成与采集</li><li>数据传输。Kafka做消息总线连接在线和离线系统。</li><li>数据入库。数据仓库、ETL（抽取转换加载）</li><li>数据计算。数据仓库中的数据表如何能被高效的查询很关键，因为这会直接关系到数据分析的效率。常见的查询引擎可以归到三个模式中，Batch 类、MPP 类、Cube 类，头条在 3 种模式上都有所应用。</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于Go的package一些总结</title>
    <link href="/2021/04/19/%E5%85%B3%E4%BA%8EGo%E7%9A%84package%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/"/>
    <url>/2021/04/19/%E5%85%B3%E4%BA%8EGo%E7%9A%84package%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考: <a href="https://zhuanlan.zhihu.com/p/239820433">Go 语言中你应该知道的关于 Package 的所有 - 知乎</a></p></blockquote><h3 id="package的基本认识"><a href="#package的基本认识" class="headerlink" title="package的基本认识"></a>package的基本认识</h3><p>相比于<code>Java</code>而言，<code>Go</code>的包并不算一个新鲜的概念。</p><p><code>Go</code>中的<code>package</code>可以简单理解为一个文件夹的名字，但是它又可以和文件夹不同名，但是，在一个文件夹下，只能存在一个同名包，就算这个文件夹下有一个子文件夹，包名也不能和它上一级文件夹下的包名相同。</p><p>比如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">are<br>|<br>|___package you<br>|<br>|___ok<br>|<br>|___package me<br></code></pre></td></tr></table></figure><p><code>pakcage me</code>和<code>package you</code> 不能同名，同时<code>me</code>也称为<code>you</code>的嵌套包。</p><h3 id="包内变量或函数的对外可见性"><a href="#包内变量或函数的对外可见性" class="headerlink" title="包内变量或函数的对外可见性"></a>包内变量或函数的对外可见性</h3><p>对外可见性指的是一个包内的变量或者方法能不能被其他的包<code>import</code>，<code>Go</code>没有像<code>Java</code>那样使用关键字来对变量或方法的可见性进行约束，而是巧妙的利用了首字母大小写来作区分：<code>首字母大写的变量名或者方法名是对其他包可见的，否则即不可见；首字母小写的变量名或者方法名在同包内可见。</code></p><h3 id="包的命名规范"><a href="#包的命名规范" class="headerlink" title="包的命名规范"></a>包的命名规范</h3><p><code>Go</code>是一门以简洁著称语言，简洁也是它的设计原则，所以，<code>Go</code>官方也鼓励使用简洁的包命名，最好包名全部使用小写而且包名足够简短。尽量避免使用类似<code>under_scores</code>， <code>hy-phens</code>， <code>mixedCaps</code>等形式的命名。</p><h3 id="包的编译"><a href="#包的编译" class="headerlink" title="包的编译"></a>包的编译</h3><h3 id="Init函数"><a href="#Init函数" class="headerlink" title="Init函数"></a>Init函数</h3><h3 id="包的别名"><a href="#包的别名" class="headerlink" title="包的别名"></a>包的别名</h3><h3 id="import多个包时，包的执行顺序"><a href="#import多个包时，包的执行顺序" class="headerlink" title="import多个包时，包的执行顺序"></a>import多个包时，包的执行顺序</h3><h3 id="安装第三方包"><a href="#安装第三方包" class="headerlink" title="安装第三方包"></a>安装第三方包</h3>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git blame用法</title>
    <link href="/2021/04/19/Tools/Git/git-blame%E7%94%A8%E6%B3%95/"/>
    <url>/2021/04/19/Tools/Git/git-blame%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>在使用<code>Git</code>作为代码的版本控制系统时，有时候想查看下这行代码是谁写的或者谁修改的，可以使用<code>git blame</code>命令。</p><p>其具体用法为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">从文件第一行开始查看</span><br>git blame 文件名<br><span class="hljs-meta prompt_"># </span><span class="language-bash">指定行的范围查看,比如查看10-30行的代码</span><br>git blame 10,30 文件名<br></code></pre></td></tr></table></figure><p>通过<code>Enter</code>进行换行，通过<code>Q</code>退出查看。</p><p>该命令的输出格式为:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">commit_ID | 代码提交作者 | 提交时间 | 代码位于文件中的行数 | 实际代码 <br></code></pre></td></tr></table></figure><p>知道<code>commit_ID</code>后，可以使用命令<code>git show commit_ID</code>查看具体的改动情况。</p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL删除正在使用的数据库</title>
    <link href="/2021/04/19/PostgreSQL%E5%88%A0%E9%99%A4%E6%AD%A3%E5%9C%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>/2021/04/19/PostgreSQL%E5%88%A0%E9%99%A4%E6%AD%A3%E5%9C%A8%E4%BD%BF%E7%94%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<p>当我在卸载<code>PostgreSQL</code>的一个数据库时，提示这个数据库正在被使用，不能被卸载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">=&gt;drop database db;<br>ERROR:  database &quot;db&quot; is being accessed by other users<br>DETAIL:  There is 1 other session using the database.<br></code></pre></td></tr></table></figure><p>然后到网上查了下有没有强制删除的方法，主要方法如下：首先禁止会话再连入数据库中，然后断掉当前的所有的连接，然后卸载就行了。</p><p><strong>1.禁止会话连入</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">update</span> pg_database <span class="hljs-keyword">set</span> datallowconn <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;false&#x27;</span> <span class="hljs-keyword">where</span> datname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;db_name&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>2.中断当前数据库的所有连接</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">select</span> pg_terminate_backend(pid) <span class="hljs-keyword">from</span> pg_stat_activity <span class="hljs-keyword">where</span> datname <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;db&#x27;</span>;<br></code></pre></td></tr></table></figure><p><strong>3.删除数据库</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">drop</span> database db;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL数据类型varchar与text的区别</title>
    <link href="/2021/04/15/PostgreSQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bvarchar%E4%B8%8Etext%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/04/15/PostgreSQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8Bvarchar%E4%B8%8Etext%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>有兴趣的可以读一下官方文档：<a href="https://www.postgresql.org/docs/8.0/datatype-character.html">PostgreSQL: Documentation: 8.0: Character Types</a></p><p>下面是它们各自的描述：</p><table><thead><tr><th align="left">名字</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>varchar(n)</code></td><td align="left">变长，有长度限制</td></tr><tr><td align="left"><code>char(n)</code></td><td align="left">定长，不足补空白</td></tr><tr><td align="left"><code>text</code></td><td align="left">变长，无长度限制</td></tr></tbody></table><p><code>char</code>没什么好说的，它是定长的，如果你指定了长度为10，实际存入字符长度为5，那么会用空格在后面补齐，但是在比较的时候，又会自动把空格去掉。</p><p><code>text</code>与<code>varchar</code>，不会自动添加空格，但是它们中包含的空格会在比较时计算在内。</p><p><code>text</code>与<code>varchar</code>二者是没有区别的，在引擎盖下它是全部<code>varlena</code>（<a href="http://www.varlena.com/varlena.php">可变长度数组</a>）。</p><p>另外如果有兴趣，也可以查看Depesz的这篇文章：<a href="https://www.depesz.com/2010/03/02/charx-vs-varcharx-vs-varchar-vs-text/">CHAR(x) vs. VARCHAR(x) vs. VARCHAR vs. TEXT</a>，这里对它们做了详细的测试，以显示所有4种数据类型的插入和选择的性能是相似的。它还详细介绍了在需要时限制长度的其他方法。基于函数的约束或域提供了即时增加长度约束的优点，并且基于减少字符串长度约束很少，depesz得出结论，其中一个通常是长度限制的最佳选择。</p><p>关于这次测试的几个注意点：</p><blockquote><ul><li>char（n） - 处理短于<code>n</code>（填充它们<code>n</code>）的值时占用太多空间，并且由于添加尾随空格可能导致细微错误，此外更改限制也有问题</li><li>varchar（n） - 更改实时环境中的限制是有问题的（在更改表时需要独占锁定）</li><li>varchar - 就像文本一样</li><li><strong>文本 - 对我来说是胜利者</strong> - 超过（n）数据类型，因为它没有问题，而且超过varchar - 因为它有不同的名称</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go时间包避坑指南</title>
    <link href="/2021/04/15/Go%E6%97%B6%E9%97%B4%E5%8C%85%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/"/>
    <url>/2021/04/15/Go%E6%97%B6%E9%97%B4%E5%8C%85%E9%81%BF%E5%9D%91%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<p>首先看一段代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>st := <span class="hljs-string">&quot;2019-11-21 11:59:01&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, st)<br>t, _ := time.Parse(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>, st)<br>fmt.Println(t.Unix())<br><br>tt := time.Unix(t.Unix(), <span class="hljs-number">0</span>)<br>fmt.Println(tt.Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码的任务很简单，就是将字符串格式的时间转化为时间戳。<br>但是直到调试我才无意发现，这个是有问题的，转化后的unix并不是原来的时间。。<br>运行结果如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">2019-11-21 11:59:01<br>1574337541<br>2019-11-21 19:59:01<br></code></pre></td></tr></table></figure><p>时间总是会多了8个小时，让我联想到了我们的东8区，估计和时区有关系。</p><p>看了下time.Parse的解释：</p><p>其中的一句：</p><p><code>In the absence of a time zone indicator, Parse returns a time in UTC.</code></p><p>翻译如下：</p><p>在没有时区指示符的情况下，Parse以UTC返回时间。</p><blockquote><p>UTC是什么？<br>整个地球分为二十四时区，每个时区都有自己的本地时间。在国际无线电通信场合，为了统一起见，使用一个统一的时间，称为通用协调时(UTC, Universal Time Coordinated)。UTC与格林尼治平均时(GMT, Greenwich Mean Time)一样，都与英国伦敦的本地时相同。北京时区是东八区，领先UTC八个小时。</p><p>UTC + 时区差 ＝ 本地时间<br>所以，前面的问题就是因为没有指定位置符，导致按照UTC时间进行转化的时间戳，错误的多了8个小时，然后使用time.Unix方法按照本地的时间创建Time对象，再次format时就会按照本地时区进行打印，导致时间多了8小时，直接给他减去8小时就好了，当然这样肯定不优雅，golang时间包time已经封装了对应的方法：<code>ParseInLocation</code></p></blockquote><p>使用以下的方式就可以正确的转化时间了：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> LOC, _ = time.LoadLocation(<span class="hljs-string">&quot;Asia/Shanghai&quot;</span>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>st := <span class="hljs-string">&quot;2019-11-21 11:59:01&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, st)<br>t, _ := time.ParseInLocation(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>, st, LOC)<br>fmt.Println(t.Unix())<br><br>tt := time.Unix(t.Unix(), <span class="hljs-number">0</span>)<br>fmt.Println(tt.Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>))<br>&#125;<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">2019-11-21 11:59:01<br>1574308741<br>2019-11-21 11:59:01<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang中常用的类型转换方法</title>
    <link href="/2021/04/15/Golang%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/"/>
    <url>/2021/04/15/Golang%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>这里只对一些开发中常用的转换做一个记录，以备查询。</p><h3 id="string-和-int-相互转换"><a href="#string-和-int-相互转换" class="headerlink" title="string 和 int 相互转换"></a>string 和 int 相互转换</h3><h4 id="string-转-int"><a href="#string-转-int" class="headerlink" title="string 转 int"></a>string 转 int</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-type">int</span>, err := strconv.Atoi(<span class="hljs-type">string</span>)<br></code></pre></td></tr></table></figure><h4 id="string-转-int64"><a href="#string-转-int64" class="headerlink" title="string 转 int64"></a>string 转 int64</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-type">int64</span>, err := strconv.ParseInt(<span class="hljs-type">string</span>, <span class="hljs-number">10</span>, <span class="hljs-number">64</span>)<br></code></pre></td></tr></table></figure><h4 id="int-转-string"><a href="#int-转-string" class="headerlink" title="int 转 string"></a>int 转 string</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-type">string</span> := strconv.Itoa(<span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><h4 id="int64-转-string"><a href="#int64-转-string" class="headerlink" title="int64 转 string"></a>int64 转 string</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-type">string</span> := strconv.FormatInt(<span class="hljs-type">int64</span>,<span class="hljs-number">10</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL的comment注释问题</title>
    <link href="/2021/04/15/PostgreSQL%E7%9A%84comment%E6%B3%A8%E9%87%8A%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/15/PostgreSQL%E7%9A%84comment%E6%B3%A8%E9%87%8A%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>由<code>MySQL</code>到<code>PostgreSQL</code>，会带来很多使用<code>MySQL</code>的习惯。</p><p>今天在使用<code>GORM</code>框架创建一个表的时候，我在使用<code>GORM</code>的<code>Tag</code>为字段添加了<code>comment</code>，想着这样就不用加在代码里加注释了，这在<code>MySQL</code> 中属于基操。</p><p>然后在运行代码生成表结构的时候总是提示在<code>COMMENT</code>处存在错误，也并不说不支持，由于对<code>GORM</code>不是很熟悉，让我一度以为是我写的不对，于是翻阅官方文档，<code>GitHub</code>的<code>Issuses</code>，最终发现是<code>PostgreSQL</code>不支持在创建表的时候直接加<code>comment</code>，我真是。。。</p><p>当然，虽然不能在创建表的时候加<code>comment</code>，但是可以在创建后加。</p><p><strong>给表添加注释：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">comment <span class="hljs-keyword">on</span> <span class="hljs-keyword">table</span> mofan <span class="hljs-keyword">is</span> <span class="hljs-string">&#x27;莫凡&#x27;</span>;<br></code></pre></td></tr></table></figure><p>这里是在给<code>mofan</code>表添加注释。</p><p><strong>给字段添加注释：</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">comment <span class="hljs-keyword">on</span> <span class="hljs-keyword">column</span> mofan.name <span class="hljs-keyword">is</span> &quot;My Name&quot;<br></code></pre></td></tr></table></figure><p>这里是给<code>mofan</code>表的<code>name</code>字段添加注释。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JetBrains系列工具的使用技巧</title>
    <link href="/2021/04/15/Tools/JetBrains/JetBrains%E7%B3%BB%E5%88%97%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2021/04/15/Tools/JetBrains/JetBrains%E7%B3%BB%E5%88%97%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<p><strong>将选中的代码或者单词全部变成大写或者小写</strong></p><p><code>Ctrl + Shift + U</code></p><p><strong>代开IDE中的终端</strong></p><p><code>Alt + F12</code></p><p><strong>隐藏在界面下方打开的界面，比如Debug界面或者Console界面</strong></p><p><code>Shift + ESC</code></p><p><strong>关闭打开的标签页</strong></p><p><code>Ctrl + W</code></p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>JetBrains</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JetBrains</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用GORM框架需要注意的几点问题</title>
    <link href="/2021/04/15/%E4%BD%BF%E7%94%A8GORM%E6%A1%86%E6%9E%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%87%A0%E7%82%B9%E9%97%AE%E9%A2%98/"/>
    <url>/2021/04/15/%E4%BD%BF%E7%94%A8GORM%E6%A1%86%E6%9E%B6%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E7%9A%84%E5%87%A0%E7%82%B9%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h4 id="表名末尾自动追加s问题"><a href="#表名末尾自动追加s问题" class="headerlink" title="表名末尾自动追加s问题"></a>表名末尾自动追加<code>s</code>问题</h4><p>当使用GORM框架构建数据库表的结构时，它会在表明的结尾自动追加<code>s</code>字符，例如表明为<code>abc</code>，则到数据库中就变成了<code>abcs</code>。</p><p>仅用的方法很简单，把构建表结构的<code>DB</code>对象的<code>SingularTable</code>属性设置为<code>true</code>，默认是<code>false</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">db.SingularTable(<span class="hljs-literal">true</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>开源项目</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>GORM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git常用操作</title>
    <link href="/2021/04/14/Tools/Git/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/04/14/Tools/Git/Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<blockquote><p>不定时更新，附上一个学习Git的网站：<a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程 - 廖雪峰的官方网站</a></p></blockquote><h3 id="回退到指定版本"><a href="#回退到指定版本" class="headerlink" title="回退到指定版本"></a>回退到指定版本</h3><h4 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git log<br></code></pre></td></tr></table></figure><h4 id="回退到指定版本-1"><a href="#回退到指定版本-1" class="headerlink" title="回退到指定版本"></a>回退到指定版本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git reset --hard &lt;版本号&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">版本号不需要全写，可以只写前几位，具体几位要看git能不能根据此只找到一条记录，比如你只写一位可能找到很多条包含前一位的记录，这是不行的</span><br></code></pre></td></tr></table></figure><h4 id="强制推送到服务器"><a href="#强制推送到服务器" class="headerlink" title="强制推送到服务器"></a>强制推送到服务器</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">shellgit push -f origin master<br></code></pre></td></tr></table></figure><h3 id="查看Git的配置信息"><a href="#查看Git的配置信息" class="headerlink" title="查看Git的配置信息"></a>查看Git的配置信息</h3><p><code>git</code> 中通过 <code>git config</code> 查看配置信息<br><code>config</code> 配置有<code>system</code>级别 <code>global（用户级别）</code> 和<code>local（当前仓库）</code>三个<br>配置的读取顺序: <code>system</code> –&gt; <code>global</code> –&gt;<code>local</code> ，所以，底层的配置会覆盖高层的配置。</p><h4 id="查看系统config"><a href="#查看系统config" class="headerlink" title="查看系统config"></a>查看系统config</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --system --list<br></code></pre></td></tr></table></figure><h4 id="查看当前用户（global）配置"><a href="#查看当前用户（global）配置" class="headerlink" title="查看当前用户（global）配置"></a>查看当前用户（global）配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global  --list<br></code></pre></td></tr></table></figure><h4 id="查看当前仓库配置信息"><a href="#查看当前仓库配置信息" class="headerlink" title="查看当前仓库配置信息"></a>查看当前仓库配置信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --local  --list<br></code></pre></td></tr></table></figure><h3 id="Git打tag与撤销tag"><a href="#Git打tag与撤销tag" class="headerlink" title="Git打tag与撤销tag"></a>Git打tag与撤销tag</h3><h4 id="删除本地tag"><a href="#删除本地tag" class="headerlink" title="删除本地tag"></a>删除本地tag</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git tag -d &lt;tagname&gt;<br></code></pre></td></tr></table></figure><h4 id="删除远端tag"><a href="#删除远端tag" class="headerlink" title="删除远端tag"></a>删除远端tag</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin --delete &lt;tagname&gt;<br></code></pre></td></tr></table></figure><h4 id="向远端推送本地tag"><a href="#向远端推送本地tag" class="headerlink" title="向远端推送本地tag"></a>向远端推送本地tag</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin &lt;tagname&gt;<br></code></pre></td></tr></table></figure><h4 id="向远端推送本地所有tag"><a href="#向远端推送本地所有tag" class="headerlink" title="向远端推送本地所有tag"></a>向远端推送本地所有tag</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git push origin --tags<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go:避免在循环中直接使用defer</title>
    <link href="/2021/04/13/Go-%E9%81%BF%E5%85%8D%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8defer/"/>
    <url>/2021/04/13/Go-%E9%81%BF%E5%85%8D%E5%9C%A8%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8defer/</url>
    
    <content type="html"><![CDATA[<p>看下面的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<br>    time.Sleep(time.Second)<br>    <span class="hljs-comment">// ......</span><br>    conn, err := grpc.Dial(address, grpc.WithInsecure())<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        log.Fatalf(<span class="hljs-string">&quot;did not connect: %v&quot;</span>, err)<br>    &#125;<br>    <span class="hljs-keyword">defer</span> conn.Close()<br>        <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由于这是一个死循环，defer代码不会被执行到，所以申请的内存得不到释放，然后会导致程序占满整个内存，死机。 注意这里需要强调的是<strong>直接使用</strong>，如果是封装到匿名函数中，结果就不一样了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> &#123;<br>    time.Sleep(time.Second)<br>    <span class="hljs-comment">// ......</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">()</span></span>&#123;<br>        conn, err := grpc.Dial(address, grpc.WithInsecure())<br>        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>            log.Fatalf(<span class="hljs-string">&quot;did not connect: %v&quot;</span>, err)<br>        &#125;<br>        <span class="hljs-keyword">defer</span> conn.Close()<br>    &#125;<br>        <span class="hljs-comment">//...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这里的defer会在匿名函数结束的时候得到执行，所以这样写就不会出现之前的资源没有释放的情况。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL模式(SCHEMA)基本操作</title>
    <link href="/2021/04/13/PostgreSQL%E6%A8%A1%E5%BC%8F-SCHEMA-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/04/13/PostgreSQL%E6%A8%A1%E5%BC%8F-SCHEMA-%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p><code>PostgreSQL</code> 模式（<code>SCHEMA</code>）可以看成是一个表的集合。</p><p>一个模式可以包含<strong>视图、索引、数据类型、函数和操作符</strong>等。</p><p>相同的对象名称可以被用于不同的模式中而不会出现冲突，例如 <code>schema1</code> 和 <code>myschema</code> 都可以包含名为 <code>mytable</code> 的表。</p><p>使用模式的优势：</p><ul><li>允许多个用户使用一个数据库并且不会互相干扰。</li><li>将数据库对象组织成逻辑组以便更容易管理。</li><li>第三方应用的对象可以放在独立的模式中，这样它们就不会与其他对象的名称发生冲突。</li></ul><p>模式类似于操作系统层的目录，但是模式不能嵌套。</p><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><h4 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h4><p>使用<code>CREATE SCHEMA</code> 语句。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-comment">-- 创建模式</span><br><span class="hljs-keyword">CREATE</span> SCHEMA myschema;<br><br><span class="hljs-comment">-- 在某个模式下创建表，如果模式不存在则创建模式并在该模式下创建表，模式存在则仅创建表</span><br><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> myschema.company(<br>   ID   <span class="hljs-type">INT</span>              <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   NAME <span class="hljs-type">VARCHAR</span> (<span class="hljs-number">20</span>)     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   AGE  <span class="hljs-type">INT</span>              <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   ADDRESS  <span class="hljs-type">CHAR</span> (<span class="hljs-number">25</span>),<br>   SALARY   <span class="hljs-type">DECIMAL</span> (<span class="hljs-number">18</span>, <span class="hljs-number">2</span>),<br>   <span class="hljs-keyword">PRIMARY</span> KEY (ID)<br>);<br></code></pre></td></tr></table></figure><h4 id="切换模式"><a href="#切换模式" class="headerlink" title="切换模式"></a>切换模式</h4><p><code>\dn</code> : 查看数据库下所有的模式</p><p><code>\set search_path=模式名</code> : 切换到对应模式下</p><p><code>\dt</code> 或 <code>\d</code> : 查看模式下表的<strong>关联列表</strong></p><p> <code>\dp</code> 查看模式下表的<strong>存取权限</strong></p><h4 id="删除模式"><a href="#删除模式" class="headerlink" title="删除模式"></a>删除模式</h4><p>删除一个空的模式：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> SCHEMA myschema;<br></code></pre></td></tr></table></figure><p>删除一个模式以及其中包含的所有对象：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">DROP</span> SCHEMA myschema CASCADE;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL对表的常用操作</title>
    <link href="/2021/04/13/PostgreSQL%E5%AF%B9%E8%A1%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/04/13/PostgreSQL%E5%AF%B9%E8%A1%A8%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><p>使用<code>CREATE TABLE</code> 语句。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> COMPANY(<br>   ID <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   NAME           TEXT    <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   AGE            <span class="hljs-type">INT</span>     <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>   ADDRESS        <span class="hljs-type">CHAR</span>(<span class="hljs-number">50</span>),<br>   SALARY         <span class="hljs-type">REAL</span><br>);<br></code></pre></td></tr></table></figure><p>其他命令:</p><p><code>\d</code> : 查看存在的表的列表</p><p><code>\d tablename</code> : 查看表的信息</p><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>使用<code>DROP TABLE</code> 语句。</p><p>示例：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> department, company;<br><br><span class="hljs-comment">-- 配合 IF EXISTS 使用, 如果存在删除表</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> department, company;<br></code></pre></td></tr></table></figure><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><h4 id="修改列的数据类型"><a href="#修改列的数据类型" class="headerlink" title="修改列的数据类型"></a>修改列的数据类型</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ALTER</span> column_name TYPE datatype;<br></code></pre></td></tr></table></figure><h4 id="修改列的名称"><a href="#修改列的名称" class="headerlink" title="修改列的名称"></a>修改列的名称</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name RENAME old_cloumn_name <span class="hljs-keyword">TO</span> new_column_name;<br></code></pre></td></tr></table></figure><h4 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h4><p>删除一列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> col1;<br></code></pre></td></tr></table></figure><p>删除多列</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> col1, <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">COLUMN</span> col2;<br></code></pre></td></tr></table></figure><h4 id="新增列"><a href="#新增列" class="headerlink" title="新增列"></a>新增列</h4><p>在<code>company</code> 表新增 <code>age</code> 列，类型为<code>real</code>，非空。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> company <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">column</span> <span class="hljs-type">real</span> <span class="hljs-type">real</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><h4 id="给列添加-NOT-NULL-约束"><a href="#给列添加-NOT-NULL-约束" class="headerlink" title="给列添加 NOT NULL 约束"></a>给列添加 NOT NULL 约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name MODIFY column_name datatype <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>;<br></code></pre></td></tr></table></figure><h4 id="给列添加-UNIQUE-约束"><a href="#给列添加-UNIQUE-约束" class="headerlink" title="给列添加 UNIQUE 约束"></a>给列添加 UNIQUE 约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> MyUniqueConstraint <span class="hljs-keyword">UNIQUE</span>(column1, column2...);<br></code></pre></td></tr></table></figure><p><code>MyUniqueConstraint</code>: 约束的名字，方便管理</p><h4 id="给列添加-CHECK-约束"><a href="#给列添加-CHECK-约束" class="headerlink" title="给列添加 CHECK 约束"></a>给列添加 CHECK 约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> MyUniqueConstraint <span class="hljs-keyword">CHECK</span> (<span class="hljs-keyword">CONDITION</span>);<br></code></pre></td></tr></table></figure><p><code>MyUniqueConstraint</code>: 约束的名字，方便管理</p><p><code>CONDITION</code>: 约束，即为列的条件，比如<code>age &gt; 20</code></p><h4 id="删除约束"><a href="#删除约束" class="headerlink" title="删除约束"></a>删除约束</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> MyUniqueConstraint;<br><br># 如果是MySQL<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> INDEX MyUniqueConstraint;<br></code></pre></td></tr></table></figure><h4 id="给表添加主键"><a href="#给表添加主键" class="headerlink" title="给表添加主键"></a>给表添加主键</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">ADD</span> <span class="hljs-keyword">CONSTRAINT</span> MyPrimaryKey <span class="hljs-keyword">PRIMARY</span> KEY (column1, column2...);<br></code></pre></td></tr></table></figure><h4 id="删除主键"><a href="#删除主键" class="headerlink" title="删除主键"></a>删除主键</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">CONSTRAINT</span> MyPrimaryKey;<br><br># 如果是MySQL<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> table_name <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PRIMARY</span> KEY;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL对数据库的常用操作</title>
    <link href="/2021/04/13/PostgreSQL%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/04/13/PostgreSQL%E5%AF%B9%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p><code>PostgreSQL</code> 创建数据库可以用以下三种方式：</p><ul><li>1、使用 <strong>CREATE DATABASE</strong> SQL 语句来创建。</li><li>2、使用 <strong>createdb</strong> 命令来创建。</li><li>3、使用 <strong>pgAdmin</strong> 等可视化工具创建。</li></ul><p>这里只介绍前两种。</p><h4 id="CREATE-DATABASE-创建数据库"><a href="#CREATE-DATABASE-创建数据库" class="headerlink" title="CREATE DATABASE 创建数据库"></a>CREATE DATABASE 创建数据库</h4><p>基本创建，默认属于当前用户</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> DATABASE <span class="hljs-operator">&lt;</span>dbname<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><p>指定数据库所有者</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">CREATE</span> DATABASE <span class="hljs-operator">&lt;</span>dbname<span class="hljs-operator">&gt;</span> OWNER <span class="hljs-operator">&lt;</span>username<span class="hljs-operator">&gt;</span>;<br></code></pre></td></tr></table></figure><h4 id="createdb-命令创建数据库"><a href="#createdb-命令创建数据库" class="headerlink" title="createdb 命令创建数据库"></a>createdb 命令创建数据库</h4><p><code>createdb</code> 是一个 SQL 命令 <code>CREATE DATABASE</code> 的封装。</p><p><code>createdb</code> 命令语法格式如下：</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs inform7">createdb <span class="hljs-comment">[option...]</span> <span class="hljs-comment">[dbname <span class="hljs-comment">[description]</span>]</span><br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><p><strong>dbname</strong>：要创建的数据库名。</p><p><strong>description</strong>：关于新创建的数据库相关的说明。</p><p><strong>options</strong>：参数可选项，可以是以下值：</p><table><thead><tr><th align="left">序号</th><th align="center">选项 &amp; 描述</th></tr></thead><tbody><tr><td align="left"><strong>-D tablespace</strong></td><td align="center">指定数据库默认表空间。</td></tr><tr><td align="left"><strong>-e</strong></td><td align="center">将 <code>createdb</code> 生成的命令发送到服务端。</td></tr><tr><td align="left"><strong>-E encoding</strong></td><td align="center">指定数据库的编码，默认是<code>utf-8</code></td></tr><tr><td align="left"><strong>-l locale</strong></td><td align="center">指定数据库的语言环境。</td></tr><tr><td align="left"><strong>-T template</strong></td><td align="center">指定创建此数据库的模板。</td></tr><tr><td align="left"><strong>–help</strong></td><td align="center">显示 <code>createdb</code> 命令的帮助信息。</td></tr><tr><td align="left"><strong>-h host</strong></td><td align="center">指定服务器的主机名。</td></tr><tr><td align="left"><strong>-p port</strong></td><td align="center">指定服务器监听的端口，或者 <code>socket</code> 文件。</td></tr><tr><td align="left"><strong>-U username</strong></td><td align="center">连接数据库的用户名。</td></tr><tr><td align="left"><strong>-w</strong></td><td align="center">忽略输入密码。</td></tr><tr><td align="left"><strong>-W</strong></td><td align="center">连接时强制要求输入密码。</td></tr></tbody></table><p><code>createdb</code> 命令和 <code>psql</code> 命令一样，均位于 <strong>PostgreSQL安装目录&#x2F;bin</strong> 下，执行创建数据库的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">createdb -h localhost -p 5432 -U postgres &lt;dbname&gt;<br></code></pre></td></tr></table></figure><p>上面的命令，我们使用了超级用户 <code>postgres</code> 登录到主机地址为 <code>localhost</code>，端口号为 <code>5432</code> 的 <code>PostgreSQL</code> 数据库中并创建 <code>dbname</code> 数据库。</p><h3 id="选择数据库"><a href="#选择数据库" class="headerlink" title="选择数据库"></a>选择数据库</h3><p>选择数据库的方式也有三种：分别是在数据库的命令窗口、在系统终端窗口和可视化工具，这里也只介绍前两种。</p><h4 id="数据库的命令窗口"><a href="#数据库的命令窗口" class="headerlink" title="数据库的命令窗口"></a>数据库的命令窗口</h4><p><code>\l</code> : 查看已经存在的数据库</p><p><code>\c &lt;dbname&gt;</code> : 进入到指定的数据库</p><h4 id="系统命令行窗口"><a href="#系统命令行窗口" class="headerlink" title="系统命令行窗口"></a>系统命令行窗口</h4><p>使用<code>psql</code>命令，具体的使用请通过<code>psql --help</code> 查看.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">psql -h localhost -p 5432 -U &lt;username&gt; -d &lt;dbname&gt;<br></code></pre></td></tr></table></figure><ul><li><code>-h</code> 指定数据库服务器IP地址</li><li><code>-p</code> 指定端口</li><li><code>-U</code> 指定登陆用户名</li><li><code>-d</code> 指定登陆到的数据库名称，可以省略，直接加数据库名，如果省略<code>-d</code>后面的内容，则默认登陆到和用户名相同的数据库</li></ul><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><p><code>PostgreSQL</code> 删除数据库可以用以下三种方式：</p><ul><li>1、使用 <strong>DROP DATABASE</strong> SQL 语句来删除。</li><li>2、使用 <strong>dropdb</strong> 命令来删除。</li><li>3、使用 <strong>pgAdmin</strong> 工具。</li></ul><p>这里只介绍前两种。</p><h4 id="DROP-DATABASE-删除数据库"><a href="#DROP-DATABASE-删除数据库" class="headerlink" title="DROP DATABASE 删除数据库"></a>DROP DATABASE 删除数据库</h4><p><strong>注意：</strong></p><ul><li><p><code>DROP DATABASE </code>会删除数据库的系统目录项并且删除包含数据的文件目录。</p></li><li><p><code>DROP DATABASE</code> 只能由超级管理员或数据库拥有者执行。</p></li><li><p><code>DROP DATABASE</code> 命令需要在 <code>PostgreSQL</code> 命令窗口来执行。</p></li></ul><p>删除名称为<code>dbname</code> 的数据库</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> DATABASE <span class="hljs-operator">&lt;</span>dbname<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><p>如果存在<code>dbname</code> 则删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs SQL"><span class="hljs-keyword">DROP</span> DATABASE IF <span class="hljs-keyword">EXISTS</span> <span class="hljs-operator">&lt;</span>dbname<span class="hljs-operator">&gt;</span><br></code></pre></td></tr></table></figure><h4 id="dropdb-命令删除数据库"><a href="#dropdb-命令删除数据库" class="headerlink" title="dropdb 命令删除数据库"></a>dropdb 命令删除数据库</h4><p><code>dropdb</code> 是 <code>DROP DATABASE</code> 的包装器。</p><p><code>dropdb</code> 用于删除 <code>PostgreSQL</code> 数据库。</p><p><code>dropdb</code> 命令只能由超级管理员或数据库拥有者执行。</p><p><code>dropdb</code> 命令语法格式如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake">dropdb [connection-<span class="hljs-keyword">option</span>...] [<span class="hljs-keyword">option</span>...] dbname<br></code></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><p><strong>dbname</strong>：要删除的数据库名。</p><p><strong>options</strong>：参数可选项，可以是以下值：</p><table><thead><tr><th align="left">序号</th><th align="center">选项 &amp; 描述</th></tr></thead><tbody><tr><td align="left"><strong>-e</strong></td><td align="center">显示 <code>dropdb</code> 生成的命令并发送到数据库服务器。</td></tr><tr><td align="left"><strong>-i</strong></td><td align="center">在做删除的工作之前发出一个验证提示。</td></tr><tr><td align="left"><strong>-V</strong></td><td align="center">打印 <code>dropdb</code> 版本并退出。</td></tr><tr><td align="left"><strong>–if-exists</strong></td><td align="center">如果数据库不存在则发出提示信息，而不是错误信息。</td></tr><tr><td align="left"><strong>–help</strong></td><td align="center">显示有关 <code>dropdb</code> 命令的帮助信息。</td></tr><tr><td align="left"><strong>-h host</strong></td><td align="center">指定运行服务器的主机名。</td></tr><tr><td align="left"><strong>-p port</strong></td><td align="center">指定服务器监听的端口，或者 <code>socket</code> 文件。</td></tr><tr><td align="left"><strong>-U username</strong></td><td align="center">连接数据库的用户名。</td></tr><tr><td align="left"><strong>-w</strong></td><td align="center">连接数据库的用户名。</td></tr><tr><td align="left"><strong>-W</strong></td><td align="center">连接时强制要求输入密码。</td></tr><tr><td align="left"><strong>–maintenance-db&#x3D;dbname</strong></td><td align="center">删除数据库时指定连接的数据库，默认为 <code>postgres</code>，如果它不存在则使用 <code>template1</code>。</td></tr></tbody></table><p>基本使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dropdb -h localhost -p 5432 -U &lt;username&gt; --if-exists &lt;dbname&gt; <br></code></pre></td></tr></table></figure><p>我们使用了用户 <code>username</code> 登录到主机地址为 <code>localhost</code>，端口号为 <code>5432</code> 的 <code>PostgreSQL</code> 数据库中并删除 <code>dbname</code> 数据库。</p><h3 id="修改数据库信息"><a href="#修改数据库信息" class="headerlink" title="修改数据库信息"></a>修改数据库信息</h3><h4 id="修改数据库密码"><a href="#修改数据库密码" class="headerlink" title="修改数据库密码"></a>修改数据库密码</h4><p>修改密码有两种方式，一种是在<code>psql</code>客户端使用<code>Postgresql</code>命令的方式，另一种是不限制客户端，使用SQL语句修改。</p><p><strong>psql</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql">test1<span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> \password <br>Enter <span class="hljs-keyword">new</span> password: <br>Enter it again: <br>test1<span class="hljs-operator">=</span><span class="hljs-operator">&gt;</span> <br></code></pre></td></tr></table></figure><p><strong>SQL语句</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> test1 PASSWORD <span class="hljs-string">&#x27;&lt;采用相关协议加密后的密码字符串&gt;&#x27;</span><br></code></pre></td></tr></table></figure><p>采用这种方式修改要注意数据库日志问题，如果数据库采用主从复制模型，修改主数据库会导致从数据库的密码也修改了。</p><h3 id="查看数据库的所有用户"><a href="#查看数据库的所有用户" class="headerlink" title="查看数据库的所有用户"></a>查看数据库的所有用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql">\du<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis开启远程登陆</title>
    <link href="/2021/04/13/Redis%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86/"/>
    <url>/2021/04/13/Redis%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E7%99%BB%E9%99%86/</url>
    
    <content type="html"><![CDATA[<p><code>Redis</code>开启远程登录只需要两步操作，修改配置文件，和开放对应端口（默认是6379）。</p><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p><code>redis.conf</code> 一般位于<code>redis安装包</code> 解压后的目录，如果有指定，最常用的位置是<code>/etc/redis/redis.conf</code></p><p>打开<code>redis.conf</code>文件后</p><ol><li><p>找到<code>bind127.0.0.1 -::1</code>这一行，将其注释掉。</p></li><li><p>找到 <code>protected-mode yes</code> 改为 <code>protected-mode no</code></p></li></ol><p>保存后重启<code>redis-server</code>，注意要加载到我们配置过的<code>redis.conf</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-server redis.conf<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果想在后台运行，使用命令</span><br>nohup redis-server redis.conf &amp;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">这会在当前目录创建nohup.log文件，是<span class="hljs-built_in">nohup</span>运行reids-server的日志输出文件。</span><br></code></pre></td></tr></table></figure><h4 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h4><p>默认端口是<code>6379</code>，如果是别的，请自行替换。</p><p>如果是<code>iptable</code>防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">命令行操作</span><br>iptables -A INPUT -p tcp --dport 6379 -j ACCEPT<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">或者</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">修改配置文件</span><br>vim /etc/sysconfig/iptables<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在最后一行添加</span><br>-A RH-Firewall-1-INPUT -m state NEW -m tcp -dport 8080 -j ACCEPT<br></code></pre></td></tr></table></figure><p>如果是<code>firewall</code>防火墙</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">firewall-cmd --zone=public --add-port=6379/tcp --permanent<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">重启防火墙</span><br>firewall-cmd --reload<br></code></pre></td></tr></table></figure><h4 id="登陆redis-server"><a href="#登陆redis-server" class="headerlink" title="登陆redis-server"></a>登陆redis-server</h4><h5 id="redis-cli命令"><a href="#redis-cli命令" class="headerlink" title="redis-cli命令"></a>redis-cli命令</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这里登陆db2数据库</span><br>redis-cli -h host -p port -a password -n 2<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">切换db的命令</span><br><span class="hljs-meta prompt_">&gt; </span><span class="language-bash">select db 1</span><br></code></pre></td></tr></table></figure><h5 id="可视化工具"><a href="#可视化工具" class="headerlink" title="可视化工具"></a>可视化工具</h5><p>这里推荐<a href="https://rdm.dev/">RDM - 适用于Windows，macOS，iPad 和 Linux 的 Redis ® 的 GUI 管理工具.</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis配置访问密码</title>
    <link href="/2021/04/13/Redis%E9%85%8D%E7%BD%AE%E8%AE%BF%E9%97%AE%E5%AF%86%E7%A0%81/"/>
    <url>/2021/04/13/Redis%E9%85%8D%E7%BD%AE%E8%AE%BF%E9%97%AE%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>Redis配置密码访问的方式有两种。</p><p>最常用的是修改配置文件<code>redis.conf</code>，但需要重启<code>redis-server</code>，如有需要，请做好数据的持久化后再重启，因为重启<code>redis-server</code>会清除所有<code>db</code>下的数据。</p><p>另一种是在<code>redis-cli</code>的交互界面配置，这种是临时的，在<code>redis-server</code>重启后就会失效。</p><h4 id="通过修改配置文件配置密码"><a href="#通过修改配置文件配置密码" class="headerlink" title="通过修改配置文件配置密码"></a>通过修改配置文件配置密码</h4><p><code>redis.conf</code>配置文件一般是在<code>redis安装包</code>解压后的目录，当然你也可以放在其他位置，比如常用的<code>/etc/redis/redis.conf</code></p><p>通过<code>Vim</code>打开这个文件，使用<code>Vim</code>的查找命令<code>/</code>找到<code>requirepass</code>，将它取消注释，然后删除后面的<code>footbared</code>，改成你的密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">vim redis.conf<br><br><span class="hljs-comment"># 在vim中，按 Shift + : 进入命令行界面，输入 /requirepass ，按 n 查找下一个，找到后取消注释，设置密码。</span><br></code></pre></td></tr></table></figure><p>重启<code>redis-server</code>，指定配置文件启动。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef | grep redis-server<br><br>kill xxx<br><br>redis-server redis.conf<br></code></pre></td></tr></table></figure><p>现在用<code>redis-cli</code>连接<code>redis-server</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli -h &lt;IP地址&gt; -p &lt;端口&gt; -a &lt;密码&gt;<br></code></pre></td></tr></table></figure><p>具体的<code>redis-cli</code>命令，可以通过<code>redis-cli --help</code>查看。</p><h4 id="临时修改"><a href="#临时修改" class="headerlink" title="临时修改"></a>临时修改</h4><p><code>redis-server</code> 已启动的情况下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 使用redis-cli连接redis-server</span><br>redis-cli -h IP地址 -p 端口号(默认6379)<br><br><span class="hljs-comment"># 在交互界面输入命令，设置密码</span><br>&gt; config <span class="hljs-built_in">set</span> requirepass areyouok123<br><br><span class="hljs-comment"># 查看设置的密码</span><br>&gt; config get requirepass<br><br><span class="hljs-comment"># 退出redis-cli，重新连接，再次输入命令就提示你要输入密码了</span><br>&gt; config get requirepass<br>(error) NOAUTH Authentication required.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim常用操作</title>
    <link href="/2021/04/13/Tools/Vim/Vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/04/13/Tools/Vim/Vim%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><p><strong>&#x2F;text</strong> : 正向查找<code>text</code>，按<code>n</code>查找下一个，按<code>N</code>查找上一个。</p><p><strong>?text</strong> : 反向查找<code>text</code>，按<code>n</code>查找下一个，按<code>N</code>查找上一个。</p><p>***&#x2F;#** ： 查找光标当前的单词，如果光标当前单词为<code>text</code>，那么就是查找<code>text</code>。</p><p><strong>:set ignorecase</strong> ：设置查找忽略大小写。</p><p><strong>:set noignorecase</strong> ：设置查找不忽略大小写。</p><p><strong>:nohisearch</strong> : 关闭当前的高亮显示，当再次查找时恢复高亮。</p><p><strong>:set incsearch</strong> : 逐步搜索模式，对当前渐入的字符进行查找，不必等待输入完成再查找。</p><p><strong>:set wrapscan</strong> : 重新搜索，当搜索到文件头或尾时，返回重新搜索。</p><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><p><strong>x 或 Del</strong> ：删除光标所在处的单个字符。</p><p><strong>dd</strong> : 删除当前光标所在的行。</p><p><strong>#dd</strong> : 删除从光标处开始的<code>#</code>行内容，<code>#</code>是一个数字。</p><p><strong>d^</strong> : 删除一行中从光标位置到行首的所有字符。</p><p><strong>d$</strong> : 删除一行中从光标位置到行尾的所有字符。</p><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p><strong>yy</strong> : 复制当前行的内容到剪切板。</p><p><strong>#yy</strong> : 复制从光标处开始的<code>#</code>行内容，<code>#</code>是一个数字。</p><h4 id="粘贴"><a href="#粘贴" class="headerlink" title="粘贴"></a>粘贴</h4><p><strong>p</strong> : 将缓冲区的内容粘贴到光标位置处之后（小写）。</p><p><strong>P</strong> : 将缓冲区的内容粘贴到光标位置处之前（大写）。</p><h4 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h4><p><strong>i</strong> : 在当前位置插入</p><p><strong>A</strong> : 在当前行尾插入</p><p><strong>I</strong> : 在当前行首插入</p><p><strong>o</strong> : 在当前行后插入一行</p><p><strong>O</strong> : 在当前行前插入一行</p><h3 id="文件窗口"><a href="#文件窗口" class="headerlink" title="文件窗口:"></a>文件窗口:</h3><p>:open file –在当前窗口打开新文件</p><p>:split file –在新窗口打开文件</p><p>:new file –用新窗口打开文件,同 :split file</p><p>:bn –切换到下一个文件</p><p>:bp –切换到上一个文件</p><p>:args –查看当前打开的文件列表(当前正在编辑的文件会用[]括起来)</p><p>:e <a href="ftp://192.168.10.76/abc.txt">ftp://192.168.10.76/abc.txt</a></p><p>:e \qadrive est.txt –打开远程文件</p><p>:split –打开一个新窗口,光标停在顶层的窗口上</p><p>:new –打开一个新窗口,光标停在顶层的窗口上</p><p>:vsplit –横向打开窗口。</p><p>Ctrl+ww –移动到下一个窗口</p><p>Ctrl+wj –移动到下方的窗口</p><p>Ctrl+wk –移动到上方的窗口</p><p>:!ls %:p  显示当前文件完整路径，但是会离开Vim页面</p><p>2、其他命令:</p><p>Esc&#x2F;Ctrl+[ – 键入命令</p><p>:!command –执行shell命令</p><p>:suspend&#x2F;Ctrl+Z –挂起vim,回到shell,fg 返回vim</p><p>:!perl -c script.pl –检查perl脚本语法,不用退出vim</p><p>:!perl script.pl –执行perl脚本, 不用退出vim</p><p>:help –显示帮助文档</p><p>:help i –显示i的帮助文档(:特殊键用&lt;&gt;, -t:启动参数用-)</p><p>3、编辑命令:</p><p>拷贝粘贴剪切:</p><p>yy –拷贝当前行</p><p>2yy –拷贝当前行开始的2行</p><p>p –在当前光标后粘贴</p><p>P –在当前行前粘贴</p><p>:1,10 co 20 –将1-10行插入到第20行之后。</p><p>:1,$ co $ –将整个文件复制一份并添加到文件尾部</p><p>v –进入选择模式,相当于在Windows下按住 Shift选择</p><p>V –进入选择模式,整行选择</p><p>ddp –交换当前行和其下一行</p><p>2dd –剪切当前行之后的2行</p><p>:1,10d –将1-10行剪切</p><p>:1, 10 m 20 –将第1-10行移动到第20行之后</p><p>替换:</p><p>ra –将当前光标所在字符替换为a</p><p>s&#x2F;old&#x2F;new&#x2F; –用old替换new,替换当前行的第一个匹配</p><p>s&#x2F;old&#x2F;new&#x2F;g –用old替换new,替换当前行的所有匹配</p><p>%s&#x2F;old&#x2F;new&#x2F; –用old替换new,替换所有行的第一个匹配</p><p>%s&#x2F;old&#x2F;new&#x2F;g –用old替换new,替换所有匹配</p><p>:10,20 s&#x2F;^&#x2F;text&#x2F;g –在第10行到第20行每行前面加上text(:3,5 s&#x2F;^&#x2F;#&#x2F;g –注释3-5行, :3,5 s&#x2F;^#&#x2F;&#x2F;g<br>–解除3-5行的注释, :1,$ s&#x2F;^&#x2F;#&#x2F;g –注释整个文档, :%s&#x2F;^&#x2F;#&#x2F;g –注释整个文档)</p><p>ddp –交换光标所在行和下一行</p><p>移动:</p><p>h –左移一个字符(5h –左移5个字符)</p><p>l –右移一个字符(5l –右移5个字符)</p><p>k –上移一个字符(5k –上移5个字符)</p><p>j –下移一个字符(5j –下移5个字符)</p><p>w –向后移动一个单词(5w –向后移动5个单词)</p><p>b –向前移动一个单词(5b –向前移动5个单词)</p><p>e –同 w ,光标停在单词尾部</p><p>ge –同 e ,光标停在单词尾部</p><p>^ –移动到本行第一个非空白字符</p><p>0 –移动到本行第0个字符</p><p>–同0</p><p>$ –移动到行尾(3$ –移动到下面3行的行尾)</p><p>gg –移动到文件头(10gg –移动到第10行首)</p><p>[[ –同 gg</p><p>G –移动到文件尾(10G –移动到第10行尾)</p><p>]] –同 G</p><p>fx –移动到本行光标后第一个为x的字符(3fx –移动到本行光标后第3个为x的字符)</p><p>Fx –同 fx ,反向查找</p><p>:20 –跳到20行行首</p><p>Ctrl+e –向下滚动一行</p><p>Ctrl+y –向上滚动一行</p><p>Ctrl+d –向下滚动半屏</p><p>Ctrl+u –向上滚动半屏</p><p>Ctrl+f –向下滚动一屏</p><p>Ctrl+b –向上滚动一屏</p><p>撤销:</p><p>u –撤销</p><p>U –撤销对整行的操作</p><p>Ctrl+r –撤销刚才的撤销</p><p>删除:</p><p>x –删除当前字符(3x –删除当前光标开始向后三个字符)</p><p>X –删除当前字符的前一个字符, 同 dh</p><p>dl –删除当前字符, 同 x</p><p>dh –删除前一个字符</p><p>dd –删除当前行</p><p>dj –删除上一行</p><p>dk –删除下一行</p><p>10d –删除当前行开始的10行。</p><p>D –删除当前字符至行尾, 同 d$</p><p>kdgg –删除当前行之前所有行(不包括当前行)</p><p>:1,10d –删除1-10行</p><p>:11,$d –删除11行及以后所有的行</p><p>:1,$d –删除所有行</p><p>J　–删除两行之间的空行, 合并两行</p><p>退出</p><p>:wq –保存并退出</p><p>ZZ –保存并退出</p><p>:q! –强制退出并忽略所有更改</p><p>:e! –放弃所有修改，并打开原来文件</p><p>:close –关闭窗口,最后一个窗口不能使用此命令,可以防止意外退出vim</p><p>:q –如果是最后一个被关闭的窗口，那么将退出vim</p><p>1、文件窗口:</p><p>:open file –在当前窗口打开新文件</p><p>:split file –在新窗口打开文件</p><p>:new file –用新窗口打开文件,同 :split file</p><p>:bn –切换到下一个文件</p><p>:bp –切换到上一个文件</p><p>:args –查看当前打开的文件列表(当前正在编辑的文件会用[]括起来)</p><p>:e <a href="ftp://192.168.10.76/abc.txt">ftp://192.168.10.76/abc.txt</a></p><p>:e \qadrive est.txt –打开远程文件</p><p>:split –打开一个新窗口,光标停在顶层的窗口上</p><p>:new –打开一个新窗口,光标停在顶层的窗口上</p><p>:vsplit –横向打开窗口。</p><p>Ctrl+ww –移动到下一个窗口</p><p>Ctrl+wj –移动到下方的窗口</p><p>Ctrl+wk –移动到上方的窗口</p><p>2、其他命令:</p><p>Esc&#x2F;Ctrl+[ – 键入命令</p><p>:!command –执行shell命令</p><p>:suspend&#x2F;Ctrl+Z –挂起vim,回到shell,fg 返回vim</p><p>:!perl -c script.pl –检查perl脚本语法,不用退出vim</p><p>:!perl script.pl –执行perl脚本, 不用退出vim</p><p>:help –显示帮助文档</p><p>:help i –显示i的帮助文档(:特殊键用&lt;&gt;, -t:启动参数用-)</p><p>3、编辑命令:</p><p>插入:</p><p>i –在当前位置插入</p><p>A –在当前行尾插入</p><p>I –在当前行首插入</p><p>o –在当前行后插入一行</p><p>O –在当前行前插入一行</p><p>拷贝粘贴剪切:</p><p>yy –拷贝当前行</p><p>2yy –拷贝当前行开始的2行</p><p>p –在当前光标后粘贴</p><p>P –在当前行前粘贴</p><p>:1,10 co 20 –将1-10行插入到第20行之后。</p><p>:1,$ co $ –将整个文件复制一份并添加到文件尾部</p><p>v –进入选择模式,相当于在Windows下按住 Shift选择</p><p>V –进入选择模式,整行选择</p><p>ddp –交换当前行和其下一行</p><p>2dd –剪切当前行之后的2行</p><p>:1,10d –将1-10行剪切</p><p>:1, 10 m 20 –将第1-10行移动到第20行之后</p><p>替换:</p><p>ra –将当前光标所在字符替换为a</p><p>s&#x2F;old&#x2F;new&#x2F; –用old替换new,替换当前行的第一个匹配</p><p>s&#x2F;old&#x2F;new&#x2F;g –用old替换new,替换当前行的所有匹配</p><p>%s&#x2F;old&#x2F;new&#x2F; –用old替换new,替换所有行的第一个匹配</p><p>%s&#x2F;old&#x2F;new&#x2F;g –用old替换new,替换所有匹配</p><p>:10,20 s&#x2F;^&#x2F;text&#x2F;g –在第10行到第20行每行前面加上text(:3,5 s&#x2F;^&#x2F;#&#x2F;g –注释3-5行, :3,5 s&#x2F;^#&#x2F;&#x2F;g<br>–解除3-5行的注释, :1,$ s&#x2F;^&#x2F;#&#x2F;g –注释整个文档, :%s&#x2F;^&#x2F;#&#x2F;g –注释整个文档)</p><p>ddp –交换光标所在行和下一行</p><p>移动:</p><p>h –左移一个字符(5h –左移5个字符)</p><p>l –右移一个字符(5l –右移5个字符)</p><p>k –上移一个字符(5k –上移5个字符)</p><p>j –下移一个字符(5j –下移5个字符)</p><p>w –向后移动一个单词(5w –向后移动5个单词)</p><p>b –向前移动一个单词(5b –向前移动5个单词)</p><p>e –同 w ,光标停在单词尾部</p><p>ge –同 e ,光标停在单词尾部</p><p>^ –移动到本行第一个非空白字符</p><p>0 –移动到本行第0个字符</p><p>–同0</p><p>$ –移动到行尾(3$ –移动到下面3行的行尾)</p><p>gg –移动到文件头(10gg –移动到第10行首)</p><p>[[ –同 gg</p><p>G –移动到文件尾(10G –移动到第10行尾)</p><p>]] –同 G</p><p>fx –移动到本行光标后第一个为x的字符(3fx –移动到本行光标后第3个为x的字符)</p><p>Fx –同 fx ,反向查找</p><p>:20 –跳到20行行首</p><p>Ctrl+e –向下滚动一行</p><p>Ctrl+y –向上滚动一行</p><p>Ctrl+d –向下滚动半屏</p><p>Ctrl+u –向上滚动半屏</p><p>Ctrl+f –向下滚动一屏</p><p>Ctrl+b –向上滚动一屏</p><p>撤销:</p><p>u –撤销</p><p>U –撤销对整行的操作</p><p>Ctrl+r –撤销刚才的撤销</p><p>删除:</p><p>x –删除当前字符(3x –删除当前光标开始向后三个字符)</p><p>X –删除当前字符的前一个字符, 同 dh</p><p>dl –删除当前字符, 同 x</p><p>dh –删除前一个字符</p><p>dd –删除当前行</p><p>dj –删除上一行</p><p>dk –删除下一行</p><p>10d –删除当前行开始的10行。</p><p>D –删除当前字符至行尾, 同 d$</p><p>kdgg –删除当前行之前所有行(不包括当前行)</p><p>:1,10d –删除1-10行</p><p>:11,$d –删除11行及以后所有的行</p><p>:1,$d –删除所有行</p><p>J　–删除两行之间的空行, 合并两行</p><p>退出</p><p>:wq –保存并退出</p><p>ZZ –保存并退出</p><p>:q! –强制退出并忽略所有更改</p><p>:e! –放弃所有修改，并打开原来文件</p><p>:close –关闭窗口,最后一个窗口不能使用此命令,可以防止意外退出vim</p><p>:q –如果是最后一个被关闭的窗口，那么将退出vim</p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Vim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一览Go开源项目</title>
    <link href="/2021/04/11/%E4%B8%80%E8%A7%88Go%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/"/>
    <url>/2021/04/11/%E4%B8%80%E8%A7%88Go%E5%BC%80%E6%BA%90%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<blockquote><p>源地址：<a href="https://github.com/jaydenwen123/golang-open-source-projects">golang-open-source-projects</a></p></blockquote><p>这个项目可以理解为针对互联网IT人打造的中文版awesome-go。已有的awesome-go项目， 汇总了很多go开源项目， 但存在的问题是收集太全了， 而且每个项目没有详细描述。</p><p> 本项目作为awesome-go的一个扩展，根据go语言中文社区提供的资料，还有互联网企业架构设计中的常见组件分类， 共精心挑选了154个开源项目（项目不限于在github开源的项目）， 分成以下17个大类。</p><p> 项目初衷是帮助到那些想学习和借鉴优秀golang开源项目， 和在互联网架构设计时期望快速寻找合适轮子的人。</p><p>ps: 以下项目<strong>star数均大于100</strong>，且会定期检查项目的url，剔除无效链接。 每个分类下的项目会按照<strong>star数从高到低</strong>进行排列。</p><p><a href="#%E7%9B%AE%E5%BD%95">目录</a></p><ul><li><a href="#%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F">监控系统</a></li><li><a href="#%E5%AE%B9%E5%99%A8%E6%8A%80%E6%9C%AF">容器技术</a></li><li><a href="#PaaS%E5%B7%A5%E5%85%B7">PaaS工具</a></li><li><a href="#%E5%A4%A7%E6%95%B0%E6%8D%AE">大数据</a></li><li><a href="#%E5%BE%AE%E6%9C%8D%E5%8A%A1">微服务</a></li><li><a href="#CI/CD">CI&#x2F;CD</a></li><li><a href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%8A%80%E6%9C%AF">数据库技术</a></li><li><a href="#%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF">存储技术</a></li><li><a href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F">分布式系统</a></li><li><a href="#%E6%B6%88%E6%81%AF%E7%B3%BB%E7%BB%9F">消息系统</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%A1%E7%90%86">服务器管理</a></li><li><a href="#%E5%AE%89%E5%85%A8%E5%B7%A5%E5%85%B7">安全工具</a></li><li><a href="#%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7">网络工具</a></li><li><a href="#Web%E5%B7%A5%E5%85%B7">Web工具</a></li><li><a href="#Web%E6%A1%86%E6%9E%B6">Web框架</a></li><li><a href="#%E5%8C%BA%E5%9D%97%E9%93%BE%E6%8A%80%E6%9C%AF">区块链技术</a></li><li><a href="#%E5%85%B6%E5%AE%83">其它</a></li></ul><h1 id="监控系统"><a href="#监控系统" class="headerlink" title="监控系统"></a>监控系统</h1><table><thead><tr><th>项目</th><th>简介</th><th>Star数</th></tr></thead><tbody><tr><td><a href="https://github.com/grafana/grafana">grafana&#x2F;grafana                      </a></td><td>Grafana 是一个用于监控指标分析和图表展示的工具， 后端支持 Graphite, InfluxDB &amp; Prometheus &amp; Open-falcon等， 它是一个流行的监控组件， 目前在各大中小型公司中广泛应用</td><td>34113</td></tr><tr><td><a href="https://github.com/prometheus/prometheus">prometheus&#x2F;prometheus                      </a></td><td>Prometheus 是一个开源的服务监控系统和时间序列数据库， 提供监控数据存储，展示，告警等功能</td><td>29808</td></tr><tr><td><a href="https://github.com/bosun-monitor/bosun">bosun-monitor&#x2F;bosun                      </a></td><td>专业的跨平台开源系统监控项目，go语言编写，灵活的模板和表达式配合上各种collector可以监控任何应用或系统级的运行数据，比 zabbix更轻量级、更易入手和更适合定制。</td><td>2961</td></tr><tr><td><a href="https://github.com/sourcegraph/checkup">sourcegraph&#x2F;checkup                      </a></td><td>一个分布式的无锁的站点健康状态检查工具。 支持检查http， tcp， dns等的状态 并可将结果保存在s3。 自带了一个美观的界面。</td><td>2822</td></tr><tr><td><a href="https://github.com/influxdata/kapacitor">influxdata&#x2F;kapacitor                      </a></td><td>Kapacitor 是一个开源框架，用来处理、监控和警告时间序列数据。</td><td>1879</td></tr><tr><td><a href="https://github.com/rapidloop/rtop">rapidloop&#x2F;rtop                      </a></td><td>rtop 是一个简单的无代理的远程服务器监控工具，基于 SSH 连接进行工作。无需在被监控的服务器上安装任何软件。rtop 直接通过 SSH 连接到待监控服务器，然后执行命令来收集监控数据。rtop 每几秒钟就自动更新监控数据，类似其他 *top 命令</td><td>1845</td></tr><tr><td><a href="https://github.com/open-falcon/of-release">open-falcon&#x2F;of-release                      </a></td><td>OpenFalcon是一款小米开源的监控系统。功能：数据采集免配置：agent自发现、支持Plugin、主动推送模式; 容量水平扩展：生产环境每秒50万次数据收集、告警、存储、绘图，可持续水平扩展。告警策略自发现：Web界面、支持策略模板、模板继承和覆盖、多种告警方式、支持回调动作。告警设置人性化：支持最大告警次数、告警级别设置、告警恢复通知、告警暂停、不同时段不同阈值、支持维护周期，支持告警合并。历史数据高效查询：秒级返回上百个指标一年的历史数据。Dashboard人性化：多维度的数据展示，用户自定义Dashboard等功能。架构设计高可用：整个系统无核心单点，易运维，易部署。</td><td>1237</td></tr><tr><td><a href="https://github.com/rach/pome">rach&#x2F;pome                      </a></td><td>Pome 是 Postgres Metrics 的意思。Pome 是一个 PostgreSQL 的指标仪表器，用来跟踪你的数据库的健康状况。</td><td>1085</td></tr><tr><td><a href="https://github.com/gy-games/smartping">gy-games&#x2F;smartping                      </a></td><td>SmartPing为一个各机器(点)间间互PING检测工具，支持互PING，单向PING，绘制拓扑及报警功能。 系统设计为无中心化原则，所有的数据均存储自身点中，默认数据循环保留1个月时间，由自身点的数据绘制 出PING包 的状态，由各其他点的数据绘制 进PING包 的状态，并API接口获取其他点数据绘制整体PING拓扑图，拓扑图中存在报警功能。</td><td>856</td></tr><tr><td><a href="https://github.com/TalkingData/owl">TalkingData&#x2F;owl                      </a></td><td>OWL是TalkingData公司推出的一款开源分布式监控系统, 演示环境<a href="http://54.223.127.87/">http://54.223.127.87/</a> 登录账号密码demo&#x2F;demo</td><td>758</td></tr><tr><td><a href="https://github.com/pinggg/pingd">pinggg&#x2F;pingd                      </a></td><td>pingd 是世界上最简单的监控服务，使用 golang 编写。软件支持 IPv6，但是服务器不支持. pingd 允许同时 ping 上千个 IPs，在此期间还可以管理监控的主机。用户提供主机名或者 IP，还有用户邮箱地址，就可以使用 3 个生成 URLs 来开启，停止或者删除你的追踪。每当你的服务器停机或者后台在线都会发送通知，还包含控制 URLs。</td><td>383</td></tr><tr><td><a href="https://github.com/cloudinsight/cloudinsight-agent">cloudinsight&#x2F;cloudinsight-agent                      </a></td><td>提供可视化监控的saas平台cloudinsight开源的一个监控客户端。 Cloudinsight 探针可以收集它所在操作系统的各种指标，然后发送到 Cloudinsight 后端服务</td><td>357</td></tr><tr><td><a href="https://github.com/gravitational/satellite">gravitational&#x2F;satellite                      </a></td><td>用于监测kubernetes健康状态的一个工具／库。 其特点是：轻量级定期测试， 高可用性和弹性网络分区， 无单点故障， 以时间序列的格式存储监控数据。</td><td>166</td></tr><tr><td><a href="https://github.com/kovetskiy/zabbixctl">kovetskiy&#x2F;zabbixctl                      </a></td><td>Zabbixctl 是采用Zabbix服务API的命令行工具，它提供了有效的方式去查询和处理trigger 状态、主机最新数据和用户组。</td><td>122</td></tr></tbody></table><h1 id="容器技术"><a href="#容器技术" class="headerlink" title="容器技术"></a>容器技术</h1><table><thead><tr><th>项目</th><th>简介</th><th>Star数</th></tr></thead><tbody><tr><td><a href="https://github.com/docker/docker">docker&#x2F;docker                      </a></td><td>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）。几乎没有性能开销,可以很容易地在机器和数据中心中运行。最重要的是,他们不依赖于任何语言、框架或包装系统。</td><td>56684</td></tr><tr><td><a href="https://github.com/vmware/harbor">vmware&#x2F;harbor                      </a></td><td>容器应用的开发和运行离不开可靠的镜像管理。从安全和效率等方面考虑，部署在私有环境内的Registry是非常必要的。Project Harbor是由VMware公司中国团队为企业用户设计的Registry server开源项目，包括了权限管理(RBAC)、LDAP、审计、管理界面、自我注册、HA等企业必需的功能，同时针对中国用户的特点，设计镜像复制和中文支持等功能</td><td>11230</td></tr><tr><td><a href="https://github.com/coreos/rkt">coreos&#x2F;rkt                      </a></td><td>Rocket （也叫 rkt）是 CoreOS 推出的一款容器引擎，和 Docker 类似，帮助开发者打包应用和依赖包到可移植容器中，简化搭环境等部署工作。Rocket 和 Docker 不同的地方在于，Rocket 没有 Docker 那些为企业用户提供的“友好功能”，比如云服务加速工具、集群系统等。反过来说，Rocket 想做的，是一个更纯粹的业界标准。</td><td>8914</td></tr><tr><td><a href="https://github.com/coreos/clair">coreos&#x2F;clair                      </a></td><td>Clair 是一个容器漏洞分析服务。它提供一个能威胁容器漏洞的列表，并且在有新的容器漏洞发布出来后会发送通知给用户。</td><td>6426</td></tr><tr><td><a href="https://github.com/shipyard/shipyard">shipyard&#x2F;shipyard                      </a></td><td>Shipyard 是一个基于 Web 的 Docker 管理工具，支持多 host，可以把多个 Docker host 上的 containers 统一管理；可以查看 images，甚至 build images；并提供 RESTful API 等等。 Shipyard 要管理和控制 Docker host 的话需要先修改 Docker host 上的默认配置使其支持远程管理。</td><td>6407</td></tr><tr><td><a href="https://github.com/zettio/weave">zettio&#x2F;weave                      </a></td><td>Weave 创建一个虚拟网络并连接到部署在多个主机上的 Docker 容器。</td><td>5798</td></tr><tr><td><a href="https://github.com/weaveworks/scope">weaveworks&#x2F;scope                      </a></td><td>一个docker&amp;kubernetes的管理，监控可视化工具， 可以看到容器间的拓扑关系和tcp通信</td><td>4206</td></tr><tr><td><a href="https://github.com/alibaba/pouch">alibaba&#x2F;pouch                      </a></td><td>Pouch 是 Alibaba 公司开源的容器引擎技术，其主要功能包括基本的容器管理能力，安全稳定的强容器隔离能力，以及对应用无侵入性的富容器技术。</td><td>4177</td></tr><tr><td><a href="https://github.com/docker/swarmkit">docker&#x2F;swarmkit                      </a></td><td>SwarmKit 是Docker公司开源的Docker集群管理和容器编排工具，其主要功能包括节点发现、基于raft算法的一致性和任务调度等。</td><td>2329</td></tr><tr><td><a href="https://github.com/emccode/rexray">emccode&#x2F;rexray                      </a></td><td>REX-Ray 是一个 EMC {code} 团队领导的开源项目，为 Docker、Mesos 及其他容器运行环境提供持续的存储访问。其设计旨在囊括通用存储、虚拟化和云平台，提供高级的存储功能。</td><td>1743</td></tr><tr><td><a href="https://github.com/docker/libnetwork">docker&#x2F;libnetwork                      </a></td><td>Libnetwork 提供一个原生 Go 实现的容器连接，是容器的网络。libnetwork 的目标是定义一个健壮的容器网络模型（Container Network Model），提供一个一致的编程接口和应用程序的网络抽象。</td><td>1612</td></tr><tr><td><a href="https://github.com/cloud66/habitus">cloud66&#x2F;habitus                      </a></td><td>一个快速实现docker build 流程的工具， 支持复杂的docker build流程，实现多个dockerfile的build流程，典型应用如将需要静态编译的程序，如go， java这类程序在一个docker build编译好之后，得到的二进制包用到后续的build流程</td><td>1090</td></tr><tr><td><a href="https://github.com/vishvananda/wormhole">vishvananda&#x2F;wormhole                      </a></td><td>WWormhole 是一个能识别命名空间的由 Socket 激活的隧道代理。可以让你安全的连接在不同物理机器上的 Docker 容器。可以用来完成一些有趣的功能，例如连接运行在容器本机的服务或者在连接后创建按需的服务。</td><td>370</td></tr></tbody></table><h1 id="PaaS工具"><a href="#PaaS工具" class="headerlink" title="PaaS工具"></a>PaaS工具</h1><table><thead><tr><th>项目</th><th>简介</th><th>Star数</th></tr></thead><tbody><tr><td><a href="https://github.com/kubernetes/kubernetes">kubernetes&#x2F;kubernetes                      </a></td><td>Kubernetes 是来自 Google 云平台的开源容器集群管理系统。基于 Docker 构建一个容器的调度服务。该系统可以自动在一个容器集群中选择一个工作容器供使用。其核心概念是 Container Pod。</td><td>64452</td></tr><tr><td><a href="https://github.com/rancher/rancher">rancher&#x2F;rancher                      </a></td><td>Rancher2是基于Go编写的k8s管理平台，采用k8s in k8s的方式，极大的简化了k8s部署，并能同时管理多套k8s集群，操作和安全俱佳，是一款非常好的Devops工具</td><td>13922</td></tr><tr><td><a href="https://github.com/tsuru/tsuru">tsuru&#x2F;tsuru                      </a></td><td>在 Tsuru 的 PaaS 服务下，你可以选择自己的编程语言，选择使用 SQL 或者 NoSQL 数据库，memcache、redis、等等许多服务，甚至与你可以使用 Git 版本控制工具来上传你应用。</td><td>3286</td></tr><tr><td><a href="https://github.com/laincloud/lain">laincloud&#x2F;lain                      </a></td><td>Lain 是一个基于 docker 的 PaaS 系统。其面向技术栈多样寻求高效运维方案的高速发展中的组织，devops 人力缺乏的 startup ，个人开发者。统一高效的开发工作流，降低应用运维复杂度；在 IaaS &#x2F; 私有 IDC 裸机的基础上直接提供应用开发，集成，部署，运维的一揽子解决方案。</td><td>449</td></tr><tr><td><a href="https://github.com/ooyala/atlantis">ooyala&#x2F;atlantis                      </a></td><td>Atlantis 是一款基于 Docker，使用 Go 编写，为 HTTP 应用准备的开源 PaaS。Atlantis 可以在路由请求中轻松的构建和部署应用到容器。Atlantis 在 Ooyala 的新应用中得到了很广泛的应用。</td><td>385</td></tr><tr><td><a href="https://github.com/weibocom/opendcp">weibocom&#x2F;opendcp                      </a></td><td>OpenDCP是一个基于Docker的云资源管理与调度平台，集镜像仓库、多云支持、服务编排、服务发现等功能与一身，支持服务池的扩缩容，其技术体系源于微博用于支持节假日及热点峰值流量的弹性调度DCP系统。OpenDCP允许利用公有云服务器搭建起适应互联网应用的IT基础设施，并且将运维的工作量降到最低。</td><td>381</td></tr><tr><td><a href="https://github.com/mesos/cloudfoundry-mesos">mesos&#x2F;cloudfoundry-mesos                      </a></td><td>Cloud Foundry-Mesos框架由华为与Mesosphere的工程师合作完成，能够为应用提供安全可靠的、可伸缩、可扩展的云端运行环境，并且应用能够 享用Cloud Foundry生态圈内各类丰富的服务资源。企业能够通过Cloud Foundry开发云应用，并通过Cloud Foundry-Mesos将应用部署到DCOS上，使应用能够与DCOS上安装的其他服务及应用框架共享资源，实现资源利用率最大化，能够大幅降低企业 数据中心运营成本。DCOS能够运行在虚拟和物理环境上，能够支持Linux（以及很快支持Windows），并可适用于私有云、公有云及混合云环境。</td><td>107</td></tr></tbody></table><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><table><thead><tr><th>项目</th><th>简介</th><th>Star数</th></tr></thead><tbody><tr><td><a href="https://github.com/istio/istio">istio&#x2F;istio                      </a></td><td>Istio是由Google、IBM和Lyft开源的微服务管理、保护和监控框架。使用istio可以很简单的创建具有负载均衡、服务间认证、监控等功能的服务网络，而不需要对服务的代码进行任何修改。</td><td>22197</td></tr><tr><td><a href="https://github.com/go-kit/kit">go-kit&#x2F;kit                      </a></td><td>Go-kit 是一个 Go 语言的分布式开发包，用于开发微服务。</td><td>16516</td></tr><tr><td><a href="https://github.com/uber/jaeger">uber&#x2F;jaeger                      </a></td><td>Jaeger是Uber的分布式跟踪系统 ，基于google dapper的原理构建， 以Cassandra作为存储层</td><td>10479</td></tr><tr><td><a href="https://github.com/micro/micro">micro&#x2F;micro                      </a></td><td>Micro是一个专注于简化分布式系统开发的微服务生态系统。可插拔的插件化设计，提供强大的可插拔的架构来保证基础组件可以被灵活替换。</td><td>7764</td></tr><tr><td><a href="https://github.com/eBay/fabio">eBay&#x2F;fabio                      </a></td><td>fabio 是 ebay 团队用 golang 开发的一个快速、简单零配置能够让 consul 部署的应用快速支持 http(s) 的负载均衡路由器。这里有一篇中文文章<a href="http://dockone.io/article/1567%E4%BB%8B%E7%BB%8D%E4%BA%86%E5%A6%82%E4%BD%95%E7%94%A8fabio%EF%BC%8Bconsul%E5%AE%9E%E7%8E%B0%E6%9C%8D%E5%8A%A1%E5%8F%91%E7%8E%B0%EF%BC%8C%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%EF%BC%8C%E5%B9%B6%E9%98%90%E8%BF%B0%E4%BA%86%E5%8E%9F%E7%90%86%EF%BC%8C">http://dockone.io/article/1567介绍了如何用fabio＋consul实现服务发现，负载均衡，并阐述了原理，</a> 最后还有demo程序</td><td>6289</td></tr><tr><td><a href="https://github.com/goadesign/goa">goadesign&#x2F;goa                      </a></td><td>Goa 是一款用 Go 用于构建微服务的框架，采用独特的设计优先的方法。</td><td>3757</td></tr><tr><td><a href="https://github.com/NYTimes/gizmo">NYTimes&#x2F;gizmo                      </a></td><td>纽约时报开源的go微服务工具.提供如下特性:标准化配置和日志;可配置策略的状态监测端点;用于管理 pprof 端点和日志级别的配置;结构化日志，提供基本请求信息;端点的有用度量;优雅的停止服务; 定义期待和词汇的基本接口</td><td>3076</td></tr><tr><td><a href="https://github.com/koding/kite">koding&#x2F;kite                      </a></td><td>一个基于go语言的微服务框架, Kite是Koding公司内部的一个框架, 该框架提供服务发现，多种认证功能，服务端通过RPC进行通信，同时还提供了websocket的js库，方便浏览器于服务器间进行通信。</td><td>2709</td></tr><tr><td><a href="https://github.com/afex/hystrix-go">afex&#x2F;hystrix-go                      </a></td><td>用来隔离远程系统调用， 第三方库调用 ，服务调用， 提供熔断机制，避免雪崩效应的库， Hystrix的go 版本。 注Hystrixs是Netflix开源的一个java库</td><td>2407</td></tr><tr><td><a href="https://github.com/fagongzi/gateway">fagongzi&#x2F;gateway                      </a></td><td>Gateway是一个使用go实现的基于HTTP的API 网关。<strong>特性</strong> ：API 聚合 ; 流控;  熔断; 负载均衡; 健康检查;  监控;  消息路由;  后端管理WebUI .  <strong>能做什么</strong>：规划更友好的URL给调用者。聚合多个API的结果返回给API调用者，利于移动端，后端可以实现原子接口。保护后端API服务不会被突发异常流量压垮。提供熔断机制，使得后端API Server具备自我恢复能力。借助消息路由能力，实现灰度发布，AB测试。</td><td>2364</td></tr><tr><td><a href="https://github.com/goodrain/rainbond">goodrain&#x2F;rainbond                      </a></td><td>云帮是一款以应用为中心的开源PaaS，深度整合Kubernetes的容器管理和Service Mesh微服务架构最佳实践，满足支撑业务高速发展所需的敏捷开发、高效运维和精益管理需求</td><td>2195</td></tr><tr><td><a href="https://github.com/sourcegraph/appdash">sourcegraph&#x2F;appdash                      </a></td><td>go版本的分布式应用跟踪系统， 基于google dapper的原理构建</td><td>1622</td></tr><tr><td><a href="https://github.com/andot/hprose">andot&#x2F;hprose                      </a></td><td>Hprose 是高性能远程对象服务引擎（High Performance Remote Object Service Engine）的缩写 —— 微服务首选引擎。它是一个先进的轻量级的跨语言跨平台面向对象的高性能远程动态通讯中间件。它不仅简单易用，而且功能强大。你只需要稍许的时间去学习，就能用它轻松构建跨语言跨平台的分布式应用系统了。</td><td>609</td></tr></tbody></table><h1 id="CI-x2F-CD"><a href="#CI-x2F-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h1><table><thead><tr><th>项目</th><th>简介</th><th>Star数</th></tr></thead><tbody><tr><td><a href="https://github.com/drone/drone">drone&#x2F;drone                      </a></td><td>Drone 是一个基于 Docker 的持续发布平台，使用 Go 语言开发</td><td>20737</td></tr><tr><td><a href="https://github.com/caicloud/cyclone">caicloud&#x2F;cyclone                      </a></td><td>Cyclone 是一个打造容器工作流的云原生持续集成持续发布平台，简单易用，使用 Go 语言开发，有详尽的中文文档</td><td>877</td></tr></tbody></table><h1 id="数据库技术"><a href="#数据库技术" class="headerlink" title="数据库技术"></a>数据库技术</h1><table><thead><tr><th>项目</th><th>简介</th><th>Star数</th></tr></thead><tbody><tr><td><a href="https://github.com/pingcap/tidb">pingcap&#x2F;tidb                      </a></td><td>TiDB 是国内 PingCAP 团队开发的一个分布式 SQL 数据库。其灵感来自于 Google 的 F1, TiDB 支持包括传统 RDBMS 和 NoSQL 的特性。</td><td>22947</td></tr><tr><td><a href="https://github.com/influxdata/influxdb">influxdata&#x2F;influxdb                      </a></td><td>一个可以水平扩展的时间序列数据库， 内建http api， 支持对数据打tag，灵活的查询策略和数据的实时查询，支持类sql语句进行查询</td><td>18525</td></tr><tr><td><a href="https://github.com/cockroachdb/cockroach">cockroachdb&#x2F;cockroach                      </a></td><td>CockroachDB (蟑螂数据库）是一个可伸缩的、支持地理位置处理、支持事务处理的数据存储系统。CockroachDB 提供两种不同的的事务特性，包括快照隔离（snapshot isolation，简称SI）和顺序的快照隔离（SSI）语义，后者是默认的隔离级别。</td><td>17960</td></tr><tr><td><a href="https://github.com/google/cayley">google&#x2F;cayley                      </a></td><td>Cayley 是 Google 的一个开源图(Graph)数据库，其灵感来自于 Freebase 和 Google 的 Knowledge Graph 背后的图数据库。</td><td>13277</td></tr><tr><td><a href="https://github.com/dgraph-io/dgraph">dgraph-io&#x2F;dgraph                      </a></td><td>dgraph 是可扩展的，分布式的，低延迟图形数据库。DGraph 的目标是提供 Google 生产水平的规模和吞吐量，在超过TB的结构数据里，未用户提供足够低延迟的实时查询。DGraph 支持 GraphQL 作为查询语言，响应 JSON。</td><td>12759</td></tr><tr><td><a href="https://github.com/wandoulabs/codis">wandoulabs&#x2F;codis                      </a></td><td>Codis 是一个分布式 Redis 解决方案, 对于上层的应用来说, 连接到 Codis Proxy 和连接原生的 Redis Server 没有明显的区别 (不支持的命令列表), 上层应用可以像使用单机的 Redis 一样使用, Codis 底层会处理请求的转发, 不停机的数据迁移等工作, 所有后边的一切事情, 对于前面的客户端来说是透明的, 可以简单的认为后边连接的是一个内存无限大的 Redis 服务.</td><td>10927</td></tr><tr><td><a href="https://github.com/youtube/vitess">youtube&#x2F;vitess                      </a></td><td>outube出品的开源分布式MySQL工具集Vitess，自动分片存储MySQL数据表，将单个SQL查询改写为分布式发送到多个MySQL Server上，支持行缓存（比MySQL本身缓存效率高），支持复制容错，已用于Youtube生产环境</td><td>9720</td></tr><tr><td><a href="https://github.com/sosedoff/pgweb">sosedoff&#x2F;pgweb                      </a></td><td>gweb 是一个采用 Go 语言开发的基于 Web 的 PostgreSQL 管理系统。</td><td>6325</td></tr><tr><td><a href="https://github.com/flike/kingshard">flike&#x2F;kingshard                      </a></td><td>一个高性能的mysql中间件， 支持读写分离， 数据分片， 安全审计等功能</td><td>5070</td></tr><tr><td><a href="https://github.com/olivere/elastic">olivere&#x2F;elastic                      </a></td><td>elastic是开源搜索引擎elasticsearch的golang客户端，API友好，支持绝大部分es的接口,支持的es版本全面，从1.x到最新的6.x全覆盖</td><td>4822</td></tr><tr><td><a href="https://github.com/siddontang/ledisdb">siddontang&#x2F;ledisdb                      </a></td><td>ledisdb是一个参考ssdb，采用go实现，底层基于leveldb，类似redis的高性能nosql数据库，提供了kv，list，hash以及zset数据结构的支持。</td><td>3246</td></tr><tr><td><a href="https://github.com/XiaoMi/Gaea">XiaoMi&#x2F;Gaea                      </a></td><td>Gaea是小米商城&#x2F;系统组研发的基于mysql协议的数据库中间件，目前在小米商城大陆和海外得到广泛使用。</td><td>1408</td></tr><tr><td><a href="https://github.com/outbrain/orchestrator">outbrain&#x2F;orchestrator                      </a></td><td>MySQL 复制拓扑可视化工具</td><td>787</td></tr><tr><td><a href="https://github.com/slicebit/qb">slicebit&#x2F;qb                      </a></td><td>qb是用来让使更容易使用数据库的go语言的数据库工具包。它受Python最喜欢的ORM SQLAlchemy的启发，既是一个ORM，也是一个查询生成器。它在表达api和查询构建东西的情形下是相当模块化的。</td><td>524</td></tr><tr><td><a href="https://github.com/hidu/mysql-schema-sync">hidu&#x2F;mysql-schema-sync                      </a></td><td>mysql-schema-sync 是一款使用go开发的、跨平台的、绿色无依赖的 MySQL 表结构自动同步工具。用于将线上(其他环境)数据库结构变化同步到测试（本地）环境!</td><td>418</td></tr><tr><td><a href="https://github.com/chasex/redis-go-cluster">chasex&#x2F;redis-go-cluster                      </a></td><td>redis-go-cluster 是基于 Redigo 实现的 Golang Redis 客户端。redis-go-cluster 可以在本地缓存 slot 信息，并且当集群修改的时候会自动更新。此客户端管理每个节点连接池，使用 goroutine 来尽可能的并发执行，达到了高效，低延迟。</td><td>375</td></tr><tr><td><a href="https://github.com/mediocregopher/radix">mediocregopher&#x2F;radix                      </a></td><td>radix是redis官方推荐的客户端之一，相比于redigo,radix.v2特点是轻量、接口实现优雅、API友好</td><td>327</td></tr><tr><td><a href="https://github.com/goshawkdb/server">goshawkdb&#x2F;server                      </a></td><td>GoshawkDB 是一个采用 Go 语言开发支持多平台的分布式的对象存储服务，支持事务以及容错。GoshawkDB 的事务控制是在客户端完成的。GoshawkDB 服务器端使用 AGPL 许可，而 Go 语言客户端使用 Apache 许可证</td><td>204</td></tr><tr><td><a href="https://github.com/degdb/degdb">degdb&#x2F;degdb                      </a></td><td>DegDB 是分布式的经济图数据库。</td><td>201</td></tr></tbody></table><h1 id="存储技术"><a href="#存储技术" class="headerlink" title="存储技术"></a>存储技术</h1><table><thead><tr><th>项目</th><th>简介</th><th>Star数</th></tr></thead><tbody><tr><td><a href="https://github.com/ipfs/go-ipfs">ipfs&#x2F;go-ipfs                      </a></td><td>IPFS 是分布式文件系统，寻求连接所有计算机设备的相同文件系统。在某些方面，这很类似于原始的 Web 目标，但是 IPFS 最终会更像单个比特流群交换的 git 对象。IPFS ＝ InterPlanetary File System</td><td>9425</td></tr><tr><td><a href="https://github.com/chrislusf/seaweedfs">chrislusf&#x2F;seaweedfs                      </a></td><td>SeaweedFS 是简单，高伸缩性的分布式文件系统，包含两部分：存储数十亿的文件；快速为文件服务。SeaweedFS 作为支持全 POSIX 文件系统语义替代，Seaweed-FS 选择仅实现 key-file 的映射，类似 “NoSQL”，也可以说是 “NoFS”。</td><td>9348</td></tr><tr><td><a href="https://github.com/spf13/afero">spf13&#x2F;afero                      </a></td><td>Afero 是一个文件系统框架，提供一个简单、统一和通用的 API 和任何文件系统进行交互，作为抽象层还提供了界面、类型和方法。Afero 的界面十分简洁，设计简单，舍弃了不必要的构造函数和初始化方法。Afero 作为一个库还提供了一组可交互操作的后台文件系统，这样在与 Afero 协作时，还可以保留 os 和 ioutil 软件包的功能和好处。</td><td>2631</td></tr><tr><td><a href="https://github.com/coreos/torus">coreos&#x2F;torus                      </a></td><td>Torus是一种针对容器集群量身打造的存储系统，可以为通过Kubernetes编排和管理的容器集群提供可靠可扩展的存储。这是继etcd、rkt、flannel，以及CoreOS Linux之后CoreOS发布的另一个开源产品。</td><td>1800</td></tr><tr><td><a href="https://github.com/emccode/rexray">emccode&#x2F;rexray                      </a></td><td>REX-Ray 是一个 EMC {code} 团队领导的开源项目，为 Docker、Mesos 及其他容器运行环境提供持续的存储访问。其设计旨在囊括通用存储、虚拟化和云平台，提供高级的存储功能。</td><td>1743</td></tr><tr><td><a href="https://github.com/Terry-Mao/bfs">Terry-Mao&#x2F;bfs                      </a></td><td>bfs 是使用 Go 编写的分布式文件系统（小文件存储）。</td><td>1133</td></tr><tr><td><a href="https://github.com/gostor/gotgt">gostor&#x2F;gotgt                      </a></td><td>Gotgt 是使用 Go 编写的高性能、可扩展的 iSCSI target 服务。</td><td>161</td></tr></tbody></table><h1 id="分布式系统"><a href="#分布式系统" class="headerlink" title="分布式系统"></a>分布式系统</h1><table><thead><tr><th>项目</th><th>简介</th><th>Star数</th></tr></thead><tbody><tr><td><a href="https://github.com/chrislusf/seaweedfs">chrislusf&#x2F;seaweedfs                      </a></td><td>SeaweedFS 是简单，高伸缩性的分布式文件系统，包含两部分：存储数十亿的文件；快速为文件服务。SeaweedFS 作为支持全 POSIX 文件系统语义替代，Seaweed-FS 选择仅实现 key-file 的映射，类似 “NoSQL”，也可以说是 “NoFS”。</td><td>9348</td></tr><tr><td><a href="https://github.com/kelseyhightower/confd">kelseyhightower&#x2F;confd                      </a></td><td>Confd是一个轻量级的配置管理工具。通过查询Etcd，结合配置模板引擎，保持本地配置最新，同时具备定期探测机制，配置变更自动reload。</td><td>6887</td></tr><tr><td><a href="https://github.com/hashicorp/nomad">hashicorp&#x2F;nomad                      </a></td><td>Nomad 是一个集群管理器和调度器，专为微服务和批量处理工作流设计。Nomad 是分布式，高可用，可扩展到跨数据中心和区域的数千个节点。</td><td>5944</td></tr><tr><td><a href="https://github.com/chrislusf/glow">chrislusf&#x2F;glow                      </a></td><td>Glow 是使用 Go 编写的易用分布式计算系统，是 Hadoop Map Reduce，Spark，Flint，Samza 等等的替代品。Glow 的目标是提供一个库，可以在并行线程或者分布式集群机器中进行更简单计算。</td><td>2760</td></tr><tr><td><a href="https://github.com/chrislusf/gleam">chrislusf&#x2F;gleam                      </a></td><td>此处是一个通过Go和LuaJIT编写的快速和可扩展的分布式map&#x2F;reduce系统，很好的将Go的高并发性与Luajit高性能相结合，可独立运行或用于分布式计算。</td><td>2420</td></tr><tr><td><a href="https://github.com/purpleidea/mgmt">purpleidea&#x2F;mgmt                      </a></td><td>mgmt 是一个分布式的，事件驱动的配置管理工具。该工具支持并行执行，其 librarification 作为新的及已存在的软件的基础管理工具。</td><td>2197</td></tr><tr><td><a href="https://github.com/youtube/doorman">youtube&#x2F;doorman                      </a></td><td>Doorman 是一个客户端速率限制的解决方案，客户端与共享资源进行通讯，包括数据库、gRPC 服务、RESTful API 等等可使用 Doorman 来限制对资源的调用。Doorman 使用 Go 语言开发，使用 gRPC 的通讯协议。其高可用特性需要一个分布式的锁管理器，当前支持 etcd，也可使用 Zookeeper 替代。</td><td>1521</td></tr><tr><td><a href="https://github.com/nanopack/yoke">nanopack&#x2F;yoke                      </a></td><td>Yoke 是 Postgres 的高可用集群，具有自动切换和自动集群恢复。Postgres冗余&#x2F;自动故障转移解决方案，提供一个高可用PostgreSQL集群的简单管理。</td><td>1372</td></tr><tr><td><a href="https://github.com/huichen/zerg">huichen&#x2F;zerg                      </a></td><td>基于docker的分布式爬虫服务</td><td>464</td></tr><tr><td><a href="https://github.com/silenceper/dcmp">silenceper&#x2F;dcmp                      </a></td><td>DCMP是分布式配置管理平台。提供了一个etcd的管理界面，可通过界面修改配置信息，借助confd可实现配置文件的同步。</td><td>193</td></tr></tbody></table><h1 id="消息系统"><a href="#消息系统" class="headerlink" title="消息系统"></a>消息系统</h1><table><thead><tr><th>项目</th><th>简介</th><th>Star数</th></tr></thead><tbody><tr><td><a href="https://github.com/bitly/nsq">bitly&#x2F;nsq                      </a></td><td>NSQ 是无中心设计、节点自动注册和发现的开源消息系统。可作为内部通讯框架的基础，易于配置和发布。</td><td>17388</td></tr><tr><td><a href="https://github.com/RichardKnop/machinery">RichardKnop&#x2F;machinery                      </a></td><td>Machinery 是一个 Go 语言的异步任务队列和作业队列，基于分布式消息传递。类似 Python 的 Celery 框架。</td><td>3902</td></tr><tr><td><a href="https://github.com/blackbeans/kiteq">blackbeans&#x2F;kiteq                      </a></td><td>KiteQ 是一个基于 go + protobuff 实现的多种持久化方案的 mq 框架（消息队列）。</td><td>742</td></tr></tbody></table><h1 id="服务器管理"><a href="#服务器管理" class="headerlink" title="服务器管理"></a>服务器管理</h1><table><thead><tr><th>项目</th><th>简介</th><th>Star数</th></tr></thead><tbody><tr><td><a href="https://github.com/gravitational/teleport">gravitational&#x2F;teleport                      </a></td><td>teleport 是 初创公司Gravitational 的一款基于ssh和https的远程管理linux 集群服务器的工具， 其特点是支持双重校验登陆；操作记录回放；session共享，便于协作排障；自动发现集群的服务器和容器</td><td>7928</td></tr><tr><td><a href="https://github.com/square/sharkey">square&#x2F;sharkey                      </a></td><td>Sharkey 是OpenSSH管理证书使用的服务。Sharkey 分为客户端组件和服务端组件，服务端负责发布已签署的主机证书，客户端负责在机器上安装主机证书。</td><td>335</td></tr><tr><td><a href="https://github.com/idcos/osinstall">idcos&#x2F;osinstall                      </a></td><td>CloudBoot”(OSinstall)云装机平台，是金融云初创公司杭州云霁科技推出的一款X86服务器全自动装机工具，遵循Apache协议，完全开源免费。全自动构建物理机资源池，像创建虚拟机一样方便的安装物理机。</td><td>299</td></tr></tbody></table><h1 id="安全工具"><a href="#安全工具" class="headerlink" title="安全工具"></a>安全工具</h1><table><thead><tr><th>项目</th><th>简介</th><th>Star数</th></tr></thead><tbody><tr><td><a href="https://github.com/inconshreveable/ngrok">inconshreveable&#x2F;ngrok                      </a></td><td>ngrok 是一个反向代理，通过在公共的端点和本地运行的 Web 服务器之间建立一个安全的通道。ngrok 可捕获和分析所有通道上的流量，便于后期分析和重放。</td><td>18297</td></tr><tr><td><a href="https://github.com/yahoo/gryffin">yahoo&#x2F;gryffin                      </a></td><td>Gryffin 是雅虎开发的一个大规模 Web 安全扫描平台。它不是另外一个扫描器，其主要目的是为了解决两个特定的问题 —— 覆盖率和伸缩性。</td><td>2003</td></tr><tr><td><a href="https://github.com/xiam/hyperfox">xiam&#x2F;hyperfox                      </a></td><td>Hyperfox 是一个安全的工具用来代理和记录局域网中的 HTTP 和 HTTPS 通讯。</td><td>1310</td></tr><tr><td><a href="https://github.com/sheepbao/gomitmproxy">sheepbao&#x2F;gomitmproxy                      </a></td><td>GomitmProxy是想用golang语言实现的mitmproxy，主要实现http代理，目前实现了http代理和https抓包功能。</td><td>277</td></tr></tbody></table><h1 id="网络工具"><a href="#网络工具" class="headerlink" title="网络工具"></a>网络工具</h1><table><thead><tr><th>项目</th><th>简介</th><th>Star数</th></tr></thead><tbody><tr><td><a href="https://github.com/containous/traefik">containous&#x2F;traefik                      </a></td><td>Træfɪk 是一个新型的http反向代理、负载均衡软件，能轻易的部署微服务. 它支持多种后端 (Docker, Swarm, Mesos&#x2F;Marathon, Consul, Etcd, Zookeeper, BoltDB, Rest API, file…) ,可以对配置进行自动化、动态的管理.</td><td>28027</td></tr><tr><td><a href="https://github.com/buger/gor">buger&#x2F;gor                      </a></td><td>Gor 是用 Go 编写的简单 HTTP 流量复制工具，主要是为了从生产服务器返回流量到开发环境。使用 Gor 可以在实际的用户会话中测试代码。</td><td>12436</td></tr><tr><td><a href="https://github.com/cyfdecyf/cow">cyfdecyf&#x2F;cow                      </a></td><td>COW 是一个简化穿墙的 HTTP 代理服务器。它能自动检测被墙网站，仅对这些网站使用二级代理；支持多种协议：sock5、http、shadow、cow</td><td>8036</td></tr><tr><td><a href="https://github.com/google/seesaw">google&#x2F;seesaw                      </a></td><td>Seesaw 是 Google 开源的一个基于 Linux 的负载均衡系统。Seesaw 包含基本的负载均衡特性，同时支持一些高级的功能，诸如：anycast, Direct Server Return (DSR), 支持多个 VLANs 和集中式配置。同时其设计的宗旨是易于维护。需要注意的是，尽管该项目挂靠在 Google 名下，但并非 Google 官方产品。</td><td>4978</td></tr><tr><td><a href="https://github.com/mehrdadrad/mylg">mehrdadrad&#x2F;mylg                      </a></td><td>myLG是一个开源的网络工具集，它包含了很多不同类型的网络诊断工具, 功能包括ping，trace， bgp， dns lookup， 端口扫描， 局域网网络发现，提供web界面, tcpdump等</td><td>2293</td></tr><tr><td><a href="https://github.com/uber/tchannel">uber&#x2F;tchannel                      </a></td><td>TChannel 是用于 RPC 的网络复用和成帧协议。</td><td>1090</td></tr><tr><td><a href="https://github.com/GameXG/TcpRoute2">GameXG&#x2F;TcpRoute2                      </a></td><td>TcpRoute, TCP 层的路由器。对于 TCP 连接自动从多个线路(允许任意嵌套)、多个域名解析结果中选择最优线路。TcpRoute2 是 golang 重写的版本。通过 socks5 代理协议对外提供服务。代理功能拆分成了独立的库，详细代理url格式级选项请参见 ProxyClient，目前支持直连、socks4、socks4a、socks5、http、https、ss 代理线路</td><td>722</td></tr><tr><td><a href="https://github.com/jpillora/go-tcp-proxy">jpillora&#x2F;go-tcp-proxy                      </a></td><td>go-tcp-proxy是一个简单的tcp代理， 可以用于tcp端口转发， 也可以用做http代理使用</td><td>379</td></tr></tbody></table><h1 id="Web工具"><a href="#Web工具" class="headerlink" title="Web工具"></a>Web工具</h1><table><thead><tr><th>项目</th><th>简介</th><th>Star数</th></tr></thead><tbody><tr><td><a href="https://github.com/yudai/gotty">yudai&#x2F;gotty                      </a></td><td>GoTTY 是个简单的命令行工具，可以把 CLI 工具共享成 Web 应用。GoTTY 可以把终端作为 Web 应用共享。</td><td>13682</td></tr><tr><td><a href="https://github.com/valyala/fasthttp">valyala&#x2F;fasthttp                      </a></td><td>fasthttp 是 Go 的快速 HTTP 实现，当前在 1M 并发的生产环境使用非常成功，可以从单个服务器进行 100K qps 的持续连接。HTTP 服务器性能与 net&#x2F;http 比较，fasthttp 比 net&#x2F;http 快 10 倍</td><td>11804</td></tr><tr><td><a href="https://github.com/gizak/termui">gizak&#x2F;termui                      </a></td><td>Go语言编写的终端仪表盘</td><td>9661</td></tr><tr><td><a href="https://github.com/henrylee2cn/pholcus">henrylee2cn&#x2F;pholcus                      </a></td><td>Pholcus（幽灵蛛）是一款纯Go语言编写的高并发、分布式、重量级爬虫软件，支持单机、服务端、客户端三种运行模式，拥有Web、GUI、命令行三种操作界面；规则简单灵活、批量任务并发、输出方式丰富（mysql&#x2F;mongodb&#x2F;csv&#x2F;excel等）、有大量Demo共享；同时她还支持横纵向两种抓取模式，支持模拟登录和任务暂停、取消等一系列高级功能。</td><td>6297</td></tr><tr><td><a href="https://github.com/lonelycode/tyk">lonelycode&#x2F;tyk                      </a></td><td>Tyk 是一个开源的、轻量级的、快速可伸缩的 API 网关，支持配额和速度限制，支持认证和数据分析，支持多用户多组织，提供全 RESTful API。</td><td>5328</td></tr><tr><td><a href="https://github.com/etsy/hound">etsy&#x2F;hound                      </a></td><td>快如闪电的代码搜索开源工具</td><td>4345</td></tr><tr><td><a href="https://github.com/Terry-Mao/goim">Terry-Mao&#x2F;goim                      </a></td><td>goim 是一个支持集群的im及实时推送服务（支持websocket，http和tcp协议）</td><td>4009</td></tr><tr><td><a href="https://github.com/huichen/wukong">huichen&#x2F;wukong                      </a></td><td>WuKong 是一个全文搜索引擎。功能特性有：高效索引和搜索（1M条微博500M数据28秒索引完，1.65毫秒搜索响应时间，19K搜索QPS）；支持中文分词（使用sego分词包并发分词，速度27MB&#x2F;秒）；支持计算关键词在文本中的紧邻距离（token proximity）；支持计算BM25相关度；支持自定义评分字段和评分规则；支持在线添加、删除索引；支持持久存储；可实现分布式索引和搜索等</td><td>3553</td></tr><tr><td><a href="https://github.com/afex/hystrix-go">afex&#x2F;hystrix-go                      </a></td><td>用来隔离远程系统调用， 第三方库调用 ，服务调用， 提供熔断机制，避免雪崩效应的库， Hystrix的go 版本。 注Hystrixs是Netflix开源的一个java库</td><td>2407</td></tr><tr><td><a href="https://github.com/tus/tusd">tus&#x2F;tusd                      </a></td><td>实现文件上传的断点续传功能， 整套功能包含了协议实现，client， server。 client及server有多种语言的实现包括go， python， node等</td><td>1556</td></tr><tr><td><a href="https://github.com/codetainerapp/codetainer">codetainerapp&#x2F;codetainer                      </a></td><td>Codetainer 可以让你创建基于浏览器上的代码运行沙箱，可方便的嵌入到你的 Web 应用中。你可以把它当成是 codepicnic.com 的开源克隆) .</td><td>975</td></tr><tr><td><a href="https://github.com/ga0/netgraph">ga0&#x2F;netgraph                      </a></td><td>netgraph 是一个 Go 语言编写的跨平台的 B&#x2F;S 架构的 HTTP 抓包工具，方便在 Linux 服务器上直接查看 HTTP 包。</td><td>809</td></tr><tr><td><a href="https://github.com/andyxning/shortme">andyxning&#x2F;shortme                      </a></td><td>用Golang编写的URL短链接服务。</td><td>244</td></tr><tr><td><a href="https://github.com/hidu/pproxy">hidu&#x2F;pproxy                      </a></td><td>http抓包代理程序,http协议调试工具</td><td>237</td></tr></tbody></table><h1 id="Web框架"><a href="#Web框架" class="headerlink" title="Web框架"></a>Web框架</h1><table><thead><tr><th>项目</th><th>简介</th><th>Star数</th></tr></thead><tbody><tr><td><a href="https://github.com/gin-gonic/gin">gin-gonic&#x2F;gin                      </a></td><td>Gin 是一个用 Go 语言开发的 Web 框架，提供类 Martini 的 API，但是性能更好。因为有了 httprouter 性能提升了 40 倍之多。</td><td>36433</td></tr><tr><td><a href="https://github.com/astaxie/beego">astaxie&#x2F;beego                      </a></td><td>beego是一个用Go开发的应用框架，思路来自于tornado，路由设计来源于sinatra，</td><td>23525</td></tr><tr><td><a href="https://github.com/kataras/iris">kataras&#x2F;iris                      </a></td><td>通过Iris-Go，可以方便的帮助你来开发基于web的应用。简单来说：Iris-Go与国内大牛的BeeGo类似，但从其官方介绍的资料来看，Iris-Go的性能更优！</td><td>17776</td></tr><tr><td><a href="https://github.com/labstack/echo">labstack&#x2F;echo                      </a></td><td>Echo 是个快速的 HTTP 路由器（零动态内存分配），也是 Go 的微型 Web 框架。</td><td>16793</td></tr><tr><td><a href="https://github.com/codegangsta/martini">codegangsta&#x2F;martini                      </a></td><td>Martini 是一个非常新的 Go 语言的 Web 框架，使用 Go 的 net&#x2F;http 接口开发，类似 Sinatra 或者 Flask 之类的框架，你可使用自己的 DB 层、会话管理和模板。</td><td>10888</td></tr><tr><td><a href="https://github.com/hoisie/web">hoisie&#x2F;web                      </a></td><td>web.go 跟 web.py 类似，但使用的是 Go 编程语言实现的 Web 应用开发框架。Go发布没多久该框架就诞生了，差不多是最早的Go框架。目前已经有段时间没有更新了。不过，该框架代码不多，其源码可以读一读。</td><td>3440</td></tr><tr><td><a href="https://github.com/go-macaron/macaron">go-macaron&#x2F;macaron                      </a></td><td>Macaron 是一个具有高生产力和模块化设计的 Go Web 框架。框架秉承了 Martini 的基本思想，并在此基础上做出高级扩展。</td><td>2952</td></tr><tr><td><a href="https://github.com/gernest/utron">gernest&#x2F;utron                      </a></td><td>utron 是一个 Go 语言轻量级的 MVC 框架，用于快速构建可伸缩以及可靠的数据库驱动的 Web 应用。</td><td>2159</td></tr><tr><td><a href="https://github.com/olahol/melody">olahol&#x2F;melody                      </a></td><td>Melody 是一个 Go 语言的微型 WebSocket 框架，基于 github.com&#x2F;gorilla&#x2F;websocket 开发，</td><td>1771</td></tr><tr><td><a href="https://github.com/henrylee2cn/faygo">henrylee2cn&#x2F;faygo                      </a></td><td>Faygo 是一款快速、简洁的Go Web框架，可用极少的代码开发出高性能的Web应用程序（尤其是API接口）。只需定义 struct Handler，Faygo 就能自动绑定、验证请求参数并生成在线API文档。</td><td>1503</td></tr><tr><td><a href="https://github.com/lunny/tango">lunny&#x2F;tango                      </a></td><td>Tango，微内核可扩展的Go语言Web框架。同时支持函数和结构体作为执行体，插件丰富。</td><td>835</td></tr><tr><td><a href="https://github.com/robfig/revel">robfig&#x2F;revel                      </a></td><td>Revel 是 Go 语言的框架，其思路完全来自 Java 的 Play Framework。</td><td>159</td></tr><tr><td><a href="https://github.com/go-baa/baa">go-baa&#x2F;baa                      </a></td><td>Baa 一个简单高效的Go web开发框架。主要有路由、中间件，依赖注入和HTTP上下文构成。</td><td>141</td></tr></tbody></table><h1 id="区块链技术"><a href="#区块链技术" class="headerlink" title="区块链技术"></a>区块链技术</h1><table><thead><tr><th>项目</th><th>简介</th><th>Star数</th></tr></thead><tbody><tr><td><a href="https://github.com/ethereum/go-ethereum">ethereum&#x2F;go-ethereum                      </a></td><td>go-ethereum客户端通常被称为geth，它是个命令行界面，执行在Go上实现的完整以太坊节点。通过安装和运行geth，可以参与到以太坊前台实时网络并进行以下操作：a. 挖掘真的以太币  b. 在不同地址间转移资金 c .创建合约，发送交易  d . 探索区块历史 e.很多其他功能</td><td>25587</td></tr><tr><td><a href="https://github.com/hyperledger/fabric">hyperledger&#x2F;fabric                      </a></td><td>Fabric是一个开源区块链实现，开发环境建立在VirtualBox虚拟机上，部署环境可以自建网络，也可以直接部署在BlueMix上，部署方式可传统可docker化，共识达成算法插件化，支持用Go和JavaScript开发智能合约，尤以企业级的安全机制和membership机制为特色。你要是不知道这些术语什么意思，就记住一点，Fabric之于区块链，很可能正如Hadoop之于大数据。</td><td>9967</td></tr><tr><td><a href="https://github.com/chain/chain">chain&#x2F;chain                      </a></td><td>**金融领域的区块链项目 **. Chain是由一家刚成立两年的美国创业公司Chain推出，是一个企业级的区块链平台架构，可以让机构构造从零开始更好的金融服务。Chain 开放标准在以下方面实现突破：• 全新的共识模型在不到一秒的时间里实现交易的最终完成，即便是交易量非常大也能支持;• 私密解决方案对区块链数据进行加密，并让相关对手方和监管者进行有选择的读取;• 智能合约框架和虚拟机支持简单的规则执行，以及进行键值存储的图灵完整程序; • 可伸缩的数据模型可以为网络参与者降低运行负荷; • 丰富的元数据层可支持满足KYC（了解你的客户）和 AML（反洗钱）要求</td><td>1671</td></tr></tbody></table><h1 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h1><table><thead><tr><th>项目</th><th>简介</th><th>Star数</th></tr></thead><tbody><tr><td><a href="https://github.com/gohugoio/hugo">gohugoio&#x2F;hugo                      </a></td><td>Hugo是由Go语言实现的静态网站生成器；简单、易用、高效、易扩展、快速部署；相比于Hexo、Jekyll，hugo的优势是生成速度极快。</td><td>42615</td></tr><tr><td><a href="https://github.com/mattermost/platform">mattermost&#x2F;platform                      </a></td><td>mattermost 是一个 Slack 的开源替代品。Mattermost 采用 Go 语言开发，这是一个开源的团队通讯服务。为团队带来跨 PC 和移动设备的消息、文件分享，提供归档和搜索功能。</td><td>17854</td></tr><tr><td><a href="https://github.com/grpc/grpc-go">grpc&#x2F;grpc-go                      </a></td><td>GRPC 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP&#x2F;2 设计。目前提供 C、Java 和 Go 语言版本，分别是：grpc, grpc-java, grpc-go. 其中 C 版本支持 C, C++, Node.js, Python, Ruby, Objective-C, PHP 和 C# 支持.GRPC 基于 HTTP&#x2F;2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。</td><td>10893</td></tr><tr><td><a href="https://github.com/Netflix/chaosmonkey">Netflix&#x2F;chaosmonkey                      </a></td><td>Chaos Monkey是netflix公司开源的一个用于服务可用性测试的工具，通过有计划的在生产系统制造真实的故障（如cpu负载高， 内存溢出，磁盘写满，服务器宕机等）来检测系统的可用性。</td><td>8257</td></tr><tr><td><a href="https://github.com/apex/apex">apex&#x2F;apex                      </a></td><td>管理，部署aws lambda函数的工具， 支持用go语言编写lambda函数（注：目前aws官方不支持用go语言编写lambda函数，但是apex却可以变相支持）</td><td>8004</td></tr><tr><td><a href="https://github.com/rakyll/hey">rakyll&#x2F;hey                      </a></td><td>Boom 是 google 一女工程师使用 Go 语言开发的类似 apache ab 的性能测试工具。相比 ab，boom跨平台性更好，而且更容易安装。</td><td>7859</td></tr><tr><td><a href="https://github.com/visualfc/liteide">visualfc&#x2F;liteide                      </a></td><td>LiteIDE是一款开源、跨平台的轻量级Go语言集成开发环境（IDE）。</td><td>5925</td></tr><tr><td><a href="https://github.com/yinghuocho/firefly-proxy">yinghuocho&#x2F;firefly-proxy                      </a></td><td>穿墙工具。 GFW梯子。 提供客户端和服务端。支持多个平台， 包括linux， macos， windows ，android</td><td>4964</td></tr><tr><td><a href="https://github.com/qor/qor">qor&#x2F;qor                      </a></td><td>Qor 是基于 Golang 开发的的CMS 一系列工具库，基于 Qor可以快速搭建网站的后台管理系统。Qor 的工作库包含：1，后台管理：可以对数据库进去 CURD 管理，支持一对一，一对多，多对多关联关系维护等等； 2，支持上传图片到云以及 filesystem，resize、crop 图片等等 ；3，Publish 发布系统，可以修改数据，并且经过检查后，再发布到正式环境中； 4，状态机，可以用于开发工作流的系统； 5，I18n，翻译，可以通过在 WEB 界面翻译，并将翻译保存到数据库中； 6，L10n，本地化，不同于翻译，他可以针对某个地区来对内容，或者数据结构进行本地化。7，Roles，权限管理； 8，Exchange，通过 Excel，CSV 导入导出数据； 9，Worker，后台任务管理，可用于跑定时任务等等</td><td>4325</td></tr><tr><td><a href="https://github.com/golang/mobile">golang&#x2F;mobile                      </a></td><td>Gomobile是一个应用于iOS和Android的优秀跨平台开发库，为开发者提供用于创建Android和iOS 移动平台代码的工具。</td><td>4074</td></tr><tr><td><a href="https://github.com/getlantern/lantern">getlantern&#x2F;lantern                      </a></td><td>Lantern是一个点对点科学上网软件。</td><td>2469</td></tr><tr><td><a href="https://github.com/vzex/dog-tunnel">vzex&#x2F;dog-tunnel                      </a></td><td>狗洞是一个高速的 P2P 端口映射工具，同时支持Socks5代理。 0.5版后开始开源，UDP底层基于开源库KCP重写，效率大大提高，在恶劣环境下优势明显。 同时提供非P2P版本（Lite版本），两端连接过程完全不依赖中间服务器，支持加密和登陆认证，自动重连，但是需要人为确保两端能正常连通（否则请使用默认的P2P版本）</td><td>1782</td></tr><tr><td><a href="https://github.com/prasmussen/glot">prasmussen&#x2F;glot                      </a></td><td>glot 是可以可以在线运行各种编程语言代码片段的平台，项目采用 Haskell Script 、Go、Erlang 和 Shell 开发，运行环境基于 Docker 容器进行。</td><td>1268</td></tr><tr><td><a href="https://github.com/yanyiwu/gojieba">yanyiwu&#x2F;gojieba                      </a></td><td>“结巴”中文分词的Golang语言版本。</td><td>1014</td></tr><tr><td><a href="https://github.com/mikespook/gorbac">mikespook&#x2F;gorbac                      </a></td><td>goRBAC 为 Go 语言应用提供了轻量级的基于角色的访问控制。</td><td>998</td></tr><tr><td><a href="https://github.com/mailslurper/mailslurper">mailslurper&#x2F;mailslurper                      </a></td><td>MailSlurper 是一个便携的 SMTP 邮件服务器，对本地和团队应用开发来说非常有用。MailSlurper 体积小运行快速，支持 SQLite, MSSQL 和 MySQL. 数据库。</td><td>691</td></tr><tr><td><a href="https://github.com/xjdrew/kone">xjdrew&#x2F;kone                      </a></td><td>可用于家庭或者企业网络的透明代理，可用来翻墙等</td><td>621</td></tr><tr><td><a href="https://github.com/codeskyblue/gosuv">codeskyblue&#x2F;gosuv                      </a></td><td>进程管理， 类似于python的supervisord ， 提供了web管理界面</td><td>591</td></tr><tr><td><a href="https://github.com/oikomi/FishChatServer2">oikomi&#x2F;FishChatServer2                      </a></td><td>FishChat（鱼传——鱼传尺素）分布式可伸缩 IM 服务器，是一款纯 golang 编写优秀的即时通讯软件(IM), 它集合了市面上已有产品的优点, 并具备 智能硬件网关管理(学习QQ物联思想, 构思中)。</td><td>466</td></tr><tr><td><a href="https://github.com/rafael-santiago/cherry">rafael-santiago&#x2F;cherry                      </a></td><td>Cherry 是一个使用 Go 语言开发的 Web 聊天引擎。</td><td>215</td></tr><tr><td><a href="https://github.com/robustirc/robustirc">robustirc&#x2F;robustirc                      </a></td><td>RobustIRC 是不会有网络中断情况的 IRC。RobustIRC 主要特性：服务器不可用的时候不会有网络中断； 可以使用标准 IRC 客户端； 健壮，可以很好处理客户端和网络的连接问题</td><td>126</td></tr></tbody></table><p><strong><a href="#%E7%9B%AE%E5%BD%95">⬆ 返回顶部</a></strong></p>]]></content>
    
    
    <categories>
      
      <category>开源项目</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>开源项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>开源的RPC框架</title>
    <link href="/2021/04/11/%E5%BC%80%E6%BA%90%E7%9A%84RPC%E6%A1%86%E6%9E%B6/"/>
    <url>/2021/04/11/%E5%BC%80%E6%BA%90%E7%9A%84RPC%E6%A1%86%E6%9E%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>开源的RPC框架主要分为两大类：</p><p>一类是跟某种特定语言平台绑定的，另一类是与语言无关即跨语言平台的。</p><p>本文主要列举一些在行业内比较流行的框架。</p><h4 id="跟语言平台绑定的开源-RPC-框架"><a href="#跟语言平台绑定的开源-RPC-框架" class="headerlink" title="跟语言平台绑定的开源 RPC 框架"></a>跟语言平台绑定的开源 RPC 框架</h4><ul><li>Dubbo：国内最早开源的 RPC 框架，由阿里巴巴公司开发并于 2011 年末对外开源，仅支持 Java 语言。</li><li>Motan：微博内部使用的 RPC 框架，于 2016 年对外开源，仅支持 Java 语言。</li><li>Tars：腾讯内部使用的 RPC 框架，于 2017 年对外开源，仅支持 C++ 语言。</li><li>Spring Cloud：国外 Pivotal 公司 2014 年对外开源的 RPC 框架，仅支持 Java 语言</li></ul><h4 id="跨语言平台的开源-RPC-框架"><a href="#跨语言平台的开源-RPC-框架" class="headerlink" title="跨语言平台的开源 RPC 框架"></a>跨语言平台的开源 RPC 框架</h4><ul><li>gRPC：Google 于 2015 年对外开源的跨语言 RPC 框架，支持多种语言。</li><li>Thrift：最初是由 Facebook 开发的内部系统跨语言的 RPC 框架，2007 年贡献给了 Apache 基金，成为 Apache 开源项目之一，支持多种语言。</li><li>hprose：一个MIT开源许可的新型轻量级跨语言跨平台的面向对象的高性能远程动态通讯中间件。它支持众多语言:nodeJs, C++, .NET, Java, Delphi, Objective-C, ActionScript, JavaScript, ASP, PHP, Python, Ruby, Perl, Golang 。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h4 id="Dubbo"><a href="#Dubbo" class="headerlink" title="Dubbo"></a>Dubbo</h4><p>先来聊聊 Dubbo，Dubbo 可以说是国内开源最早的 RPC 框架了，目前只支持 Java 语言，它的架构可以用下面这张图展示。</p><p><img src="https://www.cmdbyte.com/2021/02/Dubbo_%E6%9E%B6%E6%9E%84.webp" alt="Dubbo_架构"></p><p>从图中你能看到，Dubbo 的架构主要包含四个角色，其中 Consumer 是服务消费者，Provider 是服务提供者，Registry 是注册中心，Monitor 是监控系统。</p><p>具体的交互流程是 Consumer 一端通过注册中心获取到 Provider 节点后，通过 Dubbo 的客户端 SDK 与 Provider 建立连接，并发起调用。Provider 一端通过 Dubbo 的服务端 SDK 接收到 Consumer 的请求，处理后再把结果返回给 Consumer。</p><h4 id="Motan"><a href="#Motan" class="headerlink" title="Motan"></a>Motan</h4><p>Motan 是国内另外一个比较有名的开源的 RPC 框架，同样也只支持 Java 语言实现，它的架构可以用下面这张图描述。</p><p><img src="https://www.cmdbyte.com/2021/02/Motan_%E6%9E%B6%E6%9E%84.webp" alt="Motan_架构"></p><p>Motan 与 Dubbo 的架构类似，都需要在 Client 端（服务消费者）和 Server 端（服务提供者）引入 SDK，其中 Motan 框架主要包含下面几个功能模块。</p><ul><li>register：用来和注册中心交互，包括注册服务、订阅服务、服务变更通知、服务心跳发送等功能。</li><li>protocol：用来进行 RPC 服务的描述和 RPC 服务的配置管理，这一层还可以添加不同功能的 filter 用来完成统计、并发限制等功能。</li><li>serialize：将 RPC 请求中的参数、结果等对象进行序列化与反序列化</li><li>transport：用来进行远程通信，默认使用 Netty NIO 的 TCP 长链接方式。</li><li>cluster：请求时会根据不同的高可用与负载均衡策略选择一个可用的 Server 发起远程调用。</li></ul><h4 id="Tars"><a href="#Tars" class="headerlink" title="Tars"></a>Tars</h4><p>Tars 是腾讯根据内部多年使用微服务架构的实践，总结而成的开源项目，仅支持 C++ 语言，它的架构图如下。</p><p><img src="https://www.cmdbyte.com/2021/02/Tars_%E6%9E%B6%E6%9E%84.webp" alt="Tars_架构"></p><p>Tars 的架构交互主要包括以下几个流程：</p><ol><li>服务发布流程：在 web 系统上传 server 的发布包到 patch，上传成功后，在 web 上提交发布 server 请求，由 registry 服务传达到 node，然后 node 拉取 server 的发布包到本地，拉起 server 服务。</li><li>管理命令流程：web 系统上的可以提交管理 server 服务命令请求，由 registry 服务传达到 node 服务，然后由 node 向 server 发送管理命令。</li><li>心跳上报流程：server 服务运行后，会定期上报心跳到 node，node 然后把服务心跳信息上报到 registry 服务，由 registry 进行统一管理。</li><li>信息上报流程：server 服务运行后，会定期上报统计信息到 stat，打印远程日志到 log，定期上报属性信息到 prop、上报异常信息到 notify、从 config 拉取服务配置信息。</li><li>client 访问 server 流程：client 可以通过 server 的对象名 Obj 间接访问 server，client 会从 registry 上拉取 server 的路由信息（如 IP、Port 信息），然后根据具体的业务特性（同步或者异步，TCP 或者 UDP 方式）访问 server（当然 client 也可以通过 IP&#x2F;Port 直接访问 server）。</li></ol><h4 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h4><p>Spring Cloud 利用 Spring Boot 特性整合了开源行业中优秀的组件，整体对外提供了一套在微服务架构中服务治理的解决方案。</p><p>只支持 Java 语言平台，它的架构图可以用下面这张图来描述。</p><p><img src="https://www.cmdbyte.com/2021/02/Spring_Cloud_%E6%9E%B6%E6%9E%84.webp" alt="Spring_Cloud_架构"></p><p>由此可见，Spring Cloud 微服务架构是由多个组件一起组成的，各个组件的交互流程如下。</p><ol><li>请求统一通过 API 网关 Zuul 来访问内部服务，先经过 Token 进行安全认证。</li><li>通过安全认证后，网关 Zuul 从注册中心 Eureka 获取可用服务节点列表。</li><li>从可用服务节点中选取一个可用节点，然后把请求分发到这个节点。</li><li>整个请求过程中，Hystrix 组件负责处理服务超时熔断，Turbine 组件负责监控服务间的调用和熔断相关指标，Sleuth 组件负责调用链监控，ELK 负责日志分析。</li></ol><h4 id="gRPC"><a href="#gRPC" class="headerlink" title="gRPC"></a>gRPC</h4><p>先来看下 gRPC，它的原理是通过 IDL（Interface Definition Language）文件定义服务接口的参数和返回值类型，然后通过代码生成程序生成服务端和客户端的具体实现代码，这样在 gRPC 里，客户端应用可以像调用本地对象一样调用另一台服务器上对应的方法。</p><img src="https://www.cmdbyte.com/2021/02/grpc%E4%BB%8B%E7%BB%8D.png" alt="grpc介绍" style="zoom:50%;" /><p>它的主要特性包括三个方面。</p><ol><li>通信协议采用了 HTTP&#x2F;2，因为 HTTP&#x2F;2 提供了连接复用、双向流、服务器推送、请求优先级、首部压缩等机制</li><li>IDL 使用了ProtoBuf，ProtoBuf 是由 Google 开发的一种数据序列化协议，它的压缩和传输效率极高，语法也简单</li><li>多语言支持，能够基于多种语言自动生成对应语言的客户端和服务端的代码。</li></ol><h4 id="Thrift"><a href="#Thrift" class="headerlink" title="Thrift"></a>Thrift</h4><p>再来看下 Thrift，Thrift 是一种轻量级的跨语言 RPC 通信方案，支持多达 25 种编程语言。为了支持多种语言，跟 gRPC 一样，Thrift 也有一套自己的接口定义语言 IDL，可以通过代码生成器，生成各种编程语言的 Client 端和 Server 端的 SDK 代码，这样就保证了不同语言之间可以相互通信。它的架构图可以用下图来描述。</p><p><img src="https://www.cmdbyte.com/2021/02/Thrift_%E6%9E%B6%E6%9E%84.webp" alt="Thrift_架构"></p><p>从这张图上可以看出 Thrift RPC 框架的特性。</p><ol><li>支持多种序列化格式：如 Binary、Compact、JSON、Multiplexed 等。</li><li>支持多种通信方式：如 Socket、Framed、File、Memory、zlib 等。</li><li>服务端支持多种处理方式：如 Simple 、Thread Pool、Non-Blocking 等。</li></ol><h4 id="Hprose"><a href="#Hprose" class="headerlink" title="Hprose"></a>Hprose</h4><p> Hprose (High Performance Remote Object Service Engine) 是一个MIT开源许可的新型轻量级跨语言跨平台的面向对象的高性能远程动态通讯中间件。它支持众多语言，例如nodeJs, C++, .NET, Java, Delphi, Objective-C, ActionScript, JavaScript, ASP, PHP, Python, Ruby, Perl 等语言，通过 Hprose 可以在这些语言之间实现方便且高效的互通。 Hprose 易学易用，且功能强大，您只需很短时间的学习，就可以用它方便地构建出跨语言跨平台分布式的电信级应用系统。</p><p><a href="https://hprose.com/">Hprose Home</a></p>]]></content>
    
    
    <categories>
      
      <category>RPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RPC</tag>
      
      <tag>框架</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>防火墙firewall</title>
    <link href="/2021/04/11/%E9%98%B2%E7%81%AB%E5%A2%99firewall/"/>
    <url>/2021/04/11/%E9%98%B2%E7%81%AB%E5%A2%99firewall/</url>
    
    <content type="html"><![CDATA[<p>从Cent OS 7.0开始，Cent OS 默认使用<code>firewall</code>作为其防火墙。</p><h2 id="firewall-常用命令"><a href="#firewall-常用命令" class="headerlink" title="firewall 常用命令"></a>firewall 常用命令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">firewall-cmd --state                           <span class="hljs-comment"># 查看防火墙状态，是否是running</span><br>firewall-cmd --reload                          <span class="hljs-comment"># 重新载入配置，比如添加规则之后，需要执行此命令</span><br>firewall-cmd --get-zones                       <span class="hljs-comment"># 列出支持的zone</span><br>firewall-cmd --get-services                    <span class="hljs-comment"># 列出支持的服务，在列表中的服务是放行的</span><br>firewall-cmd --query-service ftp               <span class="hljs-comment"># 查看ftp服务是否支持，返回yes或者no</span><br>firewall-cmd --add-service=ftp                 <span class="hljs-comment"># 临时开放ftp服务</span><br>firewall-cmd --add-service=ftp --permanent     <span class="hljs-comment"># 永久开放ftp服务</span><br>firewall-cmd --remove-service=ftp --permanent  <span class="hljs-comment"># 永久移除ftp服务</span><br>firewall-cmd --add-port=80/tcp --permanent     <span class="hljs-comment"># 永久添加80端口 </span><br>iptables -L -n                                 <span class="hljs-comment"># 查看规则，这个命令是和iptables的相同的</span><br>man firewall-cmd                               <span class="hljs-comment"># 查看帮助</span><br></code></pre></td></tr></table></figure><h2 id="用法实例"><a href="#用法实例" class="headerlink" title="用法实例"></a>用法实例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 开启80端口</span><br>firewall-cmd --zone=public --add-port=80/tcp --permanent<br><span class="hljs-comment"># 参数解析：</span><br><span class="hljs-comment"># --zone               # 作用域</span><br><span class="hljs-comment"># --add-port=80/tcp    # 添加端口，格式为：端口/通讯协议</span><br><span class="hljs-comment"># --permanent          # 永久生效，没有此参数重启后失效</span><br><br><span class="hljs-comment"># 启动防火墙</span><br>systemctl start firewalld.service   <br><br><span class="hljs-comment"># 关闭防火墙</span><br>systemctl stop firewalld.service   <br><br><span class="hljs-comment"># 禁止firewall开机启动</span><br>systemctl <span class="hljs-built_in">disable</span> firewalld.service       <br><br><span class="hljs-comment"># 重启防火墙</span><br>firewall-cmd --reload<br><br><span class="hljs-comment"># 查看防火墙状态</span><br>systemctl status firewalld.service<br><br><span class="hljs-comment"># 查看防火墙规则</span><br>iptables -L -n<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>firewall</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>防火墙iptables</title>
    <link href="/2021/04/11/%E9%98%B2%E7%81%AB%E5%A2%99iptables/"/>
    <url>/2021/04/11/%E9%98%B2%E7%81%AB%E5%A2%99iptables/</url>
    
    <content type="html"><![CDATA[<p>从Cent OS 7.0开始，Cent OS 默认使用<code>firewall</code>作为其防火墙。若使用<code>iptable</code>，需要关闭<code>firewall</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 1、直接关闭firewalld防火墙</span><br>systemctl stop firewalld.service        <span class="hljs-comment">#停止firewall</span><br>systemctl <span class="hljs-built_in">disable</span> firewalld.service     <span class="hljs-comment">#禁止firewall开机启动</span><br><br><span class="hljs-comment"># 2、安装 iptables service</span><br>yum -y install iptables-services<br><br><span class="hljs-comment"># 如果要修改防火墙配置，如增加防火墙端口3306</span><br>vi /etc/sysconfig/iptables <br><span class="hljs-comment"># 增加规则</span><br>-A INPUT -m state --state NEW -m tcp -p tcp --dport 3306 -j ACCEPT<br><br><span class="hljs-comment"># 保存退出后</span><br>systemctl restart iptables.service    <span class="hljs-comment">#重启防火墙使配置生效</span><br>systemctl <span class="hljs-built_in">enable</span> iptables.service     <span class="hljs-comment">#设置防火墙开机启动</span><br><br><span class="hljs-comment"># 最后重启系统使设置生效。</span><br></code></pre></td></tr></table></figure><h2 id="iptables-配置"><a href="#iptables-配置" class="headerlink" title="iptables 配置"></a>iptables 配置</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看iptables配置</span><br>iptables -L -n<br><br><span class="hljs-comment"># 添加常用端口规则：</span><br><span class="hljs-comment">#允许对外请求的返回包</span><br>iptables -A INPUT -m state --state RELATED,ESTABLISHED -j ACCEPT<br><span class="hljs-comment">#允许icmp包通过</span><br>iptables -A INPUT -p icmp --icmp-type any -j ACCEPT<br><span class="hljs-comment">#允许来自于lo接口的数据包，如果没有此规则，将不能通过127.0.0.1访问本地服务</span><br>iptables -A INPUT -i lo -j ACCEPT<br> <br><span class="hljs-comment">#常用端口</span><br>iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport 21 -j ACCEPT<br>iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport 22 -j ACCEPT<br>iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport 23 -j ACCEPT<br>iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport 80 -j ACCEPT<br>iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport 443 -j ACCEPT<br>iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport 3306 -j ACCEPT<br>iptables -A INPUT -p tcp -m state --state NEW -m tcp --dport 8080 -j ACCEPT<br><br><span class="hljs-comment">#过滤所有非以上规则的请求</span><br>iptables -P INPUT DROP<br><br><span class="hljs-comment">#如果要添加内网ip信任（接受其所有TCP请求）</span><br><span class="hljs-comment">#注：(**.**.**.**)为IP,下同</span><br>iptables -A INPUT -p tcp -s **.**.**.** -j ACCEPT<br><br><span class="hljs-comment">#要封停一个IP，使用下面这条命令</span><br>iptables -I INPUT -s **.**.**.** -j DROP<br><span class="hljs-comment">#要解封一个IP，使用下面这条命令</span><br>iptables -D INPUT -s **.**.**.** -j DROP<br><br><span class="hljs-comment"># 保存重启防火墙</span><br>/etc/init.d/iptables save<br>service iptables restart<br></code></pre></td></tr></table></figure><h2 id="用法实例"><a href="#用法实例" class="headerlink" title="用法实例"></a>用法实例</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#允许所有入栈规则</span><br>iptables -P INPUT ACCEPT<br><br><span class="hljs-comment">#清空默认所有规则</span><br>iptables -F<br><br><span class="hljs-comment">#清空自定义的所有规则</span><br>iptables -X<br><br><span class="hljs-comment">#计数器置0</span><br>iptables -Z<br><br><span class="hljs-comment"># 关闭端口,常用删除端口规则命令</span><br><span class="hljs-comment"># 查看当前端口所在行数</span><br>iptables -L -n --line-number<br><br><span class="hljs-comment"># 删除指定序列的端口（下面是删除第五条端口）</span><br>iptables -D INPUT 5<br><br><span class="hljs-comment"># 确认是否已经删除，可以重新查看列表</span><br>iptables -L -n --line-number<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>iptables</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux终端调用可视化程序打开文件或路径</title>
    <link href="/2021/04/11/Linux%E7%BB%88%E7%AB%AF%E8%B0%83%E7%94%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%88%96%E8%B7%AF%E5%BE%84/"/>
    <url>/2021/04/11/Linux%E7%BB%88%E7%AB%AF%E8%B0%83%E7%94%A8%E5%8F%AF%E8%A7%86%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%89%93%E5%BC%80%E6%96%87%E4%BB%B6%E6%88%96%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p>一般在控制台中，可以使用命令操作各式文本文件。但有些时候，我们需要在当前位置打开文件管理器或者其他的界面程序比如用<code>Word</code>打开<code>.doc</code>文件等。</p><p>常规做法是，打开文件管理器，再一层层点进对应目录，找到对应文件，再双击打开。如果文件层级很深，这将是一个很费力的操作。</p><p>其实在终端，我们可以通过命令调用某些程序，直接打开文件或者路径。</p><h3 id="方式一-借助nautilus"><a href="#方式一-借助nautilus" class="headerlink" title="方式一: 借助nautilus"></a>方式一: 借助nautilus</h3><p><code>nautilus</code> 是 <code>Ubuntu</code> 下默认的文件管理器。<br>在控制台可以使用 <code>nautilus</code> 命令打开文件管理器，并且文件管理器界面所处的路径和当前终端相同。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nautilus &lt;path&gt;<br></code></pre></td></tr></table></figure><p>为了更方便的使用该命令，可以为它添加 <code>alias</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">alias opendir=&#x27;nautilus&#x27;<br></code></pre></td></tr></table></figure><h3 id="方式二：直接打开"><a href="#方式二：直接打开" class="headerlink" title="方式二：直接打开"></a>方式二：直接打开</h3><p>大多数软件安装后都是可以从命令行调用启动的，如果不能在终端调用，也可以找到其安装路径，将其添加到环境变量中。</p><p>因此直接调用对应的应用程序，打开对应文件。例如</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wps xxx.doc<br>FoxitReader xxx.pdf<br></code></pre></td></tr></table></figure><h3 id="方式三：xdg-open"><a href="#方式三：xdg-open" class="headerlink" title="方式三：xdg-open"></a>方式三：xdg-open</h3><p>上面介绍的两种方式需要记住两类命令，一类是打开路径的，一类是打开文件的，但我们用鼠标无论是打开文件夹还是打开文件都只有一个操作–双击，其背后的原理就是文件夹或文件的打开都绑定了一个默认操作它的程序。</p><p>所以，我们可以使用<code>xdg-open</code>命令打开文件或文件夹，剩下的具体用什么程序打开，交给系统去判断。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">xdg-open xxx.doc<br>xdg-open xxx.pdf<br>xdg-open xxx.png<br>xdg-open xxx.mp4<br>xdg-open .<br>xdg-open ~/Downloads<br></code></pre></td></tr></table></figure><p><code>xdg-open</code>命令还有一个操作，就是可以传入网址，系统监测到是网址，于是调用默认的浏览器去打开它。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">xdg-open https://www.baidu.com<br></code></pre></td></tr></table></figure><p>总之，<code>xdg-open</code>可以完成所有你用鼠标双击的操作，都是调用默认的程序去打开对应的文件。</p><p>为了方便输入这个命令，同样可以给它添加一个<code>alias</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">alias dakai=&#x27;xdg-open&#x27;<br>alias 打开=&#x27;xdg-open&#x27;<br></code></pre></td></tr></table></figure><p>我们看到我们添加了两个<code>alias</code>，于是就实现了输入英文或者输入中文都能使用<code>xdg-open</code>的操作，免去了在终端还有切换一次中英文的操作。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux问题之WARNING REMOTE HOST IDENTIFICATION HAS CHANGED!</title>
    <link href="/2021/04/10/Linux%E9%97%AE%E9%A2%98%E4%B9%8BWARNING-REMOTE-HOST-IDENTIFICATION-HAS-CHANGED/"/>
    <url>/2021/04/10/Linux%E9%97%AE%E9%A2%98%E4%B9%8BWARNING-REMOTE-HOST-IDENTIFICATION-HAS-CHANGED/</url>
    
    <content type="html"><![CDATA[<p>在使用<code>ssh</code> 传输文件时，报了下面的问题：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs txt">[root@xx]# scp xxx.tar root@192.168.13.14:/root/<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @<br>@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@<br>IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!<br>Someone could be eavesdropping on you right now (man-in-the-middle attack)!<br>It is also possible that a host key has just been changed.<br>The fingerprint for the ECDSA key sent by the remote host is<br>SHA256:9XvufSSIeZ7MAurIZ1Qw9Z13YV1Zcim2kthmECgYw.<br>Please contact your system administrator.<br>Add correct host key in /root/.ssh/known_hosts to get rid of this message.<br>Offending ECDSA key in /root/.ssh/known_hosts:8<br>ECDSA host key for 192.168.13.14 has changed and you have requested strict checking.<br>Host key verification failed.<br>lost connection<br></code></pre></td></tr></table></figure><p>文件传输不过去，只需要删除<code>.ssh</code>目录下的known_hosts文件就能传输了。<br><code>rm -rf ~/.ssh/known_hosts</code></p><p>应该是之前进行过传输，生成了这么一个认证文件，后来另一台机器可能重装系统了，但是路由器分给它的内网IP没有变，但是在通信认证的时候发现和原先的认证记录对不起来，造成了这个问题。这是我的个人猜测，如果有更好的简介，欢迎留言交流。</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux安装Python和配置Pip</title>
    <link href="/2021/04/08/Linux%E5%AE%89%E8%A3%85Python%E5%92%8C%E9%85%8D%E7%BD%AEPip/"/>
    <url>/2021/04/08/Linux%E5%AE%89%E8%A3%85Python%E5%92%8C%E9%85%8D%E7%BD%AEPip/</url>
    
    <content type="html"><![CDATA[<blockquote><p>系统：Ubuntu 16.04 LTS</p><p>Python 版本：3.9.4</p><p>Pip 版本: 21.0.1</p></blockquote><p>用系统默认的 <code>Python</code> 安装的 <code>pip</code> 一执行 <code>pip</code> 命令就报错（默认的<code>Python</code> 版本分别是 <code>2.7</code> 和 <code>3.5</code> ），通过打印的错误来看，应该是兼容性的问题。</p><p>为了节省时间，于是决定从官网下载最新 <code>Python</code> 使用，并通过创建软连接的方式，达到在终端直接输入 <code>python</code> 或者 <code>pip</code> ，能够使用我自己装的 <code>Python</code> 和 <code>Pip</code>。</p><p>考虑到默认 <code>Pip</code> 仓库的下载速度比较慢，于是将 <code>Pip</code> 的仓库换成了清华的，同时在文末也放了几个国内的其他仓库地址，因为有些东西某个仓库里可能没有，需要使用其他仓库下载，视具体情况根据需要设置。</p><p>由于自己下载的 <code>Python</code> 编译安装完后就自带了对应的 <code>Pip</code> ，所以，下面的文章分两部分，分别是<code>安装Python</code>、<code>配置Pip</code></p><h3 id="安装Python"><a href="#安装Python" class="headerlink" title="安装Python"></a>安装Python</h3><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>Linux版本的Python下载地址：<a href="https://www.python.org/downloads/source/">Python Source Releases | Python.org</a></p><p>都是源码下载，需要自己编译，我下载的 <code>xz</code> 格式的压缩包。</p><h4 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h4><p>请在 <code>sudo</code> 模式下进行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">解压压缩包</span><br>tar -xvf Python-3.9.4.tar.xz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">配置</span><br>cd Python-3.9.4<br>./configure<br><span class="hljs-meta prompt_"># </span><span class="language-bash">编译 &amp; 安装</span><br>make &amp;&amp; make install<br></code></pre></td></tr></table></figure><p>安装完后在<code>/usr/local/bin</code> 中会看到编译后的<code>Python</code> 可执行文件</p><h4 id="创建软连接"><a href="#创建软连接" class="headerlink" title="创建软连接"></a>创建软连接</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">先删除原先的python软连接</span><br>sudo rm -rf /usr/bin/python<br><span class="hljs-meta prompt_"># </span><span class="language-bash">创建软连接</span><br>sudo ln -s /usr/local/bin/python3.9 /usr/bin/python<br></code></pre></td></tr></table></figure><h3 id="配置Pip"><a href="#配置Pip" class="headerlink" title="配置Pip"></a>配置Pip</h3><h4 id="创建软连接-1"><a href="#创建软连接-1" class="headerlink" title="创建软连接"></a>创建软连接</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建软连接</span><br>sudo ln -s /usr/local/bin/pip3.9 /usr/bin/pip<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果提示已经存在软连接，则先删除再创建</span><br>sudo rm -rf /usr/bin/pip<br></code></pre></td></tr></table></figure><h4 id="修改全局仓库地址"><a href="#修改全局仓库地址" class="headerlink" title="修改全局仓库地址"></a>修改全局仓库地址</h4><p>在当前的用户目录下，创建文件夹.pip，在里面新建文件pip.conf</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir .pip &amp;&amp; cd .pip<br>vim pip.conf<br></code></pre></td></tr></table></figure><p>在里面写入下面的内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">[global]<br>index-url = https://pypi.tuna.tsinghua.edu.cn/simple/<br></code></pre></td></tr></table></figure><h4 id="其他的仓库地址"><a href="#其他的仓库地址" class="headerlink" title="其他的仓库地址"></a>其他的仓库地址</h4><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt"># 阿里源<br>[global]<br>index-url = http://mirrors.aliyun.com/pypi/simple/<br>trusted-host = mirrors.aliyun.com<br><br># 豆瓣源<br>[global]<br>index-url = http://pypi.douban.com/simple<br>trusted-host = pypi.douban.com<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Python</tag>
      
      <tag>pip</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置Sphinx并支持Markdown及表格</title>
    <link href="/2021/04/08/Tools/Sphinx/%E9%85%8D%E7%BD%AESphinx%E5%B9%B6%E6%94%AF%E6%8C%81Markdown%E5%8F%8A%E8%A1%A8%E6%A0%BC/"/>
    <url>/2021/04/08/Tools/Sphinx/%E9%85%8D%E7%BD%AESphinx%E5%B9%B6%E6%94%AF%E6%8C%81Markdown%E5%8F%8A%E8%A1%A8%E6%A0%BC/</url>
    
    <content type="html"><![CDATA[<p>在公司同事的提议下，说能不能用<code>Sphinx</code>做一个web形式的接口文档，于是我研究了一番，由于<code>Sphinx</code>默认支持的<code>rst</code>格式的文档，所以第一个问题就是让它支持<code>Markdown</code>格式的文档，再就是考虑到接口文档会有表格对字段进行说明，所以，还需要让它支持<code>Markdown</code>形式的表格，从这两个点出发也遇到了下面几个问题：</p><ol><li>我是在一台<code>Ubuntu 16.04</code> 的机器上进行的，默认的<code>Python</code>版本是 <code>2.7</code> 和 <code>3.5</code>，<code>Sphinx</code> 官网推荐安装方式是使用 <code>Pip</code> 安装，由于系统默认没有 <code>Pip</code>，于是我就安装了<code>python2</code>的<code>Pip</code>，即<code>python-pip</code>，但是运行 <code>Pip</code> 却出错，看错误应该是兼容性问题，于是卸载并安装了<code>Python3</code>的<code>Pip</code>，即<code>python3-pip</code>，能用，但是导入支持表格的插件时总是提示导入失败。</li><li>环境搭建好，在写文档的时候，又涉及到目录的问题，官方文档对目录这块说的很模糊，几乎没有参考价值，在网上搜答案基本也都对目录这块没什么描述，最终，在看官方文档时闪过一个灵感，经过多次尝试，最终满足了自己的需求。</li></ol><p>由于官网的文档都是英文的，如果你不爱看英文文章，也想<code>quick start</code>，那么这篇文章可以满足你的基本需求。</p><h3 id="Pip的问题"><a href="#Pip的问题" class="headerlink" title="Pip的问题"></a>Pip的问题</h3><p>对于上面描述中的 <code>Pip</code> 问题的解决，我的思路是去官方网站安装 <code>Python</code> 并作为系统默认 <code>Python</code> 使用。</p><p>参考我的这篇文章：<a href="https://www.mofan.life/2021/04/08/Linux%E5%AE%89%E8%A3%85Python%E5%92%8C%E9%85%8D%E7%BD%AEPip/">Linux安装Python和配置Pip - Mofan </a></p><h3 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h3><p>如果使用<code>Pip</code>默认的软件源，安装过程可能有点慢，如果你想快一点，我强烈建议你看一下<code>Pip的问题</code>里那篇文章介绍的修改<code>Pip</code>源的操作。</p><p>如果下面的安装出现<code>Time out</code>，请按方向键⬆️，将命令再执行一遍。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装sphinx</span><br>pip install -U sphinx<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 markdown 插件</span><br>pip install recommonmark<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装支持表格的插件</span><br>pip install sphinx-markdown-tables<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果你希望你生成的html页面中的搜索框支持中文搜索，那么这个插件也需要安装</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">这个插件有两个版本，下面的jieba3k是适用于python3的，如果你用的是python2，那么换成jieba</span><br>pip install jieba3k<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装主题 sphinx-rtd-theme,当然你也可以安装别的。</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">主题网址：https://sphinx-themes.org/</span><br>pip install sphinx-rtd-theme<br></code></pre></td></tr></table></figure><h3 id="开始配置文档项目"><a href="#开始配置文档项目" class="headerlink" title="开始配置文档项目"></a>开始配置文档项目</h3><p>一切准备就绪后，新建一个文件夹，作为文档的工程文件夹，下面以<code>doc</code>为例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir doc &amp;&amp; cd doc<br></code></pre></td></tr></table></figure><p>然后执行<code>sphinx-quickstart</code>，</p><p>接着会出现很多的问题，类似下面这样：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs txt">Welcome to the Sphinx 1.8.0 quickstart utility.<br><br>Please enter values for the following settings (just press Enter to<br>accept a default value, if one is given in brackets).<br><br>Selected root path: .<br><br>You have two options for placing the build directory for Sphinx output.<br>Either, you use a directory &quot;_build&quot; within the root path, or you separate<br>&quot;source&quot; and &quot;build&quot; directories within the root path.<br>&gt; Separate source and build directories (y/n) [n]: y # 源路径和输出路径分开(强烈建议这样做)<br><br>Inside the root directory, two more directories will be created; &quot;_templates&quot;<br>for custom HTML templates and &quot;_static&quot; for custom stylesheets and other static<br>files. You can enter another prefix (such as &quot;.&quot;) to replace the underscore.<br>&gt; Name prefix for templates and static dir [_]:<br><br>The project name will occur in several places in the built documentation.<br>&gt; Project name: Mofan API     # 项目名称<br>&gt; Author name(s): Mofan     # 作者<br>&gt; Project release []: 1.0.0 # 版本号<br><br>If the documents are to be written in a language other than English,<br>you can select a language here by its language code. Sphinx will then<br>translate text that it generates into that language.<br><br>For a list of supported codes, see<br>http://sphinx-doc.org/config.html#confval-language.<br>&gt; Project language [en]: zh_CN # 中文<br></code></pre></td></tr></table></figure><p>以前的版本可能还会有后面的问题，但那些问题都可以用默认的，因为我们马上就要修改配置文件了，可以通过修改配置文件满足我们的所有需求，包括上面的问题。</p><p>完成上面的操作后，查看当前的文件夹，你会看到四个文件<code>source</code>、<code>build</code> 、<code>Makefile</code>、<code>make.bat</code>。</p><p>我们只需要关注两个文件即可：</p><ul><li><code>source</code>：这编写文档的地方</li><li><code>build</code>：这是存放静态web文件的地方，里面的<code>html</code>文件夹就可以放到诸如<code>tomcat</code>、<code>nginx</code>等<code>web容器</code>中。</li></ul><p>下面的操作也主要围绕<code>source</code>文件夹展开，因为这才是我们真正工作的地方。</p><h3 id="编写配置文件"><a href="#编写配置文件" class="headerlink" title="编写配置文件"></a>编写配置文件</h3><p>进入<code>source</code>目录，<code>conf.py</code>即是它的配置文件，其实就是一个地道的<code>Python</code> 文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># Configuration file for the Sphinx documentation builder.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This file only contains a selection of the most common options. For a full</span><br><span class="hljs-comment"># list see the documentation:</span><br><span class="hljs-comment"># https://www.sphinx-doc.org/en/master/usage/configuration.html</span><br><br><span class="hljs-comment"># -- Path setup --------------------------------------------------------------</span><br><br><span class="hljs-comment"># If extensions (or modules to document with autodoc) are in another directory,</span><br><span class="hljs-comment"># add these directories to sys.path here. If the directory is relative to the</span><br><span class="hljs-comment"># documentation root, use os.path.abspath to make it absolute, like shown here.</span><br><span class="hljs-comment">#</span><br><br><span class="hljs-comment"># 把这一块的注释去掉</span><br><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> sys<br>sys.path.insert(<span class="hljs-number">0</span>, os.path.abspath(<span class="hljs-string">&#x27;.&#x27;</span>))<br><br><br><span class="hljs-comment"># -- Project information -----------------------------------------------------</span><br><br><span class="hljs-comment"># 这里是运行 sphinx-quickstart 后你配置的东西</span><br>project = <span class="hljs-string">&#x27;Mofan API&#x27;</span><br>copyright = <span class="hljs-string">&#x27;2021, Mofan&#x27;</span><br>author = <span class="hljs-string">&#x27;Mofan&#x27;</span><br><br><span class="hljs-comment"># The full version, including alpha/beta/rc tags</span><br>release = <span class="hljs-string">&#x27;1.0.0&#x27;</span><br><br><br><span class="hljs-comment"># -- General configuration ---------------------------------------------------</span><br><br><span class="hljs-comment"># Add any Sphinx extension module names here, as strings. They can be</span><br><span class="hljs-comment"># extensions coming with Sphinx (named &#x27;sphinx.ext.*&#x27;) or your custom</span><br><span class="hljs-comment"># ones.</span><br><br><span class="hljs-comment"># 这里是定义插件的地方，分别是支持markdown的插件和支持markdown表格的插件</span><br>extensions = [<span class="hljs-string">&#x27;recommonmark&#x27;</span>,<br>  <span class="hljs-string">&#x27;sphinx_markdown_tables&#x27;</span>,<br>]<br><br><br><span class="hljs-comment"># 这个需要自己加上，这里主要说明什么格式的文件由什么解析</span><br>source_suffix = &#123;<br>    <span class="hljs-string">&#x27;.rst&#x27;</span>: <span class="hljs-string">&#x27;restructuredtext&#x27;</span>,<br>    <span class="hljs-string">&#x27;.txt&#x27;</span>: <span class="hljs-string">&#x27;markdown&#x27;</span>,<br>    <span class="hljs-string">&#x27;.md&#x27;</span>: <span class="hljs-string">&#x27;markdown&#x27;</span>,<br>&#125;<br><br><span class="hljs-comment"># Add any paths that contain templates here, relative to this directory.</span><br>templates_path = [<span class="hljs-string">&#x27;_templates&#x27;</span>]<br><br><span class="hljs-comment"># The language for content autogenerated by Sphinx. Refer to documentation</span><br><span class="hljs-comment"># for a list of supported languages.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># This is also used if you do content translation via gettext catalogs.</span><br><span class="hljs-comment"># Usually you set &quot;language&quot; from the command line for these cases.</span><br><br><span class="hljs-comment"># 这里也是在运行 sphinx-quickstart 时配置的信息</span><br>language = <span class="hljs-string">&#x27;zh_CN&#x27;</span><br><br><span class="hljs-comment"># List of patterns, relative to source directory, that match files and</span><br><span class="hljs-comment"># directories to ignore when looking for source files.</span><br><span class="hljs-comment"># This pattern also affects html_static_path and html_extra_path.</span><br>exclude_patterns = []<br><br><br><span class="hljs-comment"># -- Options for HTML output -------------------------------------------------</span><br><br><span class="hljs-comment"># The theme to use for HTML and HTML Help pages.  See the documentation for</span><br><span class="hljs-comment"># a list of builtin themes.</span><br><span class="hljs-comment">#</span><br><br><span class="hljs-comment"># 可以在这里修改主题</span><br>html_theme = <span class="hljs-string">&#x27;sphinx_rtd_theme&#x27;</span><br><br><span class="hljs-comment"># Add any paths that contain custom static files (such as style sheets) here,</span><br><span class="hljs-comment"># relative to this directory. They are copied after the builtin static files,</span><br><span class="hljs-comment"># so a file named &quot;default.css&quot; will overwrite the builtin &quot;default.css&quot;.</span><br><span class="hljs-comment"># html_static_path = [&#x27;_static&#x27;]</span><br><br><span class="hljs-comment"># 这里要自己加上，这里对应jieba3k插件，是让web页面搜索支持中文的配置</span><br>html_search_language = <span class="hljs-string">&#x27;zh&#x27;</span><br></code></pre></td></tr></table></figure><p>完成上面的配置后，你就可以返回上级目录，进行编译生成html文档了，命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ..<br><br>make html<br></code></pre></td></tr></table></figure><p>然后用浏览器打开<code>build/html/index.html</code> 文件，你会看到你配置的主题，还有一些默认的信息，这些信息来自<code>source/index.rst</code>文件。</p><h3 id="编写接口文档添加目录"><a href="#编写接口文档添加目录" class="headerlink" title="编写接口文档添加目录"></a>编写接口文档添加目录</h3><h4 id="编写文档"><a href="#编写文档" class="headerlink" title="编写文档"></a>编写文档</h4><p>首先进入到source目录，然后创建文件，但别忘了在<code>index.rst</code>文件中声明你创建的文件。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">cd</span> <span class="hljs-keyword">source</span><br><br><span class="hljs-keyword">vim</span> hello.md<br></code></pre></td></tr></table></figure><p>用<code>markdown</code>格式编写hello.md文件</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># Hello</span><br><br>Are you ok?<br></code></pre></td></tr></table></figure><p>在index.rst文件中声明。<code>vim index.rst</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs rst">.. Mofan API documentation master file, created by<br>   sphinx-quickstart on Thu Apr  8 10:08:14 2021.<br>   You can adapt this file completely to your liking, but it should at least<br>   contain the root `toctree` directive.<br><br>Welcome to Mofan API&#x27;s documentation!<br>=======================================<br><br>.. toctree::<br>   :maxdepth: 1<br><br>   hello<br><br>Indices and tables<br>==================<br><br>* :ref:`genindex`<br>* :ref:`modindex`<br>* :ref:`search`<br></code></pre></td></tr></table></figure><p>这个文件不能是<code>md</code>格式的，需要为<code>rst</code>格式的，因为这里面包含了一些命令。</p><ul><li><code>.. </code>这是一个注释，不会被编译到页面中</li><li><code>=====</code>：它定义文档标题，它的长度必须大于等于标题长度</li><li><code>toctree</code>：这是一个命令，<code>maxdepth</code>是它的参数之一，用于指定解析到哪一级的文档标题，这个可以自己换个数字看看效果就懂了</li><li><code>hello</code>：这里是文件的名字，无需后缀，这是和<code>index.rst</code>同级目录的。</li></ul><p>定义文件基本介绍就这样，下面介绍创建目录，并在目录里创建文件。</p><h4 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h4><p>我们在source文件夹里，创建<code>world</code>目录，然后在里面创建文件。不过要注意，目录里必须也要有一个<code>index.rst</code>文件，它用于描述该目录下的文件结构，和<code>source/index.rst</code>文件作用是相同的，不过<code>source/index.rst</code>文件处于根节点，相当于老大。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir world<br><br>cd world<br><br>vim index.rst<br></code></pre></td></tr></table></figure><p>把下面的信息放进去:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rst">World<br>======<br><br>.. toctree::<br>   :maxdepth: 1<br><br>   mofan<br></code></pre></td></tr></table></figure><p>上面的<code>World</code>是这级目录的标题，你要点击这个标题才能看到下面的<code>Hello,Mofan</code>。</p><p>如果不这样做的话，那么编译成<code>html</code>后，<code>Hello,Mofan</code>和<code>Hello</code>是同级的。</p><p>然后就得创建<code>mofan.md</code>文件了。<code>vim mofan.md</code>，写入下面的信息：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-section"># Hello,Mofan</span><br><br>very ok!<br></code></pre></td></tr></table></figure><p>完成上面工作后，还要做一件最重要的事，告诉老大哥这里有一个文件夹。</p><p>编辑<code>source/index.rst</code>文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd ..<br><br>vim index.rst<br></code></pre></td></tr></table></figure><p>在<code>hello</code>的下面添加<code>world/index</code>，同样不需要带文件后缀，类似下面这样</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rst">.. Mofan API documentation master file, created by<br>   sphinx-quickstart on Thu Apr  8 10:08:14 2021.<br>   You can adapt this file completely to your liking, but it should at least<br>   contain the root `toctree` directive.<br><br>Welcome to Mofan API&#x27;s documentation!<br>=======================================<br><br>.. toctree::<br>   :maxdepth: 1<br><br>   hello<br>   world/index<br><br>Indices and tables<br>==================<br><br>* :ref:`genindex`<br>* :ref:`modindex`<br>* :ref:`search`<br></code></pre></td></tr></table></figure><p>这个时候，既可以回到有<code>make.bat</code>的文件，运行<code>make html</code>生成<code>html</code>页面了，然后刷新浏览器就可以看到变化。</p><p>如果你发现运行<code>make html</code>后生成的页面还有你在<code>source</code>里删除的文件信息，那么，运行<code>make clean</code> 后，再运行<code>make install</code>即可。</p><p>如果想更多的了解<code>reStructuredText</code> 语法的话，可以参考<a href="https://zh-sphinx-doc.readthedocs.io/en/latest/rest.html">reStructuredText 简介 — Sphinx 使用手册</a>作为一个简单的入门。</p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Sphinx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sphinx</tag>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Websocket</title>
    <link href="/2021/03/31/Websocket/"/>
    <url>/2021/03/31/Websocket/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/zt102545/article/details/85396360">(5条消息) 通过HTTP请求Websocket_Admin-CSDN博客_websocket请求</a></p><p>还需要深入学习。</p>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
      <tag>WebSocket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL开启远程访问</title>
    <link href="/2021/03/31/PostgreSQL%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/"/>
    <url>/2021/03/31/PostgreSQL%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/</url>
    
    <content type="html"><![CDATA[<p>让<code>PostgreSQL</code>支持远程访问，需要修改两个文件：<code>postgresql.conf</code> 和 <code>pg_hba.conf</code></p><p>关于这两个文件的位置在这里简单说下，只说<code>Mac</code> 和 <code>Linux</code> 的。</p><p><code>Mac</code> : 默认是在<code>/Library/PostgreSQL/&lt;版本号&gt;/data</code> 下面。(版本9.6)</p><p><code>Ubuntu</code>: 默认在<code>/etc/postgresql/&lt;版本号&gt;/main</code> 下面。(版本9.6)</p><p><code>CentOS</code>: 默认在<code>/var/lib/pgsql/13/data/</code>下面。(版本13)</p><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>1.修改<code>pg_hba.conf</code>文件，在原先的<code>host all all</code> 下面添加内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt">host all all 0.0.0.0 0.0.0.0 md5<br></code></pre></td></tr></table></figure><p>2.修改<code>postgresql.conf</code> 文件</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">找到：<br>#listen_addresses=&#x27;localhost&#x27;<br><br>改成：<br>listen_addresses=&#x27;*&#x27;<br></code></pre></td></tr></table></figure><p>重启数据库<code>service postgres restart</code>，有时候需要携带版本号<code>service postgres restart</code>(这是在CentOS中使用PostgreSQL 13遇到的情况)</p><p>这样实现了远程访问，如果服务器在局域网中，那么还需要做一下内网穿透工作，推荐使用花生壳工具，当然你也可以在<code>GitHub</code>上搜索相关的开源技术，这里我比较推荐这两个:</p><ul><li><p><a href="https://github.com/ehang-io/nps">nps</a></p></li><li><p><a href="https://github.com/snail007/goproxy">goproxy</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL的使用</title>
    <link href="/2021/03/31/PostgreSQL%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/03/31/PostgreSQL%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>导入导出数据，很靠谱</p><p><a href="https://blog.csdn.net/justlpf/article/details/91789787">(5条消息) POSTGRESQL 数据库导入导出_justlpf的专栏-CSDN博客</a></p><p>读懂第一个的基础上看看这个，我也没细看</p><p><a href="http://www.voidcn.com/article/p-byjmvxxs-bqu.html">PostgreSQL（七）备份还原 - 程序园</a></p><p>这个可有可无。</p><p><a href="https://blog.csdn.net/luojinbai/article/details/43407947">(5条消息) PostgreSQL pg_dump&amp;pg_restore 数据的导出和导入_luojinbai的专栏-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gRPC安装</title>
    <link href="/2021/03/31/gRPC%E5%AE%89%E8%A3%85/"/>
    <url>/2021/03/31/gRPC%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<blockquote><p>卸载前面，这篇文章是我在3月份写的，当时刚入门Go，好多坑不懂，刚入职就碰到grpc,protobuf这些，对我来说都算新鲜事物，所以该有的坑都踩了一下。<br>这篇文章无形中安装了官方文档里写的C++安装这块（<a href="https://grpc.io/docs/languages/cpp/quickstart/">Quick start | C++ | gRPC</a>），所以，我建议，如果安装C++的直接参考官方文档即可，当然安装其他的也可以参考官方文档，都是走的通的，但是有一点需要注意，在跟官方文档走的时候，最好有自己的梯子。<br>我这篇文档以及官方文档里C++的部分，都是从源码编译的角度出发，所以，编译后不仅会生成grpc_cpp_plugin，还会生成诸如：grpc_python_plugin、grpc_node_plugin等，同时也会生成protoc，所以，这算是一个比较完全的方式，大多数情况下，只要不涉及到C++，直接去上面官方文档里找对应的语言进行安装即可.</p></blockquote><blockquote><p>Ubuntu 16.04 LTS</p><p>或</p><p>Mac OS BigSur</p></blockquote><p>在安装<code>gRPC</code> 时，竟然莫名其妙的走了很多弯路，其实官方安装方法很简单，但是困难的地方在于你要用龟速来从<code>GitHub</code>下载这么庞大的一个东西。</p><p>为了节省时间，我强烈建议你整个梯子用，或者晚上睡觉前让它执行克隆任务。</p><h3 id="资源准备"><a href="#资源准备" class="headerlink" title="资源准备"></a>资源准备</h3><p>这一步需要点时间，如果没有梯子的话。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载grpc代码</span><br>git clone https://github.com/grpc/grpc.git<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载完后进入grpc目录</span><br>cd grpc<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">更新子模块, 加上--recursive可以把源码下载下来，为了避免乱七八糟的问题，强烈建议你带上</span><br>git submodule update --init --recursive<br></code></pre></td></tr></table></figure><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><p>这一步还好，如果网速不错，很快就能完成。</p><h5 id="Linux系统"><a href="#Linux系统" class="headerlink" title="Linux系统"></a>Linux系统</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt-get install pkg-config<br><br>sudo apt-get install autoconf automake libtool make g++ unzip<br><br>sudo apt-get install libgflags-dev libgtest-dev<br><br>sudo apt-get install clang libc++-dev<br></code></pre></td></tr></table></figure><h5 id="Mac系统"><a href="#Mac系统" class="headerlink" title="Mac系统"></a>Mac系统</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">brew install autoconf automake libtool<br></code></pre></td></tr></table></figure><h3 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h3><p>这是重头戏，编译也挺慢的，看机器性能。</p><h4 id="安装ProtoBuf"><a href="#安装ProtoBuf" class="headerlink" title="安装ProtoBuf"></a>安装ProtoBuf</h4><p><code>gRPC</code>默认使用<code>protobuf</code>作为传输协议。我们先安装protobuf，在<code>grpc/third_party/protobuf/</code>下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><br>sudo ./autogen.sh   #生成配置脚本<br>sudo ./configure    #生成Makefile文件，默认路径为/usr/local/<br>sudo make<br>sudo make install <br>sudo ldconfig       #更新共享库缓存<br></code></pre></td></tr></table></figure><p>此时，在<code>/usr/local/bin</code>你会看到<code>protoc</code>可执行文件，新开一个终端，然后<code>protoc --version</code>试一下是否成功安装。</p><h4 id="安装gRPC"><a href="#安装gRPC" class="headerlink" title="安装gRPC"></a>安装gRPC</h4><p>官方推荐使用<code>bazel</code>进行编译，但我用的是<code>cmake</code>进行的编译，不同平台的编译方法在<code>/grpc/BUILDING.md</code>文件有说明，这里的<code>cmake</code>编译方法也是来自这个文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">mkdir</span> -p cmake/build</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> cmake/build</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">cmake ../..</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">执行make install 进行安装</span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">make install</span><br></code></pre></td></tr></table></figure><p>这里编译的时候在<code>ubuntu  16.04</code>上可能会遇到ld的报错，意思大概是说你装了两个不同版本的<code>libprotobuf.so</code>，可能会导致冲突。上网搜索之后了解到这是因为<code>ubuntu</code>默认安装了一个低版本的<code>protobuf</code>，解决办法是卸载掉这个就好了，用上面编译安装的<code>3.x</code>版本：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sudo apt-<span class="hljs-built_in">get</span> <span class="hljs-built_in">remove</span> libprotobuf-dev<br></code></pre></td></tr></table></figure><p>然后重新<code>cmake</code>一下就好了。</p><p>完成上面的步骤后，你会发现在创建的<code>cmake/build</code>文件夹里，有<code>grpc_xxx_plugin</code>这些可执行文件，使用命令将他们移动到<code>/usr/local/bin</code>下，这样就可以使用<code>which grpc_xxx_plugin</code>打印它的位置了，这在将来使用<code>protoc</code>命令生成<code>protobuf</code>文件时需要用到。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo mv grpc* /usr/local/bin<br></code></pre></td></tr></table></figure><h3 id="测试成果"><a href="#测试成果" class="headerlink" title="测试成果"></a>测试成果</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd examples/cpp/helloworld/<br>make<br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启一个服务</span><br>./greeter_server <br><span class="hljs-meta prompt_"># </span><span class="language-bash">在另一个terminal</span><br>./greeter_client<br></code></pre></td></tr></table></figure><p>看到程序输出<code>Hello world</code>，就意味着你成功了。</p>]]></content>
    
    
    <categories>
      
      <category>RPC</category>
      
      <category>gRPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RPC</tag>
      
      <tag>gRPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu16.04进入桌面不显示菜单栏和侧栏</title>
    <link href="/2021/03/31/Ubuntu16-04%E8%BF%9B%E5%85%A5%E6%A1%8C%E9%9D%A2%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%8F%9C%E5%8D%95%E6%A0%8F%E5%92%8C%E4%BE%A7%E6%A0%8F/"/>
    <url>/2021/03/31/Ubuntu16-04%E8%BF%9B%E5%85%A5%E6%A1%8C%E9%9D%A2%E4%B8%8D%E6%98%BE%E7%A4%BA%E8%8F%9C%E5%8D%95%E6%A0%8F%E5%92%8C%E4%BE%A7%E6%A0%8F/</url>
    
    <content type="html"><![CDATA[<p>使用<code>VMware</code>装的 <code>Ubuntu16.04</code>，本来一切正常，结果在某次开机后发现：进入桌面不显示菜单栏和侧栏，但是终端可以在桌面右键打开，于是就有了下面的操作。</p><p>首先执行下命令查看下问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat ~/.xsession-errors<br></code></pre></td></tr></table></figure><p>大体记得是，输出信息是找不到某个桌面服务了，所以就 <code>exit</code> 了。</p><p>查阅资料发现主要由下面这两种解决方法。我的问题是通过下面的第二种方法解决的。</p><p><strong>解决方法：</strong></p><h5 id="第一种：重新启动lightdm服务"><a href="#第一种：重新启动lightdm服务" class="headerlink" title="第一种：重新启动lightdm服务"></a>第一种：重新启动lightdm服务</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo service lightdm restart<br></code></pre></td></tr></table></figure><p>之后重启系统，<code>reboot</code></p><h5 id="第二种：重装桌面环境"><a href="#第二种：重装桌面环境" class="headerlink" title="第二种：重装桌面环境"></a>第二种：重装桌面环境</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo apt install --reinstall ubuntu-desktop<br></code></pre></td></tr></table></figure><p>同样重启系统, <code>reboot</code></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gRPC介绍</title>
    <link href="/2021/03/31/gRPC%E4%BB%8B%E7%BB%8D/"/>
    <url>/2021/03/31/gRPC%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="gRPC与RPC"><a href="#gRPC与RPC" class="headerlink" title="gRPC与RPC"></a>gRPC与RPC</h3><p><code>gRPC</code>是什么可以用官网的一句话来概括</p><blockquote><p>A high-performance, open-source universal RPC framework</p></blockquote><p><strong>所谓RPC(remote procedure call 远程过程调用)框架实际是提供了一套机制，使得应用程序之间可以进行通信，而且也遵从server&#x2F;client模型。使用的时候客户端调用server端提供的接口就像是调用本地的函数一样。</strong>如下图所示就是一个典型的RPC结构图。</p><img src="https://www.cmdbyte.com/2021/02/grpc%E4%BB%8B%E7%BB%8D.png" alt="grpc介绍" style="zoom:50%;" /><h3 id="gRPC-vs-Restful-API"><a href="#gRPC-vs-Restful-API" class="headerlink" title="gRPC vs Restful API"></a>gRPC vs Restful API</h3><p>既然<code>RPC</code>也是<code>server/client</code>模型，那么和<code>Restful API</code>有什么区别呢？</p><p><code>gRPC</code>和<code>Restful API</code>都提供了一套通信机制，用于<code>server/client</code>模型通信，而且它们都使用<code>http</code>作为底层的传输协议(严格地说, gRPC使用的http2.0，而<code>Restful API</code>则不一定)。不过<code>gRPC</code>还是有些特有的优势，如下：</p><ul><li><code>gRPC</code>可以通过<code>protobuf</code>来定义接口，从而可以有更加严格的接口约束条件。</li><li>通过<code>protobuf</code>可以将数据序列化为二进制编码，这会大幅减少需要传输的数据量，从而大幅提高性能。</li><li><code>gRPC</code>可以方便地支持流式通信(理论上通过<code>http2.0</code>就可以使用<code>streaming</code>模式, 但是通常web服务的restful api似乎很少这么用，通常的流式数据应用如视频流，一般都会使用专门的协议如<code>HLS</code>，<code>RTMP</code>等，这些就不是我们通常web服务了，而是有专门的服务器应用。）</li></ul><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ul><li>需要对接口进行严格约束的情况，比如我们提供了一个公共的服务，很多人，甚至公司外部的人也可以访问这个服务，这时对于接口我们希望有更加严格的约束，我们不希望客户端给我们传递任意的数据，尤其是考虑到安全性的因素，我们通常需要对接口进行更加严格的约束。这时<code>gRPC</code>就可以通过<code>protobuf</code>来提供严格的接口约束。</li><li>对于性能有更高的要求时。有时我们的服务需要传递大量的数据，而又希望不影响我们的性能，这个时候也可以考虑<code>gRPC</code>服务，因为通过<code>protobuf</code>我们可以将数据压缩编码转化为二进制格式，通常传递的数据量要小得多，而且通过<code>http2</code>我们可以实现异步的请求，从而大大提高了通信效率。</li></ul><p>但是，通常我们不会去单独使用<code>gRPC</code>，而是将<code>gRPC</code>作为一个部件进行使用，这是因为在生产环境，我们面对大并发的情况下，需要使用分布式系统来去处理，而gRPC并没有提供分布式系统相关的一些必要组件。而且，真正的线上服务还需要提供包括负载均衡，限流熔断，监控报警，服务注册和发现等等必要的组件。</p>]]></content>
    
    
    <categories>
      
      <category>RPC</category>
      
      <category>gRPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RPC</tag>
      
      <tag>gRPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CI/CD环境</title>
    <link href="/2021/03/30/CI-CD%E7%8E%AF%E5%A2%83/"/>
    <url>/2021/03/30/CI-CD%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>介绍：</p><p><a href="https://blog.csdn.net/qq_43659763/article/details/105363963">(5条消息) 基于公司开发环境搭建CI&#x2F;CD平台总结_゛思无量，自相忘的博客-CSDN博客</a></p><p>Jekins:</p><p><a href="https://www.jianshu.com/p/d8204513086b">CI&amp;CD环境搭建 - Jenkins的搭建与配置 - 简书</a></p><p>详细的部署流程：</p><p><a href="https://www.pianshen.com/article/1356952233/">搭建 CI&#x2F;CD 流水线 - 程序员大本营</a></p><p>Jekins搭建测试代码：</p><p><a href="https://github.com/samarpit1111/devops_pipeline_demo">samarpit1111&#x2F;devops_pipeline_demo: Complete DevOps CI&#x2F;CD Pipeline Demo with Jenkins &amp; Docker</a></p><p>自动化测试：</p><p><a href="https://zhuanlan.zhihu.com/p/149095173">如何从0搭建自己的自动化测试体系 - 知乎</a></p><p>不错的网站：</p><p><a href="https://www.pianshen.com/">程序员大本营</a></p><p>Hibernate:</p><p><a href="https://zhuanlan.zhihu.com/p/103120396?utm_source=qq">为什么很多人不愿意用hibernate了? - 知乎</a></p><p>GRPC：</p><p><a href="https://www.jianshu.com/p/9c947d98e192">gRPC详解 - 简书</a></p>]]></content>
    
    
    <categories>
      
      <category>TODO</category>
      
      <category>CI/CD</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CI/CD</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux配置ssh远程登录</title>
    <link href="/2021/03/30/Linux%E9%85%8D%E7%BD%AEssh%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/"/>
    <url>/2021/03/30/Linux%E9%85%8D%E7%BD%AEssh%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>本来不想写的，但是发现网上没有一个靠谱的教程。简单的写几个步骤，照着做能实现：<code>Linux</code>安装<code>ssh</code>工具，配置<code>ssh</code>允许<code>root</code>登陆，开放对应端口，默认<code>ssh</code>端口是<code>22</code>。</p><h3 id="安装ssh"><a href="#安装ssh" class="headerlink" title="安装ssh"></a>安装ssh</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># Ubuntu</span><br>sudo apt install openssh-server<br><br><span class="hljs-comment"># CentOS</span><br>sudo yum install openssh-server<br></code></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>新系统如果没有<code>vim</code>先安装下<code>vim</code>。<code>sudo apt install vim</code></p><p>修改配置文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">sudo vim <span class="hljs-regexp">/etc/</span>ssh/sshd_config<br></code></pre></td></tr></table></figure><p>将里面字段改成这样：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">原：PermitRootLogin prohibit-password<br>现：PermitRootLogin yes<br><br>原：PasswordAuthentication no<br>现：PasswordAuthentication yes<br></code></pre></td></tr></table></figure><p>上面的字段可能被注释了，要删除 <code>#</code>。</p><p>重启ssh <code>sudo /etc/init.d/ssh restart</code></p><h3 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h3><p>iptables防火墙好像没有默认开放22端口。开放端口命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">iptables -A INPUT -p tcp --dport 22 -j ACCEPT<br>iptables -A OUTPUT -p tcp --sport 22 -j ACCEPT<br></code></pre></td></tr></table></figure><p>然后就可以<code>ssh root@xxxxx</code>登陆了</p><h3 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h3><p>这里指的是外网访问：</p><p>如果Linux在局域网，你想在外网访问，那么需要内网穿透工具，花生壳的使用方式可以看一下。<a href="https://service.oray.com/question/4287.html">花生壳 3.0 for Linux 相关安装使用文档</a></p><p>如果是外网Linux，那就直接<code>ssh root@ip</code>登陆即可。</p><h3 id="指定端口登陆"><a href="#指定端口登陆" class="headerlink" title="指定端口登陆"></a>指定端口登陆</h3><p>如果没有使用<code>22</code>端口的话，<code>ssh</code>登陆指定端口的命令：<code>ssh -p 端口号 root@xxxx</code></p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang interface{}转struct的两种方法</title>
    <link href="/2021/03/28/Golang-interface-%E8%BD%ACstruct%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <url>/2021/03/28/Golang-interface-%E8%BD%ACstruct%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="使用断言，做强制转换"><a href="#使用断言，做强制转换" class="headerlink" title="使用断言，做强制转换"></a>使用断言，做强制转换</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">p, ok := (Value).(user)<br><span class="hljs-keyword">if</span> ok &#123;<br>fmt.Println(<span class="hljs-string">&quot;id:&quot;</span> + p.Id)<br>fmt.Println(<span class="hljs-string">&quot;name:&quot;</span> + p.Name)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;can not convert&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="JSON序列化"><a href="#JSON序列化" class="headerlink" title="JSON序列化"></a>JSON序列化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go">resByre,resByteErr:=json.Marshal(ResponseData)<br><span class="hljs-keyword">if</span> resByteErr != <span class="hljs-literal">nil</span> &#123;<br>c.Data(utils.ErrorResult(<span class="hljs-string">&quot;读取信息失败&quot;</span> + resByteErr.Error()))<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">var</span> newData MnConfig<br>jsonRes:=json.Unmarshal(resByre,&amp;newData)<br><span class="hljs-keyword">if</span> jsonRes != <span class="hljs-literal">nil</span> &#123;<br>c.Data(utils.ErrorResult(<span class="hljs-string">&quot;读取信息失败&quot;</span> + jsonRes.Error()))<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;encoding/json&quot;</span><br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br> <br><span class="hljs-keyword">type</span> user <span class="hljs-keyword">struct</span> &#123;<br>Id <span class="hljs-type">int</span> <span class="hljs-string">`json:&quot;id&quot;`</span><br>Name <span class="hljs-type">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>&#125;<br> <br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br> <br>newUser:=user&#123;<br>Id:   <span class="hljs-number">1</span>,<br>Name: <span class="hljs-string">&quot;Mofan&quot;</span>,<br>&#125;<br> <br><span class="hljs-keyword">var</span> newInterface1 <span class="hljs-keyword">interface</span>&#123;&#125;<br> <br><span class="hljs-comment">//第一种使用interface</span><br>newInterface1=newUser<br>fmt.Printf(<span class="hljs-string">&quot;使用interface: %v\n&quot;</span>,newInterface1.(user))<br> <br><span class="hljs-comment">//第二种使用json</span><br><span class="hljs-keyword">var</span> newInterface2 <span class="hljs-keyword">interface</span>&#123;&#125;<br>newInterface2=newUser<br>resByre, resByteErr := json.Marshal(newInterface2)<br><span class="hljs-keyword">if</span> resByteErr != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>,resByteErr)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">var</span> newData user<br>jsonRes := json.Unmarshal(resByre, &amp;newData)<br><span class="hljs-keyword">if</span> jsonRes != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>,jsonRes)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;使用 json: %v\n&quot;</span>,newData)<br> <br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">使用interface: &#123;1 Mofan&#125;<br>使用 json: &#123;1 Mofan&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Nginx配置location问题</title>
    <link href="/2021/03/28/Nginx%E9%85%8D%E7%BD%AElocation%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/28/Nginx%E9%85%8D%E7%BD%AElocation%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>由于我新增了一个静态资源项目，于是我想通过Nginx根据url的不同访问到不同的静态资源。也就是我想让<code>url+/tonger</code>的请求解析到&#x2F;home&#x2F;tonger下的静态资源，于是就有了下面的配置。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs text">// 配置tonger静态资源路径<br>location /tonger/ &#123;<br>root /home/tonger/;<br>index index.html;<br>&#125;<br><br>location / &#123;<br>root /html;<br>index index.html index.html;<br>&#125;<br></code></pre></td></tr></table></figure><p>配置完了之后发现总是报404错误，试了location的各种匹配规则写法，还是不行。</p><p>知道后来看到博客，说这样配置实际的请求访问的是<code>url+/home/tonger/index.html</code>，这样是访问不到的，要想<code>url+/tonger/index.html</code> 需要改成下面这样，尝试了一下，两种都能成功。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs text">location /tonger/ &#123;<br>root /home/;<br>index index.html;<br>&#125;<br><br>// 或者<br><br>location /tonger/ &#123;<br>alias /home/tonger/;<br>index index.html;<br>&#125;<br></code></pre></td></tr></table></figure><p>Nginx还需要好好学习一下！！！</p>]]></content>
    
    
    <categories>
      
      <category>Nginx</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nginx</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang的select经典用法</title>
    <link href="/2021/03/27/Golang%E7%9A%84select%E7%BB%8F%E5%85%B8%E7%94%A8%E6%B3%95/"/>
    <url>/2021/03/27/Golang%E7%9A%84select%E7%BB%8F%E5%85%B8%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><code>Go</code> 的 <code>select</code> 的功能和 <code>select</code>,<code>poll</code>,<code> epoll</code> 相似， 就是监听 <code>I/O</code> 操作，当 <code>I/O</code> 操作发生时，触发相应的动作。</p><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ch1:<br>fmt.Println(<span class="hljs-string">&quot;ch1 pop one element&quot;</span>)<br><span class="hljs-keyword">case</span> &lt;-ch2:<br>fmt.Println(<span class="hljs-string">&quot;ch2 pop one element&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>通过上面的示例发现，<code>select</code>的代码结构和<code>switch</code>很相似，但是，<code>select</code> 的 <code>case</code> 只匹配 <code>I/O</code> 操作，上面的示例，<code>select</code> 会一直等待，直到从<code>ch1</code> 或者 <code>ch2</code> 中读到数据，<code>select</code> 就结束了。</p><p>通过<code>select</code> 这个机制，可以实现一些有趣的功能。</p><p><strong>超时检测</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//检测ch是否timeout</span><br>timeout := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">bool</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(<span class="hljs-number">2</span> * time.Second)<br>timeout &lt;- <span class="hljs-literal">true</span><br>&#125;()<br><br><span class="hljs-comment">//ch可能在等待某个信号</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(<span class="hljs-number">3</span> * time.Second)<br>ch &lt;- <span class="hljs-number">1</span><br>&#125;()<br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-ch:<br>fmt.Println(&lt;-ch)<br><span class="hljs-keyword">case</span> &lt;-timeout:<br>fmt.Println(<span class="hljs-string">&quot;读取ch超时&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>避免缓存满了造成服务阻塞</strong></p><p>配合 <code>default</code> 语句，可以判断带缓存的 <code>channel</code> 是否满了</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-type">int</span>, <span class="hljs-number">1</span>)<br>ch &lt;- <span class="hljs-number">1</span><br><br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> ch &lt;- <span class="hljs-number">1</span>:<br>fmt.Println(&lt;-ch)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;channel已满&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>上面代码 <code>ch</code> 只有存储一个 <code>int</code> 型数据的空间，在<code>ch &lt;- 1</code> 时就满了，当 <code>ch</code> 要插入 2 的时候，发现 <code>ch</code> 已经满了（case ch &lt;- 1 阻塞住），则 <code>select</code> 执行 <code>default</code> 语句。 这样就可以实现对 <code>channel</code> 是否已满的检测， 而不是一直等待。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go的net/http包</title>
    <link href="/2021/03/27/Go%E7%9A%84net-http%E5%8C%85/"/>
    <url>/2021/03/27/Go%E7%9A%84net-http%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p><a href="https://studygolang.com/articles/9177">Go HTTP请求处理——net&#x2F;http包 - Go语言中文网 - Golang中文社区</a></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux安装PostgreSQL</title>
    <link href="/2021/03/27/Linux%E5%AE%89%E8%A3%85Postgresql/"/>
    <url>/2021/03/27/Linux%E5%AE%89%E8%A3%85Postgresql/</url>
    
    <content type="html"><![CDATA[<blockquote><p>系统：Ubuntu 16.04 LTS</p><p>PostgreSQL版本：9.6.21</p></blockquote><p>在Linux上安装 <code>PostgreSQL</code> 其实挺简单的，官网已经给了脚本文件，只需要做细微修改即可。这是<code>Ubuntu</code> 版本的官方安装文档<a href="https://www.postgresql.org/download/linux/ubuntu/">PostgreSQL: Linux downloads (Ubuntu)</a></p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>下面的命令是官方的脚本，因为我要安装的是<code>9.6</code>的版本，所以，我需要修改最后一条命令，指定我要安装的版本，<code>postgresql</code>改成<code>postgresql-9.6</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo sh -c &#x27;echo &quot;deb http://apt.postgresql.org/pub/repos/apt $(lsb_release -cs)-pgdg main&quot; &gt; /etc/apt/sources.list.d/pgdg.list&#x27;<br>wget --quiet -O - https://www.postgresql.org/media/keys/ACCC4CF8.asc | sudo apt-key add -<br>sudo apt-get update<br><span class="hljs-meta prompt_"># </span><span class="language-bash">sudo apt-get -y install postgresql</span><br>sudo apt-get -y install postgresql-9.6<br></code></pre></td></tr></table></figure><p>然后等待执行完毕就安装成功了。</p><h3 id="简单使用"><a href="#简单使用" class="headerlink" title="简单使用"></a>简单使用</h3><p>执行完上面的脚本后，系统里有了一个<code>postgres</code>用户</p><p>使用<code>sudo su postgres</code>命令切换到<code>postgres</code>用户。</p><p>然后执行<code>psql</code> 命令，你会看到下面这样的终端：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs txt">psql (9.6.21)<br>输入 &quot;help&quot; 来获取帮助信息.<br><br>postgres=#<br></code></pre></td></tr></table></figure><p>这就是<code>PostgreSQL</code>的控制台，而<code>postgres</code>是这里的最高管理员</p><h4 id="创建用户及数据库"><a href="#创建用户及数据库" class="headerlink" title="创建用户及数据库"></a>创建用户及数据库</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 创建用户<br>postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">USER</span> mofan <span class="hljs-keyword">WITH</span> PASSWORD <span class="hljs-string">&#x27;mofan&#x27;</span>;<br># 创建数据库<br>postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">CREATE</span> DATABASE mofan_data OWNER mofan;<br># 将数据库授权给用户<br>postgres<span class="hljs-operator">=</span># <span class="hljs-keyword">GRANT</span> <span class="hljs-keyword">ALL</span> PRIVILEGES <span class="hljs-keyword">ON</span> DATABASE mofan_data <span class="hljs-keyword">TO</span> mofan;<br></code></pre></td></tr></table></figure><p>这样我们就创建了一个数据库<code>mofan_data</code>，数据库由<code>mofan</code>进行管理。</p><h4 id="使用psql连接数据库"><a href="#使用psql连接数据库" class="headerlink" title="使用psql连接数据库"></a>使用psql连接数据库</h4><p>在终端连接 <code>PostgreSQL</code> 数据库需要使用 <code>psql</code> 工具，根据参数的不同可以实现本地连接或者远程连接。</p><p>命令：<code>psql [选项] &lt;数据库名称&gt;</code></p><p><strong>第一种方式：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">psql</span><br></code></pre></td></tr></table></figure><p>直接在终端执行 <code>psql</code> ，使用默认参数。</p><p>这种方式的要求是：</p><ul><li><code>PostgreSQL</code> 的用户名需要和终端当前用户名相同</li><li>数据库名需要和终端当前用户名相同</li></ul><p><strong>第二种方式：</strong></p><p>使用参数<code>-U</code>指定用户名；</p><p><code>-h</code> 指定 <code>Postgresql</code> 数据库的地址，这个地址可以是本地地址也可以是远程地址，当然，本地地址可以直接省略；</p><p><code>-d</code>指定数据库名，但这个可以省略，直接跟上数据库名即可</p><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">psql -U mofan -h 192.168.1.3 mofan_db<br></code></pre></td></tr></table></figure><p>通过上面的方式连接数据库，如果连接成功，终端也就变成了下面的形式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">数据库名=&gt;<br></code></pre></td></tr></table></figure><p>然后就可以使用SQL语句操作数据库了。</p><h4 id="常见错误"><a href="#常见错误" class="headerlink" title="常见错误"></a>常见错误</h4><p>在使用<code>psql</code>连接数据库时，如果提示<code>psql: 致命错误:  对用户&quot;mofan&quot;的对等认证失败</code>，需要修改配置文件<code>pg_hba.conf</code></p><p>这个文件的位置一般在：</p><ul><li><p><code>Mac</code> : 默认是在<code>/Library/PostgreSQL/&lt;版本号&gt;/data</code> 下面。</p></li><li><p><code>Linux</code>: 默认在<code>/etc/postgresql/&lt;版本号&gt;/main</code> 下面。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/postgresql/9.6/main/pg_hba.conf<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs txt"># &quot;local&quot; is for Unix domain socket connections only<br>local   all             all                                     peer # 把这个peer改成md5<br># IPv4 local connections:<br>host    all             all             127.0.0.1/32            md5<br># IPv6 local connections:<br>host    all             all             ::1/128                 md5<br></code></pre></td></tr></table></figure><p>修改完后，使用命令<code>service postgresql restart</code>重启数据库，问题解决。</p><h4 id="远程登录"><a href="#远程登录" class="headerlink" title="远程登录"></a>远程登录</h4><p>如果需要开启远程登录，请参考我的这篇文章：<a href="https://www.mofan.life/2021/03/31/postgresql%E5%BC%80%E5%90%AF%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AE/">PostgreSQL开启远程访问 - Mofan</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>PostgreSQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go-gorilla/session的使用</title>
    <link href="/2021/03/27/Go-gorilla-session%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/03/27/Go-gorilla-session%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p>我们都知道，现在的互联网都是可以交互的，都是可以记录用户信息的。比如我的浏览记录，我的订单，我的个人信息。这些都是可以保存到服务器上的。那么服务器是如何识别每个用户的呢？答案就是session.通过session我们可以识别是哪个用户访问了网站，我们就可以返回给他指定的信息。</p><p>那么session的原理是什么？它是怎么实现的呢？</p><p>简单来说，session就是一个记录，一个记录用户标识的记录。那么用户是如何告知我们这个记录的呢，一般情况就是通过cookie.将cookie发送给服务器，服务器进行解析，就会识别相应的记录，然后在session记录表中（可以是文件或者数据库）找到对应信息。</p><p>在go语言中我们使用session也非常的方便。</p><p>我们只需要引入gorilla这个包就可以</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span>(<br><span class="hljs-string">&quot;github.com/gorilla/sessions&quot;</span><br>）<br></code></pre></td></tr></table></figure><p>这样我们就可以使用session了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> store = sessions.NewCookieStore([]<span class="hljs-type">byte</span>(<span class="hljs-string">&quot;test&quot;</span>))<br>handleSetSession(w http.ResponseWriter, r *http.Request) &#123;<br>   session, err := store.Get(r, )<br>   err != <span class="hljs-literal">nil</span> &#123;<br>      http.Error(w, err.Error(), http.)<br>      &#125;<br>   session.Values[] = session.Values[] = session.Save(r, w)<br>&#125;<br></code></pre></td></tr></table></figure><p>我们先通过newcookiestore方法声明一个session的空间。然后通过store.get方法设置获取session变量。然后调用session.Values[“name”] &#x3D; “tom” session.Save方法就可以将session保存到服务器上。</p><p>newCookieStore这里保存的是session的秘钥，一般都是通过配置文件获取。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> store = sessions.NewCookieStore([]<span class="hljs-type">byte</span>(os.Getenv(<span class="hljs-string">&quot;SESSION_KEY&quot;</span>)))<br>store.get(r,<span class="hljs-string">&quot;menghuiguli&quot;</span>)<br></code></pre></td></tr></table></figure><p>这里设置的才是session的名字</p>]]></content>
    
    
    <categories>
      
      <category>开源项目</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>开源项目</tag>
      
      <tag>gorilla</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言ioutil.ReadFile 与ioutil.ReadAll差别</title>
    <link href="/2021/03/27/Go%E8%AF%AD%E8%A8%80ioutil-ReadFile-%E4%B8%8Eioutil-ReadAll%E5%B7%AE%E5%88%AB/"/>
    <url>/2021/03/27/Go%E8%AF%AD%E8%A8%80ioutil-ReadFile-%E4%B8%8Eioutil-ReadAll%E5%B7%AE%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p><strong>当读取91.2 MB文件时，read1耗时43ms，read2耗时99ms。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;flag&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;io/ioutil&quot;</span><br>    <span class="hljs-string">&quot;os&quot;</span><br>    <span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">read1</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> &#123;<br>    ioutil.ReadFile(filename)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">read2</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> &#123;<br>    f, err := os.Open(filename)<br>    <span class="hljs-keyword">defer</span> f.Close()<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(<span class="hljs-string">&quot;os Open error: &quot;</span>, err)<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    ioutil.ReadAll(f)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    flag.Parse()<br>    file := flag.Arg(<span class="hljs-number">0</span>)<br>    start := time.Now()<br>    read1(file)<br>    t1 := time.Now()<br>    fmt.Printf(<span class="hljs-string">&quot;Cost time %v\n&quot;</span>, t1.Sub(start))<br>    read2(file)<br>    t2 := time.Now()<br>    fmt.Printf(<span class="hljs-string">&quot;Cost time %v\n&quot;</span>, t2.Sub(t1))<br><br>&#125;<br></code></pre></td></tr></table></figure><p>查看源代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// ReadAll reads from r until an error or EOF and returns the data it read.</span><br><span class="hljs-comment">// A successful call returns err == nil, not err == EOF. Because ReadAll is</span><br><span class="hljs-comment">// defined to read from src until EOF, it does not treat an EOF from Read</span><br><span class="hljs-comment">// as an error to be reported.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadAll</span><span class="hljs-params">(r io.Reader)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">return</span> readAll(r, bytes.MinRead)<br>&#125;<br><br><span class="hljs-comment">// ReadFile reads the file named by filename and returns the contents.</span><br><span class="hljs-comment">// A successful call returns err == nil, not err == EOF. Because ReadFile</span><br><span class="hljs-comment">// reads the whole file, it does not treat an EOF from Read as an error</span><br><span class="hljs-comment">// to be reported.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadFile</span><span class="hljs-params">(filename <span class="hljs-type">string</span>)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>) &#123;<br>    f, err := os.Open(filename)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>    &#125;<br>    <span class="hljs-keyword">defer</span> f.Close()<br>    <span class="hljs-comment">// It&#x27;s a good but not certain bet that FileInfo will tell us exactly how much to</span><br>    <span class="hljs-comment">// read, so let&#x27;s try it but be prepared for the answer to be wrong.</span><br>    <span class="hljs-keyword">var</span> n <span class="hljs-type">int64</span> = bytes.MinRead<br><br>    <span class="hljs-keyword">if</span> fi, err := f.Stat(); err == <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-comment">// As initial capacity for readAll, use Size + a little extra in case Size</span><br>        <span class="hljs-comment">// is zero, and to avoid another allocation after Read has filled the</span><br>        <span class="hljs-comment">// buffer. The readAll call will read into its allocated internal buffer</span><br>        <span class="hljs-comment">// cheaply. If the size was wrong, we&#x27;ll either waste some space off the end</span><br>        <span class="hljs-comment">// or reallocate as needed, but in the overwhelmingly common case we&#x27;ll get</span><br>        <span class="hljs-comment">// it just right.</span><br>        <span class="hljs-keyword">if</span> size := fi.Size() + bytes.MinRead; size &gt; n &#123;<br>            n = size<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> readAll(f, n)<br>&#125;<br><br><span class="hljs-comment">// readAll reads from r until an error or EOF and returns the data it read</span><br><span class="hljs-comment">// from the internal buffer allocated with a specified capacity.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">readAll</span><span class="hljs-params">(r io.Reader, capacity <span class="hljs-type">int64</span>)</span></span> (b []<span class="hljs-type">byte</span>, err <span class="hljs-type">error</span>) &#123;<br>    <span class="hljs-keyword">var</span> buf bytes.Buffer<br>    <span class="hljs-comment">// If the buffer overflows, we will get bytes.ErrTooLarge.</span><br>    <span class="hljs-comment">// Return that as an error. Any other panic remains.</span><br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        e := <span class="hljs-built_in">recover</span>()<br>        <span class="hljs-keyword">if</span> e == <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> panicErr, ok := e.(<span class="hljs-type">error</span>); ok &amp;&amp; panicErr == bytes.ErrTooLarge &#123;<br>            err = panicErr<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">panic</span>(e)<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">if</span> <span class="hljs-type">int64</span>(<span class="hljs-type">int</span>(capacity)) == capacity &#123;<br>        buf.Grow(<span class="hljs-type">int</span>(capacity))<br>    &#125;<br>    _, err = buf.ReadFrom(r)<br>    <span class="hljs-keyword">return</span> buf.Bytes(), err<br>&#125;<br><br><span class="hljs-comment">// ReadFrom reads data from r until EOF and appends it to the buffer, growing</span><br><span class="hljs-comment">// the buffer as needed. The return value n is the number of bytes read. Any</span><br><span class="hljs-comment">// error except io.EOF encountered during the read is also returned. If the</span><br><span class="hljs-comment">// buffer becomes too large, ReadFrom will panic with ErrTooLarge.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Buffer)</span></span> ReadFrom(r io.Reader) (n <span class="hljs-type">int64</span>, err <span class="hljs-type">error</span>) &#123;<br>    b.lastRead = opInvalid<br>    <span class="hljs-keyword">for</span> &#123;<br>        i := b.grow(MinRead)<br>        b.buf = b.buf[:i]<br>        m, e := r.Read(b.buf[i:<span class="hljs-built_in">cap</span>(b.buf)])<br>        <span class="hljs-keyword">if</span> m &lt; <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-built_in">panic</span>(errNegativeRead)<br>        &#125;<br><br>        b.buf = b.buf[:i+m]<br>        n += <span class="hljs-type">int64</span>(m)<br>        <span class="hljs-keyword">if</span> e == io.EOF &#123;<br>            <span class="hljs-keyword">return</span> n, <span class="hljs-literal">nil</span> <span class="hljs-comment">// e is EOF, so return nil explicitly</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> e != <span class="hljs-literal">nil</span> &#123;<br>            <span class="hljs-keyword">return</span> n, e<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>读取文件主要是通过<code>Read(p []byte) (n int, err error)</code>：</p><p>官方文档中关于该接口方法的说明：</p><blockquote><p>Read 将 len(p) 个字节读取到 p 中。它返回读取的字节数 n（0 &lt;&#x3D; n &lt;&#x3D; len(p)） 以及任何遇到的错误。即使 &gt;Read 返回的 n &lt; len(p)，它也会在调用过程中占用 len(p) 个字节作为暂存空间。若可读取的数据不到 len(p) &gt;个字节，Read 会返回可用数据，而不是等待更多数据。</p></blockquote><blockquote><p>当 Read 在成功读取 n &gt; 0 个字节后遇到一个错误或 EOF (end-of-file)，它会返回读取的字节数。它可能会&gt;&gt;同时在本次的调用中返回一个non-nil错误,或在下一次的调用中返回这个错误（且 n 为 0）。 一般情况下, &gt;Reader会返回一个非0字节数n, 若 n &#x3D; len(p) 个字节从输入源的结尾处由 Read 返回，Read可能返回 err &#x3D;&#x3D; &gt;EOF 或者 err &#x3D;&#x3D; nil。并且之后的 Read() 都应该返回 (n:0, err:EOF)。</p></blockquote><blockquote><p>调用者在考虑错误之前应当首先处理返回的数据。这样做可以正确地处理在读取一些字节后产生的 I&#x2F;O 错误，同时允许EOF的出现。</p></blockquote><p><strong>结论：</strong><br>ReadFile(filename string)方法之所以速度快的原因就是先计算出file文件的size，在初始化对应size大小的buff，传入ReadRead(p []byte) 来读取字节流。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>理解Session、Cookie、Token</title>
    <link href="/2021/03/27/%E7%90%86%E8%A7%A3Session%E3%80%81Cookie%E3%80%81Token/"/>
    <url>/2021/03/27/%E7%90%86%E8%A7%A3Session%E3%80%81Cookie%E3%80%81Token/</url>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>首先要知道，<strong>HTTP是一个无状态协议</strong>。</p><p>什么是无状态呢？就是客户端发送的每一次请求对于服务器而言都是新的请求，也是是这次的请求和上一次的请求没有任何关系，它甚至不能确定这次的请求是不是来自同一个客户端发送的。</p><p>这种无状态的的好处是快速。坏处是假如我们想要把<code>www.zhihu.com/login.html</code>和<code>www.zhihu.com/index.html</code>关联起来，必须使用某些手段和工具。</p><h3 id="Cookie和Session"><a href="#Cookie和Session" class="headerlink" title="Cookie和Session"></a>Cookie和Session</h3><p>由于<code>http</code>的无状态性，所以客户端发送不同请求时，都需要带上用户名和密码这些数据，服务器需要对每个请求做一次身份认证，这无疑增加了服务器的性能开销，为了避免这种无意义的浪费，<code>Session</code>和<code>Cookie</code>出现了。</p><p>客户端访问服务器的流程如下</p><ul><li>首先，客户端会发送一个<code>http</code>请求到服务器端。</li><li>服务器端接受客户端请求后，建立一个<code>session</code>，并发送一个<code>http</code>响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了<code>sessionId</code>。</li><li>在客户端以后发起的每次请求，浏览器会自动在请求头中添加<code>Cookie</code>。</li><li>服务器接收请求，分解<code>Cookie</code>，验证信息，核对成功后返回<code>response</code>给客户端。</li></ul><p><img src="https://www.cmdbyte.com/2021/02/cookie-sesssion.png" alt="cookie-sesssion"></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li><code>Cookie</code>只是实现<code>Session</code>的其中一种方案。虽然是最常用的，但并不是唯一的方法。禁用<code>Cookie</code>后还有其他方法存储，比如放在<code>url</code>中。</li><li>现在大多都是<code>Session + Cookie</code>，但是只用<code>Session</code>不用<code>Cookie</code>，或是只用<code>Cookie</code>，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用。</li><li>用session只需要在客户端保存一个id，实际上大量数据都是保存在服务端。如果全部用<code>Cookie</code>，数据量大的时候客户端是没有那么多空间的。</li><li>如果只用<code>Cookie</code> 不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大。</li></ul><p><strong>总之，Cookie类似于你的身份证，它是一个物体，充当的是媒介，而Session就是上面的信息，充当的是认证。</strong></p><h3 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h3><p><code>Token</code> 也称作令牌，由<code>uid+time+sign[+固定参数]</code>组成。<br><code>Token</code> 的认证方式类似于<strong>临时的证书签名</strong>, 并且是一种服务端无状态的认证方式, 非常适合于 <code>Restful API </code>的场景. 所谓无状态就是服务端并不会保存身份认证相关的数据。</p><h4 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h4><ul><li>uid: 用户唯一身份标识</li><li>time: 当前时间的时间戳</li><li>sign: 签名, 使用 hash&#x2F;encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接</li><li>固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库</li></ul><h4 id="存放"><a href="#存放" class="headerlink" title="存放"></a>存放</h4><p><code>Token</code>在客户端一般存放于<code>localStorage</code>，<code>Cookie</code>，或<code>sessionStorage</code>中。在服务器一般存于数据库中。</p><h4 id="Token认证流程"><a href="#Token认证流程" class="headerlink" title="Token认证流程"></a>Token认证流程</h4><p><code>Token</code> 的认证流程与<code>Session</code>很相似</p><ul><li>用户登录，成功后服务器返回<code>Token</code>给客户端。</li><li>客户端收到数据后保存在客户端</li><li>客户端再次访问服务器，将<code>Token</code>放入<code>headers</code>中</li><li>服务器端采用过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li></ul><h3 id="Token可以抵抗csrf，cookie-session不行"><a href="#Token可以抵抗csrf，cookie-session不行" class="headerlink" title="Token可以抵抗csrf，cookie+session不行"></a>Token可以抵抗csrf，cookie+session不行</h3><p>假如用户正在登陆银行网页，同时登陆了攻击者的网页，并且银行网页未对csrf攻击进行防护。攻击者就可以在网页放一个表单，该表单提交src为<code>http://www.bank.com/api/transfer</code>，body为<code>count=1000&amp;to=Tom</code>。倘若是<code>Session+Cookie</code>，用户打开网页的时候就已经转给Tom1000元了.因为form 发起的 <code>POST</code> 请求并不受到浏览器同源策略的限制，因此可以任意地使用其他域的 <code>Cookie</code> 向其他域发送 <code>POST</code> 请求，形成 <code>CSRF</code> 攻击。在post请求的瞬间，<code>Cookie</code> 会被浏览器自动添加到请求头中。但<code>Token</code>不同，<code>Token</code>是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到<code>headers</code>里，攻击者也无法访问用户的<code>Token</code>，所以提交的表单无法通过服务器过滤，也就无法形成攻击。</p><h3 id="分布式情况下的Session和Token"><a href="#分布式情况下的Session和Token" class="headerlink" title="分布式情况下的Session和Token"></a>分布式情况下的Session和Token</h3><p>我们已经知道<code>Session</code>时有状态的，一般存于服务器内存或硬盘中，当服务器采用分布式或集群时，<code>Session</code>就会面对负载均衡问题。</p><ul><li>负载均衡多服务器的情况，不好确认当前用户是否登录，因为多服务器不共享<code>Session</code>。这个问题也可以将<code>Session</code>存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。当今的几种<a href="http://blog.51cto.com/zhibeiwang/1965018">解决session负载均衡</a>的方法。</li></ul><p>而<code>Token</code>是无状态的，<code>Token</code>字符串里就保存了所有的用户信息</p><ul><li>客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递<code>Token</code>，服务端解密<code>token</code>，就知道这个用户是谁了。通过cpu加解密，服务端就不需要存储session占用存储空间，就很好的解决负载均衡多服务器的问题了。这个方法叫做<code>JWT</code>。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><code>Session</code>存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号<code>SessionId</code>，通常存放于<code>Cookie</code>中。服务器收到<code>Cookie</code>后解析出<code>SessionId</code>，再去<code>Session</code>列表中查找，才能找到相应<code>Session</code>。</li><li><code>Cookie</code>类似一个令牌，装有<code>SessionId</code>，存储在客户端，浏览器通常会自动添加。</li><li><code>Token</code>也类似一个令牌，无状态，用户信息都被加密到<code>Token</code>中，服务器收到<code>Token</code>后解密就可知道是哪个用户。需要开发者手动添加。</li><li><code>JWT</code>只是一个跨域认证的方案。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go的os包常用操作</title>
    <link href="/2021/03/26/Go%E7%9A%84os%E5%8C%85%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/"/>
    <url>/2021/03/26/Go%E7%9A%84os%E5%8C%85%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p><strong>创建目录</strong></p><ul><li>os.Mkdir(“abc”, os.ModePerm) &#x2F;&#x2F;创建单个目录</li><li>os.MkdirAll(“a&#x2F;b&#x2F;c”, os.ModePerm) &#x2F;&#x2F;创建多级目录</li></ul><p><strong>注意：</strong>os.Mkdir创建重复的目录会产生error，os.MkdirAll则不会</p><p><strong>获取当前路径</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">os.Getwd()<br></code></pre></td></tr></table></figure><p><strong>创建文件</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">f, _ := os.Create(<span class="hljs-string">&quot;./abc.txt&quot;</span>) <span class="hljs-comment">//创建文件</span><br><span class="hljs-keyword">defer</span> f.Close()<br></code></pre></td></tr></table></figure><p><strong>打开文件</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">f, _ := os.OpenFile(<span class="hljs-string">&quot;./abc.txt&quot;</span>, os.O_RDWR|os.O_CREATE|os.O_TRUNC, <span class="hljs-number">666</span>)<br></code></pre></td></tr></table></figure><p><strong>删除文件</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">os.Remove(<span class="hljs-string">&quot;a/b/c&quot;</span>)<br>os.Remove(<span class="hljs-string">&quot;a/b/c/d.txt&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>删除目录</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">os.RemoveAll(<span class="hljs-string">&quot;abc&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>重命名文件</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">os.Rename(<span class="hljs-string">&quot;a.txt&quot;</span>, <span class="hljs-string">&quot;b.txt&quot;</span>)<br></code></pre></td></tr></table></figure><p>待整理：</p><p><a href="https://studygolang.com/articles/5024">golang中os包用法 - Go语言中文网 - Golang中文社区</a></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go的json.Marshal和json.Unmarshal</title>
    <link href="/2021/03/25/Go%E7%9A%84json.Marshal%E5%92%8Cjson.Unmarshal/"/>
    <url>/2021/03/25/Go%E7%9A%84json.Marshal%E5%92%8Cjson.Unmarshal/</url>
    
    <content type="html"><![CDATA[<blockquote><p>官方介绍： <a href="https://blog.golang.org/json">JSON and Go - The Go Blog</a></p></blockquote><h3 id="json-Marshal"><a href="#json-Marshal" class="headerlink" title="json.Marshal"></a>json.Marshal</h3><p>我们可以使用 <code>json.Marshal</code> 将 <code>JSON</code> 编码成字节数据。</p><p>函数定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Marshal</span><span class="hljs-params">(v <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> ([]<span class="hljs-type">byte</span>, <span class="hljs-type">error</span>)<br></code></pre></td></tr></table></figure><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;encoding/json&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <br>    <span class="hljs-keyword">type</span> Message <span class="hljs-keyword">struct</span> &#123;<br>        Name <span class="hljs-type">string</span><br>        Body <span class="hljs-type">string</span><br>        Time <span class="hljs-type">int64</span><br>    &#125;<br>    <br>    m := Message&#123;<span class="hljs-string">&quot;Alice&quot;</span>, <span class="hljs-string">&quot;中国&quot;</span>, <span class="hljs-number">1294706395881547000</span>&#125;<br>    b, err := json.Marshal(m)<br>    <br>    <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> &#123;<br>        fmt.Println(b)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[123 34 78 97 109 101 34 58 34 65 108 105 99 101 34 44 34 66 111 100 121 34 58 34 228 184 173 229 155 189 34 44 34 84 105 109 101 34 58 49 50 57 52 55 48 54 51 57 53 56 56 49 53 52 55 48 48 48 125]<br></code></pre></td></tr></table></figure><p>注意：</p><ul><li><code>json.Marshal</code>只能编码 <code>JSON</code> 结构数据</li><li>它只支持 <code>string</code> 类型的 <code>key</code>，如果字段是 <code>map</code> 类型，那么必须是<code>map[string]T</code> 类型</li><li>不支持<code>channel</code>、<code>complex</code>、<code>function</code> 类型数据的编码</li><li>不支持本数据结构嵌套的结构体编码</li><li>指针类型经过编码后值是它代表的内存位置存储的值，如果指针为<code>nil</code>，则编码后的值为 <code>null</code></li><li>它只编码可导出的字段（首字母大写的字段）</li></ul><h3 id="json-Unmarshal"><a href="#json-Unmarshal" class="headerlink" title="json.Unmarshal"></a>json.Unmarshal</h3><p>将字节数据解析成<code>JSON</code> 数据</p><p>函数定义：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">func Unmarshal(data []byte, v interface&#123;&#125;) error<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言sync.Map</title>
    <link href="/2021/03/25/Go%E8%AF%AD%E8%A8%80sync-Map/"/>
    <url>/2021/03/25/Go%E8%AF%AD%E8%A8%80sync-Map/</url>
    
    <content type="html"><![CDATA[<p>Go语言中的<code>map</code>在并发情况下，只读是线程安全的，同时读写是线程不安全的。</p><p>下面来看下并发情况下读写<code>map</code>会出现的问题。代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <br>    m := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">int</span>)<br>    <br>    <span class="hljs-comment">// 开启一个goroutine持续对 map 赋值</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> &#123;<br>            m[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span><br>        &#125;<br>    &#125;()<br>    <br>    <span class="hljs-comment">// 开启一个goroutine持续读 map 的值</span><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        _ = m[<span class="hljs-number">0</span>]<br>    &#125;()<br>    <br>    <span class="hljs-comment">// 让程序在后台执行</span><br>    <span class="hljs-keyword">for</span> &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行上面的代码会报错，输出如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">fatal error: concurrent map read and map write<br></code></pre></td></tr></table></figure><p>错误信息显示，并发的 <code>map</code> 读和 <code>map</code> 写，也就是说使用了两个并发函数不断地对 <code>map</code> 进行读和写而发生了竞态问题，<code>map</code> 内部会对这种并发操作进行检查并提前发现。</p><p>需要并发读写时，一般的做法是加锁，但这样性能并不高，Go语言在 <code>1.9</code> 版本中提供了一种效率较高且并发安全的 <code>sync.Map</code>，<code>sync.Map</code> 和 <code>map</code> 不同，它不是以语言原生形态提供，而是 <code>sync</code> 包下的特殊结构。</p><p><code>sync.Map</code> 有以下特性：</p><ul><li>无须初始化，直接声明即可用</li><li><code>sync.Map</code> 不能使用 <code>map</code> 的方式进行取值和赋值等操作，而是使用 <code>sync.Map</code> 的方法进行调用，<code>Store</code> 表示存储，<code>Load</code> 表示获取，<code>Delete</code> 表示删除。</li><li>使用 <code>Range</code> 配合一个回调函数进行遍历操作，通过回调函数返回内部遍历出来的值，<code>Range</code> 参数中回调函数的返回值在需要继续迭代遍历时，返回 <code>true</code>，终止迭代遍历时，返回 <code>false</code>。</li></ul><p>下面是一段并发安全的 <code>sync.Map</code> 的代码演示：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>      <span class="hljs-string">&quot;fmt&quot;</span><br>      <span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-keyword">var</span> sm sync.Map<br><br>    <span class="hljs-comment">// 将键值对保存到 sync.Map</span><br>    sm.Store(<span class="hljs-string">&quot;greece&quot;</span>, <span class="hljs-number">97</span>)<br>    sm.Store(<span class="hljs-string">&quot;london&quot;</span>, <span class="hljs-number">100</span>)<br>    sm.Store(<span class="hljs-string">&quot;egypt&quot;</span>, <span class="hljs-number">200</span>)<br><br>    <span class="hljs-comment">// 从 sync.Map 中根据键取值</span><br>    fmt.Println(sm.Load(<span class="hljs-string">&quot;london&quot;</span>))<br><br>    <span class="hljs-comment">// 根据键删除对应的键值对</span><br>    sm.Delete(<span class="hljs-string">&quot;london&quot;</span>)<br><br>    <span class="hljs-comment">// 遍历所有 sync.Map 中的键值对</span><br>    sm.Range(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(k, v <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br><br>        fmt.Println(<span class="hljs-string">&quot;iterate:&quot;</span>, k, v)<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure><p>代码输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">100 true<br>iterate: greece 97<br>iterate: egypt 200<br></code></pre></td></tr></table></figure><p>若将上面代码的<code>return true</code> 改为 <code>return false</code> ，则输出为：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">100 true<br>iterate: greece 97<br>// 也就是最后的 sm.Range 不会输出.<br></code></pre></td></tr></table></figure><p><code>sync.Map</code> 没有提供获取 <code>map</code> 数量的方法，替代方法是在获取 <code>sync.Map</code> 时遍历自行计算数量，<code>sync.Map</code> 为了保证并发安全有一些性能损失，因此在非并发情况下，使用 <code>map</code> 相比使用 <code>sync.Map</code> 会有更好的性能。</p><p>下面代码与本文开始的代码相比，它可以持续运行，不会因为并发读写同一资源而终止。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;sync&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <br>    <span class="hljs-keyword">var</span> sm sync.Map<br>    <br>    sm.Store(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-number">1</span>)<br>    <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> &#123;<br>            _, _ = sm.Load(<span class="hljs-string">&quot;a&quot;</span>)<br>        &#125;<br>    &#125;()<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-keyword">for</span> &#123;<br>            _, _ = sm.Load(<span class="hljs-string">&quot;a&quot;</span>)<br>        &#125;<br>    &#125;()<br>    <br>    <span class="hljs-keyword">for</span> &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的程序会持续运行，不会因为资源竞态问题而终止。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go占位符的使用</title>
    <link href="/2021/03/24/Go%E5%8D%A0%E4%BD%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2021/03/24/Go%E5%8D%A0%E4%BD%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="普通占位符"><a href="#普通占位符" class="headerlink" title="普通占位符"></a>普通占位符</h2><p>假设有如下数据：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Human <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-keyword">var</span> people = Human&#123;Name:<span class="hljs-string">&quot;zhangsan&quot;</span>&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">占位符</th><th align="center">说明</th><th align="center">举例</th><th align="center">输出</th></tr></thead><tbody><tr><td align="left">%v</td><td align="center">相应值的默认格式。</td><td align="center">Printf(“%v”, people)</td><td align="center">{zhangsan}</td></tr><tr><td align="left">%+v</td><td align="center">打印结构体时，会添加字段名</td><td align="center">Printf(“%+v”, people)</td><td align="center">{Name:zhangsan}</td></tr><tr><td align="left">%#v</td><td align="center">相应值的Go语法表示</td><td align="center">Printf(“#v”, people)</td><td align="center">main.Human{Name:”zhangsan”}</td></tr><tr><td align="left">%T</td><td align="center">相应值的类型的Go语法表示</td><td align="center">Printf(“%T”, people)</td><td align="center">main.Human</td></tr><tr><td align="left">%%</td><td align="center">字面上的百分号，并非值的占位符</td><td align="center">Printf(“%%”)</td><td align="center">%</td></tr></tbody></table><h2 id="布尔占位符"><a href="#布尔占位符" class="headerlink" title="布尔占位符"></a>布尔占位符</h2><table><thead><tr><th align="left">占位符</th><th align="center">说明</th><th align="center">举例</th><th align="center">输出</th></tr></thead><tbody><tr><td align="left">%t</td><td align="center">true 或 false</td><td align="center">Printf(“%t”, true)</td><td align="center">true</td></tr></tbody></table><h2 id="整数占位符"><a href="#整数占位符" class="headerlink" title="整数占位符"></a>整数占位符</h2><table><thead><tr><th align="left">占位符</th><th align="center">说明</th><th align="center">举例</th><th align="center">输出</th></tr></thead><tbody><tr><td align="left">%b</td><td align="center">二进制表示</td><td align="center">Printf(“%b”, 5)</td><td align="center">101</td></tr><tr><td align="left">%c</td><td align="center">相应Unicode码点所表示的字符</td><td align="center">Printf(“%c”, 0x4E2D)</td><td align="center">中</td></tr><tr><td align="left">%d</td><td align="center">十进制表示</td><td align="center">Printf(“%d”, 0x12)</td><td align="center">18</td></tr><tr><td align="left">%o</td><td align="center">八进制表示</td><td align="center">Printf(“%d”, 10)</td><td align="center">12</td></tr><tr><td align="left">%q</td><td align="center">单引号围绕的字符字面值，由Go语法安全地转义</td><td align="center">Printf(“%q”, 0x4E2D)</td><td align="center">‘中’</td></tr><tr><td align="left">%x</td><td align="center">十六进制表示，字母形式为小写 a-f</td><td align="center">Printf(“%x”, 13)</td><td align="center">d</td></tr><tr><td align="left">%X</td><td align="center">十六进制表示，字母形式为大写 A-F</td><td align="center">Printf(“%x”, 13)</td><td align="center">D</td></tr><tr><td align="left">%U</td><td align="center">Unicode格式：U+1234，等同于 “U+%04X”</td><td align="center">Printf(“%U”, 0x4E2D)</td><td align="center">U+4E2D</td></tr></tbody></table><h2 id="浮点数和复数的组成部分（实部和虚部）"><a href="#浮点数和复数的组成部分（实部和虚部）" class="headerlink" title="浮点数和复数的组成部分（实部和虚部）"></a>浮点数和复数的组成部分（实部和虚部）</h2><table><thead><tr><th align="left">占位符</th><th align="center">说明</th><th align="center">举例</th><th align="center">输出</th></tr></thead><tbody><tr><td align="left">%b</td><td align="center">无小数部分的，指数为二的幂的科学计数法， 与 strconv.FormatFloat 的 ‘b’ 转换格式一致。例如 -123456p-78</td><td align="center"></td><td align="center"></td></tr><tr><td align="left">%e</td><td align="center">科学计数法，例如 -1234.456e+78</td><td align="center">Printf(“%e”, 10.2)</td><td align="center">1.020000e+01</td></tr><tr><td align="left">%E</td><td align="center">科学计数法，例如 -1234.456E+78</td><td align="center">Printf(“%e”, 10.2)</td><td align="center">1.020000E+01</td></tr><tr><td align="left">%f</td><td align="center">有小数点而无指数，例如 123.456</td><td align="center">Printf(“%f”, 10.2)</td><td align="center">10.200000</td></tr><tr><td align="left">%g</td><td align="center">根据情况选择 %e 或 %f 以产生更紧凑的（无末尾的0）输出</td><td align="center">Printf(“%g”, 10.20)</td><td align="center">10.2</td></tr><tr><td align="left">%G</td><td align="center">根据情况选择 %E 或 %f 以产生更紧凑的（无末尾的0）输出</td><td align="center">Printf(“%G”, 10.20+2i)</td><td align="center">(10.2+2i)</td></tr></tbody></table><h2 id="字符串与字节切片"><a href="#字符串与字节切片" class="headerlink" title="字符串与字节切片"></a>字符串与字节切片</h2><table><thead><tr><th align="left">占位符</th><th align="center">说明</th><th align="center">举例</th><th align="center">输出</th></tr></thead><tbody><tr><td align="left">%s</td><td align="center">输出字符串表示（string类型或[]byte)</td><td align="center">Printf(“%s”, []byte(“Go语言”))</td><td align="center">Go语言</td></tr><tr><td align="left">%q</td><td align="center">双引号围绕的字符串，由Go语法安全地转义</td><td align="center">Printf(“%q”, “Go语言”)</td><td align="center">“Go语言”</td></tr><tr><td align="left">%x</td><td align="center">十六进制，小写字母，每字节两个字符</td><td align="center">Printf(“%x”, “golang”)</td><td align="center">676f6c616e67</td></tr><tr><td align="left">%X</td><td align="center">十六进制，大写字母，每字节两个字符</td><td align="center">Printf(“%X”, “golang”)</td><td align="center">676F6C616E67</td></tr></tbody></table><h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><table><thead><tr><th align="left">占位符</th><th align="center">说明</th><th align="center">举例</th><th align="center">输出</th></tr></thead><tbody><tr><td align="left">%p</td><td align="center">十六进制表示，前缀 0x</td><td align="center">Printf(“%p”, &amp;people)</td><td align="center">0x4f57f0</td></tr></tbody></table><h2 id="其它标记"><a href="#其它标记" class="headerlink" title="其它标记"></a>其它标记</h2><table><thead><tr><th align="left">占位符</th><th align="center">说明</th><th align="center">举例</th><th align="center">输出</th></tr></thead><tbody><tr><td align="left">+</td><td align="center">总打印数值的正负号；对于%q（%+q）保证只输出ASCII编码的字符。</td><td align="center">Printf(“%+q”, “中文”)</td><td align="center">“\u4e2d\u6587”</td></tr><tr><td align="left">-</td><td align="center">在右侧而非左侧填充空格（左对齐该区域）</td><td align="center"></td><td align="center"></td></tr><tr><td align="left">#</td><td align="center">备用格式：为八进制添加前导 0（%#o）  为十六进制添加前导 0x（%#x）或 0X（%#X），为 %p（%#p）去掉前导 0x；       如果可能的话，%q（%#q）会打印原始 （即反引号围绕的）字符串；  如果是可打印字符，%U（%#U）会写出该字符的       Unicode 编码形式（如字符 x 会被打印成 U+0078 ‘x’）。</td><td align="center">Printf(“%#U”, ‘中’)</td><td align="center">U+4E2D</td></tr><tr><td align="left">‘ ‘</td><td align="center">(空格)为数值中省略的正负号留出空白（% d）；   以十六进制（% x, % X）打印字符串或切片时，在字节之间用空格隔开</td><td align="center"></td><td align="center"></td></tr><tr><td align="left">0</td><td align="center">填充前导的0而非空格；对于数字，这会将填充移到正负号之后</td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>golang没有 ‘%u’ 点位符，若整数为无符号类型，默认就会被打印成无符号的。</p><p>宽度与精度的控制格式以Unicode码点为单位。宽度为该数值占用区域的最小宽度；精度为小数点之后的位数。<br> 操作数的类型为int时，宽度与精度都可用字符 ‘*’ 表示。</p><p>对于 %g&#x2F;%G 而言，精度为所有数字的总数，例如：123.45，%.4g 会打印123.5，（而 %6.2f 会打印123.45）。</p><p>%e 和 %f 的默认精度为6</p><p>对大多数的数值类型而言，宽度为输出的最小字符数，如果必要的话会为已格式化的形式填充空格。</p><p>而以字符串类型，精度为输出的最大字符数，如果必要的话会直接截断。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中string函数与strconv.Itoa函数的区别</title>
    <link href="/2021/03/24/Go%E4%B8%ADstring%E5%87%BD%E6%95%B0%E4%B8%8Estrconv-Itoa%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/03/24/Go%E4%B8%ADstring%E5%87%BD%E6%95%B0%E4%B8%8Estrconv-Itoa%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<h2 id="Itoa函数"><a href="#Itoa函数" class="headerlink" title="Itoa函数"></a>Itoa函数</h2><p>strconv.Itoa()函数的参数是一个整型数字，它可以将数字转换成对应的字符串类型的数字。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;strconv&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>string_number := <span class="hljs-number">97</span><br>result := strconv.Itoa(string_number)<br> <br>fmt.Println(result)<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, result)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">97<br>string<br></code></pre></td></tr></table></figure><h2 id="string函数"><a href="#string函数" class="headerlink" title="string函数"></a>string函数</h2><p>string函数的参数若是一个整型数字，它将该整型数字转换成ASCII码值等于该整形数字的字符。string()函数是Go语言的内置函数，不需要导入任何包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>string_number := <span class="hljs-number">97</span><br>result := <span class="hljs-type">string</span>(string_number)<br>fmt.Println(result)<br>fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>, result)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">a<br>string<br></code></pre></td></tr></table></figure><p>因为ASCII码值为97对应的字符是a，所以string(97)的结果是a</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go命名规范</title>
    <link href="/2021/03/24/Go%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/"/>
    <url>/2021/03/24/Go%E5%91%BD%E5%90%8D%E8%A7%84%E8%8C%83/</url>
    
    <content type="html"><![CDATA[<h2 id="文件命名规范"><a href="#文件命名规范" class="headerlink" title="文件命名规范"></a>文件命名规范</h2><h3 id="平台区分"><a href="#平台区分" class="headerlink" title="平台区分"></a>平台区分</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">文件名_平台<br><br>平台可选为：windows, unix, posix, plan9, darwin, bsd, linux, freebsd, nacl, netbsd, openbsd, solaris, dragonfly, bsd, notbsd, android, stubs<br><br>例： file_windows.go, file_unix.go<br></code></pre></td></tr></table></figure><h3 id="测试单元"><a href="#测试单元" class="headerlink" title="测试单元"></a>测试单元</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">文件名_test.go(包含 _test.go)或者 文件名_平台_test.go。<br><br>例：_test.go, path_test.go,  path_windows_test.go<br></code></pre></td></tr></table></figure><h3 id="版本区分-猜测"><a href="#版本区分-猜测" class="headerlink" title="版本区分(猜测)"></a>版本区分(猜测)</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">文件名_版本号等。<br><br>例：trap_windows_1.4.go<br></code></pre></td></tr></table></figure><h3 id="CPU类型区分-汇编用的多"><a href="#CPU类型区分-汇编用的多" class="headerlink" title="CPU类型区分, 汇编用的多"></a>CPU类型区分, 汇编用的多</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">文件名_(平台:可选)_CPU类型.<br><br>CPU类型可选：amd64, none, 386, arm, arm64, mips64, s390, mips64x, ppc64x, nonppc64x, s390x, x86, amd64p32<br><br>例：vdso_linux_amd64.go<br></code></pre></td></tr></table></figure><h2 id="变量、方法命名规范"><a href="#变量、方法命名规范" class="headerlink" title="变量、方法命名规范"></a>变量、方法命名规范</h2><p>1、golang的命名需要使用驼峰命名法</p><p>2、golang中根据首字母的大小写来确定可以访问的权限。无论是方法名、常量、变量名还是结构体的名称，如果首字母大写，则可以被其他的包访问；如果首字母小写，则只能在本包中使用。可以简单的理解成，首字母大写是公有的，首字母小写是私有的</p><p>3、结构体中属性名如果小写则在数据解析（如json解析,或将结构体作为请求或访问参数）时无法解析，大写的时候而且没有标签时原样转换。</p><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><h3 id="注意点一"><a href="#注意点一" class="headerlink" title="注意点一"></a>注意点一</h3><p>go build 的时候会选择性地编译以系统名结尾的文件（选择和编译环境设置的系统一致的系统名结尾的文件）。例如Linux(Unix)系统下编译只会选择<code>array_linux.go</code>文件，其它系统命名后缀文件全部忽略。</p><h3 id="注意点二"><a href="#注意点二" class="headerlink" title="注意点二"></a>注意点二</h3><p>在xxx.go文件的文件头上添加 <code>// + build !windows (tags)</code>，可以选择在windows系统下面不编译该文件。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// +build !windows</span><br><br><span class="hljs-keyword">package</span> main<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>UNC路径</title>
    <link href="/2021/03/24/UNC%E8%B7%AF%E5%BE%84/"/>
    <url>/2021/03/24/UNC%E8%B7%AF%E5%BE%84/</url>
    
    <content type="html"><![CDATA[<p>UNC（Universal Naming Convention）：通用命名规则，也称通用命名规范、通用命名约定。</p><p>UNC为网络（主要指局域网）上资源的完整Windows名称。</p><p>UNC路径格式：<code>\\servername\sharename</code>，其中<code>servername</code>是服务器名。<code>sharename</code>是共享资源的名称。</p><p>这些地址以两个反斜线 (<code>\\</code>) 开头，并提供服务器名、共享名和完整的文件路径。例如，<code>“file:\server\share\path\project file.mpp”</code>是绝对 UNC 地址。</p><p>虽然UNC路径为Win系统所创，有的时候在代码中，还是能看到使用<code>forward slash的</code>UNC样式：<code>//servername/dirname/file</code>。</p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言sync包</title>
    <link href="/2021/03/24/Go%E8%AF%AD%E8%A8%80sync%E5%8C%85/"/>
    <url>/2021/03/24/Go%E8%AF%AD%E8%A8%80sync%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<blockquote><p>来自：<a href="https://blog.csdn.net/chenguolinblog/article/details/90691127">Golang Sync包_藏经阁 | 玄苦-CSDN博客</a></p><p>本来是想参考着写的，但奈何人家写的太精美，只能直接照搬了，看来我还有很长的路要走，加油吧！</p></blockquote><h2 id="sync-Mutex"><a href="#sync-Mutex" class="headerlink" title="sync.Mutex"></a>sync.Mutex</h2><p><code>sync.Mutex</code>称为<code>互斥锁</code>，常用在并发编程里面。互斥锁需要保证的是同一个时间段内不能有多个并发协程同时访问某一个资源(临界区)。<br><code>sync.Mutex</code>有2个函数<code>Lock</code>和<code>UnLock</code>分别表示获得锁和释放锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> Lock()<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *Mutex)</span></span> UnLock()<br></code></pre></td></tr></table></figure><p>sync.Mutex初始值为UnLock状态，并且sync.Mutex常做为其它结构体的匿名变量使用。</p><p>举个例子: 我们经常使用网上支付购物东西，就会出现同一个银行账户在某一个时间既有支出也有收入，那银行就得保证我们余额准确，保证数据无误。<br>我们可以简单的实现银行的支出和收入来说明Mutex的使用</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Bank <span class="hljs-keyword">struct</span> &#123;<br>sync.Mutex<br>balance <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-comment">// In 收入</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Bank)</span></span> In(account <span class="hljs-type">string</span>, value <span class="hljs-type">float64</span>) &#123;<br>        <span class="hljs-comment">// 加锁 保证同一时间只有一个协程能访问这段代码</span><br>b.Lock()<br><span class="hljs-keyword">defer</span> b.Unlock()<br><br>v, ok := b.balance[account]<br><span class="hljs-keyword">if</span> !ok &#123;<br>b.balance[account] = <span class="hljs-number">0.0</span><br>&#125;<br><br>b.balance[account] += v<br>&#125;<br><br><span class="hljs-comment">// Out 支出</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Bank)</span></span> Out(account <span class="hljs-type">string</span>, value <span class="hljs-type">float64</span>) <span class="hljs-type">error</span> &#123;<br>        <span class="hljs-comment">// 加锁 保证同一时间只有一个协程能访问这段代码</span><br>b.Lock()<br><span class="hljs-keyword">defer</span> b.Unlock()<br><br>v, ok := b.balance[account]<br><span class="hljs-keyword">if</span> !ok || v &lt; value &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;account not enough balance&quot;</span>)<br>&#125;<br><br>b.balance[account] -= value<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sync-RWMutex"><a href="#sync-RWMutex" class="headerlink" title="sync.RWMutex"></a>sync.RWMutex</h2><p><code>sync.RWMutex</code>称为读写锁是<code>sync.Mutex</code>的一种变种，<code>sync.RWMutex</code>来自于计算机操作系统非常有名的读者写者问题。<br><code>sync.RWMutex</code>目的是为了能够支持多个并发协程同时读取某一个资源，但只有一个并发协程能够更新资源。也就是说读和写是互斥的，写和写也是互斥的，读和读是不互斥的。总结起来如下</p><ol><li>当有一个协程在读的时候，所有写的协程必须等到所有读的协程结束才可以获得锁进行写操作。</li><li>当有一个协程在读的时候，所有读的协程不受影响都可以进行读操作。</li><li>当有一个协程在写的时候，所有读、写的协程必须等到写的协程结束才可以获得锁进行读、写操作。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">mutex := &amp;sync.RWMutex&#123;&#125;<br><br>mutex.Lock()<br><span class="hljs-comment">// Update 共享变量</span><br>mutex.Unlock()<br><br>mutex.RLock()<br><span class="hljs-comment">// Read 共享变量</span><br>mutex.RUnlock()<br></code></pre></td></tr></table></figure><p><strong>它适合用在读取频繁写入不频繁的场景里。</strong></p><p>举个例子，这是一个支持多人同时查询的代码。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Bank <span class="hljs-keyword">struct</span> &#123;<br>sync.RWMutex<br>balance <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">float64</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Bank)</span></span> In(account <span class="hljs-type">string</span>, value <span class="hljs-type">float64</span>) &#123;<br>b.Lock()<br><span class="hljs-keyword">defer</span> b.Unlock()<br><br>v, ok := b.balance[account]<br><span class="hljs-keyword">if</span> !ok &#123;<br>b.balance[account] = <span class="hljs-number">0.0</span><br>&#125;<br><br>b.balance[account] += v<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Bank)</span></span> Out(account <span class="hljs-type">string</span>, value <span class="hljs-type">float64</span>) <span class="hljs-type">error</span> &#123;<br>b.Lock()<br><span class="hljs-keyword">defer</span> b.Unlock()<br><br>v, ok := b.balance[account]<br><span class="hljs-keyword">if</span> !ok || v &lt; value &#123;<br><span class="hljs-keyword">return</span> errors.New(<span class="hljs-string">&quot;account not enough balance&quot;</span>)<br>&#125;<br><br>b.balance[account] -= value<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(b *Bank)</span></span> Query(account <span class="hljs-type">string</span>) <span class="hljs-type">float64</span> &#123;<br>b.RLock()<br><span class="hljs-keyword">defer</span> b.RUnlock()<br><br>v, ok := b.balance[account]<br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0.0</span><br>&#125;<br><br><span class="hljs-keyword">return</span> v<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><p><code>sync.WaitGroup</code>指的是等待组，在Golang并发编程里面非常常见，等待一组工作完成后，再进行下一组工作。</p><p><code>sync.WaitGroup</code>有3个函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wg *WaitGroup)</span></span> Add(delta <span class="hljs-type">int</span>)  Add添加n个并发协程<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wg *WaitGroup)</span></span> Done()  Done完成一个并发协程<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(wg *WaitGroup)</span></span> Wait()  Wait等待其它并发协程结束<br></code></pre></td></tr></table></figure><p><code>sync.WaitGroup</code>拥有一个内部计数器。当计数器等于<code>0</code>时，则<code>Wait()</code>方法会立即返回。否则它将阻塞执行<code>Wait()</code>方法的<code>goroutine</code>直到计数器等于<code>0</code>时为止。要增加计数器，我们必须使用<code>Add(int)</code>方法。要减少它，我们可以使用<code>Done()</code>（将计数器减<code>1</code>），也可以传递负数给<code>Add</code>方法把计数器减少指定大小，<code>Done()</code>方法底层就是通过<code>Add(-1)</code>实现的。</p><p>在以下示例中，我们将启动八个<code>goroutine</code>，并等待他们完成：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">wg := &amp;sync.WaitGroup&#123;&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++ &#123;<br>  wg.Add(<span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">// Do something</span><br>    wg.Done()<br>  &#125;()<br>&#125;<br><br>wg.Wait()<br><span class="hljs-comment">// 继续往下执行...</span><br></code></pre></td></tr></table></figure><p>每次创建<code>goroutine</code>时，我们都会使用<code>wg.Add(1)</code>来增加<code>wg</code>的内部计数器。我们也可以在<code>for</code>循环之前调用<code>wg.Add(8)</code>。</p><p>与此同时，每个<code>goroutine</code>完成时，都会使用<code>wg.Done()</code>减少<code>wg</code>的内部计数器。</p><p><code>main goroutine</code>会在八个<code>goroutine</code>都执行<code>wg.Done()</code>将计数器变为<code>0</code>后才能继续执行。</p><p><code>sync.WaitGroup</code>在Golang编程里面最常用于协程池，下面这个例子会同时启动1000个并发协程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>     wg := &amp;sync.WaitGroup&#123;&#125;<br>     <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>         wg.Add(<span class="hljs-number">1</span>)<br>         <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>     <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>wg.Done()<br>     &#125;()<br>     time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>     fmt.Println(<span class="hljs-string">&quot;hello world ~&quot;</span>)<br> &#125;()<br>     &#125;<br>     <span class="hljs-comment">// 等待所有协程结束</span><br>     wg.Wait()<br>     fmt.Println(<span class="hljs-string">&quot;WaitGroup all process done ~&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>sync.WaitGroup没有办法指定最大并发协程数，在一些场景下会有问题。例如操作数据库场景下，我们不希望某一些时刻出现大量连接数据库导致数据库不可访问。所以，为了能够控制最大的并发数，推荐使用github.com&#x2F;remeh&#x2F;sizedwaitgroup，用法和sync.WaitGroup非常类似。</p><p>下面这个例子最多只有10个并发协程，如果已经达到10个并发协程，只有某一个协程执行了Done才能启动一个新的协程。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">import</span>  <span class="hljs-string">&quot;github.com/remeh/sizedwaitgroup&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>     # 最大<span class="hljs-number">10</span>个并发<br>     wg := sizedwaitgroup.New(<span class="hljs-number">10</span>)<br>     <span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>         wg.Add()<br>         <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>     <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>wg.Done()<br>     &#125;()<br>     time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>     fmt.Println(<span class="hljs-string">&quot;hello world ~&quot;</span>)<br> &#125;()<br>     &#125;<br>     <span class="hljs-comment">// 等待所有协程结束</span><br>     wg.Wait()<br>     fmt.Println(<span class="hljs-string">&quot;WaitGroup all process done ~&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sync-Once"><a href="#sync-Once" class="headerlink" title="sync.Once"></a>sync.Once</h2><p>sync.Once指的是只执行一次的对象实现，常用来控制某些函数只能被调用一次。sync.Once的使用场景例如单例模式、系统初始化。<br>例如并发情况下多次调用channel的close会导致panic，解决这个问题我们可以使用sync.Once来保证close只会被执行一次。</p><p>sync.Once的结构如下所示，只有一个函数。使用变量done来记录函数的执行状态，使用sync.Mutex和sync.atomic来保证线程安全的读取done。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Once <span class="hljs-keyword">struct</span> &#123;<br>m    Mutex     #互斥锁<br>done <span class="hljs-type">uint32</span>    #执行状态<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(o *Once)</span></span> Do(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>)<br></code></pre></td></tr></table></figure><p>举个例子，1000个并发协程情况下只有一个协程会执行到fmt.Printf，多次执行的情况下输出的内容还不一样，因为这取决于哪个协程先调用到该匿名函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>     once := &amp;sync.Once&#123;&#125;<br><br>     <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br> <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(idx <span class="hljs-type">int</span>)</span></span> &#123;<br>    once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(<span class="hljs-number">1</span> * time.Second)<br>fmt.Printf(<span class="hljs-string">&quot;hello world index: %d&quot;</span>, idx)<br>    &#125;)<br> &#125;(i)<br>     &#125;<br><br>     time.Sleep(<span class="hljs-number">5</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="sync-Map"><a href="#sync-Map" class="headerlink" title="sync.Map"></a>sync.Map</h2><p><code>Go</code>语言的<code>sync.Map</code>是一个并发版本的<code>map</code>，它提供了相关方法来操作里面的元素：</p><ul><li>使用<code>Store(interface &#123;&#125;，interface &#123;&#125;)</code>添加元素。</li><li>使用<code>Load(interface &#123;&#125;) interface &#123;&#125;</code>获取元素。</li><li>使用<code>Delete(interface &#123;&#125;)</code>删除元素。</li><li>使用<code>LoadOrStore(interface &#123;&#125;，interface &#123;&#125;) (interface &#123;&#125;，bool)</code>检索或添加之前不存在的元素。如果键之前在<code>map</code>中存在，则返回的布尔值为<code>true</code>。</li><li>使用<code>Range</code>遍历元素。<code>Range</code>方法接收一个类型为<code>func(key，value interface &#123;&#125;)bool</code>的函数参数。如果函数返回了<code>false</code>，则停止迭代。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go">m := &amp;sync.Map&#123;&#125;<br><br><span class="hljs-comment">// 添加元素</span><br>m.Store(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;one&quot;</span>)<br>m.Store(<span class="hljs-number">2</span>, <span class="hljs-string">&quot;two&quot;</span>)<br><br><span class="hljs-comment">// 获取元素1</span><br>value, contains := m.Load(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">if</span> contains &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, value.(<span class="hljs-type">string</span>))<br>&#125;<br><br><span class="hljs-comment">// 返回已存value，否则把指定的键值存储到map中</span><br>value, loaded := m.LoadOrStore(<span class="hljs-number">3</span>, <span class="hljs-string">&quot;three&quot;</span>)<br><span class="hljs-keyword">if</span> !loaded &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, value.(<span class="hljs-type">string</span>))<br>&#125;<br><br>m.Delete(<span class="hljs-number">3</span>)<br><br><span class="hljs-comment">// 迭代所有元素</span><br>m.Range(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(key, value <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>  fmt.Printf(<span class="hljs-string">&quot;%d: %s\n&quot;</span>, key.(<span class="hljs-type">int</span>), value.(<span class="hljs-type">string</span>))<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;)<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">one<br>three<br>1: one<br>2: two<br></code></pre></td></tr></table></figure><p>我们应该在什么时候使用<code>sync.Map</code>而不是在普通的<code>map</code>上使用<code>sync.Mutex</code>？</p><ul><li>当我们对<code>map</code>有频繁的读取和不频繁的写入时。</li><li>当多个<code>goroutine</code>读取，写入和覆盖不相交的键时。具体是什么意思呢？例如，如果我们有一个分片实现，其中包含一组4个<code>goroutine</code>，每个<code>goroutine</code>负责25％的键（每个负责的键不冲突）。在这种情况下，<code>sync.Map</code>是首选。</li></ul><p>另一篇介绍<code>sync.Map</code>的文章：<a href="https://www.mofan.life/2021/03/25/Go%E8%AF%AD%E8%A8%80sync-Map/">Go语言sync.Map - Mofan</a></p><h2 id="sync-Pool"><a href="#sync-Pool" class="headerlink" title="sync.Pool"></a>sync.Pool</h2><p>sync.Pool指的是临时对象池，Golang和Java具有GC机制，因此很多开发者基本上都不会考虑内存回收问题，不像C++很多时候开发需要自己回收对象。<br>Gc是一把双刃剑，带来了编程的方便但同时也增加了运行时开销，使用不当可能会严重影响程序的性能，因此性能要求高的场景不能任意产生太多的垃圾。<br>sync.Pool正是用来解决这类问题的，Pool可以作为临时对象池来使用，不再自己单独创建对象，而是从临时对象池中获取出一个对象。</p><p>sync.Pool有2个函数Get和Put，Get负责从临时对象池中取出一个对象，Put用于结束的时候把对象放回临时对象池中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> Get() <span class="hljs-keyword">interface</span>&#123;&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Pool)</span></span> Put(x <span class="hljs-keyword">interface</span>&#123;&#125;)<br></code></pre></td></tr></table></figure><p>看一个官方的例子：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> bufPool = sync.Pool&#123;<br>    New: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">interface</span>&#123;&#125; &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">new</span>(bytes.Buffer)<br>    &#125;,<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">timeNow</span><span class="hljs-params">()</span></span> time.Time &#123;<br>    <span class="hljs-keyword">return</span> time.Unix(<span class="hljs-number">1136214245</span>, <span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Log</span><span class="hljs-params">(w io.Writer, key, val <span class="hljs-type">string</span>)</span></span> &#123;<br>    <span class="hljs-comment">// 获取临时对象，没有的话会自动创建</span><br>    b := bufPool.Get().(*bytes.Buffer)<br>    b.Reset()<br>    b.WriteString(timeNow().UTC().Format(time.RFC3339))<br>    b.WriteByte(<span class="hljs-string">&#x27; &#x27;</span>)<br>    b.WriteString(key)<br>    b.WriteByte(<span class="hljs-string">&#x27;=&#x27;</span>)<br>    b.WriteString(val)<br>    w.Write(b.Bytes())<br>    <span class="hljs-comment">// 将临时对象放回到 Pool 中</span><br>    bufPool.Put(b)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    Log(os.Stdout, <span class="hljs-string">&quot;path&quot;</span>, <span class="hljs-string">&quot;/search?q=flowers&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的例子我们可以看到创建一个Pool对象并不能指定大小，所以<code>sync.Pool</code>的缓存对象数量是没有限制的(只受限于内存)，那sync.Pool是如何控制缓存临时对象数的呢？<br><code>sync.Pool</code>在init的时候注册了一个<code>poolCleanup</code>函数，它会清除所有的pool里面的所有缓存的对象，该函数注册进去之后会在每次Gc之前都会调用，因此sync.Pool缓存的期限只是两次Gc之间这段时间。正因Gc的时候会清掉缓存对象，所以不用担心pool会无限增大的问题。</p><p>正因为如此sync.Pool适合用于缓存临时对象，而不适合用来做持久保存的对象池(连接池等)。</p><h2 id="sync-Cond"><a href="#sync-Cond" class="headerlink" title="sync.Cond"></a>sync.Cond</h2><p><code>sync.Cond</code>指的是同步条件变量，一般需要与互斥锁组合使用，本质上是一些正在等待某个条件的协程的同步机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// NewCond returns a new Cond with Locker l.</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewCond</span><span class="hljs-params">(l Locker)</span></span> *Cond &#123;<br>    <span class="hljs-keyword">return</span> &amp;Cond&#123;L: l&#125;<br>&#125;<br><br><span class="hljs-comment">// A Locker represents an object that can be locked and unlocked.</span><br><span class="hljs-keyword">type</span> Locker <span class="hljs-keyword">interface</span> &#123;<br>    Lock()<br>    Unlock()<br>&#125;<br></code></pre></td></tr></table></figure><p><code>sync.Cond</code>有3个函数<code>Wait</code>,<code>Signal</code>,<code>Broadcast</code></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Wait 等待通知</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span></span> Wait()<br><span class="hljs-comment">// Signal 单播通知</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span></span> Signal()<br><span class="hljs-comment">// Broadcast 广播通知</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cond)</span></span> Broadcast()<br></code></pre></td></tr></table></figure><p>举个例子，<code>sync.Cond</code>用于并发协程条件变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> sharedRsc = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> wg sync.WaitGroup<br>    wg.Add(<span class="hljs-number">2</span>)<br>    m := sync.Mutex&#123;&#125;<br>    c := sync.NewCond(&amp;m)<br>    <br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// this go routine wait for changes to the sharedRsc</span><br>        c.L.Lock()<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(sharedRsc) == <span class="hljs-number">0</span> &#123;<br>            c.Wait()<br>        &#125;<br>        fmt.Println(sharedRsc[<span class="hljs-string">&quot;rsc1&quot;</span>])<br>        c.L.Unlock()<br>        wg.Done()<br>    &#125;()<br><br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        <span class="hljs-comment">// this go routine wait for changes to the sharedRsc</span><br>        c.L.Lock()<br>        <span class="hljs-keyword">for</span> <span class="hljs-built_in">len</span>(sharedRsc) == <span class="hljs-number">0</span> &#123;<br>            c.Wait()<br>        &#125;<br>        fmt.Println(sharedRsc[<span class="hljs-string">&quot;rsc2&quot;</span>])<br>        c.L.Unlock()<br>        wg.Done()<br>    &#125;()<br><br>    <span class="hljs-comment">// this one writes changes to sharedRsc</span><br>    c.L.Lock()<br>    sharedRsc[<span class="hljs-string">&quot;rsc1&quot;</span>] = <span class="hljs-string">&quot;foo&quot;</span><br>    sharedRsc[<span class="hljs-string">&quot;rsc2&quot;</span>] = <span class="hljs-string">&quot;bar&quot;</span><br>    c.Broadcast()<br>    c.L.Unlock()<br>    wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu报“xxx is not in the sudoers file.This incident will be reported”错误解决方法</title>
    <link href="/2021/03/23/Ubuntu%E6%8A%A5sudoers%E9%94%99%E8%AF%AF/"/>
    <url>/2021/03/23/Ubuntu%E6%8A%A5sudoers%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<p>我是在使用postgresql的时候出现的问题：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">xxx is not in the sudoers file.This incident will be reported<br></code></pre></td></tr></table></figure><p>按照下面的方法</p><p>解决方法来自：<a href="http://www.linuxidc.com/Linux/2016-07/133066.htm">Ubuntu报“xxx is not in the sudoers file.This incident will be reported” 错误解决方法_Linux教程_Linux公社-Linux系统门户网站</a></p><p><a href="https://www.linuxidc.com/topicnews.aspx?tid=2">Ubuntu</a>下普通用户用sudo执行命令时报”xxx is not in the sudoers file.This incident will be reported”错误，解决方法就是在&#x2F;etc&#x2F;sudoers文件里给该用户添加权限。如下：</p><p>1.切换到root用户下</p><p>2.&#x2F;etc&#x2F;sudoers文件默认是只读的，对root来说也是，因此需先添加sudoers文件的写权限,命令是:<br>chmod u+w &#x2F;etc&#x2F;sudoers</p><p>3.编辑sudoers文件<br><code>vi /etc/sudoers</code><br>找到这行 root ALL&#x3D;(ALL) ALL,在他下面添加xxx ALL&#x3D;(ALL) ALL (这里的xxx是你的用户名)</p><p>ps:这里说下你可以sudoers添加下面四行中任意一条</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">youuser      ALL=(ALL)        ALL<br><span class="hljs-meta prompt_">%</span><span class="language-bash">youuser     ALL=(ALL)        ALL</span><br>youuser      ALL=(ALL)        NOPASSWD: ALL<br><span class="hljs-meta prompt_">%</span><span class="language-bash">youuser     ALL=(ALL)        NOPASSWD: ALL</span><br></code></pre></td></tr></table></figure><ul><li>第一行:允许用户youuser执行sudo命令(需要输入密码).</li><li>第二行:允许用户组youuser里面的用户执行sudo命令(需要输入密码).</li><li>第三行:允许用户youuser执行sudo命令,并且在执行的时候不输入密码.</li><li>第四行:允许用户组youuser里面的用户执行sudo命令,并且在执行的时候不输入密码.</li></ul><p>4.撤销sudoers文件写权限,命令:<br>chmod u-w &#x2F;etc&#x2F;sudoers</p>]]></content>
    
    
    <categories>
      
      <category>Problems</category>
      
      <category>Ubuntu</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac连接L2TPVPN问题</title>
    <link href="/2021/03/23/problems/Mac%E8%BF%9E%E6%8E%A5L2TPVPN%E9%97%AE%E9%A2%98/"/>
    <url>/2021/03/23/problems/Mac%E8%BF%9E%E6%8E%A5L2TPVPN%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h3 id="最新说明，Mac-OS-Monetery-不再支持L2TP-VPN，以下设置仅对旧版系统有效"><a href="#最新说明，Mac-OS-Monetery-不再支持L2TP-VPN，以下设置仅对旧版系统有效" class="headerlink" title="最新说明，Mac OS Monetery 不再支持L2TP-VPN，以下设置仅对旧版系统有效"></a>最新说明，Mac OS Monetery 不再支持L2TP-VPN，以下设置仅对旧版系统有效</h3><p>今天需要使用softether VPN，于是去官网下载其客户端，却看到说在Mac下只有命令行模式的客户端，但是推荐使用系统网络里自带的VPN配置，于是按照其说明配置一番，在点击 connect 的时候，出现“IPSec共享密钥”丢失的提醒，于是搜索一番，找到解决方法：</p><ol><li><p>在<code>/etc/ppp</code> 目录下新建文件<code>options</code></p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/ppp/options<br></code></pre></td></tr></table></figure></li><li><p>在<code>options</code> 文件中新增</p> <figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">plugin</span> L2TP.ppp<br>l2tpnoipsec<br></code></pre></td></tr></table></figure></li></ol><p>完成后再连接就没有问题了</p>]]></content>
    
    
    <categories>
      
      <category>Problems</category>
      
      <category>Mac</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译OpenSSL遇到POD错误</title>
    <link href="/2021/03/23/%E7%BC%96%E8%AF%91OpenSSL%E9%81%87%E5%88%B0POD%E9%94%99%E8%AF%AF/"/>
    <url>/2021/03/23/%E7%BC%96%E8%AF%91OpenSSL%E9%81%87%E5%88%B0POD%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<p>解压玩OpenSSL包后，执行<code>./configure</code>时，发现这个错误：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">POD document had syntax errors at /usr/bin/pod2man5.28 line 72. 　　<br>make： *** ［install_docs］ 错误 255<br></code></pre></td></tr></table></figure><p>解决：删除 pod2man文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo rm -rf /usr/bin/pod2man<br></code></pre></td></tr></table></figure><p>来自网上的分析：</p><p>原因分析：这是由于OpenSSL 1.0.1e 与 perl5.18 不兼容。有人验证 安装perl 5.16 可以兼容，安排低版本perl 5.16可以解决问题。　　</p>]]></content>
    
    
    <categories>
      
      <category>Problems</category>
      
      <category>OpenSSL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>OpenSSL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>白话解析: 一致性哈希算法</title>
    <link href="/2021/03/21/%E7%99%BD%E8%AF%9D%E8%A7%A3%E6%9E%90-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
    <url>/2021/03/21/%E7%99%BD%E8%AF%9D%E8%A7%A3%E6%9E%90-%E4%B8%80%E8%87%B4%E6%80%A7%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>又看到一篇不错的文章: <a href="https://mp.weixin.qq.com/s/wKvD7r5Jcz7QqH7pUsLS0Q">https://mp.weixin.qq.com/s/wKvD7r5Jcz7QqH7pUsLS0Q</a></p><blockquote><p>作者：朱双印</p><p>链接：<a href="https://www.zsythink.net/archives/1182">白话解析：一致性哈希算法 consistent hashing-朱双印博客</a></p></blockquote><p>在了解一致性哈希算法之前，最好先了解一下缓存中的一个应用场景，了解了这个应用场景之后，再来理解一致性哈希算法，就容易多了，也更能体现出一致性哈希算法的优点，那么，我们先来描述一下这个经典的分布式缓存的应用场景。</p><h2 id="场景描述"><a href="#场景描述" class="headerlink" title="场景描述"></a>场景描述</h2><p>假设，我们有三台缓存服务器，用于缓存图片，我们为这三台缓存服务器编号为0号、1号、2号，现在，有3万张图片需要缓存，我们希望这些图片被均匀的缓存到这3台服务器上，以便它们能够分摊缓存的压力。也就是说，我们希望每台服务器能够缓存1万张左右的图片，那么，我们应该怎样做呢？如果我们没有任何规律的将3万张图片平均的缓存在3台服务器上，可以满足我们的要求吗？可以！但是如果这样做，当我们需要访问某个缓存项时，则需要遍历3台缓存服务器，从3万个缓存项中找到我们需要访问的缓存，遍历的过程效率太低，时间太长，当我们找到需要访问的缓存项时，时长可能是不能被接受的，也就失去了缓存的意义，缓存的目的就是提高速度，改善用户体验，减轻后端服务器压力，如果每次访问一个缓存项都需要遍历所有缓存服务器的所有缓存项，想想就觉得很累，那么，我们该怎么办呢？原始的做法是对缓存项的键进行哈希，将hash后的结果对缓存服务器的数量进行取模操作，通过取模后的结果，决定缓存项将会缓存在哪一台服务器上，这样说可能不太容易理解，我们举例说明，仍然以刚才描述的场景为例，假设我们使用图片名称作为访问图片的key，假设图片名称是不重复的，那么，我们可以使用如下公式，计算出图片应该存放在哪台服务器上。</p><p><strong>hash（图片名称）% N</strong></p><p>因为图片的名称是不重复的，所以，当我们对同一个图片名称做相同的哈希计算时，得出的结果应该是不变的，如果我们有3台服务器，使用哈希后的结果对3求余，那么余数一定是0、1或者2，没错，正好与我们之前的服务器编号相同，如果求余的结果为0， 我们就把当前图片名称对应的图片缓存在0号服务器上，如果余数为1，就把当前图片名对应的图片缓存在1号服务器上，如果余数为2，同理，那么，当我们访问任意一个图片的时候，只要再次对图片名称进行上述运算，即可得出对应的图片应该存放在哪一台缓存服务器上，我们只要在这一台服务器上查找图片即可，如果图片在对应的服务器上不存在，则证明对应的图片没有被缓存，也不用再去遍历其他缓存服务器了，通过这样的方法，即可将3万张图片随机的分布到3台缓存服务器上了，而且下次访问某张图片时，直接能够判断出该图片应该存在于哪台缓存服务器上，这样就能满足我们的需求了，我们暂时称上述算法为HASH算法或者取模算法，取模算法的过程可以用下图表示。</p><p>但是，使用上述HASH算法进行缓存时，会出现一些缺陷，试想一下，如果3台缓存服务器已经不能满足我们的缓存需求，那么我们应该怎么做呢？没错，很简单，多增加两台缓存服务器不就行了，假设，我们增加了一台缓存服务器，那么缓存服务器的数量就由3台变成了4台，此时，如果仍然使用上述方法对同一张图片进行缓存，那么这张图片所在的服务器编号必定与原来3台服务器时所在的服务器编号不同，因为除数由3变为了4，被除数不变的情况下，余数肯定不同，这种情况带来的结果就是当服务器数量变动时，所有缓存的位置都要发生改变，换句话说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据，同理，假设3台缓存中突然有一台缓存服务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，但是如果移除了一台缓存服务器，那么缓存服务器数量从3台变为2台，如果想要访问一张图片，这张图片的缓存位置必定会发生改变，以前缓存的图片也会失去缓存的作用与意义，由于大量缓存在同一时间失效，造成了缓存的雪崩，此时前端缓存已经无法起到承担部分压力的作用，后端服务器将会承受巨大的压力，整个系统很有可能被压垮，所以，我们应该想办法不让这种情况发生，但是由于上述HASH算法本身的缘故，使用取模法进行缓存时，这种情况是无法避免的，为了解决这些问题，一致性哈希算法诞生了。</p><p>但是，使用上述HASH算法进行缓存时，会出现一些缺陷，试想一下，如果3台缓存服务器已经不能满足我们的缓存需求，那么我们应该怎么做呢？没错，很简单，多增加两台缓存服务器不就行了，假设，我们增加了一台缓存服务器，那么缓存服务器的数量就由3台变成了4台，此时，如果仍然使用上述方法对同一张图片进行缓存，那么这张图片所在的服务器编号必定与原来3台服务器时所在的服务器编号不同，因为除数由3变为了4，被除数不变的情况下，余数肯定不同，这种情况带来的结果就是当服务器数量变动时，所有缓存的位置都要发生改变，换句话说，当服务器数量发生改变时，所有缓存在一定时间内是失效的，当应用无法从缓存中获取数据时，则会向后端服务器请求数据，同理，假设3台缓存中突然有一台缓存服务器出现了故障，无法进行缓存，那么我们则需要将故障机器移除，但是如果移除了一台缓存服务器，那么缓存服务器数量从3台变为2台，如果想要访问一张图片，这张图片的缓存位置必定会发生改变，以前缓存的图片也会失去缓存的作用与意义，由于大量缓存在同一时间失效，造成了缓存的雪崩，此时前端缓存已经无法起到承担部分压力的作用，后端服务器将会承受巨大的压力，整个系统很有可能被压垮，所以，我们应该想办法不让这种情况发生，但是由于上述HASH算法本身的缘故，使用取模法进行缓存时，这种情况是无法避免的，为了解决这些问题，一致性哈希算法诞生了。</p><img src="https://www.cmdbyte.com/2021/02/hash.png" alt="hash" style="zoom:67%;" /><p>我们来回顾一下使用上述算法会出现的问题。</p><p>问题1：当缓存服务器数量发生变化时，会引起缓存的雪崩，可能会引起整体系统压力过大而崩溃（大量缓存同一时间失效）。</p><p>问题2：当缓存服务器数量发生变化时，几乎所有缓存的位置都会发生改变，怎样才能尽量减少受影响的缓存呢？</p><p>其实，上面两个问题是一个问题，那么，一致性哈希算法能够解决上述问题吗？</p><p>我们现在就来了解一下一致性哈希算法。</p><h2 id="一致性哈希算法的基本概念"><a href="#一致性哈希算法的基本概念" class="headerlink" title="一致性哈希算法的基本概念"></a>一致性哈希算法的基本概念</h2><p>其实，一致性哈希算法也是使用取模的方法，只是，刚才描述的取模法是对服务器的数量进行取模，而一致性哈希算法是对2^32取模，什么意思呢？我们慢慢聊。</p><p>首先，我们把二的三十二次方想象成一个圆，就像钟表一样，钟表的圆可以理解成由60个点组成的圆，而此处我们把这个圆想象成由2^32个点组成的圆，示意图如下：</p><p><img src="https://www.cmdbyte.com/2021/02/020717_1707_2.png" alt="020717_1707_2"></p><p>圆环的正上方的点代表0，0点右侧的第一个点代表1，以此类推，2、3、4、5、6……直到2^32-1^也就是说0点左侧的第一个点代表2^32-1^</p><p>我们把这个由2的32次方个点组成的圆环称为hash环。 </p><p>那么，一致性哈希算法与上图中的圆环有什么关系呢？我们继续聊，仍然以之前描述的场景为例，假设我们有3台缓存服务器，服务器A、服务器B、服务器C，那么，在生产环境中，这三台服务器肯定有自己的IP地址，我们使用它们各自的IP地址进行哈希计算，使用哈希后的结果对2^32取模，可以使用如下公式示意。</p><p><strong>hash（服务器A的IP地址） %  2^32</strong></p><p>通过上述公式算出的结果一定是一个0到2^32-1^之间的一个整数，我们就用算出的这个整数，代表服务器A，既然这个整数肯定处于0到2^32-1^之间，那么，上图中的hash环上必定有一个点与这个整数对应，而我们刚才已经说明，使用这个整数代表服务器A，那么，服务器A就可以映射到这个环上，用下图示意：</p><p><img src="https://www.cmdbyte.com/2021/02/020717_1707_3.png" alt="020717_1707_3"></p><p>同理，服务器B与服务器C也可以通过相同的方法映射到上图中的hash环中</p><p><strong>hash（服务器B的IP地址） %  2^32</strong></p><p><strong>hash（服务器C的IP地址） %  2^32</strong></p><p>通过上述方法，可以将服务器B与服务器C映射到上图中的hash环上，示意图如下：</p><img src="https://www.cmdbyte.com/2021/02/020717_1707_4.png" alt="020717_1707_4" style="zoom:67%;" /><p>假设3台服务器映射到hash环上以后如上图所示（当然，这是理想的情况，我们慢慢聊）。</p><p>好了，到目前为止，我们已经把缓存服务器与hash环联系在了一起，我们通过上述方法，把缓存服务器映射到了hash环上，那么使用同样的方法，我们也可以将需要缓存的对象映射到hash环上。</p><p>假设，我们需要使用缓存服务器缓存图片，而且我们仍然使用图片的名称作为找到图片的key，那么我们使用如下公式可以将图片映射到上图中的hash环上。</p><p><strong>hash（图片名称） %  2^32</strong></p><p>映射后的示意图如下，下图中的橘黄色圆形表示图片：</p><img src="https://www.cmdbyte.com/2021/02/020717_1707_5.png" alt="020717_1707_5" style="zoom:67%;" /><p>好了，现在服务器与图片都被映射到了hash环上，那么上图中的这个图片到底应该被缓存到哪一台服务器上呢？上图中的图片将会被缓存到服务器A上，为什么呢？因为从图片的位置开始，沿顺时针方向遇到的第一个服务器就是A服务器，所以，上图中的图片将会被缓存到服务器A上，如下图所示：</p><img src="https://www.cmdbyte.com/2021/02/020717_1707_6.png" alt="020717_1707_6" style="zoom:67%;" /><p>没错，一致性哈希算法就是通过这种方法，判断一个对象应该被缓存到哪台服务器上的，将缓存服务器与被缓存对象都映射到hash环上以后，从被缓存对象的位置出发，沿顺时针方向遇到的第一个服务器，就是当前对象将要缓存于的服务器，由于被缓存对象与服务器hash后的值是固定的，所以，在服务器不变的情况下，一张图片必定会被缓存到固定的服务器上，那么，当下次想要访问这张图片时，只要再次使用相同的算法进行计算，即可算出这个图片被缓存在哪个服务器上，直接去对应的服务器查找对应的图片即可。</p><p>刚才的示例只使用了一张图片进行演示，假设有四张图片需要缓存，示意图如下：</p><img src="https://www.cmdbyte.com/2021/02/020717_1707_7.png" alt="020717_1707_7" style="zoom:67%;" /><p>1号、2号图片将会被缓存到服务器A上，3号图片将会被缓存到服务器B上，4号图片将会被缓存到服务器C上。</p><h2 id="一致性哈希算法的优点"><a href="#一致性哈希算法的优点" class="headerlink" title="一致性哈希算法的优点"></a>一致性哈希算法的优点</h2><p>经过上述描述，我想兄弟你应该已经明白了一致性哈希算法的原理了，但是话说回来，一致性哈希算法能够解决之前出现的问题吗，我们说过，如果简单的对服务器数量进行取模，那么当服务器数量发生变化时，会产生缓存的雪崩，从而很有可能导致系统崩溃，那么使用一致性哈希算法，能够避免这个问题吗？我们来模拟一遍，即可得到答案。</p><p>假设，服务器B出现了故障，我们现在需要将服务器B移除，那么，我们将上图中的服务器B从hash环上移除即可，移除服务器B以后示意图如下：</p><img src="https://www.cmdbyte.com/2021/02/020717_1707_8.png" alt="020717_1707_8" style="zoom:67%;" /><p>在服务器B未移除时，图片3应该被缓存到服务器B中，可是当服务器B移除以后，按照之前描述的一致性哈希算法的规则，图片3应该被缓存到服务器C中，因为从图片3的位置出发，沿顺时针方向遇到的第一个缓存服务器节点就是服务器C，也就是说，如果服务器B出现故障被移除时，图片3的缓存位置会发生改变</p><img src="https://www.cmdbyte.com/2021/02/020717_1707_9.png" alt="020717_1707_9" style="zoom:67%;" /><p>但是，图片4仍然会被缓存到服务器C中，图片1与图片2仍然会被缓存到服务器A中，这与服务器B移除之前并没有任何区别，这就是一致性哈希算法的优点，<strong>如果使用之前的hash算法，服务器数量发生改变时，所有服务器的所有缓存在同一时间失效了，而使用一致性哈希算法时，服务器的数量如果发生改变，并不是所有缓存都会失效，而是只有部分缓存会失效</strong>，前端的缓存仍然能分担整个系统的压力，而不至于所有压力都在同一时间集中到后端服务器上。</p><p>这就是一致性哈希算法所体现出的优点。</p><h2 id="hash环的偏斜"><a href="#hash环的偏斜" class="headerlink" title="hash环的偏斜"></a>hash环的偏斜</h2><p>在介绍一致性哈希的概念时，我们理想化的将3台服务器<strong>均匀</strong>的映射到了hash环上，如下图所示：</p><img src="https://www.cmdbyte.com/2021/02/020717_1707_10.png" alt="020717_1707_10" style="zoom:67%;" /><p>然而，理想很丰满，现实很骨感，在实际的映射中，服务器可能会被映射成如下模样：</p><img src="https://www.cmdbyte.com/2021/02/020717_1707_12.png" alt="020717_1707_12" style="zoom:67%;" /><p>聪明如你一定想到了，如果服务器被映射成上图中的模样，那么被缓存的对象很有可能大部分集中缓存在某一台服务器上，如下图所示：</p><img src="https://www.cmdbyte.com/2021/02/020717_1707_13.png" alt="020717_1707_13" style="zoom:67%;" /><p>上图中，1号、2号、3号、4号、6号图片均被缓存在了服务器A上，只有5号图片被缓存在了服务器B上，服务器C上甚至没有缓存任何图片，如果出现上图中的情况，A、B、C三台服务器并没有被合理的平均的充分利用，缓存分布的极度不均匀，而且，如果此时服务器A出现故障，那么失效缓存的数量也将达到最大值，在极端情况下，仍然有可能引起系统的崩溃，上图中的情况则被称之为hash环的偏斜，那么，我们应该怎样防止hash环的偏斜呢？一致性hash算法中使用”虚拟节点”解决了这个问题，我们继续聊。</p><h2 id="虚拟节点"><a href="#虚拟节点" class="headerlink" title="虚拟节点"></a>虚拟节点</h2><p>话接上文，由于我们只有3台服务器，当我们把服务器映射到hash环上的时候，很有可能出现hash环偏斜的情况，当hash环偏斜以后，缓存往往会极度不均衡的分布在各服务器上，聪明如你一定已经想到了，如果想要均衡的将缓存分布到3台服务器上，最好能让这3台服务器尽量多的、均匀的出现在hash环上，但是，真实的服务器资源只有3台，我们怎样凭空的让它们多起来呢，没错，就是凭空的让服务器节点多起来，既然没有多余的真正的物理服务器节点，我们就只能将现有的物理节点通过虚拟的方法复制出来，这些由实际节点虚拟复制而来的节点被称为”虚拟节点”。加入虚拟节点以后的hash环如下：</p><img src="https://www.cmdbyte.com/2021/02/020717_1707_14.png" alt="020717_1707_14" style="zoom:67%;" /><p>“虚拟节点”是”实际节点”（实际的物理服务器）在hash环上的复制品,一个实际节点可以对应多个虚拟节点。</p><p>从上图可以看出，A、B、C三台服务器分别虚拟出了一个虚拟节点，当然，如果你需要，也可以虚拟出更多的虚拟节点。引入虚拟节点的概念后，缓存的分布就均衡多了，上图中，1号、3号图片被缓存在服务器A中，5号、4号图片被缓存在服务器B中，6号、2号图片被缓存在服务器C中，如果你还不放心，可以虚拟出更多的虚拟节点，以便减小hash环偏斜所带来的影响，虚拟节点越多，hash环上的节点就越多，缓存被均匀分布的概率就越大。</p><p>好了，一致性哈希算法的原理就总结到这里，如有错误，欢迎赐教，如需转载，请标注原文链接。</p>]]></content>
    
    
    <categories>
      
      <category>TODO</category>
      
      <category>分布式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RPC面试题</title>
    <link href="/2021/03/19/m-rpc/"/>
    <url>/2021/03/19/m-rpc/</url>
    
    <content type="html"><![CDATA[<h2 id="谈谈RPC框架"><a href="#谈谈RPC框架" class="headerlink" title="谈谈RPC框架"></a>谈谈RPC框架</h2><p>RPC(Remote Procedure Call，远程过程调用)是一种计算机通信协议，允许调用不同进程空间的程序。RPC 的客户端和服务器可以在一台机器上，也可以在不同的机器上。程序员使用时，就像调用本地程序一样，无需关注内部的实现细节。</p><p>不同的应用程序之间的通信方式有很多，比如浏览器和服务器之间广泛使用的基于 HTTP 协议的 Restful API。与 RPC 相比，Restful API 有相对统一的标准，因而更通用，兼容性更好，支持不同的语言。HTTP 协议是基于文本的，一般具备更好的可读性。但是缺点也很明显：</p><ul><li>Restful 接口需要额外的定义，无论是客户端还是服务端，都需要额外的代码来处理，而 RPC 调用则更接近于直接调用。</li><li>基于 HTTP 协议的 Restful 报文冗余，承载了过多的无效信息，而 RPC 通常使用自定义的协议格式，减少冗余报文。</li><li>RPC 可以采用更高效的序列化协议，将文本转为二进制传输，获得更高的性能。</li><li>因为 RPC 的灵活性，所以更容易扩展和集成诸如注册中心、负载均衡等功能。</li></ul><h2 id="为什么要用RPC"><a href="#为什么要用RPC" class="headerlink" title="为什么要用RPC"></a>为什么要用RPC</h2><p>Go 语言广泛地应用于云计算和微服务，成熟的 RPC 框架和微服务框架汗牛充栋。<code>grpc</code>、<code>rpcx</code>、<code>go-micro</code> 等都是非常成熟的框架。一般而言，RPC 是微服务框架的一个子集，微服务框架可以自己实现 RPC 部分，当然，也可以选择不同的 RPC 框架作为通信基座。</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>RPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go为何没有goroutineid</title>
    <link href="/2021/03/18/Go%E4%B8%BA%E4%BD%95%E6%B2%A1%E6%9C%89goroutineid/"/>
    <url>/2021/03/18/Go%E4%B8%BA%E4%BD%95%E6%B2%A1%E6%9C%89goroutineid/</url>
    
    <content type="html"><![CDATA[<blockquote><p>文章来自：<a href="https://studygolang.com/topics/11363?fr=sidebar">go没有go协程号（goroutineid） - Go语言中文网 - Golang中文社区</a></p></blockquote><p>今天想给日志添加一个前缀，以区分不同goroutine的日志，方便以后做日志跟踪。最直接的想法是在日志函数里面增加打印goroutineid，跟以前用c语言在日志打印线程id&#x2F;进程id一样。</p><p>但是网上查了一下，go开发中不建议使用goroutineid，也没有提供获取协程id的函数（旧版本有，但现在已删除）</p><p>原因是担心人们使用goroutineid构建协程私有存储，这样很容易导致协程资源一直被占用，无法正常被gc回收。</p><p>（协程结束了，但是协程引用的变量还存放在用户自己构造的协程级私有存储，这时gc无法回收协程）</p><p>如果想在日志里面输出traceid，官方建议使用context包。但是这样做要求每个函数都增加context参数，在程序运行过程中层层传递，才可以实现。这样即不现实，也不优雅。</p><p>为了解决goroutineid，网上各出奇招，有的使用runtime包未公开的方法获取：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Goid</span><span class="hljs-params">()</span></span> <span class="hljs-type">int</span> &#123;<br>    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>  &#123;<br>        <span class="hljs-keyword">if</span> err := <span class="hljs-built_in">recover</span>(); err != <span class="hljs-literal">nil</span> &#123;<br>            fmt.Println(<span class="hljs-string">&quot;panic recover:panic info:%v&quot;</span>, err)        &#125;<br>    &#125;()<br><br>    <span class="hljs-keyword">var</span> buf [<span class="hljs-number">64</span>]<span class="hljs-type">byte</span><br>    n := runtime.Stack(buf[:], <span class="hljs-literal">false</span>)<br>    idField := strings.Fields(strings.TrimPrefix(<span class="hljs-type">string</span>(buf[:n]), <span class="hljs-string">&quot;goroutine &quot;</span>))[<span class="hljs-number">0</span>]<br>    id, err := strconv.Atoi(idField)<br>    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>        <span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;cannot get goroutine id: %v&quot;</span>, err))<br>    &#125;<br>    <span class="hljs-keyword">return</span> id<br>&#125;<br></code></pre></td></tr></table></figure><p>这个方法我觉得靠谱，显然runtime包是肯定有获取协程id的方法的，因为处理panic时默认会输出问题协程号。但是这样做效率会不会有问题，暂时还不清楚。</p><p>另外有人使用汇编，cgo的方法获取协程号的，例如github的包：github.com&#x2F;petermattis&#x2F;goid</p><p>这种效率应该高一些，网上有人测试说差了1000倍，不过这种方法兼容性不好，几乎每个版本都要使用不同的方法。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库读写分离</title>
    <link href="/2021/03/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <url>/2021/03/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</url>
    
    <content type="html"><![CDATA[<p><strong>1、what 读写分离</strong><br>读写分离，基本的原理是让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库处理SELECT查询操作。数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。</p><p><strong>2、why 那么为什么要读写分离呢？</strong><br>因为数据库的“写”（写10000条数据到oracle可能要3分钟）操作是比较耗时的。<br>但是数据库的“读”（从oracle读10000条数据可能只要5秒钟）。<br>所以读写分离，解决的是，数据库的写入，影响了查询的效率。</p><p><strong>3、when 什么时候要读写分离？</strong><br>数据库不一定要读写分离，如果程序使用数据库较多时，而更新少，查询多的情况下会考虑使用，利用数据库 主从同步 。可以减少数据库压力，提高性能。当然，数据库也有其它优化方案。memcache 或是 表折分，或是搜索引擎。都是解决方法。</p><p><strong>4、主从复制与读写分离</strong><br>在实际的生产环境中，对数据库的读和写都在同一个数据库服务器中，是不能满足实际需求的。无论是在安全性、高可用性还是高并发等各个方面都是完全不能满足实际需求的。因此，通过主从复制的方式来同步数据，再通过读写分离来提升数据库的并发负载能力。有点类似于前面我们学习过的rsync，但是不同的是rsync是对磁盘文件做备份，而mysql主从复制是对数据库中的数据、语句做备份。</p><p><img src="https://www.cmdbyte.com/2021/02/20180312205134509.png" alt="20180312205134509"></p><p>4.1、 mysq支持的复制类型</p><p>1） 基于语句的复制。在服务器上执行sql语句，在从服务器上执行同样的语句，mysql默认采用基于语句的复制，执行效率高。</p><p>2） 基于行的复制。把改变的内容复制过去，而不是把命令在从服务器上执行一遍。</p><p>3） 混合类型的复制。默认采用基于语句的复制，一旦发现基于语句无法精确复制时，就会采用基于行的复制。</p><p>4.2、 复制的工作过程</p><p>1） 在每个事务更新数据完成之前，master在二进制日志记录这些改变。写入二进制日志完成后，master通知存储引擎提交事务。</p><p>2） Slave将master的binary log复制到其中继日志。首先slave开始一个工作线程（I&#x2F;O），I&#x2F;O线程在master上打开一个普通的连接，然后开始binlog dump process。binlog dump process从master的二进制日志中读取事件，如果已经跟上master，它会睡眠并等待master产生新的事件，I&#x2F;O线程将这些事件写入中继日志。</p><p>3） Sql slave thread（sql从线程）处理该过程的最后一步，sql线程从中继日志读取事件，并重放其中的事件而更新slave数据，使其与master中的数据一致，只要该线程与I&#x2F;O线程保持一致，中继日志通常会位于os缓存中，所以中继日志的开销很小。</p><p><img src="https://www.cmdbyte.com/2021/02/20180312205215249.png" alt="20180312205215249"></p><p><strong>5、 mysql读写分离原理</strong></p><p>读写分离就是在主服务器上修改，数据会同步到从服务器，从服务器只能提供读取数据，不能写入，实现备份的同时也实现了数据库性能的优化，以及提升了服务器安全。</p><p><strong>6、前较为常见的Mysql读写分离分为以下两种：</strong></p><p>1）基于程序代码内部实现<br>在代码中根据select 、insert进行路由分类，这类方法也是目前生产环境下应用最广泛的。优点是性能较好，因为程序在代码中实现，不需要增加额外的硬件开支，缺点是需要开发人员来实现，运维人员无从下手。<br>2） 基于中间代理层实现<br>代理一般介于应用服务器和数据库服务器之间，代理数据库服务器接收到应用服务器的请求后根据判断后转发到，后端数据库，有以下代表性的程序。<br>（1）mysql_proxy。mysql_proxy是Mysql的一个开源项目，通过其自带的lua脚本进行sql判断。</p><p>（2）Atlas。是由 Qihoo 360, Web平台部基础架构团队开发维护的一个基于MySQL协议的数据中间层项目。它是在mysql-proxy 0.8.2版本的基础上，对其进行了优化，增加了一些新的功能特性。360内部使用Atlas运行的mysql业务，每天承载的读写请求数达几十亿条。支持事物以及存储过程。</p><p>（3）Amoeba。由阿里巴巴集团在职员工陈思儒使用序java语言进行开发，阿里巴巴集团将其用户生产环境下，但是他并不支持事物以及存储过程。</p><p>经过上述简单的比较，不是所有的应用都能够在基于程序代码中实现读写分离，像一些大型的java应用，如果在程序代码中实现读写分离对代码的改动就较大，所以，像这种应用一般会考虑使用代理层来实现，那么今天就使用Amoeba为例，完成主从复制和读写分离。</p><p>MySQLProxy介绍<br>下面使用MySQL官方提供的数据库代理层产品MySQLProxy搭建读写分离。<br>MySQLProxy实际上是在客户端请求与MySQLServer之间建立了一个连接池。所有客户端请求都是发向MySQLProxy，然后经由MySQLProxy进行相应的分析，判断出是读操作还是写操作，分发至对应的MySQLServer上。对于多节点Slave集群，也可以起做到负载均衡的效果。</p><p><img src="https://www.cmdbyte.com/2021/02/20180312205357645.png" alt="20180312205357645"></p><p><img src="https://www.cmdbyte.com/2021/02/20180312205418212.png" alt="20180312205418212"></p>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go的CSP并发模型</title>
    <link href="/2021/03/18/Go%E7%9A%84CSP%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/03/18/Go%E7%9A%84CSP%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p><strong>Go的CSP并发模型</strong></p><p>Go实现了两种并发形式。第一种是大家普遍认知的：多线程共享内存。其实就是Java或者C++等语言中的多线程开发。另外一种是Go语言特有的，也是Go语言推荐的：CSP（communicating sequential processes）并发模型。</p><p>CSP 是 Communicating Sequential Process 的简称，中文可以叫做通信顺序进程，是一种并发编程模型，由 <a href="https://en.wikipedia.org/wiki/Tony_Hoare">Tony Hoare</a> 于 1977 年提出。简单来说，CSP 模型由并发执行的实体（线程或者进程）所组成，实体之间通过发送消息进行通信，这里发送消息时使用的就是通道，或者叫 channel。CSP 模型的关键是关注 channel，而不关注发送消息的实体。Go 语言实现了 CSP 部分理论。</p><p>请记住下面这句话：</p><p><strong>Do not communicate by sharing memory; instead, share memory by communicating.</strong></p><p>“不要以共享内存的方式来通信，相反，要通过通信来共享内存。”</p><p>普通的线程并发模型，就是像Java、C++、或者Python，他们线程间通信都是通过共享内存的方式来进行的。非常典型的方式就是，在访问共享数据（例如数组、Map、或者某个结构体或对象）的时候，通过锁来访问，因此，在很多时候，衍生出一种方便操作的数据结构，叫做“线程安全的数据结构”。例如Java提供的包”java.util.concurrent”中的数据结构。Go中也实现了传统的线程并发模型。</p><p>Go的CSP并发模型，是通过goroutine和channel来实现的。</p><p>goroutine 是Go语言中并发的执行单位。其实就是协程，可以参考：<a href="https://www.jianshu.com/p/1368ec481c25">用大白话讲进程和线程、协程的区别 - 简书</a></p><p>channel是Go语言中各个并发结构体(goroutine)之前的通信机制。 通俗的讲，就是各个goroutine之间通信的”管道“，有点类似于Linux中的管道。</p><p><strong>Channel</strong></p><blockquote><p>Golang中使用 CSP中 channel 这个概念。channel 是被单独创建并且可以在进程之间传递，它的通信模式类似于 boss-worker 模式的，一个实体通过将消息发送到channel 中，然后又监听这个 channel 的实体处理，两个实体之间是匿名的，这个就实现实体中间的解耦，其中 channel 是同步的一个消息被发送到 channel 中，最终是一定要被另外的实体消费掉的。</p></blockquote><p><strong>Goroutine</strong></p><blockquote><p>Goroutine 是实际并发执行的实体，它底层是使用协程(coroutine)实现并发，coroutine是一种运行在用户态的用户线程，类似于 greenthread，go底层选择使用coroutine的出发点是因为，它具有以下特点：</p><p>用户空间 避免了内核态和用户态的切换导致的成本</p><p>可以由语言和框架层进行调度</p><p>更小的栈空间允许创建大量的实例</p><p>用户空间线程的调度不是由操作系统来完成的，像在java 1.3中使用的greenthread的是由JVM统一调度的(后java已经改为内核线程)，还有在ruby中的fiber(半协程) 是需要在重新中自己进行调度的，而goroutine是在golang层面提供了调度器，并且对网络IO库进行了封装，屏蔽了复杂的细节，对外提供统一的语法关键字支持，简化了并发程序编写的成本。</p></blockquote><p>待整理：</p><p><a href="https://www.jianshu.com/p/36e246c6153d">Golang CSP并发模型 - 简书</a></p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Golang精编100题-搞定golang面试</title>
    <link href="/2021/03/18/Golang%E7%B2%BE%E7%BC%96100%E9%A2%98-%E6%90%9E%E5%AE%9Agolang%E9%9D%A2%E8%AF%95/"/>
    <url>/2021/03/18/Golang%E7%B2%BE%E7%BC%96100%E9%A2%98-%E6%90%9E%E5%AE%9Agolang%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<p><a href="https://blog.csdn.net/itcastcpp/article/details/80462619">Golang精编100题-搞定golang面试_尹成的技术博客-CSDN博客_go面试题</a></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis常见面试题整理</title>
    <link href="/2021/03/18/Redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/"/>
    <url>/2021/03/18/Redis%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<blockquote><p>文章来自：<a href="http://www.devcheng.net/post/3ffff771.html">http://www.devcheng.net/post/3ffff771.html</a></p></blockquote><p>待完善内容：<a href="https://www.jianshu.com/p/65765dd10671">Redis面试题总结 - 简书</a></p><h2 id="Redis是什么"><a href="#Redis是什么" class="headerlink" title="Redis是什么"></a>Redis是什么</h2><p>Redis是一个开源的，使用ANSI C语言编写，遵循BSD协议，支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并提供多种语言API的非关系型数据库。</p><p>传统数据库遵循ACID原则，而 Nosql（Not Only SQL 的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称） 一般为分布式而分布式一般遵循 <a href="https://baike.baidu.com/item/CAP%E5%8E%9F%E5%88%99/5712863?fr=aladdin">CAP 定理</a>。</p><h2 id="Redis支持哪几种数据类型"><a href="#Redis支持哪几种数据类型" class="headerlink" title="Redis支持哪几种数据类型"></a>Redis支持哪几种数据类型</h2><ul><li>String：最基本的数据类型，二进制安全的字符串，最大512MB</li><li>List：按照添加顺序保持顺序的字符串列表，最大存储数据量 2^32 - 1</li><li>Set：无序的字符串集合，不存在重复元素，最大存储数据量 2^32 - 1</li><li>Sorted Set：已排序的字符串集合，最大存储数据量 2^32 - 1</li><li>Hash：Key-Value对的一种集合，最大存储数据量 2^32 - 1</li></ul><p>另外还有四种特殊的数据类型：</p><p>1.BloomFilter<br>2.HyperLogLog<br>3.BitMap<br>4.Geo</p><p>详细介绍请看：<a href="https://developer.51cto.com/art/201911/605731.htm">https://developer.51cto.com/art/201911/605731.htm</a></p><p><strong>注意 关于数据类型多说两句：</strong></p><p>redis里存的都是二进制数据，其实就是字节数组（byte[]），这些字节数据是没有数据类型的，只有把它们按照合理的格式解码后，可以变成一个字符串，整数或对象，此时才具有数据类型。</p><p>这一点必须要记住。<br><strong>所以任何东西只要能转化成字节数组（byte[]）的，都可以存到redis里</strong>。管你是字符串、数字、对象、图片、声音、视频、还是文件，只要变成byte数组。</p><ul><li>关键字（Keys）是用于标识一段数据的一个字符串</li><li>值（Values）是一段任意的字节序列，Redis不会关注它们实质上是什么</li></ul><p><strong>关于key</strong></p><ul><li>key不要太长，尽量不要超过1024字节，这不仅消耗内存，而且会降低查找的效率</li><li>key也不要太短，太短的话，key的可读性会降低</li><li>在一个项目中，key最好使用统一的命名模式，例如 user:10000:passwd</li></ul><h2 id="Redis是单进程单线程的吗"><a href="#Redis是单进程单线程的吗" class="headerlink" title="Redis是单进程单线程的吗"></a>Redis是单进程单线程的吗</h2><p>Redis是单进程单线程的，Redis利用队列技术将并发访问变成串行访问，消除了传统数据库串行控制的开销</p><h2 id="Redis为什么是单线程的"><a href="#Redis为什么是单线程的" class="headerlink" title="Redis为什么是单线程的"></a>Redis为什么是单线程的</h2><p>首先多线程会涉及到锁，而且多线程处理会涉及到线程切换而消耗CPU。</p><p>CPU不是Redis的性能瓶颈，Redis的性能瓶颈最可能是内存和网络带宽。</p><p>Redis的单线程不能发挥多核CPU性能，但是可以通过在单机上开多个Redis实例来解决。</p><p><strong>补充额外知识点 ：</strong>其它开源软件采用的模型<br>Nginx：多进程单线程模型<br>Memcached：单进程多线程模型</p><h2 id="Memcache与Redis的区别有哪些"><a href="#Memcache与Redis的区别有哪些" class="headerlink" title="Memcache与Redis的区别有哪些"></a>Memcache与Redis的区别有哪些</h2><p><strong>Memcache （MC）</strong></p><p>看看 MC 的特点：<br>MC 处理请求时使用多线程异步 IO 的方式，可以合理利用 CPU 多核的优势，性能非常优秀；<br>MC 功能简单，使用内存存储数据；<br>MC 的内存结构以及钙化问题我就不细说了，大家可以查看官网了解下；<br>MC 对缓存的数据可以设置失效期，过期后的数据会被清除；<br>失效的策略采用延迟失效，就是当再次使用数据时检查是否失效；<br>当容量存满时，会对缓存中的数据进行剔除，剔除时除了会对过期 key 进行清理，还会按 LRU 策略对数据进行剔除。</p><p>另外，使用 MC 有一些限制，这些限制在现在的互联网场景下很致命，成为大家选择Redis、MongoDB的重要原因：<br>key 不能超过 250 个字节；<br>value 不能超过 1M 字节；<br>key 的最大失效时间是 30 天；<br>只支持 K-V 结构，不提供持久化和主从同步功能。</p><p><strong>Redis</strong></p><p>先简单说一下 Redis 的特点，方便和 MC 比较。</p><p>与 MC 不同的是，Redis 采用单线程模式处理请求。<br>这样做的原因有 2 个：<br>一个是因为采用了非阻塞的异步事件处理机制；<br>另一个是缓存数据都是内存操作 IO 时间不会太长，单线程可以避免线程上下文切换产生的代价。<br>Redis 支持持久化，所以 Redis 不仅仅可以用作缓存，也可以用作 NoSQL 数据库。<br>相比 MC，Redis 还有一个非常大的优势，就是除了 K-V 之外，还支持多种数据格式，例如 list、set、sorted set、hash 等。<br>Redis 提供主从同步机制，以及 Cluster 集群部署能力，能够提供高可用服务。</p><h2 id="什么是Redis数据持久？方式都有哪些，各自的优缺点是什么？"><a href="#什么是Redis数据持久？方式都有哪些，各自的优缺点是什么？" class="headerlink" title="什么是Redis数据持久？方式都有哪些，各自的优缺点是什么？"></a>什么是Redis数据持久？方式都有哪些，各自的优缺点是什么？</h2><p>1.redis持久化就是把内存的数据写到磁盘中去，防止服务器宕机了内存数据丢失。<br>2.数据持久化的方式有2种： RDB(默认) 和 AOF 。</p><p><strong>RDB （redis database）</strong><br>核心函数rdbSave(生成RDB文件)和rdbLoad（从文件加载内存）两个函数</p><p><img src="https://www.cmdbyte.com/2021/02/20200401173912460.png" alt="20200401173912460"></p><p><strong>AOF （append-only file）</strong><br>每当执行服务器(定时)任务或者函数时flushAppendOnlyFile 函数都会被调用， 这个函数执行以下两个工作<br>AOF 写入保存。</p><p>存储的内容是 redis通讯协议格式命令的命令文本存储。点击立即了解 —&gt; <a href="https://www.cnblogs.com/nele/p/8908298.html">https://www.cnblogs.com/nele/p/8908298.html</a></p><p>WRITE：根据条件，将 aof_buf 中的缓存写入到 AOF 文件<br>SAVE：根据条件，调用 fsync 或 fdatasync 函数，将 AOF 文件保存到磁盘中。</p><p><img src="https://www.cmdbyte.com/2021/02/20200401174021504.png" alt="20200401174021504"></p><p><strong>区别：</strong><br>1、AOF 文件比 RDB 更新频率高，优先使用 AOF 还原数据。<br>2、AOF 比 RDB 更安全也更大<br>3、RDB 性能比 AOF 好<br>4、如果两个都配了优先加载AOF</p><h2 id="Redis的淘汰策略"><a href="#Redis的淘汰策略" class="headerlink" title="Redis的淘汰策略"></a>Redis的淘汰策略</h2><p>Redis提供了六种淘汰策略：</p><ul><li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li><li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li>no-enviction（驱逐）：禁止驱逐数据</li></ul><p>使用策略规则：<br>1、如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru<br>2、如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random</p><h2 id="什么是缓存穿透，缓存击穿，缓存雪崩？"><a href="#什么是缓存穿透，缓存击穿，缓存雪崩？" class="headerlink" title="什么是缓存穿透，缓存击穿，缓存雪崩？"></a>什么是缓存穿透，缓存击穿，缓存雪崩？</h2><p><strong>缓存穿透</strong><br>描述： 缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p><p>解决方案：</p><p>接口层增加校验，如用户鉴权校验，id做基础校验，id&lt;&#x3D;0的直接拦截；<br>从缓存取不到的数据，在数据库中也没有取到，这时也可以将key-value对写为key-null，缓存有效时间可以设置短点，如30秒（设置太长会导致正常情况也没法使用）。这样可以防止攻击用户反复用同一个id暴力攻击</p><p><strong>缓存击穿</strong></p><p>描述：缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p><p>解决方案：</p><p>设置热点数据永远不过期。<br>加互斥锁，互斥锁参考代码如下：</p><p><img src="https://www.cmdbyte.com/2021/02/20200401174137877.png" alt="20200401174137877"></p><p>1）缓存中有数据，直接走上述代码13行后就返回结果了</p><p>2）缓存中没有数据，第1个进入的线程，获取锁并从数据库去取数据，没释放锁之前，其他并行进入的线程会等待100ms，再重新去缓存取数据。这样就防止都去数据库重复取数据，重复往缓存中更新数据情况出现。</p><p>3）当然这是简化处理，理论上如果能根据key值加锁就更好了，就是线程A从数据库取key1的数据并不妨碍线程B取key2的数据，上面代码明显做不到这点。</p><p><strong>缓存雪崩</strong></p><p>描述： 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是， 缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。</p><p>解决方案：</p><p>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。<br>如果缓存数据库是分布式部署，将热点数据均匀分布在不同搞得缓存数据库中。<br>设置热点数据永远不过期。</p><h2 id="在Redis中如何保证只存20W的热点数据？"><a href="#在Redis中如何保证只存20W的热点数据？" class="headerlink" title="在Redis中如何保证只存20W的热点数据？"></a>在Redis中如何保证只存20W的热点数据？</h2><p>先计算出20W数据需要占用数据的空间，然后设置数据淘汰策略为 allkey-lru 回收最少使用策略。</p><h2 id="Redis支持事务吗？"><a href="#Redis支持事务吗？" class="headerlink" title="Redis支持事务吗？"></a>Redis支持事务吗？</h2><p>支持 , 表现为多条命令，要么都执行，要么都不执行。</p><p>redis的事务可以分为两步，定义事务和执行事务。<br>使用multi命令开启一个事务，然后把要执行的所有命令都依次排上去。<br>这就定义好了一个事务。此时使用exec命令来执行这个事务，或使用discard命令来放弃这个事务。<br>你可能希望在你的事务开始前，你关心的key不想被别人操作，那么可以使用watch命令来监视这些key，<br>如果开始执行前这些key被其它命令操作了则会取消事务的。也可以使用unwatch命令来取消对这些key的监视。</p><p>redis事务具有以下特点：<br>1、如果开始执行事务前出错，则所有命令都不执行<br>2、一旦开始，则保证所有命令一次性按顺序执行完而不被打断<br>3、如果执行过程中遇到错误，会继续执行下去，不会停止的<br>4、对于执行过程中遇到错误，是不会进行回滚的</p><p>很显然，这并不是我们通常认为的事务，因为它连原子性都保证不了。保证不了原子性是因为redis不支持回滚，不过它也给出了不支持的理由。</p><p>不支持回滚的理由：<br>1、redis认为，失败都是由命令使用不当造成<br>2、redis这样做，是为了保持内部实现简单快速<br>3、redis还认为，回滚并不能解决所有问题<br>因此 , 使用redis事务的不太多</p><h2 id="Redis-架构模式有哪些？讲讲各自的特点？"><a href="#Redis-架构模式有哪些？讲讲各自的特点？" class="headerlink" title="Redis 架构模式有哪些？讲讲各自的特点？"></a>Redis 架构模式有哪些？讲讲各自的特点？</h2><p><img src="https://www.cmdbyte.com/2021/02/20200401174303361.png" alt="20200401174303361"></p><p><img src="https://www.cmdbyte.com/2021/02/2020040117431646.png" alt="2020040117431646"></p><p><img src="https://www.cmdbyte.com/2021/02/20200401174326799.png" alt="20200401174326799"></p><p><img src="https://www.cmdbyte.com/2021/02/20200401174336173.png" alt="20200401174336173"></p><h2 id="Redis-集群方案都有哪些？"><a href="#Redis-集群方案都有哪些？" class="headerlink" title="Redis 集群方案都有哪些？"></a>Redis 集群方案都有哪些？</h2><p>1.twemproxy，大概概念是，它类似于一个代理方式， 使用时在本需要连接 redis 的地方改为连接 twemproxy， 它会以一个代理的身份接收请求并使用一致性 hash 算法，将请求转接到具体 redis，将结果再返回 twemproxy。<br>缺点： twemproxy 自身单端口实例的压力，使用一致性 hash 后，对 redis 节点数量改变时候的计算值的改变，数据无法自动移动到新的节点。</p><p>2.codis，目前用的最多的集群方案，基本和 twemproxy 一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新 hash 节点</p><p>3.redis cluster3.0 自带的集群，特点在于他的分布式算法不是一致性 hash，而是 hash 槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。</p><h2 id="Redis支持的Java客户端都有哪些？官方推荐使用哪个？"><a href="#Redis支持的Java客户端都有哪些？官方推荐使用哪个？" class="headerlink" title="Redis支持的Java客户端都有哪些？官方推荐使用哪个？"></a>Redis支持的Java客户端都有哪些？官方推荐使用哪个？</h2><p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p><h2 id="Redis和Redisson有什么关系？"><a href="#Redis和Redisson有什么关系？" class="headerlink" title="Redis和Redisson有什么关系？"></a>Redis和Redisson有什么关系？</h2><p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象<br>(Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish &#x2F; Subscribe, HyperLogLog)。</p><h2 id="Jedis与Redisson对比有什么优缺点？"><a href="#Jedis与Redisson对比有什么优缺点？" class="headerlink" title="Jedis与Redisson对比有什么优缺点？"></a>Jedis与Redisson对比有什么优缺点？</h2><p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；</p><p>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。<br>Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上</p><h2 id="Redis分布式锁如何续期？"><a href="#Redis分布式锁如何续期？" class="headerlink" title="Redis分布式锁如何续期？"></a>Redis分布式锁如何续期？</h2><p><a href="https://zhuanlan.zhihu.com/p/71185118">https://zhuanlan.zhihu.com/p/71185118</a></p><h2 id="Redis分布式锁如何防止死锁"><a href="#Redis分布式锁如何防止死锁" class="headerlink" title="Redis分布式锁如何防止死锁"></a>Redis分布式锁如何防止死锁</h2><p>方法1 ， 编写2个方法一个加锁，一个解锁</p><p><strong>加锁代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">LOCK_SUCCESS</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;OK&quot;</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SET_IF_NOT_EXIST</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;NX&quot;</span>;<br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SET_WITH_EXPIRE_TIME</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;PX&quot;</span>;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 尝试获取分布式锁</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> jedis Redis客户端</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> lockKey 锁</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> requestId 请求标识</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> expireTime 超期时间</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 是否获取成功</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryGetDistributedLock</span><span class="hljs-params">(Jedis jedis, String lockKey, String requestId, <span class="hljs-type">int</span> expireTime)</span> &#123;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.set(lockKey, requestId, SET_IF_NOT_EXIST, SET_WITH_EXPIRE_TIME, expireTime);<br>        <span class="hljs-keyword">if</span> (LOCK_SUCCESS.equals(result)) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>     &#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们加锁就一行代码：jedis.set(String key, String value, String nxxx, String expx, int time)，这个set()方法一共有五个形参：</p><ul><li>第一个为key，我们使用key来当锁，因为key是唯一的。</li><li>第二个为value，我们传的是requestId，很多童鞋可能不明白，有key作为锁不就够了吗，为什么还要用到value？原因就是我们在上面讲到可靠性时，分布式锁要满足第四个条件解铃还须系铃人，通过给value赋值为requestId，我们就知道这把锁是哪个请求加的了，在解锁的时候就可以有依据。requestId可以使用UUID.randomUUID().toString()方法生成。</li><li>第三个为nxxx，这个参数我们填的是NX，意思是SET IF NOT EXIST，即当key不存在时，我们进行set操作；若key已经存在，则不做任何操作；</li><li>第四个为expx，这个参数我们传的是PX，意思是我们要给这个key加一个过期的设置，具体时间由第五个参数决定。</li><li>第五个为time，与第四个参数相呼应，代表key的过期时间。</li><li>总的来说，执行上面的set()方法就只会导致两种结果：</li></ul><p>当前没有锁（key不存在），那么就进行加锁操作，并对锁设置个有效期，同时value表示加锁的客户端。<br>已有锁存在，不做任何操作。</p><p><strong>解锁代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Long</span> <span class="hljs-variable">RELEASE_SUCCESS</span> <span class="hljs-operator">=</span> <span class="hljs-number">1L</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 释放分布式锁</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> jedis Redis客户端</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> lockKey 锁</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> requestId 请求标识</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span> 是否释放成功</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseDistributedLock</span><span class="hljs-params">(Jedis jedis, String lockKey, String requestId)</span> &#123;<br>       <span class="hljs-type">String</span> <span class="hljs-variable">script</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;<br>       <span class="hljs-type">Object</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> jedis.eval(script, Collections.singletonList(lockKey), Collections.singletonList(requestId));<br>       <span class="hljs-keyword">if</span> (RELEASE_SUCCESS.equals(result)) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br></code></pre></td></tr></table></figure><p>可以看到，我们解锁只需要两行代码就搞定了！第一行代码，我们写了一个简单的Lua脚本代码，没想到这次居然用上了。<br>第二行代码，我们将Lua代码传到jedis.eval()方法里，并使参数KEYS[1]赋值为lockKey，ARGV[1]赋值为requestId。<br>eval()方法是将Lua代码交给Redis服务端执行</p><h2 id="Redis常用命令介绍"><a href="#Redis常用命令介绍" class="headerlink" title="Redis常用命令介绍"></a>Redis常用命令介绍</h2><p><strong>字符串：</strong><br>setnx(key,value) 只在键 key 不存在的情况下， 将键 key 的值设置为 value 。key存在,不做任何操作。<br>setex(key,seconds,value) 将key设置及生存时间seconds秒,原值存在覆盖。<br>psetex(key,milliseconds,value) 与setex同样,只是单位是毫秒。<br>getset(key,value) 设置新值并返回旧值,不存在返回nil<br>setrange(key,offset,value) 从偏移量开始offset开始<br>mset 同时给多个key复制</p><p><strong>哈希表(map)：</strong><br>hset(hash field value) 将哈希表 hash 中域 field 的值设置为 value<br>hmset key field value [field value …] 同时将多个 field-value (域-值)对设置到哈希表 key 中。<br>hget hash field 返回哈希表中给定域的值。<br>hgetall key 返回哈希表 key 中，所有的域和值。</p><p><strong>队列(queue):</strong><br>lpush key value [value …] 将一个或多个值 value 插入到列表 key 的表头<br>lpop key 移除并返回列表 key 的头元素,不存在返回nil<br>lset key index value 将列表 key 下标为 index 的元素的值设置为 value 。<br>brpop key [key …] timeout 在超时时间内移除列表尾元素，阻塞的。</p><p><strong>集合：</strong><br>sadd key member [member …] 将一个或多个 member 元素加入到集合 key 当中，已经存在于集合的 member 元素将被忽略<br>sismember key member 如果 member 元素是集合的成员，返回 1 。 如果 member 元素不是集合的成员，或 key 不存在，返回 0 。<br>spop key 移除集合key的随机元素<br>smembers key 返回集合 key 中的所有成员。<br>sdiff key [key …] 返回给定多个集合之间的差集。</p><p><strong>有序集合：</strong><br>zadd key score member [[score member] [score member] …] 将一个或多个 member 元素及其 score 值加入到有序集 key 当中。<br>zscore key member 返回有序集 key 中，成员 member 的 score 值。<br>zcount key min max score 值在 min 和 max 之间的成员的数量。<br>zrange key start stop [withscores] 返回有序集 key 中，指定区间内的成员(从小到大)。<br>zrank key member 返回有序集 key 中成员 member 的排名。其中有序集成员按 score 值递增(从小到大)顺序排列。<br>zrem key member [member …] 移除有序集 key 中的一个或多个成员，不存在的成员将被忽略。</p><p><strong>时效性：</strong><br>expire(key,seconds) 为给定 key 设置生存时间，当 key 过期时(生存时间为 0 )，它会被自动删除。<br>expireat( key,timestamp) 设置过期时间戳,expireatcache1355292000# 这个 key 将在 2012.12.12 过期<br>ttl(key) 返回剩余时间<br>persist key 移除key有效期，转换成永久的</p><p><strong>数据指令：</strong><br>keys pattern 符合给定模式的 key 列表。阻塞的<br>scan 异步的 有重复</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
      <tag>Redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用程序爬取网站返回HTTP418错误</title>
    <link href="/2021/03/14/%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%88%AC%E5%8F%96%E7%BD%91%E7%AB%99%E8%BF%94%E5%9B%9EHTTP418%E9%94%99%E8%AF%AF/"/>
    <url>/2021/03/14/%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%88%AC%E5%8F%96%E7%BD%91%E7%AB%99%E8%BF%94%E5%9B%9EHTTP418%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<p>使用爬虫请求网站页面，返回信息中没有爬到页面，查看返回体中的<code>Status Code</code>，显示<code>418</code>。</p><p>在使用浏览器访问网站的时候，有些网站会检查访问的请求头信息，这也是反扒策略的一种，服务器通过检查请求头信息来判断这是否是人为的一次请求。</p><p>在请求中加入请求头信息即可。例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">req, err := http.NewRequest(http.MethodGet, url, <span class="hljs-literal">nil</span>)<br>req.Header.Add(<span class="hljs-string">&quot;User-Agent&quot;</span>, <span class="hljs-string">&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 11_0_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/89.0.4389.82 Safari/537.36&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>go mod命令</title>
    <link href="/2021/03/13/go-mod%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/03/13/go-mod%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>Go1.11之前对于Go的版本管理主要用过 glide，下面介绍 Go 1.11 之后官方支持的版本管理工具 mod。</p><p>关于 mod 官方给出了三个命令 <code>go help mod</code>、<code>go help modules</code>、<code>go help module-get</code> 帮助了解使用。</p><h2 id="设置-GO111MODULE"><a href="#设置-GO111MODULE" class="headerlink" title="设置 GO111MODULE"></a>设置 GO111MODULE</h2><p>可以用环境变量 <code>GO111MODULE</code> 开启或关闭模块支持，它有三个可选值：off、on、auto，默认值是 auto。</p><ul><li><code>GO111MODULE=off</code> 无模块支持，go 会从 GOPATH 和 vendor 文件夹寻找包。</li><li><code>GO111MODULE=on</code> 模块支持，go 会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。</li><li><code>GO111MODULE=auto</code> 在 $GOPATH&#x2F;src 外面且根目录有 go.mod 文件时，开启模块支持。</li></ul><p>在使用模块的时候，GOPATH 是无意义的，不过它还是会把下载的依赖储存在 <code>GOPATH/pkg/mod</code> 中，也会把<code>go install</code>的结果放在<code>GOPATH/pkg/mod</code>中，也会把<code>go install</code>的结果放在<code>GOPATH/bin</code> 中。</p><h2 id="Go-mod-命令"><a href="#Go-mod-命令" class="headerlink" title="Go mod 命令"></a>Go mod 命令</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">download    download modules to local cache (下载依赖的module到本地cache))<br>edit        edit go.mod from tools or scripts (编辑go.mod文件)<br>graph       print module requirement graph (打印模块依赖图))<br>init        initialize new module in current directory (再当前文件夹下初始化一个新的module, 创建go.mod文件))<br>tidy        add missing and remove unused modules (增加丢失的module，去掉未用的module)<br>vendor      make vendored copy of dependencies (将依赖复制到vendor下)<br>verify      verify dependencies have expected content (校验依赖)<br>why         explain why packages or modules are needed (解释为什么需要依赖)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go使用iota</title>
    <link href="/2021/03/13/Go%E4%BD%BF%E7%94%A8iota/"/>
    <url>/2021/03/13/Go%E4%BD%BF%E7%94%A8iota/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><strong>iota是golang语言的常量计数器,只能在常量的表达式中使用。</strong></p><p>iota在const关键字出现时将被重置为0(const内部的第一行之前)，const中每新增一行常量声明将使iota计数一次(iota可理解为const语句块中的行索引)。</p><p>使用iota能简化定义，在定义枚举时很有用。</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><h3 id="iota只能在常量表达式中使用"><a href="#iota只能在常量表达式中使用" class="headerlink" title="iota只能在常量表达式中使用"></a>iota只能在常量表达式中使用</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Println(<span class="hljs-literal">iota</span>)<br><span class="hljs-comment">//编译错误：undefined: iota</span><br></code></pre></td></tr></table></figure><h3 id="每次const出现时，都会让iota初始化为0（自增长）"><a href="#每次const出现时，都会让iota初始化为0（自增长）" class="headerlink" title="每次const出现时，都会让iota初始化为0（自增长）"></a>每次const出现时，都会让iota初始化为0（自增长）</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> a = <span class="hljs-literal">iota</span> <span class="hljs-comment">//a = 0</span><br><span class="hljs-keyword">const</span> (<br>b = <span class="hljs-literal">iota</span>   <span class="hljs-comment">// b = 1</span><br>    c    <span class="hljs-comment">//c = 1</span><br>)<br></code></pre></td></tr></table></figure><h3 id="自定义类型"><a href="#自定义类型" class="headerlink" title="自定义类型"></a>自定义类型</h3><p>自增长常量经常包含一个自定义枚举类型，允许你依靠编译器完成自增设置。</p><p>下面是time包的例子，它定义了个Weekday命名类型，然后为一周的每一天定义了一个常量，周日从零开始。这在其他编程语言中一般称为枚举类型。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Weekday <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>    Sunday Weekday = <span class="hljs-literal">iota</span><br>    Monday<br>    Tuesday<br>    Wednesday<br>    Thursday<br>    Friday<br>    Saturday<br>)<br></code></pre></td></tr></table></figure><h3 id="可跳过的值"><a href="#可跳过的值" class="headerlink" title="可跳过的值"></a>可跳过的值</h3><p>在使用iota定义一组常量的时候，如果有些中间值不需要，可以使用<code>_</code>跳过。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyInt <span class="hljs-type">int</span><br><br><span class="hljs-keyword">const</span> (<br>a MyInt = <span class="hljs-literal">iota</span> <span class="hljs-comment">//a = 0</span><br>    b       <span class="hljs-comment">//b = 1</span><br>    _<br>    _<br>    c       <span class="hljs-comment">//c = 4</span><br>)<br></code></pre></td></tr></table></figure><h3 id="位掩码表示"><a href="#位掩码表示" class="headerlink" title="位掩码表示"></a>位掩码表示</h3><p><strong><code>iota</code> 可以做更多事情，而不仅仅是 increment。更精确地说，<code>iota</code> 总是用于 increment，但是它可以用于表达式，在常量中的存储结果值。</strong></p><p>下面是来自net包的例子，用于给一个无符号整数的最低5bit的每个bit指定一个名字：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Flags <span class="hljs-type">uint</span><br><br><span class="hljs-keyword">const</span> (<br>    FlagUp Flags = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span> <span class="hljs-comment">// is up</span><br>    FlagBroadcast            <span class="hljs-comment">// supports broadcast access capability</span><br>    FlagLoopback             <span class="hljs-comment">// is a loopback interface</span><br>    FlagPointToPoint         <span class="hljs-comment">// belongs to a point-to-point link</span><br>    FlagMulticast            <span class="hljs-comment">// supports multicast access capability</span><br>)<br></code></pre></td></tr></table></figure><p>随着iota的递增，每个常量对应表达式1 &lt;&lt; iota，是连续的2的幂，分别对应一个bit位置。使用这些常量可以用于测试、设置或清除对应的bit位的值：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> Flags <span class="hljs-type">uint</span><br><br><span class="hljs-keyword">const</span> (<br>    FlagUp           Flags = <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-literal">iota</span> <span class="hljs-comment">// is up</span><br>    FlagBroadcast                      <span class="hljs-comment">// supports broadcast access capability</span><br>    FlagLoopback                       <span class="hljs-comment">// is a loopback interface</span><br>    FlagPointToPoint                   <span class="hljs-comment">// belongs to a point-to-point link</span><br>    FlagMulticast                      <span class="hljs-comment">// supports multicast access capability</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsUp</span><span class="hljs-params">(v Flags)</span></span> <span class="hljs-type">bool</span>     &#123; <span class="hljs-keyword">return</span> v&amp;FlagUp == FlagUp &#125; <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TurnDown</span><span class="hljs-params">(v *Flags)</span></span>     &#123; *v &amp;^= FlagUp &#125; <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">SetBroadcast</span><span class="hljs-params">(v *Flags)</span></span> &#123; *v |= FlagBroadcast &#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">IsCast</span><span class="hljs-params">(v Flags)</span></span> <span class="hljs-type">bool</span>   &#123; <span class="hljs-keyword">return</span> v&amp;(FlagBroadcast|FlagMulticast) != <span class="hljs-number">0</span> &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> v Flags = FlagMulticast | FlagUp <span class="hljs-comment">// v 10001</span><br>    fmt.Printf(<span class="hljs-string">&quot;%b %t\n&quot;</span>, v, IsUp(v)) <span class="hljs-comment">// &quot;10001 true&quot;</span><br>    TurnDown(&amp;v)<br>    fmt.Printf(<span class="hljs-string">&quot;%b %t\n&quot;</span>, v, IsUp(v)) <span class="hljs-comment">// &quot;10000 false&quot;</span><br>    SetBroadcast(&amp;v)<br>    fmt.Printf(<span class="hljs-string">&quot;%b %t\n&quot;</span>, v, IsUp(v))   <span class="hljs-comment">// &quot;10010 false&quot;</span><br>    fmt.Printf(<span class="hljs-string">&quot;%b %t\n&quot;</span>, v, IsCast(v)) <span class="hljs-comment">// &quot;10010 true&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs text">10001 true<br><br>10000 false<br><br>10010 false<br><br>10010 true<br></code></pre></td></tr></table></figure><h3 id="定义数量级"><a href="#定义数量级" class="headerlink" title="定义数量级"></a>定义数量级</h3><p>下面的每个常量都是1024的幂</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    _ = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span> * <span class="hljs-literal">iota</span>)<br>    KiB <span class="hljs-comment">// 1024</span><br>    MiB <span class="hljs-comment">// 1048576</span><br>    GiB <span class="hljs-comment">// 1073741824</span><br>    TiB <span class="hljs-comment">// 1099511627776             (exceeds 1 &lt;&lt; 32)</span><br>    PiB <span class="hljs-comment">// 1125899906842624</span><br>    EiB <span class="hljs-comment">// 1152921504606846976</span><br>    ZiB <span class="hljs-comment">// 1180591620717411303424    (exceeds 1 &lt;&lt; 64)</span><br>    YiB <span class="hljs-comment">// 1208925819614629174706176</span><br>)<br></code></pre></td></tr></table></figure><p>不过iota常量生成规则也有其局限性。例如，它并不能用于产生1000的幂（KB、MB等），因为Go语言并没有计算幂的运算符。</p><h3 id="定义在一行的情况"><a href="#定义在一行的情况" class="headerlink" title="定义在一行的情况"></a>定义在一行的情况</h3><p>如果多个iota在一行，那么它将在下一行增长，而不是立即取得它的引用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>    Apple, Banana = <span class="hljs-literal">iota</span> + <span class="hljs-number">1</span>, <span class="hljs-literal">iota</span> + <span class="hljs-number">2</span> <span class="hljs-comment">//Apple = 1, Banana = 2</span><br>    Cherimoya, Durian    <span class="hljs-comment">//Cherimoya = 2, Durian = 3</span><br>    Elderberry, Fig   <span class="hljs-comment">//Elderberry = 3, Fig = 4</span><br>)<br></code></pre></td></tr></table></figure><h3 id="中间插队"><a href="#中间插队" class="headerlink" title="中间插队"></a>中间插队</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>i = <span class="hljs-literal">iota</span>  <span class="hljs-comment">// i = 0</span><br>    j = <span class="hljs-number">3.14</span>  <span class="hljs-comment">// j = 3.14</span><br>    k         <span class="hljs-comment">// k = 3.14</span><br>    l = <span class="hljs-literal">iota</span>  <span class="hljs-comment">// l = 3</span><br>    _<br>    m         <span class="hljs-comment">// m = 5</span><br>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中Map的比较</title>
    <link href="/2021/03/12/Go%E4%B8%ADMap%E7%9A%84%E6%AF%94%E8%BE%83/"/>
    <url>/2021/03/12/Go%E4%B8%ADMap%E7%9A%84%E6%AF%94%E8%BE%83/</url>
    
    <content type="html"><![CDATA[<h2 id="两个Map相等的条件"><a href="#两个Map相等的条件" class="headerlink" title="两个Map相等的条件"></a>两个Map相等的条件</h2><ul><li>两个map都为nil或者都不为nil，并且长度要相等</li><li>相同的map对象或者所有key要对应相同</li><li>map对应的value也要深度相等</li></ul><p>注意第10行代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(s <span class="hljs-type">string</span>, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    sDir := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    tDir := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _,ss:= <span class="hljs-keyword">range</span> s &#123;<br>        sDir[<span class="hljs-type">string</span>(ss)]++<br>    &#125;<br>    <span class="hljs-keyword">for</span> _,tt:= <span class="hljs-keyword">range</span> t &#123;<br>        tDir[<span class="hljs-type">string</span>(tt)]++<br>    &#125;<br>    <span class="hljs-comment">//报错：invalid operation: sDir == tDir(map can only be compared to nil)</span><br>    <span class="hljs-keyword">return</span> sDir == tDir<br>&#125;<br></code></pre></td></tr></table></figure><p>Golang中要比较两个map实例需要使用<code>reflect</code>包的<code>DeepEqual()</code>方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">isAnagram</span><span class="hljs-params">(s <span class="hljs-type">string</span>, t <span class="hljs-type">string</span>)</span></span> <span class="hljs-type">bool</span> &#123;<br>    sDir := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    tDir := <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>&#123;&#125;<br>    <span class="hljs-keyword">for</span> _,ss:= <span class="hljs-keyword">range</span> s &#123;<br>        sDir[<span class="hljs-type">string</span>(ss)]++<br>    &#125;<br>    <span class="hljs-keyword">for</span> _,tt:= <span class="hljs-keyword">range</span> t &#123;<br>        tDir[<span class="hljs-type">string</span>(tt)]++<br>    &#125;<br>    <span class="hljs-keyword">return</span> reflect.DeepEqual(sDir,tDir)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go语言中如何比较两个map[string]interface{}是否相等</title>
    <link href="/2021/03/12/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAmap-string-interface-%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/"/>
    <url>/2021/03/12/Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%A6%82%E4%BD%95%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AAmap-string-interface-%E6%98%AF%E5%90%A6%E7%9B%B8%E7%AD%89/</url>
    
    <content type="html"><![CDATA[<ul><li><p>Map是无序的</p></li><li><p>Go语言中两个<code>interface&#123;&#125;</code> 是无法直接比较是否相等。因为类型不确定，任何类型的数据都可以被塞到interface{}中。</p></li></ul><h3 id="比较两个map-string-interface-是否相等："><a href="#比较两个map-string-interface-是否相等：" class="headerlink" title="比较两个map[string]interface{}是否相等："></a>比较两个map[string]interface{}是否相等：</h3><p>首先，我们可以将它们转化为 json 字符串来比较，但是因为Map是无序的，所以转化的json字符串不一定会一模一样。（当然，你也可以用反射来做，但是代码量多，麻烦。）</p><p>所以我们可以将其转化成顺序一样的 slice ，然后再转化未 json 。 这样就确保的json可以一样了。</p><p>代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">CompareTwoMapInterface</span><span class="hljs-params">(data1 <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;, </span></span><br><span class="hljs-params"><span class="hljs-function">data2 <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> <span class="hljs-type">bool</span> &#123;<br>keySlice := <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>, <span class="hljs-number">0</span>)<br>dataSlice1 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">0</span>)<br>dataSlice2 := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">interface</span>&#123;&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> data1 &#123;<br>keySlice = <span class="hljs-built_in">append</span>(keySlice, key)<br>dataSlice1 = <span class="hljs-built_in">append</span>(dataSlice1, value)<br>&#125;<br><span class="hljs-keyword">for</span> _, key := <span class="hljs-keyword">range</span> keySlice &#123;<br><span class="hljs-keyword">if</span> data, ok := data2[key]; ok &#123;<br>dataSlice2 = <span class="hljs-built_in">append</span>(dataSlice2, data)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br>dataStr1, _ := json.Marshal(dataSlice1)<br>dataStr2, _ := json.Marshal(dataSlice2)<br><br><span class="hljs-keyword">return</span> <span class="hljs-type">string</span>(dataStr1) == <span class="hljs-type">string</span>(dataStr2)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gob踩坑记录</title>
    <link href="/2021/03/12/gob%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2021/03/12/gob%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>今天在写多个参数的RPC请求调用demo时，遇到了这样一个问题:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">panic: gob: type main.Cuboid has no exported fields<br></code></pre></td></tr></table></figure><p>在网上一查，竟然犯了一个低级错误。Go语言包内变量、函数等对外可见性是根据首字母是否大写实现的，我结构体里的参数因为要传给别的进程使用，所以应该首字母大写，让其对外可见。</p><p>源程序：</p><p>rpc_server.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;net&quot;</span><br><span class="hljs-string">&quot;net/http&quot;</span><br><span class="hljs-string">&quot;net/rpc&quot;</span><br><span class="hljs-string">&quot;time&quot;</span><br>)<br><br><span class="hljs-keyword">type</span> MathUtils <span class="hljs-keyword">struct</span> &#123;<br><br>&#125;<br><span class="hljs-comment">// ---------这里有问题 start -------------</span><br><span class="hljs-keyword">type</span> Cuboid <span class="hljs-keyword">struct</span> &#123;<br>length <span class="hljs-type">float32</span><br>width <span class="hljs-type">float32</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MathUtils)</span></span> CuboidArea(req Cuboid, resp *<span class="hljs-type">float32</span>) <span class="hljs-type">error</span> &#123;<br>*resp = req.length * req.width<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-comment">// -----------------end------------------</span><br><span class="hljs-comment">// 上面的字段改成 length -&gt; Length, width -&gt; Width</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>err := rpc.Register(<span class="hljs-built_in">new</span>(MathUtils))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err.Error())<br>&#125;<br><br>rpc.HandleHTTP()<br><br>listen, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:8081&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err.Error())<br>&#125;<br><br>http.Serve(listen, <span class="hljs-literal">nil</span>)<br><br>time.Sleep(<span class="hljs-number">10</span> * time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><p>rpc_client.go</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;net/rpc&quot;</span><br>)<br><span class="hljs-comment">// -------------有问题 start --------------</span><br><span class="hljs-keyword">type</span> Cuboid <span class="hljs-keyword">struct</span> &#123;<br>length <span class="hljs-type">float32</span><br>width <span class="hljs-type">float32</span><br>&#125;<br><span class="hljs-comment">// --------------end---------------------</span><br><span class="hljs-comment">// 修改：length -&gt; Length, width -&gt; Width</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>client, err := rpc.DialHTTP(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:8081&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err.Error())<br>&#125;<br><span class="hljs-keyword">var</span> resp <span class="hljs-type">float32</span><br>req := Cuboid&#123; <span class="hljs-number">3.30</span>,  <span class="hljs-number">22.37</span>&#125;<br>err = client.Call(<span class="hljs-string">&quot;MathUtils.CuboidArea&quot;</span>, req, &amp;resp)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-comment">// 未修改前，此处报错：panic: gob: type main.Cuboid has no exported fields</span><br><span class="hljs-built_in">panic</span>(err.Error())<br>&#125;<br>fmt.Println(resp)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用数据结构</title>
    <link href="/2021/03/12/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2021/03/12/%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<blockquote><p>推荐一个知乎大佬：<a href="https://www.zhihu.com/people/qiongmanong">https://www.zhihu.com/people/qiongmanong</a></p></blockquote><p><strong>数组</strong>，<strong>栈</strong>，<strong>队列</strong>，<strong>链表</strong>，<strong>树</strong>，<strong>图</strong>，<strong>字母树（其实他们就是树而已，但还是值得单独拿出来讲的）</strong>，<strong>哈希表</strong></p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是最简单也最常用的数据结构。其他的数据结构诸如栈和队列，都是从数组衍生出来的。<br>下面是一个拥有四个元素的简单数组，包含了元素1，2，3，4.</p><p><img src="https://www.cmdbyte.com/2021/02/v2-55a6b107d884f18cc9f381587b177e07_b.jpg" alt="v2-55a6b107d884f18cc9f381587b177e07_b"></p><p>每个元素都依附于一个正整数，称作索引，它就对应于数组中该元素所在的位置。大多数的编程语言中，数组的起始索引都为0 （0-based，译者注）.<br>数组一般有以下两种：<br>一维数组（上图所示）<br>多维数组（数组里面包含数组）</p><h3 id="数组的基本操作"><a href="#数组的基本操作" class="headerlink" title="数组的基本操作"></a>数组的基本操作</h3><p>插入 — 在给<a href="https://link.zhihu.com/?target=http://www.1point3acres.com/warald-evaluation-%E5%85%8D%E8%B4%B9%E5%92%A8%E8%AF%A2%E8%83%8C%E6%99%AF%E8%AF%84%E4%BC%B0%E5%AE%9A%E4%BD%8D/">定位</a>置插入一个元素<br>取值 — 返回给定位置的数值<br>删除 — 在给定位置删除元素<br>元素总数 — 数组包含元素的个数</p><h3 id="数组类常问问题"><a href="#数组类常问问题" class="headerlink" title="数组类常问问题"></a>数组类常问问题</h3><p>数组中第二小的数<br>数组中出现的第一个无重复的数<br>合并两个已排序数组<br>重新排放数组的正数和负数</p><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><p>我们平时熟悉的软件操作中的撤销（回退）操作，基本会出现在所有应用中。你好奇过它是咋工作的吗？原理是这样的：你把之前的状态（有限的数量）都存到内存中，存的顺序是最新的操作存在最近一个。这个光靠数组是不能实现的。这是栈擅长的地方。<br>现实中也有栈的例子。比如你把一大堆书垂直叠（一本压着另外一本）起来放。为了拿到他们里面靠中部位置的书，你得把上面的书都拿走才行。这就是著名的LIFO（后进先出）的工作原理。<br>下图是一个包含有三个元素的栈，数值为1，2，3. 元素3在栈顶，它会被最先删除。</p><p><img src="https://www.cmdbyte.com/2021/02/v2-82dbaa1a8f9a6481a0d063107376afea_b.jpg" alt="v2-82dbaa1a8f9a6481a0d063107376afea_b"></p><h3 id="栈的基本操作"><a href="#栈的基本操作" class="headerlink" title="栈的基本操作"></a>栈的基本操作</h3><p>进栈 — 在栈顶插入元素<br>出栈 — 把栈顶元素弹出（删除）<br>判空 — 返回栈是否为空<br>栈顶元素 — 只返回栈顶元素而不删除<br>译者注：对于栈所有的操作，都只出现在栈顶这个地方</p><h3 id="栈常见的面试问题"><a href="#栈常见的面试问题" class="headerlink" title="栈常见的面试问题"></a>栈常见的面试问题</h3><p>借助栈来计算后缀表达式的值<br>将栈里的元素进行排序<br>判断括号表达式是否合法</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><p>和栈类似，队列是另外一种线性数据结构。这种数据结构将元素按照顺序的方式存储。和栈最本质的区别就是：和后进先出相反，队列实现了先进先出的特性（FIFO， First in First Out）。<br>队列在生活中有非常贴切的例子：一堆人排在售票台前面。如果新来了一个人，这个人得排在队尾，而不是队伍前面。另一方面，排在第一的人则能第一个买到票，然后离开队伍。<br>下面是一个包含了四个元素的队列（1， 2， 3， 4）。1站在队头，会被第一个删除。</p><p><img src="https://www.cmdbyte.com/2021/02/v2-564c6af81cf8ae1e530fdfd1af9e8dc7_b.jpg" alt="v2-564c6af81cf8ae1e530fdfd1af9e8dc7_b"></p><h3 id="队列的常用操作"><a href="#队列的常用操作" class="headerlink" title="队列的常用操作"></a>队列的常用操作</h3><p>进队 — 在队尾加入一个元素<br>出队 — 从队头删除元素<br>判空 — 判断队列是否为空<br>队头元素 — 返回但不删除队头元素</p><h3 id="常见的队列题"><a href="#常见的队列题" class="headerlink" title="常见的队列题"></a>常见的队列题</h3><p>用队列实现栈<br>将队列里面的前k个元素翻转<br>借助队列来产生从1到n的二进制数</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表是另外一种重要的线性数据结构。链表初看起来和数组很类似，但他们在内存分配，内部结构，以及像插入和删除这样的基本操作上，都是不一样的。<br>链表就是一串 串起来 的节点，他们的每一个节点都包含了数据和指向下一个节点的信息。链表有头结点，指向链表中的第一个元素。<br>链表结构经常用来实现文件系统，哈希表，以及邻接表。<br>下图是一个链表的内部结构图示。</p><p><img src="https://www.cmdbyte.com/2021/02/v2-06be83df20e234ec3989d8b9e5530901_b.jpg" alt="v2-06be83df20e234ec3989d8b9e5530901_b"></p><p>我们常见的链表有以下两种：<br>Singly Linked List (Unidirectional)<br>Doubly Linked List (Bi-directional)<br>单链表 （单一方向）<br>双链表 （双向）</p><h3 id="链表基本操作："><a href="#链表基本操作：" class="headerlink" title="链表基本操作："></a>链表基本操作：</h3><p>末端插入 — 在链表的末尾插入给定元素<br>头部插入 — 在链表的头部插入给定元素<br>删除 — 在链表中删除给定元素<br>头部删除 — 删除头部第一个元素<br>搜索 — 判断给定元素是否存在于链表中<br>判空 — 判断链表是否为空</p><h3 id="常见的链表问题"><a href="#常见的链表问题" class="headerlink" title="常见的链表问题"></a>常见的链表问题</h3><p>翻转链表<br>检查链表中是否有环<br>返回距离尾部距离为N的节点<br>删除链表中的重复元素</p><h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>图包含一系列的节点，这些节点通过网络相互连接起来。这些节点也被称为Vertcies。对于每个对子（x, y)，我们则称为边，表示节点x和节点y是相连的。边也可能包含权重或是花费信息，表明了从x到也所需要的消耗。</p><p><img src="https://www.cmdbyte.com/2021/02/v2-bee1f6be5a679aebb0ace677ae13d629_b.jpg" alt="v2-bee1f6be5a679aebb0ace677ae13d629_b"></p><p>图的类型：<br>无向图<br>有向图</p><p>在计算机语言中，图通常用下面两种方法表示：<br>邻接矩阵<br>邻接表</p><h3 id="常用的图遍历算法："><a href="#常用的图遍历算法：" class="headerlink" title="常用的图遍历算法："></a>常用的图遍历算法：</h3><p>宽度优先搜索<br>深度优先搜索<br>常见的图问题<br>实现宽搜和深搜<br>判断一个图是不是一棵树<br>数图中的边数<br>找两个节点之间的最短路径</p><h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><p>树是非线性数据结构，它也是由节点和边组成的。因此树和图类似，但他们最大的不同是树上没有环存在。<br>树被广泛应用在AI和其他复杂算法中，因为它能提供高效的存储，使得问题能得以解决。<br>下面是一颗简单树，图中也包含了常见的树的术语。</p><img src="https://www.cmdbyte.com/2021/02/v2-9cac91c97db12e50cf564421d8872b85_b.jpg" alt="v2-9cac91c97db12e50cf564421d8872b85_b" style="zoom:80%;" /><p>我们可以有以下的各种树的形状：</p><ul><li>N叉树</li><li>平衡树</li><li>二叉树</li><li>二叉搜索树</li><li>AVL树</li><li>红黑树</li><li>2-3树</li></ul><p>上面这些树中，以二叉树和二叉搜索树最为常用。</p><h3 id="常见的树的问题"><a href="#常见的树的问题" class="headerlink" title="常见的树的问题"></a>常见的树的问题</h3><p>求二叉树的高度<br>求二叉搜索树中的第k大的数值<br>找离根节点距离为k的所有节点<br>找给定节点的所有祖先节点</p><h2 id="字母树"><a href="#字母树" class="headerlink" title="字母树"></a>字母树</h2><p>字母树，也叫做前缀树，是一种树形的数据结构，它是一种解决字符串相关的问题的高效数据结构。能快速查询回馈信息，经常用在字典中查询单词的场景下，它能为搜索引擎提供自动补全，甚至能帮到IP查询。<br>下图演示了如何将三个单词（top, thus, their）插入到字母树中，并保存下来：</p><img src="https://www.cmdbyte.com/2021/02/v2-e46b3aa5a9c822ed6a63e6d3d7b84136_b.jpg" alt="v2-e46b3aa5a9c822ed6a63e6d3d7b84136_b" style="zoom:50%;" /><p>在字母树中，单词都是从下至下一个字母一个字母保存起来的。绿色的节点（p, s, r）表示的是该节点是一个单词的最后一个字母，p对应top，s对应thus，而r则对应于their。</p><h3 id="常见的字母树问题"><a href="#常见的字母树问题" class="headerlink" title="常见的字母树问题"></a>常见的字母树问题</h3><p>数字母树中的单词总数<br>打印字母树中所有的单词<br>用字母树排序数组<br>借助字母树来从字典中取单词<br>建一个满足T9的字典（译者注：T9 stands forText on 9 keys）</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>哈希是一个分辨不同的实体，从而将每个实体存储在某个预先计算好的索引上，这个预先算出来的值被称作“键”。因此，实体都是由键值对的形式存放的，把一大堆这样的东西称为字典。每个实体都能通过键来找到。基于哈希这种思想的数据结构有不少，但最常用的是哈希表。<br>哈希表一般通过数组来实现。<br>哈希表的效率取决于以下三个因数：</p><ol><li>哈希函数</li><li>哈希表的容量</li><li>冲突避免方式</li></ol><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><p>找数组中的对称对子<br>追踪旅程的完整路径<br>检查一个数组是否为另一数组的子集<br>检查多个数组之间是不是没有共同元素</p><p>上面就是八种你在算法面试之前必知必会的数据结构。</p>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go二维切片初始化</title>
    <link href="/2021/03/11/Go%E4%BA%8C%E7%BB%B4%E5%88%87%E7%89%87%E5%88%9D%E5%A7%8B%E5%8C%96/"/>
    <url>/2021/03/11/Go%E4%BA%8C%E7%BB%B4%E5%88%87%E7%89%87%E5%88%9D%E5%A7%8B%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 方法0</span><br>row, column := <span class="hljs-number">3</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">var</span> answer [][]<span class="hljs-type">int</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; row; i++ &#123;<br>inline := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, column)<br>answer = <span class="hljs-built_in">append</span>(answer, inline)<br>&#125;<br>fmt.Println(answer)<br><br><span class="hljs-comment">// 方法1</span><br>answer1 := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, row)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> answer1 &#123;<br>answer1[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, column)<br>&#125;<br>fmt.Println(answer1)<br>&#125;<br><span class="hljs-comment">// [[0 0 0 0] [0 0 0 0] [0 0 0 0]]</span><br><span class="hljs-comment">// [[0 0 0 0] [0 0 0 0] [0 0 0 0]]</span><br></code></pre></td></tr></table></figure><p>Golang创建二维切片相比C++,JAVA等语言来说，要稍微麻烦一点，特此记录一下。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库面试知识点汇总</title>
    <link href="/2021/03/11/m-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/"/>
    <url>/2021/03/11/m-%E6%95%B0%E6%8D%AE%E5%BA%93%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<blockquote><p>原文：<a href="https://www.cnblogs.com/wenxiaofei/p/9853682.html">https://www.cnblogs.com/wenxiaofei/p/9853682.html</a></p></blockquote><h1 id="数据库面试知识点汇总"><a href="#数据库面试知识点汇总" class="headerlink" title="数据库面试知识点汇总"></a>数据库面试知识点汇总</h1><h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><h4 id="1-主键、外键、超键、候选键"><a href="#1-主键、外键、超键、候选键" class="headerlink" title="1.主键、外键、超键、候选键"></a><strong>1.主键、外键、超键、候选键</strong></h4><blockquote><p><strong>超键</strong>：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</p><p><strong>候选键</strong>：是最小超键，即没有冗余元素的超键。</p><p><strong>主键</strong>：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。</p><p><strong>外键</strong>：在一个表中存在的另一个表的主键称此表的外键。</p></blockquote><h4 id="2-为什么用自增列作为主键"><a href="#2-为什么用自增列作为主键" class="headerlink" title="2.为什么用自增列作为主键"></a><strong>2.为什么用自增列作为主键</strong></h4><blockquote><p>如果我们定义了主键(PRIMARY KEY)，那么InnoDB会选择主键作为聚集索引、</p><p>如果没有显式定义主键，则InnoDB会选择第一个不包含有NULL值的唯一索引作为主键索引、</p><p>如果也没有这样的唯一索引，则InnoDB会选择内置6字节长的ROWID作为隐含的聚集索引(ROWID随着行记录的写入而主键递增，这个ROWID不像ORACLE的ROWID那样可引用，是隐含的)。</p><p>数据记录本身被存于主索引（一颗B+Tree）的叶子节点上。这就要求同一个叶子节点内（大小为一个内存页或磁盘页）的各条数据记录按主键顺序存放，因此每当有一条新的记录插入时，MySQL会根据其主键将其插入适当的节点和位置，如果页面达到装载因子（InnoDB默认为15&#x2F;16），则开辟一个新的页（节点）</p><p>如果表使用自增主键，那么每次插入新的记录，记录就会顺序添加到当前索引节点的后续位置，当一页写满，就会自动开辟一个新的页</p><p>如果使用非自增主键（如果身份证号或学号等），由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。</p></blockquote><h4 id="3-触发器的作用？"><a href="#3-触发器的作用？" class="headerlink" title="3.触发器的作用？"></a><strong>3.触发器的作用？</strong></h4><blockquote><p>触发器是一种特殊的存储过程，主要是通过事件来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。可以联级运算。如，某表上的触发器上包含对另一个表的数据操作，而该操作又会导致该表触发器被触发。</p></blockquote><h4 id="4-什么是存储过程？用什么来调用？"><a href="#4-什么是存储过程？用什么来调用？" class="headerlink" title="4.什么是存储过程？用什么来调用？"></a><strong>4.什么是存储过程？用什么来调用？</strong></h4><blockquote><p>存储过程是一个预编译的SQL语句，优点是允许模块化的设计，就是说只需创建一次，以后在该程序中就可以调用多次。如果某次操作需要执行多次SQL，使用存储过程比单纯SQL语句执行要快。</p><p><strong>调用：</strong></p><p>1）可以用一个命令对象来调用存储过程。</p><p>2）可以供外部程序调用，比如：java程序。</p></blockquote><h4 id="5-存储过程的优缺点？"><a href="#5-存储过程的优缺点？" class="headerlink" title="5.存储过程的优缺点？"></a><strong>5.存储过程的优缺点？</strong></h4><blockquote><p><strong>优点：</strong></p><p>1）存储过程是预编译过的，执行效率高。</p><p>2）存储过程的代码直接存放于数据库中，通过存储过程名直接调用，减少网络通讯。</p><p>3）安全性高，执行存储过程需要有一定权限的用户。</p><p>4）存储过程可以重复使用，可减少数据库开发人员的工作量。</p><p><strong>缺点：</strong>移植性差</p></blockquote><h4 id="6-存储过程与函数的区别"><a href="#6-存储过程与函数的区别" class="headerlink" title="6.存储过程与函数的区别"></a><strong>6.存储过程与函数的区别</strong></h4><p><img src="https://www.cmdbyte.com/2021/02/ymE9HPJ.png" alt="ymE9HPJ"></p><h4 id="7-什么叫视图？游标是什么？"><a href="#7-什么叫视图？游标是什么？" class="headerlink" title="7.什么叫视图？游标是什么？"></a><strong>7.什么叫视图？游标是什么？</strong></h4><blockquote><p><strong>视图：</strong></p><p>是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改会影响基本表。它使得我们获取数据更容易，相比多表查询。</p><p><strong>游标：</strong></p><p>是对查询出来的结果集作为一个单元来有效的处理。游标可以定在该单元中的特定行，从结果集的当前行检索一行或多行。可以对结果集当前行做修改。一般不使用游标，但是需要逐条处理数据的时候，游标显得十分重要。</p></blockquote><h4 id="8-视图的优缺点"><a href="#8-视图的优缺点" class="headerlink" title="8.视图的优缺点"></a><strong>8.视图的优缺点</strong></h4><blockquote><p><strong>优点：</strong></p><p>1对数据库的访问，因为视图可以有选择性的选取数据库里的一部分。</p><p>2)用户通过简单的查询可以从复杂查询中得到结果。</p><p>3)维护数据的独立性，试图可从多个表检索数据。</p><p>4)对于相同的数据可产生不同的视图。</p><p><strong>缺点：</strong></p><p>性能：查询视图时，必须把视图的查询转化成对基本表的查询，如果这个视图是由一个复杂的多表查询所定义，那么，那么就无法更改数据</p></blockquote><h4 id="9-drop、truncate、-delete区别"><a href="#9-drop、truncate、-delete区别" class="headerlink" title="9.drop、truncate、 delete区别"></a><strong>9.drop、truncate、 delete区别</strong></h4><blockquote><p><strong>最基本：</strong></p><ul><li>drop直接删掉表。</li><li>truncate删除表中数据，再插入时自增长id又从1开始。</li><li>delete删除表中数据，可以加where字句。</li></ul><p>（1） DELETE语句执行删除的过程是每次从表中删除一行，并且同时将该行的删除操作作为事务记录在日志中保存以便进行进行回滚操作。TRUNCATE TABLE 则一次性地从表中删除所有的数据并不把单独的删除操作记录记入日志保存，删除行是不能恢复的。并且在删除的过程中不会激活与表有关的删除触发器。执行速度快。</p><p>（2） 表和索引所占空间。当表被TRUNCATE 后，这个表和索引所占用的空间会恢复到初始大小，而DELETE操作不会减少表或索引所占用的空间。drop语句将表所占用的空间全释放掉。</p><p>（3） 一般而言，drop &gt; truncate &gt; delete</p><p>（4） 应用范围。TRUNCATE 只能对TABLE；DELETE可以是table和view</p><p>（5） TRUNCATE 和DELETE只删除数据，而DROP则删除整个表（结构和数据）。</p><p>（6） truncate与不带where的delete ：只删除数据，而不删除表的结构（定义）drop语句将删除表的结构被依赖的约束（constrain),触发器（trigger)索引（index);依赖于该表的存储过程&#x2F;函数将被保留，但其状态会变为：invalid。</p><p>（7） delete语句为DML（data maintain Language),这个操作会被放到 rollback segment中,事务提交后才生效。如果有相应的 tigger,执行的时候将被触发。</p><p>（8） truncate、drop是DLL（data define language),操作立即生效，原数据不放到 rollback segment中，不能回滚。</p><p>（9） 在没有备份情况下，谨慎使用 drop 与 truncate。要删除部分数据行采用delete且注意结合where来约束影响范围。回滚段要足够大。要删除表用drop;若想保留表而将表中数据删除，如果于事务无关，用truncate即可实现。如果和事务有关，或老师想触发trigger,还是用delete。</p><p>（10） Truncate table 表名 速度快,而且效率高,因为:?truncate table 在功能上与不带 WHERE 子句的 DELETE 语句相同：二者均删除表中的全部行。但 TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少。DELETE 语句每次删除一行，并在事务日志中为所删除的每行记录一项。TRUNCATE TABLE 通过释放存储表数据所用的数据页来删除数据，并且只在事务日志中记录页的释放。</p><p>（11） TRUNCATE TABLE 删除表中的所有行，但表结构及其列、约束、索引等保持不变。新行标识所用的计数值重置为该列的种子。如果想保留标识计数值，请改用 DELETE。如果要删除表定义及其数据，请使用 DROP TABLE 语句。</p><p>（12） 对于由 FOREIGN KEY 约束引用的表，不能使用 TRUNCATE TABLE，而应使用不带 WHERE 子句的 DELETE 语句。由于 TRUNCATE TABLE 不记录在日志中，所以它不能激活触发器。</p></blockquote><h4 id="10-什么是临时表，临时表什么时候删除"><a href="#10-什么是临时表，临时表什么时候删除" class="headerlink" title="10.什么是临时表，临时表什么时候删除?"></a><strong>10.什么是临时表，临时表什么时候删除?</strong></h4><blockquote><p><strong>临时表可以手动删除：</strong><br>DROP TEMPORARY TABLE IF EXISTS temp_tb;</p><p><strong>临时表只在当前连接可见，当关闭连接时，MySQL会自动删除表并释放所有空间。因此在不同的连接中可以创建同名的临时表，并且操作属于本连接的临时表。<br>创建临时表的语法与创建表语法类似，不同之处是增加关键字TEMPORARY，</strong></p><p>如：</p><p>CREATE TEMPORARY TABLE tmp_table (</p><p>NAME VARCHAR (10) NOT NULL,</p><p>time date NOT NULL<br>);</p><p>select * from tmp_table;</p></blockquote><h4 id="11-非关系型数据库和关系型数据库区别，优势比较"><a href="#11-非关系型数据库和关系型数据库区别，优势比较" class="headerlink" title="11.非关系型数据库和关系型数据库区别，优势比较?"></a><strong>11.非关系型数据库和关系型数据库区别，优势比较?</strong></h4><blockquote><p><strong>非关系型数据库的优势：</strong></p><ul><li><strong>性能：</strong>NOSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以性能非常高。</li><li><strong>可扩展性：</strong>同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。</li></ul><p><strong>关系型数据库的优势：</strong></p><ul><li><strong>复杂查询：</strong>可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询。</li><li><strong>事务支持：</strong>使得对于安全性能很高的数据访问要求得以实现。</li></ul><p><strong>其他：</strong></p><p>**1.**对于这两类数据库，对方的优势就是自己的弱势，反之亦然。</p><p>**2.**NOSQL数据库慢慢开始具备SQL数据库的一些复杂查询功能，比如MongoDB。</p><p>**3.**对于事务的支持也可以用一些系统级的原子操作来实现例如乐观锁之类的方法来曲线救国，比如Redis set nx。</p></blockquote><h4 id="12-数据库范式，根据某个场景设计数据表"><a href="#12-数据库范式，根据某个场景设计数据表" class="headerlink" title="12.数据库范式，根据某个场景设计数据表?"></a><strong>12.数据库范式，根据某个场景设计数据表?</strong></h4><blockquote><p><strong>第一范式:</strong>(确保每列保持原子性)所有字段值都是不可分解的原子值。</p><p>第一范式是最基本的范式。如果数据库表中的所有字段值都是不可分解的原子值，就说明该数据库表满足了第一范式。<br>第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式，如下表所示。<br>上表所示的用户信息遵循了第一范式的要求，这样在对用户使用城市进行分类的时候就非常方便，也提高了数据库的性能。</p><p><strong>第二范式:</strong>(确保表中的每列都和主键相关)在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。</p><p>第二范式在第一范式的基础之上更进一层。第二范式需要确保数据库表中的每一列都和主键相关，而不能只与主键的某一部分相关（主要针对联合主键而言）。也就是说在一个数据库表中，一个表中只能保存一种数据，不可以把多种数据保存在同一张数据库表中。<br>比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键。</p><p><strong>第三范式:</strong>(确保每列都和主键列直接相关,而不是间接相关) 数据表中的每一列数据都和主键直接相关，而不能间接相关。</p><p>第三范式需要确保数据表中的每一列数据都和主键直接相关，而不能间接相关。<br>比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。</p><p>**BCNF:**符合3NF，并且，主属性不依赖于主属性。</p><p>若关系模式属于第二范式，且每个属性都不传递依赖于键码，则R属于BC范式。<br>通常BC范式的条件有多种等价的表述：每个非平凡依赖的左边必须包含键码；每个决定因素必须包含键码。<br>BC范式既检查非主属性，又检查主属性。当只检查非主属性时，就成了第三范式。满足BC范式的关系都必然满足第三范式。<br>还可以这么说：若一个关系达到了第三范式，并且它只有一个候选码，或者它的每个候选码都是单属性，则该关系自然达到BC范式。<br>一般，一个数据库设计符合3NF或BCNF就可以了。</p><p>**第四范式:**要求把同一表内的多对多关系删除。</p><p>**第五范式:**从最终结构重新建立原始结构。</p></blockquote><h4 id="13-什么是-内连接、外连接、交叉连接、笛卡尔积等"><a href="#13-什么是-内连接、外连接、交叉连接、笛卡尔积等" class="headerlink" title="13.什么是 内连接、外连接、交叉连接、笛卡尔积等?"></a><strong>13.什么是 内连接、外连接、交叉连接、笛卡尔积等?</strong></h4><blockquote><p><strong>内连接:</strong> 只连接匹配的行</p><p><strong>左外连接:</strong> 包含左边表的全部行（不管右边的表中是否存在与它们匹配的行），以及右边表中全部匹配的行</p><p><strong>右外连接:</strong> 包含右边表的全部行（不管左边的表中是否存在与它们匹配的行），以及左边表中全部匹配的行</p><p>例如1：<br>SELECT a.<em>,b.</em> FROM luntan LEFT JOIN usertable as b ON a.username&#x3D;b.username</p><p>例如2：<br>SELECT a.<em>,b.</em> FROM city as a FULL OUTER JOIN user as b ON a.username&#x3D;b.username</p><p><strong>全外连接:</strong> 包含左、右两个表的全部行，不管另外一边的表中是否存在与它们匹配的行。</p><p><strong>交叉连接:</strong> 生成笛卡尔积－它不使用任何匹配或者选取条件，而是直接将一个数据源中的每个行与另一个数据源的每个行都一一匹配</p><p>例如：<br>SELECT type,pub_name FROM titles CROSS JOIN publishers ORDER BY type</p><p><strong>注意：</strong></p><p>很多公司都只是考察是否知道其概念，但是也有很多公司需要不仅仅知道概念，还需要动手写sql,一般都是简单的连接查询，具体关于连接查询的sql练习，参见以下链接：</p><p><a href="https://www.nowcoder.com/ta/sql">牛客网数据库SQL实战</a></p><p><a href="https://leetcode-cn.com/problemset/database/">leetcode中文网站数据库练习</a></p></blockquote><h4 id="14-varchar和char的使用场景"><a href="#14-varchar和char的使用场景" class="headerlink" title="14.varchar和char的使用场景?"></a><strong>14.varchar和char的使用场景?</strong></h4><blockquote></blockquote><blockquote><p>**1.**char的长度是不可变的，而varchar的长度是可变的。</p><p>定义一个char[10]和varchar[10]。<br>如果存进去的是‘csdn’,那么char所占的长度依然为10，除了字符‘csdn’外，后面跟六个空格，varchar就立马把长度变为4了，取数据的时候，char类型的要用trim()去掉多余的空格，而varchar是不需要的。</p><p>**2.**char的存取数度还是要比varchar要快得多，因为其长度固定，方便程序的存储与查找。<br>char也为此付出的是空间的代价，因为其长度固定，所以难免会有多余的空格占位符占据空间，可谓是以空间换取时间效率。<br>varchar是以空间效率为首位。</p><p>**3.**char的存储方式是：对英文字符（ASCII）占用1个字节，对一个汉字占用两个字节。<br>varchar的存储方式是：对每个英文字符占用2个字节，汉字也占用2个字节。</p><p>**4.**两者的存储数据都非unicode的字符数据。</p></blockquote><h4 id="15-SQL语言分类"><a href="#15-SQL语言分类" class="headerlink" title="15.SQL语言分类"></a><strong>15.SQL语言分类</strong></h4><blockquote><p><strong>SQL语言共分为四大类：</strong></p><ul><li>数据查询语言DQL</li><li>数据操纵语言DML</li><li>数据定义语言DDL</li><li>数据控制语言DCL。</li></ul><p><strong>1. 数据查询语言DQL</strong></p><p>数据查询语言DQL基本结构是由SELECT子句，FROM子句，WHERE子句组成的查询块：</p><p>SELECT<br>FROM<br>WHERE</p><p><strong>2 .数据操纵语言DML</strong></p><p>数据操纵语言DML主要有三种形式：</p><ol><li>插入：INSERT</li><li>更新：UPDATE</li><li>删除：DELETE</li></ol><p><strong>3. 数据定义语言DDL</strong></p><p>数据定义语言DDL用来创建数据库中的各种对象—–表、视图、索引、同义词、聚簇等如：<br>CREATE TABLE&#x2F;VIEW&#x2F;INDEX&#x2F;SYN&#x2F;CLUSTER</p><p>表 视图 索引 同义词 簇</p><p>DDL操作是隐性提交的！不能rollback</p><p><strong>4. 数据控制语言DCL</strong></p><p>数据控制语言DCL用来授予或回收访问数据库的某种特权，并控制数据库操纵事务发生的时间及效果，对数据库实行监视等。如：</p><ol><li>GRANT：授权。</li><li>ROLLBACK [WORK] TO [SAVEPOINT]：回退到某一点。回滚—ROLLBACK；回滚命令使数据库状态回到上次最后提交的状态。其格式为：<br> SQL&gt;ROLLBACK;</li><li>COMMIT [WORK]：提交。</li></ol><p>在数据库的插入、删除和修改操作时，只有当事务在提交到数据<br>库时才算完成。在事务提交前，只有操作数据库的这个人才能有权看<br>到所做的事情，别人只有在最后提交完成后才可以看到。<br>提交数据有三种类型：显式提交、隐式提交及自动提交。下面分<br>别说明这三种类型。</p><p>(1) 显式提交<br>用COMMIT命令直接完成的提交为显式提交。其格式为：<br>SQL&gt;COMMIT；</p><p>(2) 隐式提交<br>用SQL命令间接完成的提交为隐式提交。这些命令是：<br>ALTER，AUDIT，COMMENT，CONNECT，CREATE，DISCONNECT，DROP，<br>EXIT，GRANT，NOAUDIT，QUIT，REVOKE，RENAME。</p><p>(3) 自动提交<br>若把AUTOCOMMIT设置为ON，则在插入、修改、删除语句执行后，<br>系统将自动进行提交，这就是自动提交。其格式为：<br>SQL&gt;SET AUTOCOMMIT ON；</p><p>参考文章：<br><a href="https://www.cnblogs.com/study-s/p/5287529.html">https://www.cnblogs.com/study-s/p/5287529.html</a></p></blockquote><h4 id="16-like-和-的区别"><a href="#16-like-和-的区别" class="headerlink" title="16.like %和-的区别"></a><strong>16.like %和-的区别</strong></h4><blockquote><p><strong>通配符的分类:</strong></p><p>**%百分号通配符:**表示任何字符出现任意次数(可以是0次).</p><p>**_下划线通配符:**表示只能匹配单个字符,不能多也不能少,就是一个字符.</p><p><strong>like操作符:</strong> LIKE作用是指示mysql后面的搜索模式是利用通配符而不是直接相等匹配进行比较.</p><p><strong>注意:</strong> 如果在使用like操作符时,后面的没有使用通用匹配符效果是和&#x3D;一致的,SELECT * FROM products WHERE products.prod_name like ‘1000’;<br>只能匹配的结果为1000,而不能匹配像JetPack 1000这样的结果.</p><ul><li>%通配符使用: 匹配以”yves”开头的记录:(包括记录”yves”) SELECT <em>FROM products WHERE products.prod_name like ‘yves%’;<br>  匹配包含”yves”的记录(包括记录”yves”) SELECT</em> FROM products WHERE products.prod_name like ‘%yves%’;<br>  匹配以”yves”结尾的记录(包括记录”yves”,不包括记录”yves “,也就是yves后面有空格的记录,这里需要注意) SELECT * FROM products WHERE products.prod_name like ‘%yves’;</li><li><em>通配符使用: SELECT *FROM products WHERE products.prod_name like ‘_yves’; 匹配结果为: 像”yyves”这样记录.<br>  SELECT* FROM products WHERE products.prod*name like ‘yves</em>*’; 匹配结果为: 像”yvesHe”这样的记录.(一个下划线只能匹配一个字符,不能多也不能少)</li></ul><p><strong>注意事项:</strong></p><ul><li>注意大小写,在使用模糊匹配时,也就是匹配文本时,mysql是可能区分大小的,也可能是不区分大小写的,这个结果是取决于用户对MySQL的配置方式.如果是区分大小写,那么像YvesHe这样记录是不能被”yves__”这样的匹配条件匹配的.</li><li>注意尾部空格,”%yves”是不能匹配”heyves “这样的记录的.</li><li>注意NULL,%通配符可以匹配任意字符,但是不能匹配NULL,也就是说SELECT * FROM products WHERE products.prod_name like ‘%;是匹配不到products.prod_name为NULL的的记录.</li></ul><p><strong>技巧与建议:</strong></p><p>正如所见， MySQL的通配符很有用。但这种功能是有代价的：通配符搜索的处理一般要比前面讨论的其他搜索所花时间更长。这里给出一些使用通配符要记住的技巧。</p><ul><li>不要过度使用通配符。如果其他操作符能达到相同的目的，应该 使用其他操作符。</li><li>在确实需要使用通配符时，除非绝对有必要，否则不要把它们用 在搜索模式的开始处。把通配符置于搜索模式的开始处，搜索起 来是最慢的。</li><li>仔细注意通配符的位置。如果放错地方，可能不会返回想要的数.</li></ul></blockquote><p>参考博文：<a href="https://blog.csdn.net/u011479200/article/details/78513632">https://blog.csdn.net/u011479200/article/details/78513632</a></p><h4 id="17-count-、count-1-、count-column-的区别"><a href="#17-count-、count-1-、count-column-的区别" class="headerlink" title="17.count(*)、count(1)、count(column)的区别"></a><strong>17.count(*)、count(1)、count(column)的区别</strong></h4><blockquote><ul><li>count(*)对行的数目进行计算,包含NULL</li><li>count(column)对特定的列的值具有的行数进行计算,不包含NULL值。</li><li>count()还有一种使用方式,count(1)这个用法和count(*)的结果是一样的。</li></ul><p><strong>性能问题:</strong></p><p>1.任何情况下SELECT COUNT(*) FROM tablename是最优选择;</p><p>2.尽量减少SELECT COUNT(*) FROM tablename WHERE COL &#x3D; ‘value’ 这种查询;</p><p>3.杜绝SELECT COUNT(COL) FROM tablename WHERE COL2 &#x3D; ‘value’ 的出现。</p><ul><li>如果表没有主键,那么count(1)比count(*)快。</li><li>如果有主键,那么count(主键,联合主键)比count(*)快。</li><li>如果表只有一个字段,count(*)最快。</li></ul><p>count(1)跟count(主键)一样,只扫描主键。count(*)跟count(非主键)一样,扫描整个表。明显前者更快一些。</p></blockquote><h4 id="18-最左前缀原则"><a href="#18-最左前缀原则" class="headerlink" title="18.最左前缀原则"></a><strong>18.最左前缀原则</strong></h4><blockquote><p><strong>多列索引：</strong></p><p>ALTER TABLE people ADD INDEX lname_fname_age (lame,fname,age);</p><p>为了提高搜索效率，我们需要考虑运用多列索引,由于索引文件以B－Tree格式保存，所以我们不用扫描任何记录，即可得到最终结果。</p><p>注：在mysql中执行查询时，只能使用一个索引，如果我们在lname,fname,age上分别建索引,执行查询时，只能使用一个索引，mysql会选择一个最严格(获得结果集记录数最少)的索引。</p><p><strong>最左前缀原则：</strong>顾名思义，就是最左优先，上例中我们创建了lname_fname_age多列索引,相当于创建了(lname)单列索引，(lname,fname)组合索引以及(lname,fname,age)组合索引。</p></blockquote><h2 id="二、索引"><a href="#二、索引" class="headerlink" title="二、索引"></a>二、索引</h2><h4 id="1-什么是索引？"><a href="#1-什么是索引？" class="headerlink" title="1.什么是索引？"></a><strong>1.什么是索引？</strong></h4><blockquote><p><strong>何为索引：</strong></p><p>数据库索引，是数据库管理系统中一个排序的数据结构，索引的实现通常使用B树及其变种B+树。</p><p>在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法。这种数据结构，就是索引。</p></blockquote><h4 id="2-索引的作用？它的优点缺点是什么？"><a href="#2-索引的作用？它的优点缺点是什么？" class="headerlink" title="2.索引的作用？它的优点缺点是什么？"></a><strong>2.索引的作用？它的优点缺点是什么？</strong></h4><blockquote><p><strong>索引作用：</strong></p><p>协助快速查询、更新数据库表中数据。</p><p>为表设置索引要付出代价的：</p><ul><li><p>一是增加了数据库的存储空间</p></li><li><p>二是在插入和修改数据时要花费较多的时间(因为索引也要随之变动)。</p><h4 id="3-索引的优缺点？"><a href="#3-索引的优缺点？" class="headerlink" title="3.索引的优缺点？"></a><strong>3.索引的优缺点？</strong></h4></li></ul><p><strong>创建索引可以大大提高系统的性能（优点）：</strong></p><p>1.通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</p><p>2.可以大大加快数据的检索速度，这也是创建索引的最主要的原因。</p><p>3.可以加速表和表之间的连接，特别是在实现数据的参考完整性方面特别有意义。</p><p>4.在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间。</p><p>5.通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能。</p><p><strong>增加索引也有许多不利的方面(缺点)：</strong></p><p>1.创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</p><p>2.索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</p><p>3.当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</p></blockquote><h4 id="4-哪些列适合建立索引、哪些不适合建索引？"><a href="#4-哪些列适合建立索引、哪些不适合建索引？" class="headerlink" title="4.哪些列适合建立索引、哪些不适合建索引？"></a><strong>4.哪些列适合建立索引、哪些不适合建索引？</strong></h4><blockquote><p>索引是建立在数据库表中的某些列的上面。在创建索引的时候，应该考虑在哪些列上可以创建索引，在哪些列上不能创建索引。</p><p><strong>一般来说，应该在这些列上创建索引：</strong></p><p>（1）在经常需要搜索的列上，可以加快搜索的速度；</p><p>（2）在作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；</p><p>（3）在经常用在连接的列上，这些列主要是一些外键，可以加快连接的速度；</p><p>（4）在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的；</p><p>（5）在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间；</p><p>（6）在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。</p><p><strong>对于有些列不应该创建索引：</strong></p><p>（1）对于那些在查询中很少使用或者参考的列不应该创建索引。</p><p>这是因为，既然这些列很少使用到，因此有索引或者无索引，并不能提高查询速度。相反，由于增加了索引，反而降低了系统的维护速度和增大了空间需求。</p><p>（2）对于那些只有很少数据值的列也不应该增加索引。</p><p>这是因为，由于这些列的取值很少，例如人事表的性别列，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。</p><p>（3）对于那些定义为text, image和bit数据类型的列不应该增加索引。</p><p>这是因为，这些列的数据量要么相当大，要么取值很少。</p><p>(4)当修改性能远远大于检索性能时，不应该创建索引。</p><p>这是因为，修改性能和检索性能是互相矛盾的。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。因此，当修改性能远远大于检索性能时，不应该创建索引。</p></blockquote><h4 id="5-什么样的字段适合建索引"><a href="#5-什么样的字段适合建索引" class="headerlink" title="5.什么样的字段适合建索引"></a><strong>5.什么样的字段适合建索引</strong></h4><blockquote><p>唯一、不为空、经常被查询的字段</p><h4 id="6-MySQL-B-Tree索引和Hash索引的区别"><a href="#6-MySQL-B-Tree索引和Hash索引的区别" class="headerlink" title="6.MySQL B+Tree索引和Hash索引的区别?"></a><strong>6.MySQL B+Tree索引和Hash索引的区别?</strong></h4><p><strong>Hash索引和B+树索引的特点：</strong></p><ul><li>Hash索引结构的特殊性，其检索效率非常高，索引的检索可以一次定位;</li><li>B+树索引需要从根节点到枝节点，最后才能访问到页节点这样多次的IO访问;</li></ul><p><strong>为什么不都用Hash索引而使用B+树索引？</strong></p><ol><li>Hash索引仅仅能满足”&#x3D;”,”IN”和””查询，不能使用范围查询,因为经过相应的Hash算法处理之后的Hash值的大小关系，并不能保证和Hash运算前完全一样；</li><li>Hash索引无法被用来避免数据的排序操作，因为Hash值的大小关系并不一定和Hash运算前的键值完全一样；</li><li>Hash索引不能利用部分索引键查询，对于组合索引，Hash索引在计算Hash值的时候是组合索引键合并后再一起计算Hash值，而不是单独计算Hash值，所以通过组合索引的前面一个或几个索引键进行查询的时候，Hash索引也无法被利用；</li><li>Hash索引在任何时候都不能避免表扫描，由于不同索引键存在相同Hash值，所以即使取满足某个Hash键值的数据的记录条数，也无法从Hash索引中直接完成查询，还是要回表查询数据；</li><li>Hash索引遇到大量Hash值相等的情况后性能并不一定就会比B+树索引高。</li></ol><p><strong>补充：</strong></p><p>1.MySQL中，只有HEAP&#x2F;MEMORY引擎才显示支持Hash索引。</p><p>2.常用的InnoDB引擎中默认使用的是B+树索引，它会实时监控表上索引的使用情况，如果认为建立哈希索引可以提高查询效率，则自动在内存中的“自适应哈希索引缓冲区”建立哈希索引（在InnoDB中默认开启自适应哈希索引），通过观察搜索模式，MySQL会利用index key的前缀建立哈希索引，如果一个表几乎大部分都在缓冲池中，那么建立一个哈希索引能够加快等值查询。<br>B+树索引和哈希索引的明显区别是：</p><p>3.如果是等值查询，那么哈希索引明显有绝对优势，因为只需要经过一次算法即可找到相应的键值；当然了，这个前提是，键值都是唯一的。如果键值不是唯一的，就需要先找到该键所在位置，然后再根据链表往后扫描，直到找到相应的数据；</p><p>4.如果是范围查询检索，这时候哈希索引就毫无用武之地了，因为原先是有序的键值，经过哈希算法后，有可能变成不连续的了，就没办法再利用索引完成范围查询检索；<br>同理，哈希索引没办法利用索引完成排序，以及like ‘xxx%’ 这样的部分模糊查询（这种部分模糊查询，其实本质上也是范围查询）；</p><p>5.哈希索引也不支持多列联合索引的最左匹配规则；</p><p>6.B+树索引的关键字检索效率比较平均，不像B树那样波动幅度大，在有大量重复键值情况下，哈希索引的效率也是极低的，因为存在所谓的哈希碰撞问题。</p><p>7.在大多数场景下，都会有范围查询、排序、分组等查询特征，用B+树索引就可以了。</p></blockquote><h4 id="7-B树和B-树的区别"><a href="#7-B树和B-树的区别" class="headerlink" title="7.B树和B+树的区别"></a><strong>7.B树和B+树的区别</strong></h4><blockquote><ol><li>B树，每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为nul，叶子结点不包含任何关键字信息。<br> <img src="https://www.cmdbyte.com/2021/02/RbzI0R8.jpg" alt="RbzI0R8"></li><li>B+树，所有的叶子结点中包含了全部关键字的信息，及指向含有这些关键字记录的指针，且叶子结点本身依关键字的大小自小而大的顺序链接，所有的非终端结点可以看成是索引部分，结点中仅含有其子树根结点中最大（或最小）关键字。 (而B 树的非终节点也包含需要查找的有效信息)<br> <img src="https://www.cmdbyte.com/2021/02/9VbnDME.jpg" alt="9VbnDME"></li></ol></blockquote><h4 id="8-为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？"><a href="#8-为什么说B-比B树更适合实际应用中操作系统的文件索引和数据库索引？" class="headerlink" title="8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？"></a><strong>8.为什么说B+比B树更适合实际应用中操作系统的文件索引和数据库索引？</strong></h4><blockquote><p><strong>1.B+的磁盘读写代价更低</strong></p><p>B+的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。</p><p><strong>2.B+tree的查询效率更加稳定</strong></p><p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p></blockquote><h4 id="9-聚集索引和非聚集索引区别"><a href="#9-聚集索引和非聚集索引区别" class="headerlink" title="9.聚集索引和非聚集索引区别?"></a><strong>9.聚集索引和非聚集索引区别?</strong></h4><blockquote><p><strong>聚合索引(clustered index):</strong></p><p>聚集索引<strong>表记录的排列顺序和索引的排列顺序一致，所以查询效率快，</strong>只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。<br>聚集索引类似于新华字典中用拼音去查找汉字，拼音检索表于书记顺序都是按照a~z排列的，就像相同的逻辑顺序于物理顺序一样，当你需要查找a,ai两个读音的字，或是想一次寻找多个傻(sha)的同音字时，也许向后翻几页，或紧接着下一行就得到结果了。</p><p><strong>非聚合索引(nonclustered index):</strong></p><p>非聚集索引<strong>指定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，</strong>两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。<br>非聚集索引类似在新华字典上通过偏旁部首来查询汉字，检索表也许是按照横、竖、撇来排列的，但是由于正文中是a~z的拼音顺序，所以就类似于逻辑地址于物理地址的不对应。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。</p><p><strong>根本区别：</strong></p><p>聚集索引和非聚集索引的根本区别是表记录的排列顺序和与索引的排列顺序是否一致。</p></blockquote><h2 id="三、事务"><a href="#三、事务" class="headerlink" title="三、事务"></a>三、事务</h2><h4 id="1-什么是事务？"><a href="#1-什么是事务？" class="headerlink" title="1.什么是事务？"></a><strong>1.什么是事务？</strong></h4><blockquote><p>事务是对数据库中一系列操作进行统一的回滚或者提交的操作，主要用来保证数据的完整性和一致性。</p></blockquote><h4 id="2-事务四大特性（ACID）原子性、一致性、隔离性、持久性"><a href="#2-事务四大特性（ACID）原子性、一致性、隔离性、持久性" class="headerlink" title="2.事务四大特性（ACID）原子性、一致性、隔离性、持久性?"></a><strong>2.事务四大特性（ACID）原子性、一致性、隔离性、持久性?</strong></h4><blockquote><p><strong>原子性（Atomicity）:</strong><br>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p><p><strong>一致性（Consistency）:</strong><br>事务开始前和结束后，数据库的完整性约束没有被破坏。比如A向B转账，不可能A扣了钱，B却没收到。</p><p><strong>隔离性（Isolation）:</strong><br>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。</p><p><strong>持久性（Durability）:</strong><br>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p></blockquote><h4 id="3-事务的并发-事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别"><a href="#3-事务的并发-事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别" class="headerlink" title="3.事务的并发?事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别?"></a><strong>3.事务的并发?事务隔离级别，每个级别会引发什么问题，MySQL默认是哪个级别?</strong></h4><blockquote><p>从理论上来说, 事务应该彼此完全隔离, 以避免并发事务所导致的问题，然而, 那样会对性能产生极大的影响, 因为事务必须按顺序运行， 在实际开发中, 为了提升性能, 事务会以较低的隔离级别运行， 事务的隔离级别可以通过隔离事务属性指定。<br><strong>事务的并发问题</strong></p><p><strong>1、脏读：</strong>事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据</p><p><strong>2、不可重复读：</strong>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p><p><strong>3、幻读：</strong>幻读解决了不重复读，保证了同一个事务里，查询的结果都是事务开始时的状态（一致性）。</p><p>例如：事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作 这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。 而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有跟没有修改一样，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。<br><strong>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表。</strong></p><p><strong>事务的隔离级别</strong></p><p><img src="https://www.cmdbyte.com/2021/02/xAeWTSp.png" alt="xAeWTSp"></p><p><strong>读未提交：</strong>另一个事务修改了数据，但尚未提交，而本事务中的SELECT会读到这些未被提交的数据脏读</p><p><strong>不可重复读：</strong>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果因此本事务先后两次读到的数据结果会不一致。</p><p><strong>可重复读：</strong>在同一个事务里，SELECT的结果是事务开始时时间点的状态，因此，同样的SELECT操作读到的结果会是一致的。但是，会有幻读现象</p><p><strong>串行化：</strong>最高的隔离级别，在这个隔离级别下，不会产生任何异常。并发的事务，就像事务是在一个个按照顺序执行一样</p></blockquote><p><strong>特别注意：</strong></p><blockquote><p>MySQL默认的事务隔离级别为repeatable-read</p><p>MySQL 支持 4 中事务隔离级别.</p><p>事务的隔离级别要得到底层数据库引擎的支持, 而不是应用程序或者框架的支持.</p><p>Oracle 支持的 2 种事务隔离级别：READ_COMMITED , SERIALIZABLE</p><p>SQL规范所规定的标准，不同的数据库具体的实现可能会有些差异</p><p><strong>MySQL中默认事务隔离级别是“可重复读”时并不会锁住读取到的行</strong></p><p><strong>事务隔离级别：</strong>未提交读时，写数据只会锁住相应的行。</p><p><strong>事务隔离级别为：</strong>可重复读时，写数据会锁住整张表。</p><p><strong>事务隔离级别为：</strong>串行化时，读写数据都会锁住整张表。</p><p>隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。</p></blockquote><h4 id="4-事务传播行为"><a href="#4-事务传播行为" class="headerlink" title="4.事务传播行为"></a><strong>4.事务传播行为</strong></h4><blockquote><p><strong>1.PROPAGATION_REQUIRED：</strong>如果当前没有事务，就创建一个新事务，如果当前存在事务，就加入该事务，该设置是最常用的设置。</p><p><strong>2.PROPAGATION_SUPPORTS：</strong>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就以非事务执行。</p><p><strong>3.PROPAGATION_MANDATORY：</strong>支持当前事务，如果当前存在事务，就加入该事务，如果当前不存在事务，就抛出异常。</p><p><strong>4.PROPAGATION_REQUIRES_NEW：</strong>创建新事务，无论当前存不存在事务，都创建新事务。</p><p><strong>5.PROPAGATION_NOT_SUPPORTED：</strong>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</p><p><strong>6.PROPAGATION_NEVER：</strong>以非事务方式执行，如果当前存在事务，则抛出异常。</p><p><strong>7.PROPAGATION_NESTED：</strong>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</p></blockquote><h4 id="5-嵌套事务"><a href="#5-嵌套事务" class="headerlink" title="5.嵌套事务"></a><strong>5.嵌套事务</strong></h4><blockquote><p><strong>什么是嵌套事务？</strong></p><p>嵌套是子事务套在父事务中执行，子事务是父事务的一部分，在进入子事务之前，父事务建立一个回滚点，叫save point，然后执行子事务，这个子事务的执行也算是父事务的一部分，然后子事务执行结束，父事务继续执行。重点就在于那个save point。看几个问题就明了了：</p><p><strong>如果子事务回滚，会发生什么？</strong></p><p>父事务会回滚到进入子事务前建立的save point，然后尝试其他的事务或者其他的业务逻辑，父事务之前的操作不会受到影响，更不会自动回滚。</p><p><strong>如果父事务回滚，会发生什么？</strong></p><p>父事务回滚，子事务也会跟着回滚！为什么呢，因为父事务结束之前，子事务是不会提交的，我们说子事务是父事务的一部分，正是这个道理。那么：</p><p><strong>事务的提交，是什么情况？</strong></p><p>是父事务先提交，然后子事务提交，还是子事务先提交，父事务再提交？答案是第二种情况，还是那句话，子事务是父事务的一部分，由父事务统一提交。</p></blockquote><p>参考文章：<a href="https://blog.csdn.net/liangxw1/article/details/51197560">https://blog.csdn.net/liangxw1/article/details/51197560</a></p><h2 id="四、存储引擎"><a href="#四、存储引擎" class="headerlink" title="四、存储引擎"></a>四、存储引擎</h2><h4 id="1-MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别"><a href="#1-MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别" class="headerlink" title="1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别?"></a><strong>1.MySQL常见的三种存储引擎（InnoDB、MyISAM、MEMORY）的区别?</strong></h4><blockquote><p><strong>两种存储引擎的大致区别表现在：</strong></p><p>1.<strong>InnoDB支持事务，MyISAM不支持，</strong> <strong>这一点是非常之重要。</strong>事务是一种高级的处理方式，如在一些列增删改中只要哪个出错还可以回滚还原，而MyISAM就不可以了。</p><p>2.MyISAM适合查询以及插入为主的应用。</p><p>3.InnoDB适合频繁修改以及涉及到安全性较高的应用。</p><p>4.InnoDB支持外键，MyISAM不支持。</p><p>5.从MySQL5.5.5以后，InnoDB是默认引擎。</p><p>6.InnoDB不支持FULLTEXT类型的索引。</p><p>7.InnoDB中不保存表的行数，如select count(<em>) from table时，InnoDB需要扫描一遍整个表来计算有多少行，但是MyISAM只要简单的读出保存好的行数即可。注意的是，当count(</em>)语句包含where条件时MyISAM也需要扫描整个表。</p><p>8.对于自增长的字段，InnoDB中必须包含只有该字段的索引，但是在MyISAM表中可以和其他字段一起建立联合索引。</p><p>9.DELETE FROM table时，InnoDB不会重新建立表，而是一行一行的 删除，效率非常慢。MyISAM则会重建表。</p><p>10.InnoDB支持行锁（某些情况下还是锁整表，如 update table set a&#x3D;1 where user like ‘%lee%’。</p></blockquote><h4 id="2-MySQL存储引擎MyISAM与InnoDB如何选择"><a href="#2-MySQL存储引擎MyISAM与InnoDB如何选择" class="headerlink" title="2.MySQL存储引擎MyISAM与InnoDB如何选择"></a><strong>2.MySQL存储引擎MyISAM与InnoDB如何选择</strong></h4><blockquote><p>MySQL有多种存储引擎，每种存储引擎有各自的优缺点，可以择优选择使用：MyISAM、InnoDB、MERGE、MEMORY(HEAP)、BDB(BerkeleyDB)、EXAMPLE、FEDERATED、ARCHIVE、CSV、BLACKHOLE。</p><p>虽然MySQL里的存储引擎不只是MyISAM与InnoDB这两个，但常用的就是两个。<br>关于MySQL数据库提供的两种存储引擎，MyISAM与InnoDB选择使用：</p></blockquote><ul><li>1.INNODB会支持一些关系数据库的高级功能，如事务功能和行级锁，MyISAM不支持。</li><li>2.MyISAM的性能更优，占用的存储空间少，所以，选择何种存储引擎，视具体应用而定。</li></ul><blockquote><p>如果你的应用程序一定要使用事务，毫无疑问你要选择INNODB引擎。但要注意，INNODB的行级锁是有条件的。在where条件没有使用主键时，照样会锁全表。比如DELETE FROM mytable这样的删除语句。</p><p>如果你的应用程序对查询性能要求较高，就要使用MyISAM了。MyISAM索引和数据是分开的，而且其索引是压缩的，可以更好地利用内存。所以它的查询性能明显优于INNODB。压缩后的索引也能节约一些磁盘空间。MyISAM拥有全文索引的功能，这可以极大地优化LIKE查询的效率。</p><p>有人说MyISAM只能用于小型应用，其实这只是一种偏见。如果数据量比较大，这是需要通过升级架构来解决，比如分表分库，而不是单纯地依赖存储引擎。</p><p>现在一般都是选用innodb了，主要是MyISAM的全表锁，读写串行问题，并发效率锁表，效率低，MyISAM对于读写密集型应用一般是不会去选用的。<br>MEMORY存储引擎</p><p>MEMORY是MySQL中一类特殊的存储引擎。它使用存储在内存中的内容来创建表，而且数据全部放在内存中。这些特性与前面的两个很不同。<br>每个基于MEMORY存储引擎的表实际对应一个磁盘文件。该文件的文件名与表名相同，类型为frm类型。该文件中只存储表的结构。而其数据文件，都是存储在内存中，这样有利于数据的快速处理，提高整个表的效率。值得注意的是，服务器需要有足够的内存来维持MEMORY存储引擎的表的使用。如果不需要了，可以释放内存，甚至删除不需要的表。</p><p>MEMORY默认使用哈希索引。速度比使用B型树索引快。当然如果你想用B型树索引，可以在创建索引时指定。</p><p>注意，MEMORY用到的很少，因为它是把数据存到内存中，如果内存出现异常就会影响数据。如果重启或者关机，所有数据都会消失。因此，基于MEMORY的表的生命周期很短，一般是一次性的。</p></blockquote><h4 id="3-MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景"><a href="#3-MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景" class="headerlink" title="3.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?"></a><strong>3.MySQL的MyISAM与InnoDB两种存储引擎在，事务、锁级别，各自的适用场景?</strong></h4><blockquote><p><strong>事务处理上方面</strong></p></blockquote><ul><li>MyISAM：强调的是性能，每次查询具有原子性,其执行数度比InnoDB类型更快，但是不提供事务支持。</li><li>InnoDB：提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li></ul><blockquote><p><strong>锁级别</strong></p></blockquote><ul><li>MyISAM：只支持表级锁，用户在操作MyISAM表时，select，update，delete，insert语句都会给表自动加锁，如果加锁以后的表满足insert并发的情况下，可以在表的尾部插入新的数据。</li><li>InnoDB：支持事务和行级锁，是innodb的最大特色。行锁大幅度提高了多用户并发操作的新能。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</li></ul><blockquote><p><strong>关于存储引擎MyISAM和InnoDB的其他参考资料如下：</strong></p><p><a href="http://blog.csdn.net/lc0817/article/details/52757194">MySQL存储引擎中的MyISAM和InnoDB区别详解</a></p><p><a href="https://www.cnblogs.com/kevingrace/p/5685355.html">MySQL存储引擎之MyISAM和Innodb总结性梳理</a></p></blockquote><h2 id="五、优化"><a href="#五、优化" class="headerlink" title="五、优化"></a>五、优化</h2><h4 id="1-查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序"><a href="#1-查询语句不同元素（where、jion、limit、group-by、having等等）执行先后顺序" class="headerlink" title="1.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?"></a><strong>1.查询语句不同元素（where、jion、limit、group by、having等等）执行先后顺序?</strong></h4><ul><li>1.查询中用到的关键词主要包含<strong>六个</strong>，并且他们的顺序依次为 <strong>select–from–where–group by–having–order by</strong></li></ul><blockquote><p><strong>其中select和from是必须的，其他关键词是可选的，这六个关键词的执行顺序 与sql语句的书写顺序并不是一样的，而是按照下面的顺序来执行</strong></p><p>**from:**需要从哪个数据表检索数据</p></blockquote><blockquote><p>**where:**过滤表中数据的条件</p><p>**group by:**如何将上面过滤出的数据分组</p><p>**having:**对上面已经分组的数据进行过滤的条件</p><p>**select:**查看结果集中的哪个列，或列的计算结果</p><p>**order by :**按照什么样的顺序来查看返回的数据</p></blockquote><ul><li>2.<strong>from后面的表关联，是自右向左解析 而where条件的解析顺序是自下而上的。</strong></li></ul><blockquote><p>也就是说，在写SQL语句的时候，尽量把数据量小的表放在最右边来进行关联（用小表去匹配大表），而把能筛选出小量数据的条件放在where语句的最左边 （用小表去匹配大表）</p><p>其他参考资源：<br><a href="http://www.cnblogs.com/huminxxl/p/3149097.html">http://www.cnblogs.com/huminxxl/p/3149097.html</a></p></blockquote><h4 id="2-使用explain优化sql和索引"><a href="#2-使用explain优化sql和索引" class="headerlink" title="2.使用explain优化sql和索引?"></a><strong>2.使用explain优化sql和索引?</strong></h4><blockquote><p><strong>对于复杂、效率低的sql语句，我们通常是使用explain sql 来分析sql语句，这个语句可以打印出，语句的执行。这样方便我们分析，进行优化</strong></p><p><strong>table：</strong>显示这一行的数据是关于哪张表的</p><p><strong>type：</strong>这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL</p><p>**all:**full table scan ;MySQL将遍历全表以找到匹配的行；</p><p><strong>index:</strong> index scan; index 和 all的区别在于index类型只遍历索引；</p><p><strong>range：</strong>索引范围扫描，对索引的扫描开始于某一点，返回匹配值的行，常见与between ，等查询；</p><p><strong>ref：</strong>非唯一性索引扫描，返回匹配某个单独值的所有行，常见于使用非唯一索引即唯一索引的非唯一前缀进行查找；</p><p><strong>eq_ref：</strong>唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常用于主键或者唯一索引扫描；</p><p><strong>const，system：</strong>当MySQL对某查询某部分进行优化，并转为一个常量时，使用这些访问类型。如果将主键置于where列表中，MySQL就能将该查询转化为一个常量。</p><p><strong>possible_keys：</strong>显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句</p><p><strong>key：</strong> 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MySQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MySQL忽略索引</p><p><strong>key_len：</strong>使用的索引的长度。在不损失精确性的情况下，长度越短越好</p><p><strong>ref：</strong>显示索引的哪一列被使用了，如果可能的话，是一个常数</p><p><strong>rows：</strong>MySQL认为必须检查的用来返回请求数据的行数</p><p><strong>Extra：</strong>关于MySQL如何解析查询的额外信息。将在表4.3中讨论，但这里可以看到的坏的例子是Using temporary和Using filesort，意思MySQL根本不能使用索引，结果是检索会很慢。</p></blockquote><h4 id="3-MySQL慢查询怎么解决"><a href="#3-MySQL慢查询怎么解决" class="headerlink" title="3.MySQL慢查询怎么解决?"></a><strong>3.MySQL慢查询怎么解决?</strong></h4><blockquote><ul><li>slow_query_log 慢查询开启状态。</li><li>slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）。</li><li>long_query_time 查询超过多少秒才记录。</li></ul></blockquote><h2 id="六、数据库锁"><a href="#六、数据库锁" class="headerlink" title="六、数据库锁"></a>六、数据库锁</h2><h4 id="1-mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决"><a href="#1-mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决" class="headerlink" title="1.mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决?"></a><strong>1.mysql都有什么锁，死锁判定原理和具体场景，死锁怎么解决?</strong></h4><blockquote><p><strong>MySQL有三种锁的级别：</strong>页级、表级、行级。</p><ul><li><strong>表级锁：</strong>开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高,并发度最低。</li><li><strong>行级锁：</strong>开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低,并发度也最高。</li><li><strong>页面锁：</strong>开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般<br>  <strong>什么情况下会造成死锁?</strong></li></ul><p><strong>什么是死锁？</strong></p><p><strong>死锁:</strong> 是指两个或两个以上的进程在执行过程中。因争夺资源而造成的一种互相等待的现象,若无外力作用,它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁,这些永远在互相等竺的进程称为死锁进程。</p><p>表级锁不会产生死锁.所以解决死锁主要还是针对于最常用的InnoDB。</p><p><strong>死锁的关键在于：</strong>两个(或以上)的Session加锁的顺序不一致。</p><p>那么对应的解决死锁问题的关键就是：让不同的session加锁有次序。</p><p><strong>死锁的解决办法?</strong></p><p>1.查出的线程杀死 kill<br>SELECT trx_MySQL_thread_id FROM information_schema.INNODB_TRX;</p><p>2.设置锁的超时时间<br>Innodb 行锁的等待时间，单位秒。可在会话级别设置，RDS 实例该参数的默认值为 50（秒）。</p><p>生产环境不推荐使用过大的 innodb_lock_wait_timeout参数值<br>该参数支持在会话级别修改，方便应用在会话级别单独设置某些特殊操作的行锁等待超时时间，如下：<br>set innodb_lock_wait_timeout&#x3D;1000; —设置当前会话 Innodb 行锁等待超时时间，单位秒。</p><p>3.指定获取锁的顺序</p></blockquote><h4 id="2-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁"><a href="#2-有哪些锁（乐观锁悲观锁），select-时怎么加排它锁" class="headerlink" title="2.有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?"></a><strong>2.有哪些锁（乐观锁悲观锁），select 时怎么加排它锁?</strong></h4><blockquote><p><strong>悲观锁（Pessimistic Lock）:</strong></p><p>**悲观锁特点:**先获取锁，再进行业务操作。</p><p>即“悲观”的认为获取锁是非常有可能失败的，因此要先确保获取锁成功再进行业务操作。通常所说的<strong>“一锁二查三更新”即指的是使用悲观锁。</strong>通常来讲在数据库上的悲观锁需要数据库本身提供支持，即通过常用的select … for update操作来实现悲观锁。当数据库执行select for update时会获取被select中的数据行的行锁，因此其他并发执行的select for update如果试图选中同一行则会发生排斥（需要等待行锁被释放），因此达到锁的效果。select for update获取的行锁会在当前事务结束时自动释放，因此必须在事务中使用。</p><p><strong>补充：</strong><br>不同的数据库对select for update的实现和支持都是有所区别的，</p><ul><li>oracle支持select for update no wait，表示如果拿不到锁立刻报错，而不是等待，MySQL就没有no wait这个选项。</li><li>MySQL还有个问题是select for update语句执行中所有扫描过的行都会被锁上，这一点很容易造成问题。因此如果在MySQL中用悲观锁务必要确定走了索引，而不是全表扫描。</li></ul><p><strong>乐观锁（Optimistic Lock）:</strong></p><p>**1.**乐观锁，也叫乐观并发控制，它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，那么当前正在提交的事务会进行回滚。</p><p>*<em>2.*</em>**乐观锁的特点先进行业务操作，不到万不得已不去拿锁。**即“乐观”的认为拿锁多半是会成功的，因此在进行完业务操作需要实际更新数据的最后一步再去拿一下锁就好。<br>乐观锁在数据库上的实现完全是逻辑的，不需要数据库提供特殊的支持。</p><p><strong>3.<strong>一般的做法是</strong>在需要锁的数据上增加一个版本号，或者时间戳</strong>，</p><p><strong>实现方式举例如下：</strong></p><p><strong>乐观锁（给表加一个版本号字段）</strong> 这个并不是乐观锁的定义，给表加版本号，是<strong>数据库实现乐观锁的一种方式</strong>。</p><ol><li>SELECT data AS old_data, version AS old_version FROM …;</li><li>根据获取的数据进行业务操作，得到new_data和new_version</li><li>UPDATE SET data &#x3D; new_data, version &#x3D; new_version WHERE version &#x3D; old_version</li></ol><p>if (updated row &gt; 0) {</p><p>&#x2F;&#x2F; 乐观锁获取成功，操作完成</p><p>} else {</p><p>&#x2F;&#x2F; 乐观锁获取失败，回滚并重试</p><p>}</p><p><strong>注意：</strong></p><ul><li>乐观锁在不发生取锁失败的情况下开销比悲观锁小，但是一旦发生失败回滚开销则比较大，因此适合用在取锁失败概率比较小的场景，可以提升系统并发性能</li><li>乐观锁还适用于一些比较特殊的场景，例如在业务操作过程中无法和数据库保持连接等悲观锁无法适用的地方。</li></ul><p><strong>总结：</strong><br>悲观锁和乐观锁是数据库用来保证数据并发安全防止更新丢失的两种方法，例子在select … for update前加个事务就可以防止更新丢失。悲观锁和乐观锁大部分场景下差异不大，一些独特场景下有一些差别，一般我们可以从如下几个方面来判断。</p><ul><li><strong>响应速度：</strong> 如果需要非常高的响应速度，建议采用乐观锁方案，成功就执行，不成功就失败，不需要等待其他并发去释放锁。’</li><li><strong>冲突频率：</strong> 如果冲突频率非常高，建议采用悲观锁，保证成功率，如果冲突频率大，乐观锁会需要多次重试才能成功，代价比较大。</li><li><strong>重试代价：</strong> 如果重试代价大，建议采用悲观锁。</li></ul></blockquote><h2 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h2><h4 id="1-数据库的主从复制"><a href="#1-数据库的主从复制" class="headerlink" title="1.数据库的主从复制"></a><strong>1.数据库的主从复制</strong></h4><blockquote><p><strong>主从复制的几种方式:</strong></p><p><strong>同步复制:</strong></p><p>所谓的同步复制，意思是master的变化，必须等待slave-1,slave-2,…,slave-n完成后才能返回。 这样，显然不可取，也不是MySQL复制的默认设置。比如，在WEB前端页面上，用户增加了条记录，需要等待很长时间。</p><p><strong>异步复制:</strong></p><p>如同AJAX请求一样。master只需要完成自己的数据库操作即可。至于slaves是否收到二进制日志，是否完成操作，不用关心,MySQL的默认设置。</p><p><strong>半同步复制:</strong></p><p>master只保证slaves中的一个操作成功，就返回，其他slave不管。 这个功能，是由google为MySQL引入的。</p></blockquote><h4 id="2-数据库主从复制分析的-7-个问题"><a href="#2-数据库主从复制分析的-7-个问题" class="headerlink" title="2.数据库主从复制分析的 7 个问题?"></a><strong>2.数据库主从复制分析的 7 个问题?</strong></h4><p><strong>问题1：</strong>master的写操作，slaves被动的进行一样的操作，保持数据一致性，那么slave是否可以主动的进行写操作？</p><blockquote><p>假设slave可以主动的进行写操作，slave又无法通知master，这样就导致了master和slave数据不一致了。因此slave不应该进行写操作，至少是slave上涉及到复制的数据库不可以写。实际上，这里已经揭示了读写分离的概念。</p></blockquote><p><strong>问题2：</strong>主从复制中，可以有N个slave,可是这些slave又不能进行写操作，要他们干嘛？</p><blockquote><p><strong>实现数据备份:</strong><br>类似于高可用的功能，一旦master挂了，可以让slave顶上去，同时slave提升为master。</p><p>**异地容灾:**比如master在北京，地震挂了，那么在上海的slave还可以继续。<br>主要用于实现scale out,分担负载,可以将读的任务分散到slaves上。<br>【很可能的情况是，一个系统的读操作远远多于写操作，因此写操作发向master，读操作发向slaves进行操作】</p></blockquote><p><strong>问题3：</strong>主从复制中有master,slave1,slave2,…等等这么多MySQL数据库，那比如一个JAVA WEB应用到底应该连接哪个数据库?</p><blockquote><p>我们在应用程序中可以这样，insert&#x2F;delete&#x2F;update这些更新数据库的操作，用connection(for master)进行操作，</p><p>select用connection(for slaves)进行操作。那我们的应用程序还要完成怎么从slaves选择一个来执行select，例如使用简单的轮循算法。</p><p>这样的话，相当于应用程序完成了SQL语句的路由，而且与MySQL的主从复制架构非常关联，一旦master挂了，某些slave挂了，那么应用程序就要修改了。能不能让应用程序与MySQL的主从复制架构没有什么太多关系呢？<br>找一个组件，application program只需要与它打交道，用它来完成MySQL的代理，实现SQL语句的路由。<br>MySQL proxy并不负责，怎么从众多的slaves挑一个？可以交给另一个组件(比如haproxy)来完成。</p><p>这就是所谓的MySQL READ WRITE SPLITE，MySQL的读写分离。</p></blockquote><p><strong>问题4：</strong>如果MySQL proxy , direct , master他们中的某些挂了怎么办？</p><blockquote><p>总统一般都会弄个副总统，以防不测。同样的，可以给这些关键的节点来个备份。</p></blockquote><p><strong>问题5：</strong>当master的二进制日志每产生一个事件，都需要发往slave，如果我们有N个slave,那是发N次，还是只发一次？如果只发一次，发给了slave-1，那slave-2,slave-3,…它们怎么办？</p><blockquote><p>显 然，应该发N次。实际上，在MySQL master内部，维护N个线程，每一个线程负责将二进制日志文件发往对应的slave。master既要负责写操作，还的维护N个线程，负担会很重。可以这样，slave-1是master的从，slave-1又是slave-2,slave-3,…的主，同时slave-1不再负责select。 slave-1将master的复制线程的负担，转移到自己的身上。这就是所谓的多级复制的概念。</p></blockquote><p><strong>问题6：</strong>当一个select发往MySQL proxy，可能这次由slave-2响应，下次由slave-3响应，这样的话，就无法利用查询缓存了。</p><blockquote><p>应该找一个共享式的缓存，比如memcache来解决。将slave-2,slave-3,…这些查询的结果都缓存至mamcache中。</p></blockquote><p><strong>问题7：</strong>随着应用的日益增长，读操作很多，我们可以扩展slave，但是如果master满足不了写操作了，怎么办呢？</p><blockquote><p>scale on ?更好的服务器？ 没有最好的，只有更好的，太贵了。。。<br>scale out ? 主从复制架构已经满足不了。<br>可以分库【垂直拆分】，分表【水平拆分】。</p></blockquote><h4 id="3-mysql-高并发环境解决方案"><a href="#3-mysql-高并发环境解决方案" class="headerlink" title="3.mysql 高并发环境解决方案?"></a><strong>3.mysql 高并发环境解决方案?</strong></h4><blockquote><p><strong>MySQL 高并发环境解决方案：</strong> 分库 分表 分布式 增加二级缓存。。。。。</p><p><strong>需求分析：</strong>互联网单位 每天大量数据读取，写入，并发性高。</p><p><strong>现有解决方式：</strong>水平分库分表，由单点分布到多点数据库中，从而降低单点数据库压力。</p><p><strong>集群方案：</strong>解决DB宕机带来的单点DB不能访问问题。</p><p><strong>读写分离策略：</strong>极大限度提高了应用中Read数据的速度和并发量。无法解决高写入压力。</p></blockquote><h4 id="4-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）"><a href="#4-数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）" class="headerlink" title="4.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）?"></a><strong>4.数据库崩溃时事务的恢复机制（REDO日志和UNDO日志）?</strong></h4><p>转载：<a href="https://www.cnblogs.com/Bozh/archive/2013/03/18/2966494.html">MySQL REDO日志和UNDO日志</a></p><blockquote><p><strong>Undo Log:</strong></p><p>Undo Log是为了实现事务的原子性，在MySQL数据库InnoDB存储引擎中，还用了Undo Log来实现多版本并发控制(简称：MVCC)。</p><p>事务的原子性(Atomicity)事务中的所有操作，要么全部完成，要么不做任何操作，不能只做部分操作。如果在执行的过程中发生了错误，要回滚(Rollback)到事务开始前的状态，就像这个事务从来没有执行过。<br>原理Undo Log的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog）。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。</p><p>之所以能同时保证原子性和持久化，是因为以下<strong>特点：</strong></p><p>更新数据前记录Undo log。<br>为了保证持久性，必须将数据在事务提交前写到磁盘。只要事务成功提交，数据必然已经持久化。<br>Undo log必须先于数据持久化到磁盘。如果在G,H之间系统崩溃，undo log是完整的， 可以用来回滚事务。<br>如果在A-F之间系统崩溃,因为数据没有持久化到磁盘。所以磁盘上的数据还是保持在事务开始前的状态。</p><p><strong>缺陷：</strong>每个事务提交前将数据和Undo Log写入磁盘，这样会导致大量的磁盘IO，因此性能很低。<br>如果能够将数据缓存一段时间，就能减少IO提高性能。但是这样就会丧失事务的持久性。因此引入了另外一种机制来实现持久化，即Redo Log。</p><p><strong>Redo Log:</strong></p><p>原理和Undo Log相反，Redo Log记录的是新数据的备份。在事务提交前，只要将Redo Log持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是Redo Log已经持久化。系统可以根据Redo Log的内容，将所有数据恢复到最新的状态。</p></blockquote><h4 id="八、整理时参考的资料"><a href="#八、整理时参考的资料" class="headerlink" title="八、整理时参考的资料"></a><strong>八、整理时参考的资料</strong></h4><p><a href="http://mp.weixin.qq.com/s?__biz=MzIwMTY0NDU3Nw==&mid=2651936134&idx=1&sn=5213a59104f6d2a90bc18d878cafe417&chksm=8d0f3ac8ba78b3deb2ea3473906a37dd205b6e64bfbebe86cc00108242bfa4c49a7d1e509eca&mpshare=1&scene=1&srcid=0707k8Bdz85tDHyVotxEQ9of#rd">java团长 数据库整理</a></p><p><a href="https://my.oschina.net/yanpenglei/blog/1650277">20个数据库常见面试题讲解 - 鹏磊 - 开源中国”</a></p><p><a href="https://m.2cto.com/database/201710/688377.html">34个数据库常见面试题讲解</a></p><p><a href="https://kb.cnblogs.com/page/45712/">漫谈数据库索引<em>知识库</em>博客园</a></p><p><a href="https://blog.csdn.net/u011479200/article/details/78513632">Mysql| 使用通配符进行模糊查询(like,%,_)</a></p><p><a href="http://blog.csdn.net/lc0817/article/details/52757194">MySQL存储引擎中的MyISAM和InnoDB区别详解</a></p><p><a href="https://www.cnblogs.com/kevingrace/p/5685355.html">MySQL存储引擎之MyISAM和Innodb总结性梳理</a></p><p><a href="https://blog.csdn.net/liangxw1/article/details/51197560">https://blog.csdn.net/liangxw1/article/details/51197560</a></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim基本命令</title>
    <link href="/2021/03/11/Tools/Vim/Vim%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/03/11/Tools/Vim/Vim%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>本文作者</strong>：**<a href="https://www.cnblogs.com/woshimrf/p/vim.html">Ryan Miao</a>**<br><strong>本文链接</strong>：<a href="https://www.cnblogs.com/woshimrf/p/vim.html">https://www.cnblogs.com/woshimrf/p/vim.html</a></p></blockquote><blockquote><p>另一篇参考资料: <a href="https://blog.csdn.net/deng_sai/article/details/46313767">vim与复制，删除，粘贴，块操作以及快速替换功能</a></p></blockquote><p>vim简单的命令用着还好。比如插入，删除，查询。但替换就用的比较少。所以，还是需要用的时候拿出来对照者看。</p><p>使用vim编辑文件：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">vim xxx</span><br></code></pre></td></tr></table></figure><p>进入之后的界面叫做命令模式界面。可以修改文件编辑的时候叫做插入模式。</p><h2 id="命令模式-冒号-指令"><a href="#命令模式-冒号-指令" class="headerlink" title="(命令模式)冒号+指令"></a>(命令模式)冒号+指令</h2><p>在vim命令模式界面想要退出，需要输入冒号和指令</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-symbol">:wq</span>   保存并退出<br><span class="hljs-symbol">:q</span>  维修改退出<br><span class="hljs-symbol">:q!</span> 强制退出并不保存<br></code></pre></td></tr></table></figure><h2 id="命令模式-移动光标"><a href="#命令模式-移动光标" class="headerlink" title="(命令模式)移动光标"></a>(命令模式)移动光标</h2><p>在vim界面，命令模式下光标移动方法</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span>、使用上下左右方向键<br><br><span class="hljs-number">2</span>、命令模式下：<br>h   向左<br>j   向下 <br>k   向上<br>l  向右<br><br>空格键 向右<br>Backspace  向左<br>Enter  移动到下一行首<br>-  移动到上一行首。<br><br>:set  nu     <span class="hljs-regexp">//</span>显示行号<br>:set nonu    <span class="hljs-regexp">//</span>取消显示行号<br>n+        <span class="hljs-regexp">//</span>向下跳n行<br>n-         <span class="hljs-regexp">//</span>向上跳n行<br>nG        <span class="hljs-regexp">//</span>跳到行号为n的行<br>G           <span class="hljs-regexp">//</span>跳至文件的底部<br>g         <span class="hljs-regexp">//</span>跳转到文件头部<br></code></pre></td></tr></table></figure><h2 id="插入模式-编辑模式"><a href="#插入模式-编辑模式" class="headerlink" title="(插入模式)编辑模式"></a>(插入模式)编辑模式</h2><p>以下按键进入编辑插入模式</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">a      //在当前光标位置的右边添加文本<br>i       //在当前光标位置的左边添加文本<br>A     //在当前行的末尾位置添加文本<br>I      //在当前行的开始处添加文本(非空字符的行首)<br>O     //在当前行的上面新建一行<br>o     //在当前行的下面新建一行<br>R    //替换(覆盖)当前光标位置及后面的若干文本<br>J    //合并光标所在行及下一行为一行(依然在命令模式)<br></code></pre></td></tr></table></figure><p>ESC可以退出编辑模式</p><h2 id="命令模式-删除和复制"><a href="#命令模式-删除和复制" class="headerlink" title="(命令模式)删除和复制"></a>(命令模式)删除和复制</h2><p>在vim中, 除了在编辑模式下修改文件，命令模式的时候可以删除和复制</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">x         //删除当前字符<br>nx         //删除从光标开始的n个字符<br>dd       //删除当前行<br>ndd      //向下删除当前行在内的n行<br>u        //撤销上一步操作<br>U        //撤销对当前行的所有操作<br>yy       //将当前行复制到缓存区，也可以用 &quot;ayy 复制，&quot;a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。<br>nyy      //将当前行向下n行复制到缓冲区，也可以用 &quot;anyy 复制，&quot;a 为缓冲区，a也可以替换为a到z的任意字母，可以完成多个复制任务。<br>yw       //复制从光标开始到词尾的字符。<br>nyw      //复制从光标开始的n个单词。<br>y^       //复制从光标到行首的内容。  VPS侦探<br>y$       //复制从光标到行尾的内容。<br>p        //粘贴剪切板里的内容在光标后，如果使用了前面的自定义缓冲区，建议使用&quot;ap 进行粘贴。<br>P        //粘贴剪切板里的内容在光标前，如果使用了前面的自定义缓冲区，建议使用&quot;aP 进行粘贴。<br></code></pre></td></tr></table></figure><h2 id="命令模式-搜索和替换"><a href="#命令模式-搜索和替换" class="headerlink" title="(命令模式)搜索和替换"></a>(命令模式)搜索和替换</h2><p>命令模式下(esc退出插入模式)</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs text">/keyword     //向光标下搜索keyword字符串，keyword可以是正则表达式<br>?keyword     //向光标上搜索keyword字符串<br>n           //向下搜索前一个搜素动作<br>N         //向上搜索前一个搜索动作<br><br>*(#)      //当光标停留在某个单词上时, 输入这条命令表示查找与该单词匹配的下(上)一个单词. 同样, 再输入 n 查找下一个匹配处, 输入 N 反方向查找.<br><br>g*(g#)        //此命令与上条命令相似, 只不过它不完全匹配光标所在处的单词, 而是匹配包含该单词的所有字符串.<br><br>:s/old/new      //用new替换行中首次出现的old<br>:s/old/new/g         //用new替换行中所有的old<br>:n,m s/old/new/g     //用new替换从n到m行里所有的old<br>:%s/old/new/g      //用new替换当前文件里所有的old<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Vim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Radix树</title>
    <link href="/2021/03/11/Radix%E6%A0%91/"/>
    <url>/2021/03/11/Radix%E6%A0%91/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考链接:</p><p><a href="https://blog.csdn.net/petershina/article/details/53313624">图文详解Radix树</a></p><p><a href="https://www.cnblogs.com/Bozh/archive/2012/04/15/Radix.html">利用用Radix树作为Key-Value 键值对的数据路由</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>漫画算法:什么是跳跃表</title>
    <link href="/2021/03/11/%E8%B7%B3%E8%B7%83%E8%A1%A8/"/>
    <url>/2021/03/11/%E8%B7%B3%E8%B7%83%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<blockquote><p>参考网址：</p><p><a href="https://www.jianshu.com/p/dc252b5efca6">漫画算法：什么是跳跃表？</a></p><p><a href="https://blog.csdn.net/qq_24047659/article/details/88042998">文字版-什么是跳跃表</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TCP的拥塞控制</title>
    <link href="/2021/03/11/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/"/>
    <url>/2021/03/11/TCP%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是拥塞"><a href="#什么是拥塞" class="headerlink" title="什么是拥塞"></a>什么是拥塞</h2><p>拥塞：即对资源的需求超过了可用的资源。若网络中许多资源同时供应不足，网络的性能就要明显变坏，整个网络的吞吐量随之负荷的增大而下降。</p><p>拥塞控制：防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提：网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机、路由器，以及与降低网络传输性能有关的所有因素。</p><p>流量控制：指点对点通信量的控制，是端到端正的问题。流量控制所要做的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>拥塞控制代价：需要获得网络内部流量分布的信息。在实施拥塞控制之前，还需要在结点之间交换信息和各种命令，以便选择控制的策略和实施控制。这样就产生了额外的开销。拥塞控制还需要将一些资源分配给各个用户单独使用，使得网络资源不能更好地实现共享。</p><h2 id="TCP拥塞控制方法"><a href="#TCP拥塞控制方法" class="headerlink" title="TCP拥塞控制方法"></a>TCP拥塞控制方法</h2><p>慢开始( slow-start )、拥塞避免( congestion avoidance )、快重传( fast retransmit )和快恢复( fast recovery )。</p><h3 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h3><p>发送方维持一个拥塞窗口 cwnd ( congestion window )的状态变量。拥塞窗口的大小取决于网络的拥塞程度，并且动态地在变化。发送方让自己的发送窗口等于拥塞。</p><p>发送方控制拥塞窗口的原则是：只要网络没有出现拥塞，拥塞窗口就再增大一些，以便把更多的分组发送出去。但只要网络出现拥塞，拥塞窗口就减小一些，以减少注入到网络中的分组数。</p><p>慢开始算法：当主机开始发送数据时，如果立即所大量数据字节注入到网络，那么就有可能引起网络拥塞，因为现在并不清楚网络的负荷情况。因此，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是说，由小到大逐渐增大拥塞窗口数值。通常在刚刚开始发送报文段时，先把拥塞窗口 cwnd 设置为一个最大报文段MSS的数值。而在每收到一个对新的报文段的确认后，把拥塞窗口增加至多一个MSS的数值。用这样的方法逐步增大发送方的拥塞窗口 cwnd ，可以使分组注入到网络的速率更加合理。</p><p>每经过一个传输轮次，拥塞窗口 cwnd 就加倍。一个传输轮次所经历的时间其实就是往返时间RTT。不过“传输轮次”更加强调：把拥塞窗口cwnd所允许发送的报文段都连续发送出去，并收到了对已发送的最后一个字节的确认。</p><p>另，慢开始的“慢”并不是指cwnd的增长速率慢，而是指在TCP开始发送报文段时先设置cwnd&#x3D;1，使得发送方在开始时只发送一个报文段（目的是试探一下网络的拥塞情况），然后再逐渐增大cwnd。</p><pre><code class="hljs">为了防止拥塞窗口cwnd增长过大引起网络拥塞，还需要设置一个慢开始门限ssthresh状态变量（如何设置ssthresh）。慢开始门限ssthresh的用法如下：当 cwnd &lt; ssthresh 时，使用上述的慢开始算法。当 cwnd &gt; ssthresh 时，停止使用慢开始算法而改用拥塞避免算法。当 cwnd = ssthresh 时，既可使用慢开始算法，也可使用拥塞控制避免算法。</code></pre><p>拥塞避免算法：让拥塞窗口cwnd缓慢地增大，即每经过一个往返时间RTT就把发送方的拥塞窗口cwnd加1，而不是加倍。这样拥塞窗口cwnd按线性规律缓慢增长，比慢开始算法的拥塞窗口增长速率缓慢得多。</p><pre><code class="hljs">无论在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞（其根据就是没有收到确认），就要把慢开始门限ssthresh设置为出现拥塞时的发送方窗口值的一半（但不能小于2）。然后把拥塞窗口cwnd重新设置为1，执行慢开始算法。这样做的目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。如下图，用具体数值说明了上述拥塞控制的过程。现在发送窗口的大小和拥塞窗口一样大。</code></pre><p>&lt;1&gt;. 当TCP连接进行初始化时，把拥塞窗口cwnd置为1。前面已说过，为了便于理解，图中的窗口单位不使用字节而使用报文段的个数。慢开始门限的初始值设置为16个报文段，即 cwnd &#x3D; 16 。</p><p>&lt;2&gt;. 在执行慢开始算法时，拥塞窗口 cwnd 的初始值为1。以后发送方每收到一个对新报文段的确认ACK，就把拥塞窗口值另1，然后开始下一轮的传输（图中横坐标为传输轮次）。因此拥塞窗口cwnd随着传输轮次按指数规律增长。当拥塞窗口cwnd增长到慢开始门限值ssthresh时（即当cwnd&#x3D;16时），就改为执行拥塞控制算法，拥塞窗口按线性规律增长。</p><p>&lt;3&gt;. 假定拥塞窗口的数值增长到24时，网络出现超时（这很可能就是网络发生拥塞了）。更新后的ssthresh值变为12（即变为出现超时时的拥塞窗口数值24的一半），拥塞窗口再重新设置为1，并执行慢开始算法。当cwnd&#x3D;ssthresh&#x3D;12时改为执行拥塞避免算法，拥塞窗口按线性规律增长，每经过一个往返时间增加一个MSS的大小。</p><p>强调：“拥塞避免”并非指完全能够避免了拥塞。利用以上的措施要完全避免网络拥塞还是不可能的。“拥塞避免”是说在拥塞避免阶段将拥塞窗口控制为按线性规律增长，使网络比较不容易出现拥塞。</p><h3 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h3><p>如果发送方设置的超时计时器时限已到但还没有收到确认，那么很可能是网络出现了拥塞，致使报文段在网络中的某处被丢弃。这时，TCP马上把拥塞窗口 cwnd 减小到1，并执行慢开始算法，同时把慢开始门限值ssthresh减半。这是不使用快重传的情况。</p><p>快重传算法首先要求接收方每收到一个失序的报文段后就立即发出重复确认（为的是使发送方及早知道有报文段没有到达对方）而不要等到自己发送数据时才进行捎带确认。</p><p>接收方收到了M1和M2后都分别发出了确认。现在假定接收方没有收到M3但接着收到了M4。显然，接收方不能确认M4，因为M4是收到的失序报文段。根据可靠传输原理，接收方可以什么都不做，也可以在适当时机发送一次对M2的确认。但按照快重传算法的规定，接收方应及时发送对M2的重复确认，这样做可以让发送方及早知道报文段M3没有到达接收方。发送方接着发送了M5和M6。接收方收到这两个报文后，也还要再次发出对M2的重复确认。这样，发送方共收到了接收方的四个对M2的确认，其中后三个都是重复确认。快重传算法还规定，发送方只要一连收到三个重复确认就应当立即重传对方尚未收到的报文段M3，而不必继续等待M3设置的重传计时器到期。由于发送方尽早重传未被确认的报文段，因此采用快重传后可以使整个网络吞吐量提高约20%。</p><p>与快重传配合使用的还有快恢复算法，其过程有以下两个要点：</p><p>&lt;1&gt;. 当发送方连续收到三个重复确认，就执行“乘法减小”算法，把慢开始门限ssthresh减半。这是为了预防网络发生拥塞。请注意：接下去不执行慢开始算法。</p><p>&lt;2&gt;. 由于发送方现在认为网络很可能没有发生拥塞，因此与慢开始不同之处是现在不执行慢开始算法（即拥塞窗口cwnd现在不设置为1），而是把cwnd值设置为慢开始门限ssthresh减半后的数值，然后开始执行拥塞避免算法（“加法增大”），使拥塞窗口缓慢地线性增大。</p><p>下图给出了快重传和快恢复的示意图，并标明了“TCP Reno版本”。</p><p>区别：新的 TCP Reno 版本在快重传之后采用快恢复算法而不是采用慢开始算法。</p><p>也有的快重传实现是把开始时的拥塞窗口cwnd值再增大一点，即等于 ssthresh + 3 X MSS 。这样做的理由是：既然发送方收到三个重复的确认，就表明有三个分组已经离开了网络。这三个分组不再消耗网络 的资源而是停留在接收方的缓存中。可见现在网络中并不是堆积了分组而是减少了三个分组。因此可以适当把拥塞窗口扩大了些。</p><p>在采用快恢复算法时，慢开始算法只是在TCP连接建立时和网络出现超时时才使用。</p><p>采用这样的拥塞控制方法使得TCP的性能有明显的改进。</p><p>接收方根据自己的接收能力设定了接收窗口rwnd，并把这个窗口值写入TCP首部中的窗口字段，传送给发送方。因此，接收窗口又称为通知窗口。因此，从接收方对发送方的流量控制的角度考虑，发送方的发送窗口一定不能超过对方给出的接收窗口rwnd 。</p><p>发送方窗口的上限值 &#x3D; Min [ rwnd, cwnd ]</p><p>当rwnd &lt; cwnd 时，是接收方的接收能力限制发送方窗口的最大值。</p><p>当cwnd &lt; rwnd 时，则是网络的拥塞限制发送方窗口的最大值。</p>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机网络的七层模型</title>
    <link href="/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/"/>
    <url>/2021/03/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9A%84%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://blog.csdn.net/warrior_0319/article/details/80453940">https://blog.csdn.net/warrior_0319/article/details/80453940</a></p></blockquote><p>七层模型，也称为OSI（Open System Interconnection）参考模型，是国际标准化组织（ISO）制定的一个用于计算机或通讯系统间互联的标准体系。它是一个七层的、抽象的模型体，不仅包括一系列抽象的术语或概念，也包括具体的协议。<br>ISO 就是 Internationalization Standard Organization（国际标准组织）。</p><h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>看一下OSI的起源和出现过程还是挺有意思的。<br>OSI的大部分设计工作实际上只是Honeywell Information System公司的一个小组完成的，小组的技术负责人是Charlie Bachman。在70年代中期，这个小组主要是为了开发一些原型系统而成立的，主要关注数据库系统的设计。<br>70年代中，为了支持数据库系统的访问，需要一个结构化的分布式通信系统体系结构。于是这个小组研究了现有的一些解决方案，其中包括IBM公司的SNA(System Network Architecture)、ARPANET（Internet的前身）的协议、以及为标准化的数据库正在研究中的一些表示服务（presentation services）的相关概念，在1977年提出了一个七层的体系结构模型，他们内部称之为分布式系统体系结构（DSA）。<br>与此同时，1977年英国标准化协会向国际标准化组织（ISO）提议，为了定义分布处理之间的通信基础设施，需要一个标准的体系结构。结果，ISO就开放系统互联（OSI）问题成立了一个专委会（TC 97, Subcomittee 16），指定由美国国家标准协会（ANSI）开发一个标准草案，在专委会第一次正式会议之前提交。Bachman 参加了ANSI早期的会议，并提交了他的七层模型，这个模型就成了提交ISO专委会的唯一的一份草案。<br>1978年3月，在ISO的OSI专委会在华盛顿召开的会议上，与会专家很快达成了共识，认为这个分层的体系结构能够满足开放式系统的大多数需求，而且具有可扩展的能力，能够满足新的需求。于是，1978年发布了这个临时版本，1979年稍作细化之后，成了最终的版本。所以，OSI模型和1977年DSA模型基本相同。</p><h2 id="模型优点"><a href="#模型优点" class="headerlink" title="模型优点"></a>模型优点</h2><p>建立七层模型的主要目的是为解决异种网络互连时所遇到的兼容性问题。它的最大优点是将服务、接口和协议这三个概念明确地区分开来：服务说明某一层为上一层提供一些什么功能，接口说明上一层如何使用下层的服务，而协议涉及如何实现本层的服务；这样各层之间具有很强的独立性，互连网络中各实体采用什么样的协议是没有限制的，只要向上提供相同的服务并且不改变相邻层的接口就可以了。网络七层的划分也是为了使网络的不同功能模块（不同层次）分担起不同的职责，从而带来如下好处： 　　<br>● 减轻问题的复杂程度，一旦网络发生故障，可迅速定位故障所处层次，便于查找和纠错； 　　<br>● 在各层分别定义标准接口，使具备相同对等层的不同网络设备能实现互操作，各层之间则相对独立，一种高层协议可放在多种低层协议上运行； 　　<br>● 能有效刺激网络技术革新，因为每次更新都可以在小范围内进行，不需对整个网络动大手术； 　　<br>● 便于研究和教学。</p><h2 id="详细介绍"><a href="#详细介绍" class="headerlink" title="详细介绍"></a>详细介绍</h2><p>OSI中的上面4层（应用层、表示层、会话层、传输层）为高层，定义了程序的功能；下面3层（网络层、数据链路层、物理层）为低层，主要是处理面向网络的端到端数据流。</p><p>有一张网络图，我觉得总结的很好：</p><p><img src="https://www.cmdbyte.com/2021/02/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png" alt="七层网络模型"></p><h3 id="应用层（Application-Layer）"><a href="#应用层（Application-Layer）" class="headerlink" title="应用层（Application Layer）"></a>应用层（Application Layer）</h3><p>应用层是最靠近用户的OSI层。这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。。<br>协议有：HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP等。</p><p>应用层也称为应用实体（AE），它由若干个特定应用服务元素（SASE）和一个或多个公用应用服务元素（CASE）组成。每个SASE提供特定的应用服务，例如文件运输访问和管理（FTAM）、电子文电处理（MHS）、虚拟终端协议（VAP）等。CASE提供一组公用的应用服务，例如联系控制服务元素（ACSE）、可靠运输服务元素（RTSE）和远程操作服务元素（ROSE）等。主要负责对软件提供接口以使程序能使用网络服务。术语“应用层”并不是指运行在网络上的某个特别应用程序 ，应用层提供的服务包括文件传输、文件管理以及电子邮件的信息处理。</p><h3 id="表示层（Presentation-Layer）"><a href="#表示层（Presentation-Layer）" class="headerlink" title="表示层（Presentation Layer）"></a>表示层（Presentation Layer）</h3><p>数据的表示、安全、压缩。可确保一个系统的应用层所发送的信息可以被另一个系统的应用层读取。<br>格式有：JPEG、ASCll、DECOIC、加密格式等。</p><p>应用程序和网络之间的翻译官，在表示层，数据将按照网络能理解的方案进行格式化；这种格式化也因所使用网络的类型不同而不同。 　　</p><p>表示层管理数据的解密与加密，如系统口令的处理。例如：在 Internet上查询你银行账户，使用的即是一种安全连接。你的账户数据在发送前被加密，在网络的另一端，表示层将对接收到的数据解密。除此之外，表示层协议还对图片和文件格式信息进行解码和编码。</p><h3 id="会话层（Session-Layer）"><a href="#会话层（Session-Layer）" class="headerlink" title="会话层（Session Layer）"></a>会话层（Session Layer）</h3><p>建立、管理、终止会话，对应主机进程，指本地主机与远程主机正在进行的会话。<br>通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。主要在你的系统之间发起会话或者接受会话请求（设备之间需要互相认识可以是IP也可以是MAC或者是主机名）。</p><p>负责在网络中的两节点之间建立、维持和终止通信。 会话层的功能包括：建立通信链接，保持会话过程通信链接的畅通，同步两个节点之间的对话，决定通信是否被中断以及通信中断时决定从何处重新发送。 　　</p><p>你可能常常听到有人把会话层称作网络通信的“交通警察”。当通过拨号向你的 ISP （因特网服务提供商）请求连接到因特网时，ISP 服务器上的会话层向你与你的 PC 客户机上的会话层进行协商连接。若你的电话线偶然从墙上插孔脱落时，你终端机上的会话层将检测到连接中断并重新发起连接。会话层通过决定节点通信的优先级和通信时间的长短来设置通信期限。</p><h3 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h3><p>定义传输数据的协议端口号，以及流控和差错校验。<br>协议有：TCP UDP等，数据包一旦离开网卡即进入网络传输层。</p><p>定义了一些传输数据的协议和端口号（WWW端口80等），如：TCP（传输控制协议，传输效率低，可靠性强，用于传输可靠性要求高，数据量大的数据），UDP（用户数据报协议，与TCP特性恰恰相反，用于传输可靠性要求不高，数据量小的数据，如QQ聊天数据就是通过这种方式传输的）。 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。常常把这一层数据叫做段。</p><p>O S I 模型中最重要的一层。传输协议同时进行流量控制或是基于接收方可接收数据的快慢程度规定适当的发送速率。除此之外，传输层按照网络能处理的最大尺寸将较长的数据包进行强制分割。例如，以太网无法接收大于1 5 0 0 字节的数据包。发送方节点的传输层将数据分割成较小的数据片，同时对每一数据片安排一序列号，以便数据到达接收方节点的传输层时，能以正确的顺序重组。该过程即被称为排序。工作在传输层的一种服务是 T C P &#x2F; I P 协议套中的T C P （传输控制协议），另一项传输层服务是I P X &#x2F; S P X 协议集的S P X （序列包交换）。</p><h3 id="网络层（Network-Layer）"><a href="#网络层（Network-Layer）" class="headerlink" title="网络层（Network Layer）"></a>网络层（Network Layer）</h3><p>进行逻辑地址寻址，实现不同网络之间的路径选择。<br>协议有：ICMP IGMP IP（IPV4 IPV6） ARP RARP等。</p><p>在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。Internet的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。</p><p>O S I 模型的第三层，其主要功能是将网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接收方。 　<br>　<br>网络层通过综合考虑发送优先权、网络拥塞程度、服务质量以及可选路由的花费来决定从一个网络中节点A 到另一个网络中节点B 的最佳路径。由于网络层处理，并智能指导数据传送，路由器连接网络各段，所以路由器属于网络层。在网络中，“路由”是基于编址方案、使用模式以及可达性来指引数据的发送。<br>　　<br>网络层负责在源机器和目标机器之间建立它们所使用的路由。这一层本身没有任何错误检测和修正机制，因此，网络层必须依赖于端端之间的由D L L提供的可靠传输服务。 　　</p><p>网络层用于本地L A N网段之上的计算机系统建立通信，它之所以可以这样做，是因为它有自己的路由地址结构，这种结构与第二层机器地址是分开的、独立的。这种协议称为路由或可路由协议。路由协议包括I P、N o v e l l公司的I P X以及A p p l e Ta l k协议。 　　</p><p>网络层是可选的，它只用于当两个计算机系统处于不同的由路由器分割开的网段这种情况，或者当通信应用要求某种网络层或传输层提供的服务、特性或者能力时。例如，当两台主机处于同一个L A N网段的直接相连这种情况，它们之间的通信只使用L A N的通信机制就可以了(即OSI 参考模型的一二层)。</p><h3 id="数据链路层（Datalink-Layer）"><a href="#数据链路层（Datalink-Layer）" class="headerlink" title="数据链路层（Datalink Layer）"></a>数据链路层（Datalink Layer）</h3><p>建立逻辑连接、进行硬件地址寻址、差错校验等功能。（由底层网络定义协议）<br>将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正。</p><p>数据链路层协议的代表包括：SDLC、HDLC、PPP、STP、帧中继等。</p><p>定义了如何让格式化数据以进行传输，以及如何让控制对物理介质的访问。这一层通常还提供错误检测和纠正，以确保数据的可靠传输。</p><p>OSI模型的第二层，它控制网络层与物理层之间的通信。它的主要功能是如何在不可靠的物理线路上进行数据的可靠传递。为了保证传输，从网络层接收到的数据被分割成特定的可被物理层传输的帧。帧是用来移动数据的结构包，它不仅包括原始数据，还包括发送方和接收方的物理地址以及检错和控制信息。其中的地址确定了帧将发送到何处，而纠错和控制信息则确保帧无差错到达。 如果在传送数据时，接收点检测到所传数据中有差错，就要通知发送方重发这一帧。<br>　　<br>数据链路层的功能独立于网络和它的节点和所采用的物理层类型，它也不关心是否正在运行 Wo r d 、E x c e l 或使用I n t e r n e t 。有一些连接设备，如交换机，由于它们要对帧解码并使用帧信息将数据发送到正确的接收方，所以它们是工作在数据链路层的。 　　</p><p>数据链路层（DataLinkLayer):在物理层提供比特流服务的基础上，建立相邻结点之间的数据链路，通过差错控制提供数据帧（Frame）在信道上无差错的传输，并进行各电路上的动作系列。 　<br>　<br>数据链路层在不可靠的物理介质上提供可靠的传输。该层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。</p><h3 id="物理层（Physical-Layer）"><a href="#物理层（Physical-Layer）" class="headerlink" title="物理层（Physical Layer）"></a>物理层（Physical Layer）</h3><p>建立、维护、断开物理连接。（由底层网络定义协议）</p><p>主要定义物理设备标准，如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。它的主要作用是传输比特流（就是由1、0转化为电流强弱来进行传输,到达目的地后在转化为1、0，也就是我们常说的数模转换与模数转换）。这一层的数据叫做比特。</p><p>O S I 模型的最低层或第一层，该层包括物理连网媒介，如电缆连线连接器。物理层的协议产生并检测电压以便发送和接收携带数据的信号。在你的桌面P C 上插入网络接口卡，你就建立了计算机连网的基础。换言之，你提供了一个物理层。尽管物理层不提供纠错服务，但它能够设定数据传输速率并监测数据出错率。网络物理问题，如电线断开，将影响物理层。 　　用户要传递信息就要利用一些物理媒体，如双绞线、同轴电缆等，但具体的物理媒体并不在OSI的7层之内，有人把物理媒体当做第0层，物理层的任务就是为它的上一层提供一个物理连接，以及它们的机械、电气、功能和过程特性。如规定使用电缆和接头的类型、传送信号的电压等。在这一层，数据还没有被组织，仅作为原始的位流或电气电压处理，单位是bit比特。</p><h3 id="补充知识"><a href="#补充知识" class="headerlink" title="补充知识"></a>补充知识</h3><p>一个设备工作在哪一层，关键看它工作时利用哪一层的数据头部信息。网桥工作时，是以MAC头部来决定转发端口的，因此显然它是数据链路层的设备。<br>具体说:<br>物理层：网卡，网线，集线器，中继器，调制解调器<br>数据链路层：网桥，交换机<br>网络层：路由器<br>网关工作在第四层传输层及其以上。<br>集线器是物理层设备,采用广播的形式来传输信息。<br>交换机就是用来进行报文交换的机器。多为链路层设备(二层交换机)，能够进行地址学习，采用存储转发的形式来交换报文.。<br>路由器的一个作用是连通不同的网络，另一个作用是选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率。</p><h4 id="交换机和路由器的区别"><a href="#交换机和路由器的区别" class="headerlink" title="交换机和路由器的区别"></a>交换机和路由器的区别</h4><p>交换机拥有一条很高带宽的背部总线和内部交换矩阵。交换机的所有的端口都挂接在这条总线上，控制电路收到数据包以后，处理端口会查找内存中的地址对照表以确定目的MAC（网卡的硬件地址）的NIC（网卡）挂接在哪个端口上，通过内部交换矩阵迅速将数据包传送到目的端口，目的MAC若不存在则广播到所有的端口，接收端口回应后交换机会“学习”新的地址，并把它添加入内部MAC地址表中。</p><p>使用交换机也可以把网络“分段”，通过对照MAC地址表，交换机只允许必要的网络流量通过交换机。通过交换机的过滤和转发，可以有效的隔离广播风暴，减少误包和错包的出现，避免共享冲突。</p><p>交换机在同一时刻可进行多个端口对之间的数据传输。每一端口都可视为独立的网段，连接在其上的网络设备独自享有全部的带宽，无须同其他设备竞争使用。当节点A向节点D发送数据时，节点B可同时向节点C发送数据，而且这两个传输都享有网络的全部带宽，都有着自己的虚拟连接。假使这里使用的是10Mbps的以太网交换机，那么该交换机这时的总流通量就等于2×10Mbps＝20Mbps，而使用10Mbps的共享式HUB时，一个HUB的总流通量也不会超出10Mbps。</p><p>总之，交换机是一种基于MAC地址识别，能完成封装转发数据包功能的网络设备。交换机可以“学习”MAC地址，并把其存放在内部地址表中，通过在数据帧的始发者和目标接收者之间建立临时的交换路径，使数据帧直接由源地址到达目的地址。</p><p>从过滤网络流量的角度来看，路由器的作用与交换机和网桥非常相似。但是与工作在网络物理层，从物理上划分网段的交换机不同，路由器使用专门的软件协议从逻辑上对整个网络进行划分。例如，一台支持IP协议的路由器可以把网络划分成多个子网段，只有指向特殊IP地址的网络流量才可以通过路由器。对于每一个接收到的数据包，路由器都会重新计算其校验值，并写入新的物理地址。因此，使用路由器转发和过滤数据的速度往往要比只查看数据包物理地址的交换机慢。但是，对于那些结构复杂的网络，使用路由器可以提高网络的整体效率。路由器的另外一个明显优势就是可以自动过滤网络广播。</p><h4 id="集线器与路由器在功能上有什么不同"><a href="#集线器与路由器在功能上有什么不同" class="headerlink" title="集线器与路由器在功能上有什么不同?"></a>集线器与路由器在功能上有什么不同?</h4><p>首先说HUB,也就是集线器。它的作用可以简单的理解为将一些机器连接起来组成一个局域网。而交换机（又名交换式集线器）作用与集线器大体相同。但是两者在性能上有区别：集线器采用的式共享带宽的工作方式，而交换机是独享带宽。这样在机器很多或数据量很大时，两者将会有比较明显的。而路由器与以上两者有明显区别，它的作用在于连接不同的网段并且找到网络中数据传输最合适的路径。路由器是产生于交换机之后，就像交换机产生于集线器之后，所以路由器与交换机也有一定联系，不是完全独立的两种设备。路由器主要克服了交换机不能路由转发数据包的不足。</p><p>总的来说，路由器与交换机的主要区别体现在以下几个方面：</p><p>（1）工作层次不同<br>最初的的交换机是工作在数据链路层，而路由器一开始就设计工作在网络层。由于交换机工作在数据链路层，所以它的工作原理比较简单，而路由器工作在网络层，可以得到更多的协议信息，路由器可以做出更加智能的转发决策。</p><p>（2）数据转发所依据的对象不同<br>交换机是利用物理地址或者说MAC地址来确定转发数据的目的地址。而路由器则是利用IP地址来确定数据转发的地址。IP地址是在软件中实现的，描述的是设备所在的网络。MAC地址通常是硬件自带的，由网卡生产商来分配的，而且已经固化到了网卡中去，一般来说是不可更改的。而IP地址则通常由网络管理员或系统自动分配。</p><p>（3）传统的交换机只能分割冲突域，不能分割广播域；而路由器可以分割广播域<br>由交换机连接的网段仍属于同一个广播域，广播数据包会在交换机连接的所有网段上传播，在某些情况下会导致通信拥挤和安全漏洞。连接到路由器上的网段会被分配成不同的广播域，广播数据不会穿过路由器。虽然第三层以上交换机具有VLAN功能，也可以分割广播域，但是各子广播域之间是不能通信交流的，它们之间的交流仍然需要路由器。</p><p>（4）路由器提供了防火墙的服务<br>路由器仅仅转发特定地址的数据包，不传送不支持路由协议的数据包传送和未知目标网络数据包的传送，从而可以防止广播风暴。</p><p>资料来源：</p><p><a href="http://baike.baidu.com/link?url=VsZda3rzpfER6lUvXIfxOH438oYPOYTccMXy4eCIaO-v8Jnmo8DwfFKMJG8Hw1EJdSDnlcrKgp91e5y4G5Vs_a">百度百科：七层模型</a></p><p><a href="http://blog.csdn.net/superjunjin/article/details/7841099">TCP&#x2F;IP四层模型和OSI七层模型的概念</a></p><p><a href="http://blog.csdn.net/yaopeng_2005/article/details/7064869">OSI七层模型详解</a></p>]]></content>
    
    
    <categories>
      
      <category>Network</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Network</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>服务器应对大流量高并发访问的处理方法</title>
    <link href="/2021/03/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BA%94%E5%AF%B9%E5%A4%A7%E6%B5%81%E9%87%8F%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/"/>
    <url>/2021/03/11/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BA%94%E5%AF%B9%E5%A4%A7%E6%B5%81%E9%87%8F%E9%AB%98%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%9A%84%E5%A4%84%E7%90%86%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是高并发"><a href="#什么是高并发" class="headerlink" title="什么是高并发"></a>什么是高并发</h2><p>高并发（High Concurrency）通常是指通过设计保证系统能够同时并行处理很多请求。</p><p>通俗来讲，高并发是指在同一个时间点，有很多用户同时的访问同一 API 接口或者 Url 地址。它经常会发生在有大活跃用户量，用户高聚集的业务场景中。例如：12306的抢票情况；天猫双十一活动。</p><h3 id="高并发相关的一些指标"><a href="#高并发相关的一些指标" class="headerlink" title="高并发相关的一些指标"></a>高并发相关的一些指标</h3><ul><li>响应时间(Response Time)：系统对请求作出响应的时间，如果系统处理一个HTTP请求需要200ms，那么系统的响应时间就是200ms</li><li>吞吐量(Throughput)：单位时间内处理的请求数量</li><li>每秒查询速率QPS(Query Per Second)：每秒响应请求数量，一般和吞吐量分的不明显</li><li>并发用户数：同时承载正常使用系统功能的用户数量，例如一个IM系统，同时在线用户数量一定程度上代表了系统的并发用户数这个指标</li></ul><h2 id="提升系统的并发处理能力"><a href="#提升系统的并发处理能力" class="headerlink" title="提升系统的并发处理能力"></a>提升系统的并发处理能力</h2><h3 id="分布式架构设计"><a href="#分布式架构设计" class="headerlink" title="分布式架构设计"></a>分布式架构设计</h3><p>互联网的分布式架构设计是提升系统并发处理能力的方式之一，其在方法上主要有两种，一种是做垂直拓展，一种是做水平拓展。</p><ul><li>垂直拓展</li></ul><p>垂直拓展方式主要是提升单机的处理能力，也分为两种：一种是硬件层面，即升级单机的配置，比如增加内存，更换性能更好的CPU等；另一种是升级单机的架构，比如对常用的资源做缓存来减少I&#x2F;O次数，使用异步增加单服务的吞吐量，减少锁的使用来减少响应时间等</p><ul><li>水平拓展</li></ul><p>增加处理请求的服务器数量</p><h4 id="常见的互联网分层架构"><a href="#常见的互联网分层架构" class="headerlink" title="常见的互联网分层架构"></a>常见的互联网分层架构</h4><p><img src="https://www.cmdbyte.com/2021/02/20180607142425564.png"></p><p>常见互联网分布式架构如上，分为：</p><p>（1）客户端层：典型调用方是浏览器browser或者手机应用APP</p><p>（2）反向代理层：系统入口，反向代理</p><p>（3）站点应用层：实现核心应用逻辑，返回html或者json</p><p>（4）服务层：如果实现了服务化，就有这一层</p><p>（5）数据-缓存层：缓存加速访问存储</p><p>（6）数据-数据库层：数据库固化数据存储</p><p>整个系统各层次的水平扩展，又分别是如何实施的呢？</p><h4 id="分层水平拓展架构实践"><a href="#分层水平拓展架构实践" class="headerlink" title="分层水平拓展架构实践"></a>分层水平拓展架构实践</h4><h5 id="反向代理的水平拓展"><a href="#反向代理的水平拓展" class="headerlink" title="反向代理的水平拓展"></a>反向代理的水平拓展</h5><p><img src="https://www.cmdbyte.com/2021/02/20180607142445150.png" alt="反向代理的水平拓展"></p><p>反向代理层的水平扩展，是通过“DNS轮询”实现的：dns-server对于一个域名配置了多个解析ip，每次DNS解析请求来访问dns-server，会轮询返回这些ip。</p><p>当nginx成为瓶颈的时候，只要增加服务器数量，新增nginx服务的部署，增加一个外网ip，就能扩展反向代理层的性能，做到理论上的无限高并发。</p><h5 id="站点层的水平拓展"><a href="#站点层的水平拓展" class="headerlink" title="站点层的水平拓展"></a>站点层的水平拓展</h5><p><img src="https://www.cmdbyte.com/2021/02/1151134-20170601181423883-757482818.png" alt="站点层的水平拓展"></p><p>站点层的水平扩展，是通过“nginx”实现的。通过修改nginx.conf，可以设置多个web后端。</p><p>当web后端成为瓶颈的时候，只要增加服务器数量，新增web服务的部署，在nginx配置中配置上新的web后端，就能扩展站点层的性能，做到理论上的无限高并发。</p><h5 id="服务层的水平拓展"><a href="#服务层的水平拓展" class="headerlink" title="服务层的水平拓展"></a>服务层的水平拓展</h5><p><img src="https://www.cmdbyte.com/2021/02/1151134-20170601181540727-1420144971.png" alt="服务层的水平拓展"></p><p>服务层的水平扩展，是通过“服务连接池”实现的。</p><p>站点层通过RPC-client调用下游的服务层RPC-server时，RPC-client中的连接池会建立与下游服务多个连接，当服务成为瓶颈的时候，只要增加服务器数量，新增服务部署，在RPC-client处建立新的下游服务连接，就能扩展服务层性能，做到理论上的无限高并发。如果需要优雅的进行服务层自动扩容，这里可能需要配置中心里服务自动发现功能的支持。</p><h5 id="数据层的水平拓展"><a href="#数据层的水平拓展" class="headerlink" title="数据层的水平拓展"></a>数据层的水平拓展</h5><p>在数据量很大的情况下，数据层（缓存，数据库）涉及数据的水平扩展，将原本存储在一台服务器上的数据（缓存，数据库）水平拆分到不同服务器上去，以达到扩充系统性能的目的。</p><p>数据层的水平拓展也分为好几种，以数据库为例：</p><ol><li><p>按照范围水平拆分</p><p> <img src="https://www.cmdbyte.com/2021/02/1151134-20170601181656196-718003791.png" alt="按照范围水平拆分"></p><p> 每一个数据服务，存储一定范围的数据，上图为例：</p><p> user0库，存储uid范围1-1kw</p><p> user1库，存储uid范围1kw-2kw</p><p> 这个方案的好处是：</p><p> （1）规则简单，service只需判断一下uid范围就能路由到对应的存储服务；</p><p> （2）数据均衡性较好；</p><p> （3）比较容易扩展，可以随时加一个uid[2kw,3kw]的数据服务；</p><p> 不足是：</p><p>   请求的负载不一定均衡，一般来说，新注册的用户会比老用户更活跃，大范围的服务请求压力会更大；</p></li><li><p>按照哈希水平拆分</p><p> <img src="https://www.cmdbyte.com/2021/02/1151134-20170601181748821-5092464.png" alt="按照哈希表水平拆分"></p><p> 这个方案的好处是：</p><p> （1）规则简单，service只需对uid进行hash能路由到对应的存储服务；</p><p> （2）数据均衡性较好；</p><p> （3）请求均匀性较好；</p><p> 不足是：</p><p>   不容易扩展，扩展一个数据服务，hash方法改变时候，可能需要进行数据迁移；</p></li><li><p>通过主从同步读写分离拓展数据库性能</p><p> 这里需要注意的是，通过水平拆分来扩充系统性能，与主从同步读写分离来扩充数据库性能的方式有本质的不同。</p><p> 通过水平拆分扩展数据库性能：</p><p> （1）每个服务器上存储的数据量是总量的1&#x2F;n，所以单机的性能也会有提升；</p><p> （2）n个服务器上的数据没有交集，那个服务器上数据的并集是数据的全集；</p><p> （3）数据水平拆分到了n个服务器上，理论上读性能扩充了n倍，写性能也扩充了n倍（其实远不止n倍，因为单机的数据量变为了原来的1&#x2F;n）；</p><p> 通过主从同步读写分离扩展数据库性能：</p><p> （1）每个服务器上存储的数据量是和总量相同；</p><p> （2）n个服务器上的数据都一样，都是全集；</p><p> （3）理论上读性能扩充了n倍，写仍然是单点，写性能不变；</p></li></ol><p>缓存层的水平拆分和数据库层的水平拆分类似，也是以范围拆分和哈希拆分的方式居多，就不再展开。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>高并发（High Concurrency）是互联网分布式系统架构设计中必须考虑的因素之一，它通常是指，通过设计保证系统能够同时并行处理很多请求。</p><p>提高系统并发能力的方式，方法论上主要有两种：垂直扩展（Scale Up）与水平扩展（Scale Out）。前者垂直扩展可以通过提升单机硬件性能，或者提升单机架构性能，来提高并发性，但单机性能总是有极限的，互联网分布式架构设计高并发终极解决方案还是后者：水平扩展。</p><p>互联网分层架构中，各层次水平扩展的实践又有所不同：</p><p>（1）反向代理层可以通过“DNS轮询”的方式来进行水平扩展；</p><p>（2）站点层可以通过nginx来进行水平扩展；</p><p>（3）服务层可以通过服务连接池来进行水平扩展；</p><p>（4）数据库可以按照数据范围，或者数据哈希的方式来进行水平扩展；</p><p>各层实施水平扩展后，能够通过增加服务器数量的方式来提升系统的性能，做到理论上的性能无限。</p><p>未完结。。。，下次从2，3开始</p><p>参考链接：</p><ol><li><p><a href="https://blog.csdn.net/weixin_42476601/article/details/82220027">https://blog.csdn.net/weixin_42476601/article/details/82220027</a></p></li><li><p><a href="https://blog.csdn.net/xuxiaopang0417/article/details/79620670">https://blog.csdn.net/xuxiaopang0417/article/details/79620670</a></p></li><li><p><a href="https://blog.csdn.net/qq_31770711/article/details/84068144">https://blog.csdn.net/qq_31770711/article/details/84068144</a></p></li></ol>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技术</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go的字符rune</title>
    <link href="/2021/03/10/Go%E7%9A%84%E5%AD%97%E7%AC%A6rune/"/>
    <url>/2021/03/10/Go%E7%9A%84%E5%AD%97%E7%AC%A6rune/</url>
    
    <content type="html"><![CDATA[<p>golang的字符称为rune，等价于C中的char，可直接与整数转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> c <span class="hljs-type">rune</span>=<span class="hljs-string">&#x27;a&#x27;</span> <br><span class="hljs-keyword">var</span> i <span class="hljs-type">int</span> =<span class="hljs-number">98</span><br>i1:=<span class="hljs-type">int</span>(c)<br>fmt.Println(<span class="hljs-string">&quot;&#x27;a&#x27; convert to&quot;</span>,i1) <span class="hljs-comment">//98</span><br>c1:=<span class="hljs-type">rune</span>(i)<br>fmt.Println(<span class="hljs-string">&quot;98 convert to&quot;</span>,<span class="hljs-type">string</span>(c1)) <span class="hljs-comment">//a</span><br><br><span class="hljs-comment">//string to rune</span><br><span class="hljs-keyword">for</span> _, char := <span class="hljs-keyword">range</span> []<span class="hljs-type">rune</span>(<span class="hljs-string">&quot;世界你好&quot;</span>) &#123;<br>    fmt.Println(<span class="hljs-type">string</span>(char))<br>&#125;<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">&#x27;a&#x27; convert to 97<br>98 convert to b<br>世<br>界<br>你<br>好<br></code></pre></td></tr></table></figure><p>rune实际是int32类型，必需先将其转换为string才能打印出来，否则打印出来的是一个整数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">c:=<span class="hljs-string">&#x27;a&#x27;</span><br>fmt.Println(c)<br>fmt.Println(<span class="hljs-type">string</span>(c))<br>fmt.Println(<span class="hljs-type">string</span>(<span class="hljs-number">97</span>))<br></code></pre></td></tr></table></figure><p>输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">97<br>a<br>a<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>为什么使用Go</title>
    <link href="/2021/03/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Go/"/>
    <url>/2021/03/10/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8Go/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文来自：<a href="https://studygolang.com/wr?u=http://segmentfault.com">Segmentfault</a></p><p>感谢作者：Yumiku</p><p>查看原文：<a href="https://studygolang.com/wr?u=https://segmentfault.com/a/1190000022285902">为什么要用Go语言？</a></p></blockquote><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易[1]。</p><p>Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。对于高性能分布式系统领域而言，Go语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了[1]。</p></blockquote><p>其实早在2018年前，我就已经有在国内的程序员环境中断断续续地听到Go语言的消息，Go语言提供的方便的并发编程方式，十分适合我当时选择的毕业设计选题，但是受限于导师的语言选择、项目的进度追赶、考研的时间压榨，一直没有机会来好好地学习这门语言。</p><p>在进入研究生阶段后，尽管研究的方向和算法相关，但未来的职业方向还是选择了以后端为主，主要是因为想做更多和业务相关的工作。为了能在有限的时间里给予自己足够深的知识底蕴，选择了一些让自己去深入了解的方向，Go语言自然也在其中，今天终于有机会来开始研究这门语言。</p><h2 id="为什么要用Go语言？"><a href="#为什么要用Go语言？" class="headerlink" title="为什么要用Go语言？"></a>为什么要用Go语言？</h2><p>撰写此文的初衷，是本文的标题，也是我作为初学者一直以来的疑问：</p><p><strong>“我为什么要用Go语言？”</strong></p><p>为了回答这个问题，我翻阅了很多Go语言相关的文档、书籍和教程，<strong>我发现我很难在它们之中找到非常明显直接的答案</strong>，书上和教程只会说，<strong>“是的，Go语言好用”</strong>。</p><p>对于部分人来说，这个问题的答案或许很“明显”，比如选择Go语言是因为Google设计的语言、Go开发赚的钱多、XX公司使用Go语言等等，如果想要了解这门语言更加本质的东西，仅仅这些答案我认为是还不够的。</p><p>部分Go的教徒可能会说，<strong>他们选择的理由是和语言本身相关的</strong>，比如：</p><ul><li><strong>Go编译快</strong></li><li><strong>Go执行快</strong></li><li><strong>Go并发编程方便</strong></li><li><strong>Go有垃圾回收(Garbage Collection, GC)</strong></li></ul><p>的确，Go是有这些特点，<strong>但这并非都是Go独有的</strong>：</p><ul><li>运行时解释的脚本语言（比如Python）几乎不需要时间编译</li><li>C、C++甚至是汇编，基本上能够榨干一台机器的大部分性能</li><li>大部分语言都有并发编程的支持库</li><li>大部分语言都不需要程序员主动关注内存情况</li></ul><p>一些Go的忠实粉丝把这种<strong>All in One</strong>的特性作为评价语言的标准，他们认为至少在这些方面，Go是可以完美的代替其他语言的。</p><p><strong>那么，Go真的能优秀到完全替代另一个语言么？</strong></p><p>其实未必，我始终认为银弹是不存在的[2]，无论是在这次调查前，还是在这次调查后。</p><p>本文从Go语言被设计的初衷出发，深入互联网各种角落，调查Go所具有的那些特性是否足够优秀，同时和其他语言进行适当的比较，你可以选择性的阅读、接受或者反对我的内容，毕竟有交流才能传播知识。</p><p><strong>我的最终目的是让更多的初学者看到Go没有轻易暴露出的缺点，同时也能看到Go真正优秀的地方</strong>。</p><h3 id="设计Go的初衷"><a href="#设计Go的初衷" class="headerlink" title="设计Go的初衷"></a>设计Go的初衷</h3><blockquote><p>Go语言的主要目标是将静态语言的安全性和高效性与动态语言的易开发性进行有机结合，达到完美平衡，从而使编程变得更加有乐趣，而不是在艰难抉择中痛苦前行[3]。</p></blockquote><p>Google公司不可能无缘无故地设计一个新语言（一些特性相比于其他语言也没有新到哪里去），这一切肯定是有原因的。</p><p>设计Go语言是为了解决当时Google开发遇到的一些问题[4]：</p><ul><li>C++编译慢、没有现代化（入门级友好的）的内存管理</li><li>数以万计行的代码，难以维护</li><li>部署的平台各式各样，交叉编译困难</li><li>……</li></ul><p><img src="https://www.cmdbyte.com/2021/02/b630f4455797400dc088aa9296553303.png"></p><p><strong>找不到什么合适的语言，想着反正都是弄来自己用，Google选择造个轮子试试。</strong></p><blockquote><p>Go 语言起源 2007 年，并于 2009 年正式对外发布。它从 2009 年 9 月 21 日开始作为谷歌公司 20%兼职项目，即相关员工利用 20% 的空余时间来参与 Go 语言的研发工作。该项目的三位领导者均是著名的 IT 工程师：Robert Griesemer，参与开发 Java HotSpot 虚拟机；Rob Pike，Go 语言项目总负责人，贝尔实验室 Unix 团队成员，参与的项目包括 Plan 9，Inferno 操作系统和 Limbo 编程语言；Ken Thompson，贝尔实验室 Unix 团队成员，C 语言、Unix 和 Plan 9 的创始人之一，与 Rob Pike 共同开发了 UTF-8 字符集规范。自 2008 年 1 月起，Ken Thompson 就开始研发一款以 C 语言为目标结果的编译器来拓展 Go 语言的设计思想[3]。</p></blockquote><p><img src="https://www.cmdbyte.com/2021/02/1d0cd732976596f83a48008f84adfbb4.png" alt="Go 语言设计者：Griesemer、Thompson 和 Pike [3]"></p><p>当时Google的很多工程师是用的都是C&#x2F;C++，所以语法的设计上接近于C，Go的设计师们想要解决其他语言使用中的缺点，但是仍保留他们的优点[5]：</p><ul><li>静态类型和运行时效率</li><li>可读性和易用性</li><li>高性能的网络和多进程</li><li>…</li></ul><p>emmm，这些听起来还是比较玄乎，毕竟设计归设计，实现归实现，我们回顾一下现在Go的几个主要特点，编译速度、执行速度、内存管理以及并发编程。</p><h3 id="Go的编译为什么快"><a href="#Go的编译为什么快" class="headerlink" title="Go的编译为什么快"></a>Go的编译为什么快</h3><p>当然，设计Go语言也不是完全从零开始，最初Go的团队尝试设计实现一个Go语言的编译前端，由基于C的gcc编译器来编译成机器代码，这个面向gcc的前端编译器也就是目前的Go编译器之一的gccgo。</p><p><strong>与其说Go的编译为什么快，不如先说说C++的编译为什么慢</strong>，C++也可以用gcc编译，编译速度的大部分差异很有可能来源于语言设计本身。</p><p>在讨论问题之前，其中需要先说明的一点是：<strong>这里比较的编译速度都是在静态编译下的</strong>。</p><p>静态编译和动态编译的区别：</p><ul><li>静态编译：编译器在编译可执行文件时，要把使用到的链接库提取出来，链接打包进可执行文件中，编译结果只有一个可执行文件。</li><li>动态编译：可执行文件需要附带独立的库文件，不打包库到可执行文件中，减少可执行文件体积，在执行的时候再调用库即可。</li></ul><p>两种方式有各自的优点和缺点，前者不需要去管理不同版本库的兼容性问题，后者可以减少内存和存储的占用（因为可以让不同程序共享同一个库），两种方式孰优孰弱，要对应到具体的工程问题上，<strong>Go默认的编译方式是静态编译</strong>。</p><p>回到我们要讨论的问题：C++的编译为什么慢？</p><p>**C++编译慢的主要两个大头原因[6]**：</p><ul><li>头文件的include方式</li><li>模板的编译</li></ul><p>C++使用include方式引用头文件，会让需要编译的代码有乘数级的增加，例如当同一个头文件被同一个项目下的N个文件include时，编译器会将头文件引入到每一份代码中，所以同一个头文件会被编译N次（这在大多数时候都是不必要的）；C++使用的模板是为了支持泛型编程，在编写对不同类型的泛型函数时，可以提供很大的便利，但是这对于编译器来说，会增加非常多不必要的编译负担。</p><p>当然C++对这两个问题有很多后续的优化方法，但是这对于很多开发者来说，他们不想在这上面有过多时间和精力开销。</p><p>大部分后来的编程语言在引入文件的方式上，使用了<strong>import module</strong>来代替<strong>include 头文件</strong>的方式，import解决了重复编译的问题，当然Go也是使用的import方式；在模板的编译问题上，由于Go在设计理念上遵循从简入手，所以没有将泛函编程纳入到设计框架中，所以天生的没有模版编译带来的时间开销（没有泛型支持也是很多人不满Go语言的理由）。</p><p>在Go 的1.5 版本中，Go团队使用Go语言来编写Go语言的编译器（也叫自举），相比于gccgo来说：</p><ul><li>提高了编译速度，但执行速度略有下降（性能细节优化还不如gcc）</li><li>增加了可编译的平台类型（以往受限于gcc）</li></ul><p>在此之外，Go语言语法中的关键字也是非常少的(Go1.11版本里只有25个)[7]，这也可以减少编译器花费在语法解析上的时间开销。</p><p><img src="https://www.cmdbyte.com/2021/02/09710553bc35f1e2600f193f9d7589b7.png"></p><p><strong>所以在我看来，Go编译速度快，主要出于四个原因</strong>：</p><ul><li>使用了import的引用管理方式；</li><li>没有模板的编译负担；</li><li>1.5版本后的自举编译器优化；</li><li>更少的关键字。</li></ul><p><strong>所以为了加快编译速度、放弃C++而转入Go的同时，也要考虑一下是否要放弃泛型编程的优点。</strong></p><p>注：泛型可能在Go 2版本获得支持。</p><h3 id="Go的实际性能如何"><a href="#Go的实际性能如何" class="headerlink" title="Go的实际性能如何"></a>Go的实际性能如何</h3><p>Go的执行速度，可以参考一个语言性能测试数据网站 —— The Computer Language Benchmarks Game[8]。</p><p>这个网站在不同的算法上对每个语言进行测试，然后给出时间和内存上的开销数据比对。</p><p>比较的语言有C++、Java、Python。</p><p>首先是时间开销：</p><p><img src="https://www.cmdbyte.com/2021/02/69bf87eb2705f49af9789d90d882a930.png"></p><p><strong>注意</strong>：<strong>时间开销的单位是s，并且Y轴为了方便进行不同跨度上的比较，所以选取的是对数轴</strong>（即非线性轴，为1-10-100-1000的比较跨度）。</p><p>然后是内存开销：</p><p><img src="https://www.cmdbyte.com/2021/02/6b4991992ee11ecaf49f06e432304466.png"></p><p><strong>注意</strong>：<strong>Y轴为了方便进行不同跨度上的比较，所以选取的是对数轴</strong>（即非线性轴，为1000-10000-100000-1000000的比较跨度）。</p><p>需要注意的是，<strong>语言本身的性能只决定了一个程序的最高理论性能</strong>，程序具体的性能还要取决于这个程序的实现方法，所以当各个语言的性能并没有太大的差异时，性能往往只取决于程序实现的方式。</p><p>通过两个图的数据可以分析：</p><ul><li>Go虽然还无法达到C++那样的极致性能，但是<strong>在大部分情况下已经很接近了</strong>；</li><li>Go和Java在算法的时间开销上难分伯仲，但在内存的开销上Java就要高得多了；</li><li>Go在上述的绝大部分情况下，至少时间和内存开销都比Python要优秀得多；</li></ul><h3 id="Go的并发编程"><a href="#Go的并发编程" class="headerlink" title="Go的并发编程"></a>Go的并发编程</h3><p>Go的并发之所以比较受欢迎，网络上的很多内容集中在几个方面：</p><ul><li><strong>天生并发的设计</strong></li><li><strong>轻量化的并发编程方式</strong></li><li><strong>较高的并发性能</strong></li><li><strong>轻量级线程Goroutines、并发通信Channels以及其他便捷的并发同步控制工具</strong></li></ul><p>由于Go在设计的时候就考虑到了并发的支持，<strong>或者说很多特性都是为了并发而设计</strong>，这和一些后期库支持并发和第三方库支持并发的语言不同。</p><p><strong>所以Go的并发到底有多方便？</strong>在Go中使用并发，只需要在普通的函数执行前加上一个go关键字，就可以新建一个线程让函数在其中执行：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">go</span> loop() <span class="hljs-comment">// 启动一个goroutine</span><br>    loop()<br>&#125;<br></code></pre></td></tr></table></figure><p>这样带来的好处<strong>不仅仅是让并发编程更方便了</strong>，在一些特定情况下，比如Go引用一些使用了并发的库时，这些库所使用的并发也是基于Go本身的并发设计，不会存在库使用另一套并发实现的情况，这样Go调度器在处理程序中的各种并发线程时，可以有更加统一化的管理方式。</p><p>不过Go的并发对于程序的实现要求还是比较高的，在使用一些通信Channel的场合，稍有疏忽就可能出现死锁的问题，比如：</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">fatal</span> <span class="hljs-literal">error</span>: all goroutines are asleep - deadlock!<br></code></pre></td></tr></table></figure><p><strong>Go的并发量可以比大部分语言里普通的线程实现要高</strong>，这受益于轻量级的Goroutine，轻量化主要是它所占用的空间要小得多，例如64位环境下的JVM，它会默认固定为每个线程分配1MB的线程栈空间，而<strong>Goroutines大概只有4-8KB</strong>，之后再按需分配。足够轻量化的线程在相同的内存下也就可以有更高并发量（服务器CPU还没有饱和的情况下），同时也可以减少很多上下文切换的时间开销[9]。但是如果你的每个线程占用空间都非常大时（比如10MB，当然这是非常规需求的情况下），Go的轻量化优势就没有那么明显了。</p><p>Go在并发上的优点很明显，也是Go的功能目标，从语言设计上支持了并发，提供了统一便捷的工具，复杂的并发业务也需要在Go的一整套并发规范体系下进行编程，当然这肯定会牺牲部分实现自由度，但可以获得性能的提高和维护成本的下降。</p><p>PS：关于Go调度器的内容在这里并没有被提及，因为很难用简单的文字向读者说明该调度方式和其他调度方式的优劣，将在未来的某一篇中会细致地介绍Go调度器的内容。</p><h3 id="Go的垃圾回收"><a href="#Go的垃圾回收" class="headerlink" title="Go的垃圾回收"></a>Go的垃圾回收</h3><blockquote><p>垃圾回收（英语：Garbage Collection，缩写为GC），在计算机科学中是一种自动的存储器管理机制。当一个计算机上的动态存储器不再需要时，就应该予以释放，以让出存储器，这种存储器资源管理，称为垃圾回收。垃圾回收器可以让程序员减轻许多负担，也减少程序员犯错的机会[10]。</p></blockquote><p>在使用Go或者其他支持GC的语言时，**不用再像C++一样，手动地去释放不需要的变量占用的内容空间(free&#x2F;delete)**。</p><p><strong>的确，这很方便</strong>（对于懒人和容易忘记主动释放的人），<strong>但是也多了一些限制</strong>（暗箱操作的不透明性以及在GC处理上的性能开销）。<strong>GC也不是万能的</strong>，当遇到一些对性能要求较高的场景，还是需要记得进行一些主动释放或优化操作（比如说自定义内存池）。</p><p>PS：将在未来的某一篇中会细致地介绍Go垃圾回收的细节（如果你们也觉得有必要的话）。</p><h2 id="什么时候可以选择Go？"><a href="#什么时候可以选择Go？" class="headerlink" title="什么时候可以选择Go？"></a>什么时候可以选择Go？</h2><p>Go有很多优点，编译快、性能好、天生并发以及垃圾回收，很多比较有特色的内容也还没有说到（比如gofmt）。</p><p>Go语言也有很多缺点，比如<strong>第三方库支持还不够多</strong>（相比于Python来说就少的太多了）、<strong>支持编译的平台还不够广</strong>、还有<strong>被称为噩梦的依赖版本管理</strong>（已经在改善了，但是还没有达到完全可靠的程度）。</p><p><strong>所以到底Go适合做什么，不适合做什么？</strong></p><p>分析了这么多后，这个问题其实很难回答，但我们可以选择先从不适合的领域把Go剔除掉，看看我们会剩下什么。</p><h3 id="Go不适合做什么"><a href="#Go不适合做什么" class="headerlink" title="Go不适合做什么"></a>Go不适合做什么</h3><ul><li>极致高性能优化的场景，你可能需要使用C&#x2F;C++，甚至是汇编；</li><li>简单流程的脚本工具、数值分析、深度学习，可能Python更适合（至少目前是）；</li><li>搭一个博客或网站，PHP何尝不是天下第一的语言呢；</li><li>如果你想比较方便找到一份的后端工作，绝大部分公司的Java岗一直缺人（在实际生产过程中，目前Go仍没有比Java表现得好太多，至少没有好到让一个部门&#x2F;公司将核心业务重新转向Go来进行重构）；</li><li>…</li></ul><p>你可以找到类似上面那样的很多场景，你可能会发现Go并不能那么完美地替代掉谁。</p><h3 id="Go适合做什么"><a href="#Go适合做什么" class="headerlink" title="Go适合做什么"></a>Go适合做什么</h3><p>最后，到了我们的终极问题，<strong>Go到底适合做什么？</strong></p><p>读到这里你可能会觉得，好像是我把Go的特性吹了一遍，然后突然告诉你可能Go不适合你。</p><p><strong>Go天生并发，面向并发</strong>，所以Go的定位一直很清楚，从最浅显的视角来看，至少Go作为一个有较高性能的并发后端来说，是具有非常大的诱惑力的。</p><p><strong>尤其对于后端相关的程序员而言</strong>，在某些业务功能的<strong>初步实现</strong>上，简洁的语法、内置的并发、快速的编译，都可以让你更加高效快速地完成任务（前提是Go的内容足以完成你的任务），不用再去担忧编译优化和内存回收、不用担心过多的时间和内存开销、不用担心不同版本库之间的冲突（静态编译）以及不用担心交叉编译平台适配问题。</p><p><strong>大部分情况下，编写一个服务，你只需要：实现、编译、部署、运行</strong>。</p><p><strong>高效快速，足够敏捷</strong>，这在企业的绝大部分项目的初期都是适用的，这也是大部分项目对开发初期的要求。当一个项目或者服务真的可以发展下去，需求的确触碰到Go的天花板时，再考虑使用更加好的语言或方法去优化也为时不晚。</p><p>简而言之，尽管Go的过于简洁带来了很多问题（有些人说的难听点叫过于简单），Go所具有的优点，可以让大部分人用编程语言这种工具，来解决对他们而言更加重要的问题。</p><p><strong>Go语言不是银弹，但它的确能有效地解决这些问题。</strong></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li>[1] RUNOOB Go语言教程 菜鸟教程，<a href="https://www.runoob.com/go/go-tutorial.html">https://www.runoob.com/go/go-...</a></li><li>[2] 没有银弹：软件工程的本质性与附属性工作(No Silver Bullet—Essence and Accidents of Software Engineering)，<a href="http://worrydream.com/refs/Brooks-NoSilverBullet.pdf">http://worrydream.com/refs/Br...</a></li><li>[3] The way to Go，<a href="https://github.com/unknwon/the-way-to-go_ZH_CN/blob/master/eBook/01.2.md">https://github.com/unknwon/th...</a></li><li>[4] 我为什么选择使用 Go 语言？，<a href="https://juejin.im/entry/5705f83a8ac247004c04900c">https://juejin.im/entry/5705f...</a></li><li>[5] Wiki - Go，<a href="https://zh.wikipedia.org/wiki/Go">https://zh.wikipedia.org/wiki/Go</a></li><li>[6] 为什么 C++ 编译速度比 Java 慢得多？，<a href="https://www.zhihu.com/question/42964826">https://www.zhihu.com/questio...</a></li><li>[7] Github - eighmcculloch&#x2F;keywords，<a href="https://github.com/leighmcculloch/keywords">https://github.com/leighmccul...</a></li><li>[8] The Computer Language Benchmarks Game，<a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html">https://benchmarksgame-team.p...</a></li><li>[9] 为什么能有上百万个 Goroutines，却只能有上千个 Java 线程？，<a href="https://www.infoq.cn/article/a-million-go-routines-but-only-1000-java-threads">https://www.infoq.cn/article/...</a></li><li>[10] Wiki - 垃圾回收，<a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)">https://en.wikipedia.org/wiki...</a></li></ul><h2 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h2><p>在调查Go的过程中，发现了一些比较有意思、或者比较实用的文章，一并附在这里。</p><ul><li><a href="https://juejin.im/entry/5705f83a8ac247004c04900c">我为什么选择使用 Go 语言？</a>，该文写于2016年，在我的文章基本构思完成的时候，偶然看到了这篇文章，作者有很多早期Go版本的开发经验，里面有更多的细节都是出自于工程师的经验之谈，我发现其中的部分想法和我不谋而合，你可以把这篇文章当作本文的后续扩展阅读，不过要注意文章的时效，可能提及到的一些Go的缺点现在已经被改进了。</li><li><a href="http://www.ruanyifeng.com/blog/2014/11/compiler.html">C&#x2F;C++编译器的工作过程</a>，主要是供不熟悉C系的朋友了解一下编译器的工作过程。</li><li><a href="https://benchmarksgame-team.pages.debian.net/benchmarksgame/index.html">The Computer Language Benchmarks Game</a>，一个对各个语言进行性能测试的网站，里面的算法具有一定的代表性，但是不能代表所有工程可能遇到的情况，仅供参考。</li><li><a href="https://www.zhihu.com/question/59481694">为什么 Go 语言在某些方面的性能还不如 Java？</a>，这是知乎上一个2017年开始有的问题，你可以看到很多人对于这个问题的分析，从多个角度来理解语言之间的性能差异。</li><li><a href="https://github.com/golang/go/wiki/WhyGo">go-wiki WhyGo</a>，Go的Github仓库上维护的Wiki中，有一篇关于WhyGo的文章整理，不过大部分是英文，里面主要是很多关于“为什么我要选择Go”的软硬稿。</li><li><a href="https://www.zhihu.com/question/21409296">为什么要使用Go语言，Go语言的优势在哪里</a>，这个知乎的提问更早，是来自2013年的Yvonne YU用户，在Go的早期其实是具有很大的争议的，你可以看到大家在各个问题上的博弈。</li><li><a href="https://github.com/golang/go/wiki/GoUsers">哪些公司在使用Go</a>，Go的Github仓库上维护的Wiki中，有一篇关于全球都有哪些公司在使用Go，不过提供的信息大部分只有一个公司名，比如国内有阿里巴巴（而人家大部分都招Java），可以看看但参考性不大。</li><li><a href="https://studygolang.com/articles/12907">Go 语言的优点，缺点和令人厌恶的设计</a>，这是Go语言中文网上一篇2018年的文章，如果你对语言本身的一些特性的设计感兴趣，你可以选择看看，作者从很多语法层面上介绍了Go的优点和缺点。</li><li><a href="https://ruby-china.org/topics/14407">Ruby China - 瞎扯淡 真的没必要浪费心思在 Go 语言上</a>，这是我无意中找到的一篇有名的帖子，这个问题始于2013年，在Ruby China上，其中也是大佬们(可能)从各个角度来辩论Go是否值得学习，可以当作武侠小说观看。</li><li><a href="https://learnku.com/docs/the-way-to-go/go-performance-description/3580">The way to Go - 3.8 Go性能说明</a>，《The way to Go》这本书上为数不多关于Go性能问题的说明。</li><li><a href="https://www.zhihu.com/question/39990440">C++开发转向go开发是否是一个好的发展方向？</a>，2014年知乎上关于C++和Go的一个讨论，其实我觉得“如果选择一个并不意味着就要放弃另一个”，程序员不是研究语言的，也不应该是只靠某一门语言吃饭。</li><li><a href="https://blog.csdn.net/liigo/article/details/23699459">我为什么放弃Go语言 Liigo</a>，嗯，2014年，仍旧是Go争议很大的时候，CSDN上一篇阅读数很高的文章，作者从自己的角度对Go进行批判（Go早期的确是有不少问题），你可以看到早期Go的很多问题，也可以斟酌这些问题对你是否重要以及到底在2020年的Go中有没有被解决。</li><li><a href="https://www.zhihu.com/question/66944175">Golang 本身是用什么语言写的？</a>，一个关于编译的有趣的问题，可以适当了解。</li><li><a href="https://juejin.im/post/5d56b47a5188250541792ede">搞懂Go垃圾回收</a>，一篇还算比较新的分析Go垃圾回收问题的文章。</li><li><a href="https://www.infoq.cn/article/s48RakEaHPxmKNLUgEUm">有趣的编程语言：Go 语言的启动时间是 C 语言的 300 多倍，C# 的关键字最多</a>，这篇InfoQ文章其实算是一个典型的标题党，主要使用的是一个Github上关于各个语言HelloWorld程序启动时间的测试数据(<a href="https://github.com/bdrung/startup-time">https://github.com/bdrung/sta...</a>)，使用gccgo编译的Go程序的启动时间非常地长，的确是C的300多倍，但使用GC编译的Go程序启动时间只是C的2倍。</li><li><a href="https://www.infoq.cn/article/kX69fGExcjEeCzz6Crie">Go 语言的历史回顾</a>，我一直在寻找一个整理Go的版本变动细节的文章，在Go的官方文档和各种书籍上寻找无果时，在InfoQ上找到了一篇还算跟踪地比较新的（Go 1.0 - Go 1.13）文章，对于初学者而言，知道语言的变化也是很重要的（比如方便的知道哪些问题解决了，哪些还没有被解决），可能之后会拓展性的写一篇关于这个的文章。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法</title>
    <link href="/2021/03/10/m-algorithm/"/>
    <url>/2021/03/10/m-algorithm/</url>
    
    <content type="html"><![CDATA[<blockquote><p>输入 n，给出 1~n 的所有排列，不要求输出有序</p><p>即 输入 3，输出 1，2，3，12，13，23，123</p></blockquote><blockquote><p>T（name， salary， city）</p><p>求 salary &gt; 10000 且 所在 城市平均 salary &gt; 5000 的 name</p></blockquote><blockquote><p><a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95%E9%A2%98"><br>算法题</a> 去除<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%93%BE%E8%A1%A8">链表</a>中重复元素，力扣中等难度题</p><p>分析k个数组合并<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E6%8E%92%E5%BA%8F">排序</a>的时间复杂度</p></blockquote><blockquote><p>和可被k整除的子数组(这里用了35min，要了若干次提示QAQ）</p><p> 给定一个整数数组 A，返回其中元素之和可被 K 整除的（连续、非空）子数组的数目，时间要求O(n)。  输入：A &#x3D; [4,5,0,-2,-3,1], K &#x3D; 5  输出：7  </p><p>解释： 有 7 个子数组满足其元素之和可被 K &#x3D; 5 整除： [4, 5, 0, -2, -3, 1], [5], [5, 0], [5, 0, -2, -3], [0], [0, -2, -3], [-2, -3]   提示：  1 &lt;&#x3D; A.length &lt;&#x3D; 30000  -10000 &lt;&#x3D; A[i] &lt;&#x3D; 10000  2 &lt;&#x3D; K &lt;&#x3D; 10000</p></blockquote><blockquote><p>手撕代码 LRU</p></blockquote><blockquote><p>手撕代码 生产者消费者模型</p></blockquote><blockquote><p>手撕代码 反转连表</p></blockquote><blockquote><p>一致性哈希算法 深挖。一致性哈希与普通哈希的区别。缓存漂移（没答上来）</p></blockquote><blockquote><p>三数之和</p></blockquote><blockquote><p>算法题1.1</p><p>将整数转换二进制<br>然后将负数</p><p>算法题1.2</p><p>给定一个数组代表股票每天的价格，请问买卖多次的情况下，最大化利润是多少？<br>日期不重叠的情况下，可以买卖多次?<br>输入: {100, 80, 120, 130, 70, 60, 100, 125}<br>可以买卖多次: 115（80买进，130卖出；60 买进，125卖出）<br>提示：不用输出买卖的序列，只需要得到最大利润</p><p>时间复杂度多少</p><p>空间复杂度多少</p></blockquote><p>这段代码有什么问题：</p><h6 id="2-1-这段代码有什么问题，如果解决"><a href="#2-1-这段代码有什么问题，如果解决" class="headerlink" title="2.1 这段代码有什么问题，如果解决"></a>2.1 这段代码有什么问题，如果解决</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go">total := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>    sum += i<br>    <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>        total += i<br>    &#125;()<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;total:%d sum %d&quot;</span>, total, sum)<br></code></pre></td></tr></table></figure><blockquote><p>这段代码在协程里面执行，会造成数据不统一<br>可以使用加锁避免</p></blockquote><ul><li>怎么样加锁?代码实现一下</li></ul><blockquote><p>代码如下:</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> lo sync.Mutex<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    total := <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">10</span>; i++ &#123;<br>        nums += i<br>        lo.Lock()<br>        <span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>            total += i<br>            lo.Unlock()<br>        &#125;()<br>    &#125;<br>    fmt.Printf(<span class="hljs-string">&quot;total:%d&quot;</span>, total)<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>还有其他问题吗</li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>算法</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>场景</title>
    <link href="/2021/03/10/m-design/"/>
    <url>/2021/03/10/m-design/</url>
    
    <content type="html"><![CDATA[<blockquote><p>场景题：设计一个高考成绩查询系统</p><p>从前端到后端的业务流程、服务架构、信息安全、容灾措施等都要涉及</p></blockquote><blockquote><p>设计题：两个大文件找重复行</p></blockquote><blockquote><p>数组的平方</p><p>给你一个按 <strong>非递减顺序</strong> <a href="">排序</a>的整数数组 nums，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> <a href="">排序</a>。 </p><p>输入：nums &#x3D; [-4,-1,0,3,10] 输出：[0,1,9,16,100] 解释：平方后，数组变为 [16,1,0,9,100] <a href="">排序</a>后，数组变为 [0,1,9,16,100]</p></blockquote><blockquote><p>无重复字符的最长子串</p><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。 </p><p>输入: s &#x3D; “abcabcbb” 输出: 3  解释: 因为无重复字符的最长子串是 “abc”，所以其长度为 3。 </p><p>输入: s &#x3D; “bbbbb”   输出: 1   解释: 因为无重复字符的最长子串是 “b”，所以其长度为 1。</p></blockquote><blockquote><p>合并 n 个 m 长的数组，分析时间复杂度</p></blockquote><blockquote><p>设计学生成绩数据库，并写出查询语文成绩top3的人。gg，懵逼了。忘了联合主键能不能连表查询了，不敢说</p></blockquote><blockquote><p>url输入全过程 。从此引出后端除了响应请求还有什么。我（分布式系统，要有复杂均衡，一直问到分布系统。）由此引出下面一堆</p></blockquote><blockquote><p>设计一个短链接服务。如何抗住大qps， 抗大流量 。url 哈希函数怎么设计（就说了个base62）。怎么存（redis存映射）。怎么统计qps（用短链接存在自增吧）</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>场景题</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>项目</title>
    <link href="/2021/03/10/m-project/"/>
    <url>/2021/03/10/m-project/</url>
    
    <content type="html"><![CDATA[<h2 id="项目中文件传输如何实现的？粘包如何解决？断点续传如何实现"><a href="#项目中文件传输如何实现的？粘包如何解决？断点续传如何实现" class="headerlink" title="项目中文件传输如何实现的？粘包如何解决？断点续传如何实现"></a>项目中文件传输如何实现的？粘包如何解决？断点续传如何实现</h2>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>项目</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>系统</title>
    <link href="/2021/03/10/m-system/"/>
    <url>/2021/03/10/m-system/</url>
    
    <content type="html"><![CDATA[<h2 id="进程和线程以及它们的区别"><a href="#进程和线程以及它们的区别" class="headerlink" title="进程和线程以及它们的区别"></a>进程和线程以及它们的区别</h2><ul><li>进程是对运行时程序的封装，是系统进行资源调度和分配的的基本单位，实现了操作系统的并发；</li><li>线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发；</li><li>一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；</li><li>进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存。</li></ul><h2 id="线程通信？线程安全？"><a href="#线程通信？线程安全？" class="headerlink" title="线程通信？线程安全？"></a>线程通信？线程安全？</h2><h2 id="进程的通信方式"><a href="#进程的通信方式" class="headerlink" title="进程的通信方式"></a>进程的通信方式</h2><p>主要分为：管道、系统<strong>IPC</strong>（包括消息队列、信号量、共享存储）、<strong>SOCKET</strong></p><p>管道主要分为：普通管道<strong>PIPE</strong> 、流管道（<strong>s_pipe</strong>）、命名管道（<strong>name_pipe</strong>）</p><ul><li><p><strong>管道（pipe）及命名管道（named pipe）</strong>：管道可用于具有亲缘关系的父子进程间的通信，命名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；</p></li><li><p><strong>信号量</strong>：是一个计数器，用来控制多个进程对资源的访问，它通常作为一种锁机制。</p></li><li><p><strong>消息队列：</strong>消息队列是消息的链接表，存放在内核中并由消息队列标识符标识。它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；</p></li><li><p><strong>共享内存：</strong>可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；</p></li><li><p><strong>信号量：</strong>主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；</p></li><li><p><strong>套接字：</strong>这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。</p></li></ul><h2 id="线程状态"><a href="#线程状态" class="headerlink" title="线程状态"></a>线程状态</h2><ul><li>就绪状态：进程已获得除处理机以外的所需资源，等待分配处理机资源；</li><li>运行状态：占用处理机资源运行，处于此状态的进程数小于等于CPU数；</li><li>阻塞状态： 进程等待某种条件，在条件满足之前无法执行；</li></ul><h2 id="线程同步的方式有哪些"><a href="#线程同步的方式有哪些" class="headerlink" title="线程同步的方式有哪些"></a>线程同步的方式有哪些</h2><ul><li>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。</li><li>信号量：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li><li>事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作。</li></ul><h2 id="线程怎么调度"><a href="#线程怎么调度" class="headerlink" title="线程怎么调度"></a>线程怎么调度</h2><h2 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h2><p>在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它或它们现在保持着的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。</p><h2 id="死锁产生的四个必要条件"><a href="#死锁产生的四个必要条件" class="headerlink" title="死锁产生的四个必要条件"></a>死锁产生的四个必要条件</h2><ol><li>互斥：至少有一个资源必须属于非共享模式，即一次只能被一个进程使用；若其他申请使用该资源，那么申请进程必须等到该资源被释放为止；</li><li>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</li><li>不剥夺条件：进程已获得的资源，在末使用完之前，不能强行剥夺。</li><li>循环等待条件：若干进程之间形成一种头尾相接的循环等待资源关系。</li></ol><h2 id="处理死锁的基本策略"><a href="#处理死锁的基本策略" class="headerlink" title="处理死锁的基本策略"></a>处理死锁的基本策略</h2><ul><li>解决死锁的基本方法主要有 预防死锁、避免死锁、检测死锁、解除死锁 、鸵鸟策略 等</li></ul><h2 id="缓存溢出及其原因与危害"><a href="#缓存溢出及其原因与危害" class="headerlink" title="缓存溢出及其原因与危害"></a>缓存溢出及其原因与危害</h2><p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p><p>危害有以下两点：</p><ul><li>程序崩溃，导致拒绝额服务</li><li>跳转并且执行一段恶意代码</li></ul><p>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p><h2 id="虚拟内存、共享内存、常驻内存"><a href="#虚拟内存、共享内存、常驻内存" class="headerlink" title="虚拟内存、共享内存、常驻内存"></a>虚拟内存、共享内存、常驻内存</h2><h2 id="软链接和硬链接"><a href="#软链接和硬链接" class="headerlink" title="软链接和硬链接"></a>软链接和硬链接</h2><h2 id="文件和目录的区别"><a href="#文件和目录的区别" class="headerlink" title="文件和目录的区别"></a>文件和目录的区别</h2><h2 id="进程间通信？线程间通信"><a href="#进程间通信？线程间通信" class="headerlink" title="进程间通信？线程间通信"></a>进程间通信？线程间通信</h2><h2 id="多线程通信为何比多进程通信麻烦"><a href="#多线程通信为何比多进程通信麻烦" class="headerlink" title="多线程通信为何比多进程通信麻烦"></a>多线程通信为何比多进程通信麻烦</h2><h2 id="多线程和多进程注意要点，应用场景"><a href="#多线程和多进程注意要点，应用场景" class="headerlink" title="多线程和多进程注意要点，应用场景"></a>多线程和多进程注意要点，应用场景</h2><h2 id="地址空间是什么"><a href="#地址空间是什么" class="headerlink" title="地址空间是什么"></a>地址空间是什么</h2><h2 id="虚拟地址与物理地址的区别与联系"><a href="#虚拟地址与物理地址的区别与联系" class="headerlink" title="虚拟地址与物理地址的区别与联系"></a>虚拟地址与物理地址的区别与联系</h2><h2 id="堆区与栈区的区别"><a href="#堆区与栈区的区别" class="headerlink" title="堆区与栈区的区别"></a>堆区与栈区的区别</h2><h2 id="垃圾回收-相比程序员直接-free-和-delete-之类的，有什么优化（内存碎片）"><a href="#垃圾回收-相比程序员直接-free-和-delete-之类的，有什么优化（内存碎片）" class="headerlink" title="垃圾回收 相比程序员直接 free 和 delete 之类的，有什么优化（内存碎片）"></a>垃圾回收 相比程序员直接 free 和 delete 之类的，有什么优化（内存碎片）</h2><h2 id="如何看Linux程序是多线程还是多进程的-ps-PPID-PID"><a href="#如何看Linux程序是多线程还是多进程的-ps-PPID-PID" class="headerlink" title="如何看Linux程序是多线程还是多进程的(ps:PPID,PID)"></a>如何看Linux程序是多线程还是多进程的(ps:PPID,PID)</h2><h2 id="Shell编程"><a href="#Shell编程" class="headerlink" title="Shell编程"></a>Shell编程</h2><h2 id="分布式框架，singleflight并发，深挖，一直挖到sync-WaitGroup"><a href="#分布式框架，singleflight并发，深挖，一直挖到sync-WaitGroup" class="headerlink" title="分布式框架，singleflight并发，深挖，一直挖到sync.WaitGroup"></a>分布式框架，singleflight并发，深挖，一直挖到sync.WaitGroup</h2><h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><h2 id="什么是分布式系统"><a href="#什么是分布式系统" class="headerlink" title="什么是分布式系统"></a>什么是分布式系统</h2><h2 id="由分布式系统引出负载均衡"><a href="#由分布式系统引出负载均衡" class="headerlink" title="由分布式系统引出负载均衡"></a>由分布式系统引出负载均衡</h2><h2 id="负载均衡算法有哪些"><a href="#负载均衡算法有哪些" class="headerlink" title="负载均衡算法有哪些"></a>负载均衡算法有哪些</h2>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据结构</title>
    <link href="/2021/03/10/m-datastruct/"/>
    <url>/2021/03/10/m-datastruct/</url>
    
    <content type="html"><![CDATA[<h2 id="常用排序算法，快排、堆排如何实现"><a href="#常用排序算法，快排、堆排如何实现" class="headerlink" title="常用排序算法，快排、堆排如何实现"></a>常用排序算法，快排、堆排如何实现</h2><h2 id="去除链表中重复元素"><a href="#去除链表中重复元素" class="headerlink" title="去除链表中重复元素"></a>去除链表中重复元素</h2><h2 id="分析K个数组合并排序的时间复杂度"><a href="#分析K个数组合并排序的时间复杂度" class="headerlink" title="分析K个数组合并排序的时间复杂度"></a>分析K个数组合并排序的时间复杂度</h2><h2 id="b树和b-树的区别"><a href="#b树和b-树的区别" class="headerlink" title="b树和b+树的区别"></a>b树和b+树的区别</h2><h2 id="链表怎么检查环，怎么算环的长度"><a href="#链表怎么检查环，怎么算环的长度" class="headerlink" title="链表怎么检查环，怎么算环的长度"></a>链表怎么检查环，怎么算环的长度</h2><h2 id="跳表怎么实现"><a href="#跳表怎么实现" class="headerlink" title="跳表怎么实现"></a>跳表怎么实现</h2><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><h2 id="哈希表怎么实现"><a href="#哈希表怎么实现" class="headerlink" title="哈希表怎么实现"></a>哈希表怎么实现</h2><h2 id="避免哈希冲突的方法。开放寻址法、拉链法"><a href="#避免哈希冲突的方法。开放寻址法、拉链法" class="headerlink" title="避免哈希冲突的方法。开放寻址法、拉链法"></a>避免哈希冲突的方法。开放寻址法、拉链法</h2><h2 id="红黑树，性质"><a href="#红黑树，性质" class="headerlink" title="红黑树，性质"></a>红黑树，性质</h2><h2 id="最长格式正确的字符串"><a href="#最长格式正确的字符串" class="headerlink" title="最长格式正确的字符串"></a>最长格式正确的字符串</h2>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HR面</title>
    <link href="/2021/03/10/HR%E9%9D%A2/"/>
    <url>/2021/03/10/HR%E9%9D%A2/</url>
    
    <content type="html"><![CDATA[<h2 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h2><ol><li><p>做<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E9%A1%B9%E7%9B%AE">项目</a>遇到的困难？解决方法？后续计划？</p><p> 学习情况。</p></li><li><p>近期学校生活中遇到的挫折？怎么克服的？</p></li><li><p>未来打算。读研？就业？</p></li><li><p>健康状况。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>HR</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库</title>
    <link href="/2021/03/10/m-database/"/>
    <url>/2021/03/10/m-database/</url>
    
    <content type="html"><![CDATA[<h2 id="数据库分区、分表，读写分离"><a href="#数据库分区、分表，读写分离" class="headerlink" title="数据库分区、分表，读写分离"></a>数据库分区、分表，读写分离</h2><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>就是把一张表的数据分成N个区块，在逻辑上看最终只是一张表，但底层是由N个物理区块组成的。</p><h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><p>就是把一张表按一定的规则分解成N个具有独立存储空间的实体表。系统读写时需要根据定义好的规则得到对应的字表明，然后操作它。</p><h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p>读写分离，基本的原理是让主数据库处理事务性增、改、删操作（INSERT、UPDATE、DELETE），而从数据库处理SELECT查询操作。数据库复制被用来把事务性操作导致的变更同步到集群中的从数据库。</p><h2 id="冷热数据怎么处理？redis和mysql，如何保证数据一致性"><a href="#冷热数据怎么处理？redis和mysql，如何保证数据一致性" class="headerlink" title="冷热数据怎么处理？redis和mysql，如何保证数据一致性"></a>冷热数据怎么处理？redis和mysql，如何保证数据一致性</h2><h2 id="使用MySQL有哪些好处"><a href="#使用MySQL有哪些好处" class="headerlink" title="使用MySQL有哪些好处"></a>使用MySQL有哪些好处</h2><h2 id="InnoDB的特性，底层，数据分区，如何加快读写效率"><a href="#InnoDB的特性，底层，数据分区，如何加快读写效率" class="headerlink" title="InnoDB的特性，底层，数据分区，如何加快读写效率"></a>InnoDB的特性，底层，数据分区，如何加快读写效率</h2><h2 id="innodb-和-myisam-的区别"><a href="#innodb-和-myisam-的区别" class="headerlink" title="innodb 和 myisam 的区别"></a>innodb 和 myisam 的区别</h2><h2 id="主键和索引的联系和区别"><a href="#主键和索引的联系和区别" class="headerlink" title="主键和索引的联系和区别"></a>主键和索引的联系和区别</h2><h2 id="MySQL索引和B-树"><a href="#MySQL索引和B-树" class="headerlink" title="MySQL索引和B+树"></a>MySQL索引和B+树</h2><h2 id="索引优化"><a href="#索引优化" class="headerlink" title="索引优化"></a>索引优化</h2><h2 id="explain-执行计划"><a href="#explain-执行计划" class="headerlink" title="explain 执行计划"></a>explain 执行计划</h2><h2 id="extra的-using-indexing-和-using-where"><a href="#extra的-using-indexing-和-using-where" class="headerlink" title="extra的 using indexing 和 using where"></a>extra的 using indexing 和 using where</h2><h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><h2 id="聚簇索引和辅助索引"><a href="#聚簇索引和辅助索引" class="headerlink" title="聚簇索引和辅助索引"></a>聚簇索引和辅助索引</h2><h2 id="讲一下Redis"><a href="#讲一下Redis" class="headerlink" title="讲一下Redis"></a>讲一下Redis</h2><p>简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以存写速度非常快，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。redis 提供了多种数据类型来支持不同的业务场景。除此之外，redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。</p><h2 id="为什么要用Redis做缓存"><a href="#为什么要用Redis做缓存" class="headerlink" title="为什么要用Redis做缓存"></a>为什么要用Redis做缓存</h2><p>在项目中使用 Redis，主要考虑两个角度：性能和并发。如果只是为了分布式锁这些其他功能，还有其他中间件 Zookpeer 等代替，并非一定要使用 Redis。</p><h2 id="nosql-说下"><a href="#nosql-说下" class="headerlink" title="nosql 说下"></a>nosql 说下</h2><h2 id="数据库查询数据慢如何解决"><a href="#数据库查询数据慢如何解决" class="headerlink" title="数据库查询数据慢如何解决"></a>数据库查询数据慢如何解决</h2><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><h2 id="哈希索引和B-树索引的区别"><a href="#哈希索引和B-树索引的区别" class="headerlink" title="哈希索引和B+树索引的区别"></a>哈希索引和B+树索引的区别</h2><p>1.在查询速度上，如果是等值查询，那么哈希索引有绝对的优势，因为只需要经过一次哈希计算就能找到相应的值，时间复杂度是O(1)，但是，如果存在哈希碰撞，那么其查询效率将会降低，时间复杂度会变成O(n)，所以，哈希索引一般不会用在重复多的列上，比如性别、年龄的情况等。（当然，B+树不适合用在这种离散程度低的列上）</p><p>2.Hash索引是无序的，所以，不能进行范围查找，即使原先有序的列，经过哈希计算后，也会变成不连续的。</p><p>3.Hash索引不支持多列联合索引，对于联合索引来说，哈希索引在计算哈希值的时候，是将索引键合并，然后计算哈希值。</p><p>4.因为哈希索引存在哈希碰撞问题，所以，在有大量重复键的情况下，哈希索引查询效率极低，而B+树的所有查询都要找到叶子结点，性能较为稳定。</p><h2 id="哈希索引与B-索引场景区分"><a href="#哈希索引与B-索引场景区分" class="headerlink" title="哈希索引与B+索引场景区分"></a>哈希索引与B+索引场景区分</h2><p>1.在大多数场景下，都会有组合查询、范围查询、排序、分组、模糊查询等查询特征，Hash索引无法满足要求，建议数据库使用B+树索引。</p><p>2.在数据离散度高，数据基数大，而且是等值查询的时候，建议使用哈希索引。</p><h2 id="哈希索引在内存还是在磁盘"><a href="#哈希索引在内存还是在磁盘" class="headerlink" title="哈希索引在内存还是在磁盘"></a>哈希索引在内存还是在磁盘</h2><p>在内存</p><h2 id="缓存击穿-缓存雪崩"><a href="#缓存击穿-缓存雪崩" class="headerlink" title="缓存击穿 缓存雪崩"></a>缓存击穿 缓存雪崩</h2>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络</title>
    <link href="/2021/03/10/m-network/"/>
    <url>/2021/03/10/m-network/</url>
    
    <content type="html"><![CDATA[<h2 id="讲一下TCP和HTTP"><a href="#讲一下TCP和HTTP" class="headerlink" title="讲一下TCP和HTTP"></a>讲一下TCP和HTTP</h2><p>TCP协议对应传输层，HTTP协议对应应用层，HTTP协议是建立在TCP协议基础之上的。</p><p>TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。完成一个TCP连接需要经历三次握手，断开则需要四次挥手。理想状态下，TCP连接一旦建立，在通信双方任一方没有断开之前，都是处于连接状态的，</p><p>HTTP协议是负责传输数据的协议，它是一种无状态的协议，HTTP连接是一种“短连接”，在HTTP1.0中，客户端的每次请求都对应一次连接，请求完成则断开连接。在HTTP1.1中可以在一次连接中处理多个请求，并且多个请求重叠进行，不需要每个请求都经历一次“连接-断开”的过程。</p><h2 id="TCP和UDP的特性"><a href="#TCP和UDP的特性" class="headerlink" title="TCP和UDP的特性"></a>TCP和UDP的特性</h2><ul><li>TCP是面向连接的，连接要经过三次握手，断开要经过四次挥手。UDP是面向无连接的，它是一个可以随时通信的协议，只要双方建立了Socket，设置了监听端口，就可以收到到达的UDP包，并能够随时建立Socket</li><li>TCP具有流量控制和用塞控制机制，通过控制滑动窗口的大小来控制数据发送速率。而UDP理论上可以向网络中无限制的发送数据，除非在程序端做了控制。</li><li>TCP可以保证数据传输的可靠性，有速率控制、重传机制、数据校验等机制。而UDP则是尽力的传输数据，不能保证数据的可靠性。</li><li>TCP报文段头部占20个字节，比UDP多12个，加上连接有握手机制，使用效率上不如UDP。</li></ul><h2 id="TCP三次握手、四次挥手，四次能不能变成三次"><a href="#TCP三次握手、四次挥手，四次能不能变成三次" class="headerlink" title="TCP三次握手、四次挥手，四次能不能变成三次"></a>TCP三次握手、四次挥手，四次能不能变成三次</h2><h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><p>客户端➡️服务器：标志位：SYN&#x3D;1 序号为：seq&#x3D;x（默认x&#x3D;1）</p><p>服务器➡️客户端：标志位：SYN&#x3D;1，ACK&#x3D;1 确认位：ack&#x3D;x+1 序号位：seq&#x3D;y</p><p>客户端➡️服务器：标志位：ACK&#x3D;1 确认位：ack&#x3D;y+1 序号位：seq&#x3D;x+1</p><blockquote><p>这个三次握手四次挥手的基础解释以及图片</p><p><img src="https://www.cmdbyte.com/2021/02/v2-8720bd64871a5452df583fdab8207d64_720w.jpg" alt="v2-8720bd64871a5452df583fdab8207d64_720w"></p><p><img src="https://www.cmdbyte.com/2021/02/v2-2f38fb35dff4a5cc9f5352b9c7533222_720w.png" alt="v2-2f38fb35dff4a5cc9f5352b9c7533222_720w"></p></blockquote><h2 id="HTTP2-0了解吗？和HTTP1-1的差距"><a href="#HTTP2-0了解吗？和HTTP1-1的差距" class="headerlink" title="HTTP2.0了解吗？和HTTP1.1的差距"></a>HTTP2.0了解吗？和HTTP1.1的差距</h2><p>HTTP2.0可以说是SPDY的升级版，性能很高</p><p>HTTP2.0相比HTTP1.1的新特性有：</p><ul><li>新的二进制格式：HTTP1.x基于文本，HTTP2.0的解析基于二进制，实现方便且健壮</li><li>多路复用：一个连接里可以有多个request，每个request都有一个id，接收方可以根据id选择对应的服务</li><li>header压缩：使用encoder减少传输大小，通信双方个cache一份header fileds表</li><li>服务端推送</li></ul><h2 id="服务器如何处理大流量高并发请求"><a href="#服务器如何处理大流量高并发请求" class="headerlink" title="服务器如何处理大流量高并发请求"></a>服务器如何处理大流量高并发请求</h2><ul><li>增加资源供给：更大的带宽、更高配置的服务器、更高性能的web服务应用、更高性能的数据库</li><li>请求分流：使用集群，分布式的系统架构</li><li>应用优化：使用高效的编程语言、优化业务逻辑算法、优化访问数据库的SQL语句</li></ul><h2 id="计算机网络七层协议"><a href="#计算机网络七层协议" class="headerlink" title="计算机网络七层协议"></a>计算机网络七层协议</h2><p>主机代表着高层，网络代表低层。</p><p><img src="https://www.cmdbyte.com/2021/02/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png" alt="七层网络模型"></p><blockquote><p>七层网络模型</p><p><img src="https://www.cmdbyte.com/2021/02/v2-2af488004591cbc12cd82c44518523de_720w.jpg" alt="v2-2af488004591cbc12cd82c44518523de_720w"></p></blockquote><h2 id="TCP保证可靠性"><a href="#TCP保证可靠性" class="headerlink" title="TCP保证可靠性"></a>TCP保证可靠性</h2><ul><li>校验和</li><li>确认应答与序列号</li><li>超时重传</li><li>连接管理</li><li>流量控制</li><li>用塞控制<ul><li>慢开始</li><li>拥塞避免避免</li><li>快重传</li><li>快恢复</li></ul></li></ul><h2 id="TCP十六位校验如何实现的"><a href="#TCP十六位校验如何实现的" class="headerlink" title="TCP十六位校验如何实现的"></a>TCP十六位校验如何实现的</h2><p>在发送方将整个报文段分成多个16位的段，将所有段进行反码相加，然后将结果存放在校验和字段中，接收方也采用相同的方法进行计算，若最终结果为检验字段所有位全为1，则正确，否则存在错误。</p><h2 id="TCP粘包"><a href="#TCP粘包" class="headerlink" title="TCP粘包"></a>TCP粘包</h2><h2 id="802-3x工作在第几层，为什么"><a href="#802-3x工作在第几层，为什么" class="headerlink" title="802.3x工作在第几层，为什么"></a>802.3x工作在第几层，为什么</h2><h2 id="HTTPS握手，为什么需要非对称加密和对称加密"><a href="#HTTPS握手，为什么需要非对称加密和对称加密" class="headerlink" title="HTTPS握手，为什么需要非对称加密和对称加密"></a>HTTPS握手，为什么需要非对称加密和对称加密</h2><h2 id="基于UDP再设计一个可靠的协议，如何设计"><a href="#基于UDP再设计一个可靠的协议，如何设计" class="headerlink" title="基于UDP再设计一个可靠的协议，如何设计"></a>基于UDP再设计一个可靠的协议，如何设计</h2><h2 id="QUIC"><a href="#QUIC" class="headerlink" title="QUIC"></a>QUIC</h2><h2 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h2><h2 id="HTTP和HTTPS的应用场景"><a href="#HTTP和HTTPS的应用场景" class="headerlink" title="HTTP和HTTPS的应用场景"></a>HTTP和HTTPS的应用场景</h2><h2 id="HTTPS最耗时的环节"><a href="#HTTPS最耗时的环节" class="headerlink" title="HTTPS最耗时的环节"></a>HTTPS最耗时的环节</h2><h2 id="讲一下你了解的端口及对应的服务"><a href="#讲一下你了解的端口及对应的服务" class="headerlink" title="讲一下你了解的端口及对应的服务"></a>讲一下你了解的端口及对应的服务</h2><p><img src="https://www.cmdbyte.com/2021/02/v2-e584c505e895441d7b52c8f3c02c9770_720w.png" alt="v2-e584c505e895441d7b52c8f3c02c9770_720w"></p><p>具体一点可以参考：<a href="http://blog.sina.com.cn/s/blog_66ea0e2801011vb3.html">常用端口号与对应的服务以及端口关闭_typiloong_新浪博客</a></p><h2 id="简单解释一下ARP协议的工作原理"><a href="#简单解释一下ARP协议的工作原理" class="headerlink" title="简单解释一下ARP协议的工作原理"></a>简单解释一下ARP协议的工作原理</h2><p><img src="https://www.cmdbyte.com/2021/02/v2-6c73a236adcb7704e5e75162465c3aec_720w.png" alt="v2-6c73a236adcb7704e5e75162465c3aec_720w"></p><h2 id="在浏览器中输入链接发生了什么"><a href="#在浏览器中输入链接发生了什么" class="headerlink" title="在浏览器中输入链接发生了什么"></a>在浏览器中输入链接发生了什么</h2><ul><li>查找域名对应的IP地址。这一步会依次查找浏览器缓存，系统缓存，路由器缓存，ISPNDS缓存，根域名服务器</li><li>浏览器向IP对应的web服务器发送一个HTTP请求</li><li>服务器响应请求，发回网页内容</li><li>浏览器解析网页内容</li></ul><p>更加详细的一种说法（以百度为例）（来自<a href="https://link.zhihu.com/?target=https://www.nowcoder.com/discuss/1937">计算机网络之面试常考 - 牛客网</a>）</p><p><img src="https://www.cmdbyte.com/2021/02/v2-99bc5fa53acca200f564b0bd69d1bb41_720w.png" alt="v2-99bc5fa53acca200f564b0bd69d1bb41_720w"></p><h2 id="IP地址分为哪几类"><a href="#IP地址分为哪几类" class="headerlink" title="IP地址分为哪几类"></a>IP地址分为哪几类</h2><p><img src="https://www.cmdbyte.com/2021/02/v2-7438cb1ba454ffe278f5c2310e69f3aa_720w.png" alt="v2-7438cb1ba454ffe278f5c2310e69f3aa_720w"></p><p>IPv6：采用128bit，首部宽度部分为40字节</p><h2 id="ipv4-和-ipv6"><a href="#ipv4-和-ipv6" class="headerlink" title="ipv4 和 ipv6"></a>ipv4 和 ipv6</h2><h2 id="tcp-的阻塞控制"><a href="#tcp-的阻塞控制" class="headerlink" title="tcp 的阻塞控制"></a>tcp 的阻塞控制</h2><ul><li>慢开始</li><li>拥塞避免</li><li>快重传</li><li>快恢复</li></ul><h2 id="拥塞避免后再次慢开始还会从1开始吗"><a href="#拥塞避免后再次慢开始还会从1开始吗" class="headerlink" title="拥塞避免后再次慢开始还会从1开始吗"></a>拥塞避免后再次慢开始还会从1开始吗</h2><p> 是的。目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。</p><h2 id="为什么-tcp-需要拥塞控制"><a href="#为什么-tcp-需要拥塞控制" class="headerlink" title="为什么 tcp 需要拥塞控制"></a>为什么 tcp 需要拥塞控制</h2><p><strong>防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。</strong></p><p>当发送端给接收端发送数据时，只有接收端收到了数据，才会给发送端返回应答信息。如果接收端一直没有收到应答信息，则发送端会认为数据已经丢失，会进行重新发送。</p><p>接收端收不到信息其实有两种情况，一种是数据真的丢失，一种是网络通信处于拥塞状态，拥塞控制针对的就是第二种情况。</p><h2 id="Cookie与Session的区别"><a href="#Cookie与Session的区别" class="headerlink" title="Cookie与Session的区别"></a>Cookie与Session的区别</h2><ul><li><strong>数据存放位置不同</strong><ul><li>Cookie数据存放在客户的浏览器上</li><li>Session数据存放在服务器上</li></ul></li><li><strong>安全程度不同</strong><ul><li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session</li></ul></li><li><strong>性能使用程度不同</strong><ul><li>session会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能,考虑到减轻服务器性能方面，应当使用cookie</li></ul></li><li><strong>数据存储大小不同</strong><ul><li>单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，而session则存储与服务端，浏览器对其没有限制。</li></ul></li><li><strong>会话机制不同</strong><ul><li>session会话机制：session会话机制是一种服务器端机制，它使用类似于哈希表（可能还有哈希表）的结构来保存信息。</li><li>cookies会话机制：cookie是服务器存储在本地计算机上的小块文本，并随每个请求发送到同一服务器。 Web服务器使用HTTP标头将cookie发送到客户端。在客户端终端，浏览器解析cookie并将其保存为本地文件，该文件自动将来自同一服务器的任何请求绑定到这些cookie。</li></ul></li></ul><h2 id="Session-ID如何维护（Cookie里带有Session-ID）"><a href="#Session-ID如何维护（Cookie里带有Session-ID）" class="headerlink" title="Session ID如何维护（Cookie里带有Session ID）"></a>Session ID如何维护（Cookie里带有Session ID）</h2><p>A．保存session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。<br>B．由于cookie可以被人为的禁止，必须有其它的机制以便在cookie被禁止时仍然能够把session id传递回服务器，经常采用的一种技术叫做URL重写，就是把session id附加在URL路径的后面，附加的方式也有两种，一种是作为URL路径的附加信息，另一种是作为查询字符串附加在URL后面。网络在整个交互过程中始终保持状态，就必须在每个客户端可能请求的路径后面都包含这个session id。<br>C．另一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。</p><h2 id="XSS和CSRF"><a href="#XSS和CSRF" class="headerlink" title="XSS和CSRF"></a>XSS和CSRF</h2><h2 id="多台服务器session存储怎么设计"><a href="#多台服务器session存储怎么设计" class="headerlink" title="多台服务器session存储怎么设计"></a>多台服务器session存储怎么设计</h2><h2 id="多台服务器session除了存在redis还可以存在哪里"><a href="#多台服务器session除了存在redis还可以存在哪里" class="headerlink" title="多台服务器session除了存在redis还可以存在哪里"></a>多台服务器session除了存在redis还可以存在哪里</h2><h2 id="https详细过程"><a href="#https详细过程" class="headerlink" title="https详细过程"></a>https详细过程</h2><h2 id="get-post区别，还有什么其他方法，分别是做什么的"><a href="#get-post区别，还有什么其他方法，分别是做什么的" class="headerlink" title="get post区别，还有什么其他方法，分别是做什么的"></a>get post区别，还有什么其他方法，分别是做什么的</h2><h2 id="web安全问题有哪些"><a href="#web安全问题有哪些" class="headerlink" title="web安全问题有哪些"></a>web安全问题有哪些</h2><p><strong>1、SQL注入</strong><br>拼接的SQL字符串改变了设计者原来的意图，执行了如泄露、改变数据等操作，甚至控制数据库<br>服务器， SQL Injection与Command Injection等攻击包括在内</p><p><strong>2、跨站脚本攻击（XSS或css）</strong></p><p>跨站脚本(Cross-Site Scripting)是指远程WEB页面的html代码可以插入具有恶意目的的数据，当<br>浏览器下载该页面，嵌入其中的恶意脚本将被解释执行，从而对客户端用户造成伤害。简称CSS<br>或XSS<br><strong>3、没有限制URL访问</strong></p><p>系统已经对URL的访问做了限制，但这种限制却实际并没有生效。攻击者能够很容易的就伪造<br>请求直接访问未被授权的页面</p><p><strong>4、越权访问</strong></p><p>用户对系统的某个模块或功能没有权限，通过拼接URL或Cookie欺骗来访问该模块或功能</p><p><strong>5、泄露配置信息</strong></p><p>服务器返回的提示或错误信息中出现服务器版本信息泄露、程序出错泄露物理路径、程序查询<br>出错返回SQL语句、过于详细的用户验证返回信息。</p><p><strong>6、不安全的加密存储</strong></p><p>常见的问题是不安全的密钥生成和储存、不轮换密钥，和使用弱算法。使用弱的或者不带salt<br>的哈希算法来保护密码也很普遍。外部攻击者因访问的局限性很难探测这种漏洞。他们通常<br>必须首先破解其他东西以获得需要的访问。</p><p><strong>7、传输层保护不足</strong></p><p>在身份验证过程中没有使用SSL &#x2F; TLS，因此暴露传输数据和会话ID，被攻击者截听，或使<br>用过期或者配置不正确的证书。</p><p><strong>8、登录信息提示</strong></p><p>用户登录提示信息会给攻击者一些有用的信息，作为程序的开发人员应该做到对登录提示信<br>息的模糊化，以防攻击者利用登录得知用户是否存在</p><p><strong>9、重复提交请求</strong></p><p>程序员在代码中没有对重复提交请求做限制，这样就会出现订单被多次下单，帖子被重<br>复发布。恶意攻击者可能利用此漏洞对网站进行批量灌水，致使网站瘫痪</p><p><strong>10、网页脚本错误</strong></p><p>访问者所使用的浏览器不能完全支持页面里的脚本，形成“脚本错误”，也就是网站中的脚<br>本没有被成功执行。遇到“脚本错误”时一般会弹出一个非常难看的脚本运行错误警告窗口</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>网络</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go面试题</title>
    <link href="/2021/03/09/m-go/"/>
    <url>/2021/03/09/m-go/</url>
    
    <content type="html"><![CDATA[<h2 id="Go是什么？"><a href="#Go是什么？" class="headerlink" title="Go是什么？"></a>Go是什么？</h2><p>Go(又称Golang)是Google开发的一种静态强类型、编译型、并发型,并具有垃圾回收功能的编程语言。</p><h2 id="使用Go编程有什么好处？（为什么要选择Go）"><a href="#使用Go编程有什么好处？（为什么要选择Go）" class="headerlink" title="使用Go编程有什么好处？（为什么要选择Go）"></a>使用Go编程有什么好处？（为什么要选择Go）</h2><ul><li>编译快</li><li>运行速度快</li><li>自带垃圾回收</li><li>天生支持并发</li><li>静态语言，但又兼顾动态语言的优点，语法简单</li><li><strong>大部分情况下，编写一个服务，你只需要：实现、编译、部署、运行</strong>。高效快捷，足够敏捷</li></ul><h2 id="Go适合用来做什么"><a href="#Go适合用来做什么" class="headerlink" title="Go适合用来做什么"></a>Go适合用来做什么</h2><ul><li>有较高性能要求的并发服务后端</li><li>分布式系统，数据库代理器等</li><li>网络编程，这一块目前应用最广，包括Web应用、API应用、下载应用、</li><li>内存数据库，前一段时间google开发的groupcache，couchbase的部分组建</li><li>云平台，目前国外很多云平台在采用Go开发，CloudFoundy的部分组建，前VMare的技术总监自己出来搞的apcera云平台。</li></ul><h2 id="Go支持类型继承吗？"><a href="#Go支持类型继承吗？" class="headerlink" title="Go支持类型继承吗？"></a>Go支持类型继承吗？</h2><p>go不支持继承,只支持嵌入和聚合(匿名字段称为嵌入,具名字段称为聚合)。golang通过嵌入,可以到达类似继承的效果,而且更为简洁。</p><h2 id="Go支持运营商超载吗？"><a href="#Go支持运营商超载吗？" class="headerlink" title="Go支持运营商超载吗？"></a>Go支持运营商超载吗？</h2><h2 id="Go支持方法重载吗？"><a href="#Go支持方法重载吗？" class="headerlink" title="Go支持方法重载吗？"></a>Go支持方法重载吗？</h2><p>不支持。原因是Go的设计者们设计的核心原则是：让Go保持足够的简单。</p><h2 id="Go支持指针算术吗？"><a href="#Go支持指针算术吗？" class="headerlink" title="Go支持指针算术吗？"></a>Go支持指针算术吗？</h2><p>不支持。但是提供了<code>unsafe</code>包来实现指针运算的功能。</p><h2 id="Go是一个区分大小写的语言吗？"><a href="#Go是一个区分大小写的语言吗？" class="headerlink" title="Go是一个区分大小写的语言吗？"></a>Go是一个区分大小写的语言吗？</h2><p>是。</p><h2 id="Go中变量的静态类型声明是什么？"><a href="#Go中变量的静态类型声明是什么？" class="headerlink" title="Go中变量的静态类型声明是什么？"></a>Go中变量的静态类型声明是什么？</h2><p>所谓的<strong>静态类型</strong>（即 static type），就是变量声明的时候的类型。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">var age int   // int 是静态类型<br>var name string  // string 也是静态类型<br></code></pre></td></tr></table></figure><h2 id="Go中变量的动态类型声明是什么？"><a href="#Go中变量的动态类型声明是什么？" class="headerlink" title="Go中变量的动态类型声明是什么？"></a>Go中变量的动态类型声明是什么？</h2><p>所谓的 <strong>动态类型</strong>（即 concrete type，也叫具体类型）是 程序运行时系统才能看见的类型。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs text">var i interface&#123;&#125;   <br><br>i = 18  <br>i = &quot;Go编程时光&quot; <br></code></pre></td></tr></table></figure><h2 id="你能在Go中的单个声明中声明多种类型的变量吗？"><a href="#你能在Go中的单个声明中声明多种类型的变量吗？" class="headerlink" title="你能在Go中的单个声明中声明多种类型的变量吗？"></a>你能在Go中的单个声明中声明多种类型的变量吗？</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 一次性声明多个不同类型的变量</span><br><span class="hljs-keyword">var</span> n4, name, n5 = <span class="hljs-number">100</span>, <span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">888</span><br></code></pre></td></tr></table></figure><h2 id="如何在Go中打印变量的类型？"><a href="#如何在Go中打印变量的类型？" class="headerlink" title="如何在Go中打印变量的类型？"></a>如何在Go中打印变量的类型？</h2><ul><li>使用反射</li><li>使用格式输出 <code>%T</code></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;reflect&quot;</span><br>)<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> num <span class="hljs-type">float64</span> = <span class="hljs-number">3.14</span><br> <br>    <span class="hljs-comment">// 方法1：</span><br>    <span class="hljs-built_in">println</span>(reflect.TypeOf(num).Name())<br> <br>    <span class="hljs-comment">// 和方法1一样，可是省略后面的Name()</span><br>    fmt.Println(reflect.TypeOf(num))<br> <br>    <span class="hljs-comment">// 方法2：</span><br>    fmt.Printf(<span class="hljs-string">`%T`</span>, num)<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="什么是指针？"><a href="#什么是指针？" class="headerlink" title="什么是指针？"></a>什么是指针？</h2><p>指针也就是内存地址，指针变量是用来存放内存地址的变量，不同类型的指针变量所占用的存储单元长度是相同的，而存放数据的变量因数据的类型不同，所占用的存储空间长度也不同。</p><h2 id="break语句的目的是什么？"><a href="#break语句的目的是什么？" class="headerlink" title="break语句的目的是什么？"></a>break语句的目的是什么？</h2><p>用break语句可以使流程跳出switch语句体，也可以用break语句在循环结构终止本层循环体，从而提前结束本层循环。</p><h2 id="continue语句的目的是什么？"><a href="#continue语句的目的是什么？" class="headerlink" title="continue语句的目的是什么？"></a>continue语句的目的是什么？</h2><p>continue语句的作用是跳过本次循环体中余下尚未执行的语句，立即进行下一次的循环条件判定，可以理解为仅结束本次循环。</p><h2 id="goto语句的目的是什么？"><a href="#goto语句的目的是什么？" class="headerlink" title="goto语句的目的是什么？"></a>goto语句的目的是什么？</h2><p>goto语句可以使程序在没有任何条件的情况下跳转到指定的位置，所以goto语句又被称为是无条件跳转语句。</p><h2 id="解释’for’循环的语法"><a href="#解释’for’循环的语法" class="headerlink" title="解释’for’循环的语法"></a>解释’for’循环的语法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> init; condition; post &#123; &#125;<br><br><span class="hljs-comment">// 类似C的while</span><br><span class="hljs-keyword">for</span> condition &#123; &#125;<br><br><span class="hljs-comment">// 类似C的for(;;;)</span><br><span class="hljs-keyword">for</span> &#123; &#125;<br></code></pre></td></tr></table></figure><ul><li>init： 一般为赋值表达式，给控制变量赋初值；</li><li>condition： 关系表达式或逻辑表达式，循环控制条件；</li><li>post： 一般为赋值表达式，给控制变量增量或减量。</li></ul><h2 id="解释在Go中创建函数的语法"><a href="#解释在Go中创建函数的语法" class="headerlink" title="解释在Go中创建函数的语法"></a>解释在Go中创建函数的语法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">function_name</span><span class="hljs-params">( [parameter list] )</span></span> [return_types] &#123;<br>   函数体<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="你能从函数中返回多个值吗？"><a href="#你能从函数中返回多个值吗？" class="headerlink" title="你能从函数中返回多个值吗？"></a>你能从函数中返回多个值吗？</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 返回多个值</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">swap</span><span class="hljs-params">(x, y <span class="hljs-type">string</span>)</span></span> (<span class="hljs-type">string</span>, <span class="hljs-type">string</span>) &#123;<br>   <span class="hljs-keyword">return</span> y, x<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="您可以将参数传递给方法的方式有多少？"><a href="#您可以将参数传递给方法的方式有多少？" class="headerlink" title="您可以将参数传递给方法的方式有多少？"></a>您可以将参数传递给方法的方式有多少？</h2><ul><li>值传递：值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</li><li>引用传递：引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</li></ul><h2 id="将参数传递给函数的默认方式是什么？"><a href="#将参数传递给函数的默认方式是什么？" class="headerlink" title="将参数传递给函数的默认方式是什么？"></a>将参数传递给函数的默认方式是什么？</h2><p>值传递。</p><h2 id="Go中的函数作为值是什么意思？"><a href="#Go中的函数作为值是什么意思？" class="headerlink" title="Go中的函数作为值是什么意思？"></a>Go中的函数作为值是什么意思？</h2><p>函数定义后可作为另外一个函数的实参数传入。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>   <span class="hljs-comment">/* 声明函数变量 */</span><br>   getSquareRoot := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x <span class="hljs-type">float64</span>)</span></span> <span class="hljs-type">float64</span> &#123;<br>      <span class="hljs-keyword">return</span> math.Sqrt(x)<br>   &#125;<br><br>   <span class="hljs-comment">/* 使用函数 */</span><br>   fmt.Println(getSquareRoot(<span class="hljs-number">9</span>))<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Go中的方法是什么？"><a href="#Go中的方法是什么？" class="headerlink" title="Go中的方法是什么？"></a>Go中的方法是什么？</h2><p>Go 语言中同时有函数和方法。<strong>一个方法就是一个包含了接受者的函数</strong>，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集</p><h2 id="Go中变量的默认值"><a href="#Go中变量的默认值" class="headerlink" title="Go中变量的默认值"></a>Go中变量的默认值</h2><p>解释Printf（）函数的用途。</p><h2 id="什么是左值和右值？"><a href="#什么是左值和右值？" class="headerlink" title="什么是左值和右值？"></a>什么是左值和右值？</h2><ul><li><p>左值：通俗一点就是可以放在赋值号左边的叫左值 就是可以被赋值的。是一个地址</p><p>  左值一般是是一个变量可以被赋值的变量。（const变量是一个例外只能做右值）</p></li><li><p>右值：可以放在赋值号右边的 就是可以给其他变量赋值的，它可以是一个变量也可以是一个常量也可以是一个表达式。</p></li></ul><p>实际和形式参数之间有什么区别？</p><p>变量声明和变量定义有什么区别？</p><p>解释模块化编程。</p><p>什么是令牌？</p><h2 id="哪个关键字用于执行无条件分支？"><a href="#哪个关键字用于执行无条件分支？" class="headerlink" title="哪个关键字用于执行无条件分支？"></a>哪个关键字用于执行无条件分支？</h2><p>goto关键字。</p><h3 id="Go中高效的洗牌算法"><a href="#Go中高效的洗牌算法" class="headerlink" title="Go中高效的洗牌算法"></a>Go中高效的洗牌算法</h3><p>使用go自带的rand.Perm()函,将一个切片里的数据随机打散重排。</p><h4 id="rand-Perm的实现算法"><a href="#rand-Perm的实现算法" class="headerlink" title="rand.Perm的实现算法"></a>rand.Perm的实现算法</h4><p>这是采用随机交换的算法，随着i从0到n循环，先生成随机数j :&#x3D; r.Intn(i +1)，然后交换m[i] &#x3D; m[j]，m[j] &#x3D; i，每次将数组里的随机位置与当前最大值（i）进行交换（原来的值放入最后）。这个时间复杂度是O(n)，是很快的算法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Perm</span><span class="hljs-params">(nint)</span></span> []<span class="hljs-type">int</span> &#123;<span class="hljs-keyword">return</span> globalRand.Perm(n) &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(r *Rand)</span></span>Perm(nint) []<span class="hljs-type">int</span> &#123;<br>m :=<span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i :=<span class="hljs-number">0</span>; i &lt; n; i++ &#123;<br>m[i] = m[j]<br>m[j] = i<br>&#125;<br><span class="hljs-keyword">return</span> m<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="Go中的零指针是什么？"><a href="#Go中的零指针是什么？" class="headerlink" title="Go中的零指针是什么？"></a>Go中的零指针是什么？</h2><p>空指针。当一个指针被定义后没有分配到任何变量时，它的值为 nil。</p><h2 id="指针上的指针是什么？"><a href="#指针上的指针是什么？" class="headerlink" title="指针上的指针是什么？"></a>指针上的指针是什么？</h2><p>Go的结构是什么？</p><p>如何在Go中定义一个结构？</p><p>Go中的切片是什么？</p><p>如何在Go中定义切片？</p><p>如何获取切片中存在的元素数？</p><h3 id="Go中slice的len（）和cap（）函数有什么区别？"><a href="#Go中slice的len（）和cap（）函数有什么区别？" class="headerlink" title="Go中slice的len（）和cap（）函数有什么区别？"></a>Go中slice的len（）和cap（）函数有什么区别？</h3><h2 id="如何获得切片的子切片？"><a href="#如何获得切片的子切片？" class="headerlink" title="如何获得切片的子切片？"></a>如何获得切片的子切片？</h2><h3 id="Go的范围-range-是什么？"><a href="#Go的范围-range-是什么？" class="headerlink" title="Go的范围(range)是什么？"></a>Go的范围(range)是什么？</h3><p>Go中的range关键字用于for循环中迭代数组(array)、切片(slice)、通道(channel)、集合(map)的元素。</p><p>Go中的地图是什么？</p><p>如何在Go中创建地图？</p><p>如何从Go中删除地图中的条目？</p><p>什么是Go中的类型转换？</p><p>Go中的接口是什么？</p><p>Go程序能链接C&#x2F;C++程序吗</p><h3 id="为什么Go没有泛型"><a href="#为什么Go没有泛型" class="headerlink" title="为什么Go没有泛型"></a>为什么Go没有泛型</h3><ul><li>泛型困境使我们必须在开发效率、编译速度和运行速度三者中选择两个；</li><li>目前社区中的 Go 语言方案都是有缺陷的，而 Go 团队认为泛型的支持不够紧急；</li></ul><h3 id="为什么用CSP思想构建并发"><a href="#为什么用CSP思想构建并发" class="headerlink" title="为什么用CSP思想构建并发"></a>为什么用CSP思想构建并发</h3><p>因为Go的并发是基于goroutine的，goroutine的通信基于channel，并发意味着对资源的争夺，go采用的是用通信的方式共享内存，在并发设计上为channel为关注点，而不是通信的实体，所以，适合CSP。（CSP【Communicating Sequential Process，通信顺序模型】）</p><h3 id="为什么没有goroutine-ID"><a href="#为什么没有goroutine-ID" class="headerlink" title="为什么没有goroutine ID"></a>为什么没有goroutine ID</h3><p>以前有获取goroutine id的函数，后来删除了，原因是担心人们使用goroutineid构建协程私有存储，这样很容易导致协程资源一直被占用，无法正常被gc回收。</p><h3 id="restful熟悉吗？都有哪些请求方法，分别代表什么意思？"><a href="#restful熟悉吗？都有哪些请求方法，分别代表什么意思？" class="headerlink" title="restful熟悉吗？都有哪些请求方法，分别代表什么意思？"></a>restful熟悉吗？都有哪些请求方法，分别代表什么意思？</h3><ul><li>GET</li><li>PUT</li><li>POST</li><li>DELET</li></ul><p>手写循环队列</p><p>进程虚拟空间分布，全局变量放哪里？</p><p>c++ 和 go对比</p><p>怎么理解云计算</p><p>go使用踩过什么坑</p><p>go命令，go get，go tool，go test，go vet</p><h2 id="go什么情况下会发生内存泄漏？"><a href="#go什么情况下会发生内存泄漏？" class="headerlink" title="go什么情况下会发生内存泄漏？"></a>go什么情况下会发生内存泄漏？</h2><ul><li>substring使用不当造成的内存泄漏</li><li>被goroutine hang住的内存泄漏</li><li>time.Ticker应该被stop，在不被使用的时候</li><li>不恰当的使用析构函数</li></ul><p>具体：<a href="https://blog.csdn.net/weixin_44328662/article/details/89741782">https://blog.csdn.net/weixin_44328662/article/details/89741782</a></p><h2 id="go为什么高并发好？"><a href="#go为什么高并发好？" class="headerlink" title="go为什么高并发好？"></a>go为什么高并发好？</h2><p>go的分布式</p><p>谈谈go的未来</p><h2 id="Go-slice和array的区别"><a href="#Go-slice和array的区别" class="headerlink" title="Go slice和array的区别"></a>Go slice和array的区别</h2><h2 id="GMP模型，该模型有什么好处"><a href="#GMP模型，该模型有什么好处" class="headerlink" title="GMP模型，该模型有什么好处"></a>GMP模型，该模型有什么好处</h2><h2 id="string-从-“abc”-到-“abcd”，如何分配内存的"><a href="#string-从-“abc”-到-“abcd”，如何分配内存的" class="headerlink" title="string 从 “abc” 到 “abcd”，如何分配内存的"></a>string 从 “abc” 到 “abcd”，如何分配内存的</h2><h2 id="看过unsafe包吗"><a href="#看过unsafe包吗" class="headerlink" title="看过unsafe包吗"></a>看过unsafe包吗</h2><h2 id="说一下string和-byte的高效转换"><a href="#说一下string和-byte的高效转换" class="headerlink" title="说一下string和[]byte的高效转换"></a>说一下string和[]byte的高效转换</h2><h2 id="协程和线程的区别"><a href="#协程和线程的区别" class="headerlink" title="协程和线程的区别"></a>协程和线程的区别</h2><h2 id="GC流程"><a href="#GC流程" class="headerlink" title="GC流程"></a>GC流程</h2><p>扫描-标记-清除</p><h2 id="Java和Golang有什么区别"><a href="#Java和Golang有什么区别" class="headerlink" title="Java和Golang有什么区别"></a>Java和Golang有什么区别</h2><h2 id="Go编译速度快的主要原因"><a href="#Go编译速度快的主要原因" class="headerlink" title="Go编译速度快的主要原因"></a>Go编译速度快的主要原因</h2><ul><li>使用了import的引用管理方式</li><li>没有模板的编译负担</li><li>1.5版本后的自举编译器优化</li><li>更少的关键字</li></ul><h2 id="recover能处理所有的异常吗"><a href="#recover能处理所有的异常吗" class="headerlink" title="recover能处理所有的异常吗"></a>recover能处理所有的异常吗</h2><p>根据目前查到的资料和实践， recover能处理程序主动触发的panic和除0以及空指针访问、异常地址访问等错误，因此可以认为是能处理所有异常了。</p><h2 id="golang中常量是怎么实现的"><a href="#golang中常量是怎么实现的" class="headerlink" title="golang中常量是怎么实现的"></a>golang中常量是怎么实现的</h2><p>这个问法还是很奇怪的， 从汇编中看是对字符串常量加了一个标号，同时设置为SRODATA，也就是只读，对数字常量直接在代码中作为立即数使用了</p><h2 id="golang的make和new的区别是什么"><a href="#golang的make和new的区别是什么" class="headerlink" title="golang的make和new的区别是什么"></a>golang的make和new的区别是什么</h2><ul><li>new有点像c++里面的new,用来初始化各种type，然后返回其指针。 只不过由于没有构造函数的存在，所以全部用零值来填充，比较特殊的是slice,map,channel， 它们的零值都是nil。另外由于golang直接可以用&amp;struct{} 形式来初始化，所以平时用到new的机会也比较少。</li><li>make是用来初始化map,slice,以及channel的， 它返回的不是指针，而是对象本身。另外，make出来的map,slice,channel都是可以直接使用的。</li></ul><h2 id="golang-的channel是怎么实现的"><a href="#golang-的channel是怎么实现的" class="headerlink" title="golang 的channel是怎么实现的"></a>golang 的channel是怎么实现的</h2><p> golang的channel是个结构体，里面大概包含了三大部分：<br> a. 指向内容的环形缓存区，及其相关游标<br> b. 读取和写入的排队goroutine链表<br> c. 锁<br>任何操作前都需要获得锁， 当写满或者读空的时候，就将当前goroutine加入到recvq或者sendq中， 并出让cpu(gopark)。</p><h2 id="简单描述下golang的gc算法"><a href="#简单描述下golang的gc算法" class="headerlink" title="简单描述下golang的gc算法"></a>简单描述下golang的gc算法</h2><p> golang现行的gc算法是三色标记法，三色指的是在gc过程中会把对象标记给黑，灰，白三色。<br> 三色标记法是对标记-清除算法的优化，目的是减少stop the world的时间。</p><h4 id="标记-清除算法："><a href="#标记-清除算法：" class="headerlink" title="标记-清除算法："></a>标记-清除算法：</h4><p>对象只有黑白两色</p><ol><li>stop the world,即停止所有goroutine</li><li>从根对象（全局指针和栈上的对象）出发，把所有能直接或间接访问到的对象标记为黑色，其它所有对象标志为白色</li><li>清除所有白色对象</li><li>start the world</li></ol><h4 id="三色标记法："><a href="#三色标记法：" class="headerlink" title="三色标记法："></a>三色标记法：</h4><p>对象有黑白灰三色</p><ol><li>stop the world</li><li>将根对象全部标记为灰色</li><li>start the world</li><li>在goroutine中进行对灰色对象进行遍历， 将灰色对象引用的每个对象标记为灰色，然后将该灰色对象标记为黑色。</li><li>重复执行4， 直接将所有灰色对象都变成黑色对象。</li><li>stop the world，清除所有白色对象</li></ol><p>这里4，5是与用户程序是并发执行的，所以stw的时间被大大缩短了。 不过这样做可能会导致新创建的对象被误清除，因此使用了写屏障技术来解决该问题，大体逻辑是当创建新对象时将新对象置为灰色。</p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a><a href="https://geektutu.com/post/qa-golang-1.html">基础语法</a></h2><h3 id="和-的区别？"><a href="#和-的区别？" class="headerlink" title="= 和 := 的区别？"></a><code>=</code> 和 <code>:=</code> 的区别？</h3><p><code>=</code> 是赋值语句，可以定义全局变量；<code>:=</code>是声明类型（编译器帮你做的）并赋值，只能定义局部变量</p><h3 id="指针的作用"><a href="#指针的作用" class="headerlink" title="指针的作用"></a>指针的作用</h3><ul><li><p>提高执行效率：指针保存的是变量的地址，在传递变量时时引用传递，省去了值传递复制变量值的过程，提高了效率，特别是当变量体积比较大时，效率提升明显；</p></li><li><p>修改引用对象的值</p></li><li><p>方便判空操作：指针类型的零值是nil，其他类型的零值因类型不同，判空需要事先知道其类型，指针则不需要</p></li><li><p>判断值是否改变：当一个复杂类型的值被传递多次后，保存的名称和容器可能改变，但只要使用指针就行对比，就能知道是否是原来的值。</p></li></ul><h3 id="Go-允许多个返回值吗？"><a href="#Go-允许多个返回值吗？" class="headerlink" title="Go 允许多个返回值吗？"></a>Go 允许多个返回值吗？</h3><p>可以。官方建议：最好命名返回值，因为不命名返回值，虽然使得代码更加简洁了，但是会造成生成的文档可读性差。</p><h3 id="Go-有异常类型吗？"><a href="#Go-有异常类型吗？" class="headerlink" title="Go 有异常类型吗？"></a>Go 有异常类型吗？</h3><p>有，error，panic，recover</p><h3 id="什么是协程（Goroutine）"><a href="#什么是协程（Goroutine）" class="headerlink" title="什么是协程（Goroutine）"></a>什么是协程（Goroutine）</h3><p>Goroutines 是在 Golang 中执行并发任务的方式。它们仅存在于 Go 运行时的虚拟空间中而不存在于 OS 中，右 Go 调度器来管理它们的生命周期，Go Runtime为实现对go routine的调度需要维护一个GMP模型。</p><h3 id="如何高效地拼接字符串"><a href="#如何高效地拼接字符串" class="headerlink" title="如何高效地拼接字符串"></a>如何高效地拼接字符串</h3><p>使用<code>bytes.Buffer</code>来组装字符串，不要用”+”，不需要遍历，只需要将添加的字符串放在缓存末尾即可</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;bytes&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> buffer bytes.Buffer<br>    <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>        buffer.WriteString(<span class="hljs-string">&quot;a&quot;</span>)<br>    &#125;<br>    fmt.Println(buffer.String())<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="什么是-rune-类型"><a href="#什么是-rune-类型" class="headerlink" title="什么是 rune 类型"></a>什么是 rune 类型</h3><p>int32的别名，几乎在所有方面等同于int32，它用来区分字符值和整数值。</p><blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;unicode/utf8&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>    <span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;hello 你好&quot;</span><br><br>    <span class="hljs-comment">//golang中string底层是通过byte数组实现的，座椅直接求len 实际是在按字节长度计算  所以一个汉字占3个字节算了3个长度</span><br>    fmt.Println(<span class="hljs-string">&quot;len(str):&quot;</span>, <span class="hljs-built_in">len</span>(str)) <span class="hljs-comment">// len(str):12</span><br>    <br>    <span class="hljs-comment">//以下两种都可以得到str的字符串长度</span><br>    <br>    <span class="hljs-comment">//golang中的unicode/utf8包提供了用utf-8获取长度的方法</span><br>    fmt.Println(<span class="hljs-string">&quot;RuneCountInString:&quot;</span>, utf8.RuneCountInString(str)) <span class="hljs-comment">// RuneCountInString: 8</span><br><br>    <span class="hljs-comment">//通过rune类型处理unicode字符</span><br>    fmt.Println(<span class="hljs-string">&quot;rune:&quot;</span>, <span class="hljs-built_in">len</span>([]<span class="hljs-type">rune</span>(str))) <span class="hljs-comment">// rune: 8</span><br>&#125;<br></code></pre></td></tr></table></figure><p>golang中string底层是通过byte数组实现的。中文字符在unicode下占2个字节，在utf-8编码下占3个字节，而golang默认编码正好是utf-8。</p><p>golang中还有一个 byte 数据类型与 rune 相似，它们都是用来表示字符类型的变量类型。它们的不同在于：</p><ul><li>byte 等同于int8，常用来处理ascii字符</li><li>rune 等同于int32,常用来处理unicode或utf-8字符</li></ul></blockquote><h3 id="如何判断-map-中是否包含某个-key"><a href="#如何判断-map-中是否包含某个-key" class="headerlink" title="如何判断 map 中是否包含某个 key ?"></a>如何判断 map 中是否包含某个 key ?</h3><p>在根据 key 取 map 中值的时候，会返回两个值，如果存在，第一个值为 value 值，第二个为 bool 值，为true；如果不存在，则返回一个值nil，第二个值 false，只需要判断第二个值的真假就能知道map知否含有某个key。 </p><h3 id="Go-支持默认参数或可选参数吗？"><a href="#Go-支持默认参数或可选参数吗？" class="headerlink" title="Go 支持默认参数或可选参数吗？"></a>Go 支持默认参数或可选参数吗？</h3><p>不支持，但支持可变参数</p><h3 id="defer-的执行顺序"><a href="#defer-的执行顺序" class="headerlink" title="defer 的执行顺序"></a>defer 的执行顺序</h3><p>按照后进先出的方式执行</p><h3 id="如何交换-2-个变量的值？"><a href="#如何交换-2-个变量的值？" class="headerlink" title="如何交换 2 个变量的值？"></a>如何交换 2 个变量的值？</h3><ul><li>借助多重赋值的特性</li><li>使用临时变量</li></ul><h3 id="Go-语言-tag-的用处？"><a href="#Go-语言-tag-的用处？" class="headerlink" title="Go 语言 tag 的用处？"></a>Go 语言 tag 的用处？</h3><ul><li>指导json.Marshal&#x2F;Unmarshal</li><li>对struct字段进行验证</li></ul><p><a href="https://www.jianshu.com/p/c7d5c1c8a2d8">Go tag</a></p><p><a href="Golang%E8%A7%A3%E6%9E%90%E6%A0%87%E7%AD%BE%E4%B8%BB%E8%A6%81%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%AE%9E%E7%8E%B0">Go解析tag是用reflect实现</a></p><h3 id="如何判断-2-个字符串切片（slice-是相等的？"><a href="#如何判断-2-个字符串切片（slice-是相等的？" class="headerlink" title="如何判断 2 个字符串切片（slice) 是相等的？"></a>如何判断 2 个字符串切片（slice) 是相等的？</h3><ul><li>牺牲性能：使用 reflect.DeepEqual(a,b)，他可以深度比较两个对象及其它们内部包含的元素是否相等，适用于任何类型的slice</li><li>牺牲普适性：手写判断规则，只适用于已知类型的slice</li></ul><h3 id="字符串打印时，-v-、-v、-v-的区别"><a href="#字符串打印时，-v-、-v、-v-的区别" class="headerlink" title="字符串打印时，%v 、%+v、%#v 的区别"></a>字符串打印时，<code>%v</code> 、<code>%+v</code>、<code>%#v</code> 的区别</h3><p>\1. <strong>%v   只输出所有的值</strong></p><p>\2. <strong>%+v 先输出字段类型，再输出该字段的值</strong></p><p>\3. <strong>%#v 先输出结构体名字值，再输出结构体（字段类型+字段的值）</strong></p><h3 id="Go-语言中如何表示枚举值-enums-？"><a href="#Go-语言中如何表示枚举值-enums-？" class="headerlink" title="Go 语言中如何表示枚举值(enums)？"></a>Go 语言中如何表示枚举值(enums)？</h3><p>Go 语言没有 <code>enum</code> 关键字，但可以通过使用 <code>const</code> &amp; <code>iota</code> 可以实现枚举的能力。</p><h3 id="为什么要使用枚举？"><a href="#为什么要使用枚举？" class="headerlink" title="为什么要使用枚举？"></a>为什么要使用枚举？</h3><p>Stackoverflow 上有个问题 <a href="https://link.zhihu.com/?target=https://stackoverflow.com/questions/4709175/what-are-enums-and-why-are-they-useful">What are enums and why are they useful?</a> 中的回答很具备说服力。</p><blockquote><p>当一个变量（尤其是一个方法的参数）仅能取自一个很小的选择集合中时，就应该使用枚举。例如类型常量（合同状态： “permanent”, “temp”, “apprentice”）或者标记（“执行中”、“延后执行”）等。<br>当使用枚举去替代整数时，运行时会去检查传入的参数是否是合法参数（是否在定义的枚举集合当中），避免错误的传入了一个不可用的常量。</p></blockquote><h3 id="空-struct-的用途"><a href="#空-struct-的用途" class="headerlink" title="空 struct{} 的用途"></a>空 struct{} 的用途</h3><ul><li>空结构体的特点<ul><li>不占用内存</li><li>地址不变</li></ul></li><li>空结构体作用<ul><li>建议用于传递信号的通道，因为不占用内存</li></ul></li></ul><p><a href="https://www.cnblogs.com/MyUniverse/p/11595043.html">空结构体的作用</a></p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a><a href="https://geektutu.com/post/qa-golang-2.html">实现原理</a></h2><h3 id="init-函数是什么时候执行的？"><a href="#init-函数是什么时候执行的？" class="headerlink" title="init() 函数是什么时候执行的？"></a>init() 函数是什么时候执行的？</h3><p><code>main</code>包下的init()函数是在main执行前执行，其他包的init函数实在包被import后执行，如果一个文件有多个init()函数，将按照声明顺序依次执行。</p><h3 id="Go-语言的局部变量分配在栈上还是堆上？"><a href="#Go-语言的局部变量分配在栈上还是堆上？" class="headerlink" title="Go 语言的局部变量分配在栈上还是堆上？"></a>Go 语言的局部变量分配在栈上还是堆上？</h3><p>分两种情况，一种是局部变量生命周期随它的作用域生命周期相同，那么分配在栈上，如果该变量能够逃离它原先的作用域，那么会分配在栈上，这也是由Go的编译器在对局部变量进行逃逸分析后的分配结果。</p><h3 id="2-个-interface-可以比较吗-？"><a href="#2-个-interface-可以比较吗-？" class="headerlink" title="2 个 interface 可以比较吗 ？"></a>2 个 interface 可以比较吗 ？</h3><p>可以比较。分两种情况，一种都是nil可以比较，另外一种，动态类型和动态值相等。</p><h3 id="2-个-nil-可能不相等吗？"><a href="#2-个-nil-可能不相等吗？" class="headerlink" title="2 个 nil 可能不相等吗？"></a>2 个 nil 可能不相等吗？</h3><p>可能。nil是无类型的，但是值为nil的变量是有类型的，它们在比较的时候会因为类型不同而导致不同。</p><h3 id="简述-Go-语言GC-垃圾回收-的工作原理"><a href="#简述-Go-语言GC-垃圾回收-的工作原理" class="headerlink" title="简述 Go 语言GC(垃圾回收)的工作原理"></a>简述 Go 语言GC(垃圾回收)的工作原理</h3><p>在内存堆中存储着有一系列的对象，这些对象可能会与其他对象有关联（references between these objects） a tracing garbage collector 会在某一个时间点上停止原本正在运行的程序，之后它会扫描 runtim e已经知道的的 object 集合（already known set of objects），通常它们是存在于 stack 中的全局变量以及各种对象。gc 会对这些对象进行标记，将这些对象的状态标记为可达，从中找出所有的，从当前的这些对象可以达到其他地方的对象的 reference，并且将这些对象也标记为可达的对象，这个步骤被称为 mark phase，即<strong>标记阶段</strong>，这一步的主要目的是用于获取这些对象的状态信息。</p><p>一旦将所有的这些对象都扫描完，gc 就会获取到所有的无法 reach 的对象（状态为 unreachable 的对象），并且将它们回收，这一步称为 sweep phase，即是<strong>清扫阶段</strong>。</p><p>gc 仅仅搜集那些未被标记为可达（reachable）的对象。如果 gc 没有识别出一个 reference，最后有可能会将一个仍然在使用的对象给回收掉，就引起了程序运行错误。</p><p>可以看到主要的三个步骤：扫描，回收，清扫。</p><h3 id="函数返回局部变量的指针是否安全？"><a href="#函数返回局部变量的指针是否安全？" class="headerlink" title="函数返回局部变量的指针是否安全？"></a>函数返回局部变量的指针是否安全？</h3><p>安全，因为GC会捕获这个变量，等他生命周期结束清除掉。</p><h3 id="非接口非接口的任意类型-T-都能够调用-T-的方法吗？反过来呢？"><a href="#非接口非接口的任意类型-T-都能够调用-T-的方法吗？反过来呢？" class="headerlink" title="非接口非接口的任意类型 T() 都能够调用 *T 的方法吗？反过来呢？"></a>非接口非接口的任意类型 T() 都能够调用 <code>*T</code> 的方法吗？反过来呢？</h3><h2 id="并发编程"><a href="#并发编程" class="headerlink" title="并发编程"></a><a href="https://geektutu.com/post/qa-golang-3.html">并发编程</a></h2><h3 id="无缓冲的-channel-和有缓冲的-channel-的区别？"><a href="#无缓冲的-channel-和有缓冲的-channel-的区别？" class="headerlink" title="无缓冲的 channel 和有缓冲的 channel 的区别？"></a>无缓冲的 channel 和有缓冲的 channel 的区别？</h3><p>它们的区别就是一个是同步的，一个是非同步的。无缓冲的channle发送者必须等接受者接收完毕才能继续发送，否则就一直等待，这在一定程度上可以确保发送的数据一定能被接受者接收。无缓冲的发送者只管发送，不需要考虑接受者是否收到了，只有到缓冲区满了，才会阻塞。</p><h3 id="什么是协程泄露-Goroutine-Leak-？"><a href="#什么是协程泄露-Goroutine-Leak-？" class="headerlink" title="什么是协程泄露(Goroutine Leak)？"></a>什么是协程泄露(Goroutine Leak)？</h3><p>“goroutine leak,是go协程泄漏,什么是go协程泄漏,通俗来说,开启了一个goroutine,用完后,我们要正确让其结束。如果它没用了,还没结束,那就是goroutine leak。”</p><h3 id="协程泄漏产生原因"><a href="#协程泄漏产生原因" class="headerlink" title="协程泄漏产生原因"></a>协程泄漏产生原因</h3><ul><li>goroutine由于channel的读&#x2F;写端退出而一直阻塞，导致goroutine一直占用资源，而无法退出</li><li>goroutine进入死循环中，导致资源一直无法释放</li></ul><h3 id="Go-可以限制运行时操作系统线程的数量吗？"><a href="#Go-可以限制运行时操作系统线程的数量吗？" class="headerlink" title="Go 可以限制运行时操作系统线程的数量吗？"></a>Go 可以限制运行时操作系统线程的数量吗？</h3><p>GOMAXPROCS变量限制</p><h2 id="Go的地图"><a href="#Go的地图" class="headerlink" title="Go的地图"></a>Go的地图</h2><p><a href="https://blog.csdn.net/cukw6666/article/details/107982955">(2条消息) golang go语言_在Go中了解地图_cukw6666的博客-CSDN博客</a></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
      <category>Go相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>面试</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Go语言数组索引的有趣现象</title>
    <link href="/2021/03/07/%E5%85%B3%E4%BA%8EGo%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%89%E8%B6%A3%E7%8E%B0%E8%B1%A1/"/>
    <url>/2021/03/07/%E5%85%B3%E4%BA%8EGo%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9C%89%E8%B6%A3%E7%8E%B0%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载：<a href="https://blog.csdn.net/u012807459/article/details/39135849">https://blog.csdn.net/u012807459/article/details/39135849</a></p></blockquote><p>在Twitter上看到Dave Cheney提了个pop quiz  勾起了我的好奇心，可以猜下下面这段代码的运行结果。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>: <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>: <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>: <span class="hljs-number">4</span>&#125;<br>fmt.Println(a)<br>&#125;<br></code></pre></td></tr></table></figure><p>go run 一下结果就出来了 但是比较有意思的是结果是</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">[5 4 3 2 1 0]<br></code></pre></td></tr></table></figure><p>下面就一步步地分析是什么情况</p><p>[number:value] 在go的数组中代表的是在索引未number处的位置上值为value 如果索引值越界了就会重置。</p><p>5 _ _ _ _ _   index : 0, value : 5</p><p>5 _ _ _ 1 _   index : 4, value : 1</p><p>5 _ _ _ 1 0   index : 5, value : 0 因为上一个操作的元素索引为4 ([4:1])所以下一个操作的元素索引自动加1</p><p>5 _ 3 _ 1 0   index : 2, value : 3</p><p>5 _ 3 2 1 0   index : 3, value : 2 因为上一个操作的元素索引为2 ([2:3])所以下一个操作的元素索引自动加1 </p><p>5 1 3 2 1 0   index : 1, value : 4</p><p>操作数组元素的顺序是按照声明时的顺序，顺序操作的。5 1 0 3 2 4就是按照这个顺序 进行操作的。</p><p>所以如果把代码改一下就会报错 比如下面的例子</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br> <br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := [...]<span class="hljs-type">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>: <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>: <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>: <span class="hljs-number">4</span>, <span class="hljs-number">10</span>&#125;<br>fmt.Println(a)<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">prog.go:6: duplicate index in array literal: 2<br> [process exited with non-zero status]<br></code></pre></td></tr></table></figure><p>报错信息是 第二个索引重复了</p><p>接着上面的分析</p><p>5 1 3 2 1 0 index : 1, value : 4 这时如果继续操作下一个元素根据规则 索引加1</p><p>也就是 要对index : 2 的元素进行 value : 10的操作 但是之前我们已经在索引为2时赋值过了 所以就会有异常</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">duplicate index in array literal: 2<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go的time包</title>
    <link href="/2021/03/05/Go%E7%9A%84time%E5%8C%85/"/>
    <url>/2021/03/05/Go%E7%9A%84time%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h2 id="获取时间对象"><a href="#获取时间对象" class="headerlink" title="获取时间对象"></a>获取时间对象</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 获取当前时间</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Now</span><span class="hljs-params">()</span></span> Time<br><br><span class="hljs-comment">// 获取指定时间</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Date</span><span class="hljs-params">(year <span class="hljs-type">int</span>, month Month, day, hour, min, sec, nsec <span class="hljs-type">int</span>, loc *Location)</span></span> Time<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Date returns the Time corresponding to</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">yyyy-mm-dd hh:mm:ss + nsec nanoseconds</span><br><span class="hljs-comment">in the appropriate zone for that time in the given location.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">The month, day, hour, min, sec, and nsec values may be outside their usual ranges and will be normalized during the conversion. For example, October 32 converts to November 1.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">A daylight savings time transition skips or repeats times. For example, in the United States, March 13, 2011 2:15am never occurred, while November 6, 2011 1:15am occurred twice. In such cases, the choice of time zone, and therefore the time, is not well-defined. Date returns a time that is correct in one of the two zones involved in the transition, but it does not guarantee which.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Date panics if loc is nil.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="日期和文本的转换"><a href="#日期和文本的转换" class="headerlink" title="日期和文本的转换"></a>日期和文本的转换</h2><h3 id="日期转文本"><a href="#日期转文本" class="headerlink" title="日期转文本"></a>日期转文本</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Time)</span></span> Format(layout <span class="hljs-type">string</span>) <span class="hljs-type">string</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Format returns a textual representation of the time value formatted according to layout, which defines the format by showing how the reference time, defined to be</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Mon Jan 2 15:04:05 -0700 MST 2006</span><br><span class="hljs-comment">would be displayed if it were the value; it serves as an example of the desired output. The same display rules will then be applied to the time value.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">A fractional second is represented by adding a period and zeros to the end of the seconds section of layout string, as in &quot;15:04:05.000&quot; to format a time stamp with millisecond precision.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Predefined layouts ANSIC, UnixDate, RFC3339 and others describe standard and convenient representations of the reference time. For more information about the formats and the definition of the reference time, see the documentation for ANSIC and the other constants defined by this package.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h3 id="文本转日期"><a href="#文本转日期" class="headerlink" title="文本转日期"></a>文本转日期</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Parse</span><span class="hljs-params">(layout, value <span class="hljs-type">string</span>)</span></span> (Time, <span class="hljs-type">error</span>)<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Parse parses a formatted string and returns the time value it represents. The layout defines the format by showing how the reference time, defined to be</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">Mon Jan 2 15:04:05 -0700 MST 2006</span><br><span class="hljs-comment">would be interpreted if it were the value; it serves as an example of the input format. The same interpretation will then be made to the input string.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="时间戳"><a href="#时间戳" class="headerlink" title="时间戳"></a>时间戳</h2><p>指定的日期(当前日期，指定的某个日期)，距离1970年1月1日0点0时0分0秒的时间差值。有秒，纳秒两种函数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 单位：秒</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Time)</span></span> Unix() <span class="hljs-type">int64</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Unix returns t as a Unix time, the number of seconds elapsed since January 1, 1970 UTC. The result does not depend on the location associated with t.</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-comment">// 单位：纳秒</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Time)</span></span> UnixNano() <span class="hljs-type">int64</span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">UnixNano returns t as a Unix time, the number of nanoseconds elapsed since January 1, 1970 UTC. The result is undefined if the Unix time in nanoseconds cannot be represented by an int64 (a date before the year 1678 or after 2262). Note that this means the result of calling UnixNano on the zero Time is undefined. The result does not depend on the location associated with t.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="年月日时分秒等"><a href="#年月日时分秒等" class="headerlink" title="年月日时分秒等"></a>年月日时分秒等</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Time)</span></span> Year() <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Time)</span></span> Month() Month<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Time)</span></span> Day() <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Time)</span></span> Hour() <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Time)</span></span> Minute() <span class="hljs-type">int</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Time)</span></span> Second() <span class="hljs-type">int</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t Time)</span></span> Date() (year <span class="hljs-type">int</span>, month Month, day <span class="hljs-type">int</span>)<br></code></pre></td></tr></table></figure><h2 id="Sleep"><a href="#Sleep" class="headerlink" title="Sleep()"></a>Sleep()</h2><p>在程序中调用Sleep()函数，可以让当前的程序，进入睡眠。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Duration <span class="hljs-type">int64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Sleep</span><span class="hljs-params">(d Duration)</span></span><br><span class="hljs-comment">/*</span><br><span class="hljs-comment">Sleep pauses the current goroutine for at least the duration d. A negative or zero duration causes Sleep to return immediately.</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>    <span class="hljs-string">&quot;time&quot;</span><br>    <span class="hljs-string">&quot;fmt&quot;</span><br>    <span class="hljs-string">&quot;math/rand&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    time包：</span><br><span class="hljs-comment">    1年=365天</span><br><span class="hljs-comment">        day</span><br><span class="hljs-comment">    1天=24小时hour</span><br><span class="hljs-comment">    1小时=60分钟minute</span><br><span class="hljs-comment">    1分钟=60秒</span><br><span class="hljs-comment">        second</span><br><span class="hljs-comment">    1秒=1000毫秒</span><br><span class="hljs-comment">        millisecond</span><br><span class="hljs-comment">    1毫秒=1000微秒</span><br><span class="hljs-comment">        microsecond--&gt;μs</span><br><span class="hljs-comment">    1μs = 1000纳秒</span><br><span class="hljs-comment">        nanosecond--&gt;ns</span><br><span class="hljs-comment">    1ns = 1000皮秒</span><br><span class="hljs-comment">        picosecond--&gt;ps</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    A:获取时间time对象</span><br><span class="hljs-comment">        time.Now()当前时间</span><br><span class="hljs-comment">        time.Date()指定时间</span><br><span class="hljs-comment">    B：格式化：</span><br><span class="hljs-comment">        time--&gt;string</span><br><span class="hljs-comment">            t1.Format(layout string)--&gt;string</span><br><span class="hljs-comment">        string--&gt;time</span><br><span class="hljs-comment">            time.Parse(layout string, value string)--&gt;time,error</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    C：时间戳：timeStamp</span><br><span class="hljs-comment">        t1.Unix()</span><br><span class="hljs-comment">        t1.UnixNano()</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    D：获取指定内容</span><br><span class="hljs-comment">        t1.Date()--&gt;year,month,day</span><br><span class="hljs-comment">        t1.Clock()--&gt;hour,minute,second</span><br><span class="hljs-comment">        t1.Year()--&gt;year</span><br><span class="hljs-comment">        t1.Month()--&gt;Month</span><br><span class="hljs-comment">        t1.Day()--&gt;day</span><br><span class="hljs-comment">        t1.Week()</span><br><span class="hljs-comment">        t1.Hour()</span><br><span class="hljs-comment">        t1.Minute()</span><br><span class="hljs-comment">        t1.Second()</span><br><span class="hljs-comment">        t1.NanoSecond()</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    E：时间间隔：Duration</span><br><span class="hljs-comment">        type Duration int64</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">        t1.Add(d)--&gt;time</span><br><span class="hljs-comment">        t1.Sub(t2)--&gt;d</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">    F：睡眠</span><br><span class="hljs-comment">        time.Sleep(duration)//NanoSecond</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-comment">//1.获取当前的时间</span><br>     t1:=time.Now()<br>     fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>,t1)<span class="hljs-comment">// time.Time</span><br>     fmt.Println(t1)<span class="hljs-comment">//2018-05-29 10:58:23.789029492 +0800 CST m=+0.001181079</span><br>     <span class="hljs-comment">//2.获取指定的时间</span><br>     t2 :=time.Date(<span class="hljs-number">2008</span>,<span class="hljs-number">7</span>,<span class="hljs-number">15</span>,<span class="hljs-number">16</span>,<span class="hljs-number">30</span>,<span class="hljs-number">28</span>,<span class="hljs-number">0</span>,time.Local)<br>     fmt.Println(t2)<br><br>     <span class="hljs-comment">//3.time--string之间的转换</span><br>     <span class="hljs-comment">//fmt.Println(t1.String())</span><br>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">     t1.Format(&quot;格式木板&quot;)--&gt;string</span><br><span class="hljs-comment">        模板的日期必须是固定：6-1-2-3-4-5</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     time.parse(&quot;模板&quot;,str)--&gt;time</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">      */</span><br>     s1 := t1.Format(<span class="hljs-string">&quot;2006年1月2日 15:04:05&quot;</span>)<br>     fmt.Println(s1)<br><br>     s2 :=t1.Format(<span class="hljs-string">&quot;2006-01-02&quot;</span>)<br>     fmt.Println(s2)<br><br>     s3 := <span class="hljs-string">&quot;1999年10月10日&quot;</span> <span class="hljs-comment">//string</span><br>     t3,err:=time.Parse(<span class="hljs-string">&quot;2006年1月2日&quot;</span>,s3)<br>     <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span>&#123;<br>        fmt.Println(<span class="hljs-string">&quot;err:&quot;</span>,err.Error())<br>     &#125;<br>     fmt.Println(t3)<br><br>     <span class="hljs-comment">//4.时间戳：指定的日期(当前日期，指定的某个日期)，距离1970年1月1日0点0时0分0秒的时间差值：秒，纳秒</span><br>     t4 := time.Date(<span class="hljs-number">1970</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,time.UTC)<br>     timeStamp1:=t4.Unix() <span class="hljs-comment">//秒的差值</span><br>     fmt.Println(timeStamp1)<span class="hljs-comment">//3600</span><br>     timeStamp2 :=t1.Unix()<br>     fmt.Println(timeStamp2)<br><br>     timeStamp3 :=t4.UnixNano()<span class="hljs-comment">//纳秒差值</span><br>     fmt.Println(timeStamp3)<span class="hljs-comment">//3600 000 000 000</span><br>     timeStamp4:=t1.UnixNano()<br>     fmt.Println(timeStamp4)<br><br>     <span class="hljs-comment">//5.根据当前的时间获取指定的内容：年，月，日，</span><br>     year,month,day:=t1.Date()<br>     fmt.Println(year,month,day)<br>     hour,min,sec:=t1.Clock()<br>     fmt.Println(hour,min,sec)<br><br>     year2:=t1.Year()<br>     fmt.Println(<span class="hljs-string">&quot;年：&quot;</span>,year2)<br>     fmt.Println(t1.YearDay())<br>     month2:=t1.Month()<br>     fmt.Println(<span class="hljs-string">&quot;月：&quot;</span>,month2)<br>     fmt.Println(<span class="hljs-string">&quot;日：&quot;</span>,t1.Day())<br>     fmt.Println(<span class="hljs-string">&quot;小时：&quot;</span>,t1.Hour())<br>     fmt.Println(<span class="hljs-string">&quot;分钟：&quot;</span>,t1.Minute())<br>     fmt.Println(<span class="hljs-string">&quot;秒：&quot;</span>,t1.Second())<br>     fmt.Println(t1.Weekday())<span class="hljs-comment">//星期几</span><br>     fmt.Println(t1.ISOWeek()) <span class="hljs-comment">//年份，和该年份中的第几个星期</span><br>     <span class="hljs-comment">//t1.Nanosecond()</span><br><br>     <span class="hljs-comment">//5.时间间隔</span><br><br>     t5 := t1.Add(time.Minute)<span class="hljs-comment">//duritaion时间间隔之前/后</span><br>     fmt.Println(t1)<br>     fmt.Println(t5)<br>     fmt.Println(t1.Add(<span class="hljs-number">24</span>*time.Hour)) <span class="hljs-comment">//1天之后</span><br><br>     t6:=t1.AddDate(<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>)<br>     fmt.Println(t6)<br><br>     fmt.Println(t1.Add(<span class="hljs-number">-5</span>*time.Minute))<br><br>     d1:=t5.Sub(t1) <span class="hljs-comment">//两个time的时间差值： Duration</span><br>     fmt.Printf(<span class="hljs-string">&quot;%T\n&quot;</span>,d1)<br>     fmt.Println(d1)<br><br>     <span class="hljs-comment">//6.睡眠</span><br>     time.Sleep(<span class="hljs-number">3</span>*time.Second)<span class="hljs-comment">//让当前的程序进入睡眠状态</span><br>     fmt.Println(<span class="hljs-string">&quot;main...over.....&quot;</span>)<br><br>     <span class="hljs-comment">//睡眠[1-10]的秒随机数</span><br>     rand.Seed(time.Now().UnixNano())<br>     randNum := rand.Intn(<span class="hljs-number">10</span>)+<span class="hljs-number">1</span> <span class="hljs-comment">//int</span><br>     fmt.Println(randNum)<br>     time.Sleep(time.Duration(randNum)*time.Second)<span class="hljs-comment">//Duration</span><br>     fmt.Println(<span class="hljs-string">&quot;睡醒了。。&quot;</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL的几种查询方式</title>
    <link href="/2021/03/04/MySQL%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F/"/>
    <url>/2021/03/04/MySQL%E7%9A%84%E5%87%A0%E7%A7%8D%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>表结构声明：</p><p>students 表</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs text">+----+----------+--------+--------+-------+<br>| id | class_id | name   | gender | score |<br>+----+----------+--------+--------+-------+<br>|  1 |        1 | 小明   | M      |    90 |<br>|  2 |        1 | 小红   | F      |    95 |<br>|  3 |        1 | 小军   | M      |    88 |<br>|  4 |        1 | 小米   | F      |    73 |<br>|  5 |        2 | 小白   | F      |    81 |<br>|  6 |        2 | 小兵   | M      |    55 |<br>|  7 |        2 | 小林   | M      |    85 |<br>|  8 |        3 | 小新   | F      |    91 |<br>|  9 |        3 | 小王   | M      |    89 |<br>| 10 |        3 | 小丽   | F      |    85 |<br>+----+----------+--------+--------+-------+<br></code></pre></td></tr></table></figure><p>classes 表</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">+----+--------+<br>| id | name   |<br>+----+--------+<br>|  1 | 一班   |<br>|  2 | 二班   |<br>|  3 | 三班   |<br>|  4 | 四班   |<br>+----+--------+<br></code></pre></td></tr></table></figure><p>创建语句在文末。</p></blockquote><h2 id="基本查询"><a href="#基本查询" class="headerlink" title="基本查询"></a>基本查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询所有学生的全部信息<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students;<br># 查询所有学生的姓名和分数<br><span class="hljs-keyword">SELECT</span> name, score <span class="hljs-keyword">FROM</span> students;<br></code></pre></td></tr></table></figure><p><code>*</code> 表示查询所有列，查询结果是一个二维表，包含一个表的所有列以及所有列的数据。</p><p><code>SELECT</code> 的其他用法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 计算<br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">100</span> <span class="hljs-operator">+</span> <span class="hljs-number">100</span>;<br># 测试数据库是否连接<br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h2 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询 score <span class="hljs-operator">&gt;=</span> <span class="hljs-number">80</span> 的信息<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> score <span class="hljs-operator">&gt;=</span> <span class="hljs-number">80</span>;<br><br># 查询 score <span class="hljs-operator">&gt;=</span> <span class="hljs-number">80</span> 且 gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;M&#x27;</span> 的信息<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> score <span class="hljs-operator">&gt;=</span> <span class="hljs-number">80</span> <span class="hljs-keyword">AND</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;M&#x27;</span>;<br><br># 查询 score <span class="hljs-operator">&gt;=</span> <span class="hljs-number">80</span> 或者 gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;F&#x27;</span> 的信息<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> score <span class="hljs-operator">&gt;=</span> <span class="hljs-number">80</span> <span class="hljs-keyword">OR</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;F&#x27;</span>;<br><br># 查询 class_id 不等于 <span class="hljs-number">2</span> 的信息<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> class_id <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; (<span class="hljs-keyword">NOT</span>的写法不常用)<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> class_id <span class="hljs-operator">&lt;&gt;</span> <span class="hljs-number">2</span>;<br></code></pre></td></tr></table></figure><p>条件运算符的优先级从高到低为：<code>NOT</code>, <code>AND</code>, <code>OR</code>。</p><p>所以，在组合三个或者更多的条件时，要加上<code>()</code> 改变优先级。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 查询 score <span class="hljs-operator">&lt;</span> <span class="hljs-number">80</span> 或者 score <span class="hljs-operator">&gt;</span> <span class="hljs-number">90</span> 中 gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;M&#x27;</span> 的信息<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> (score <span class="hljs-operator">&lt;</span> <span class="hljs-number">80</span> <span class="hljs-keyword">OR</span> score <span class="hljs-operator">&gt;</span> <span class="hljs-number">90</span>) <span class="hljs-keyword">AND</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;M&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="投影查询"><a href="#投影查询" class="headerlink" title="投影查询"></a>投影查询</h2><p>使用<code>SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt;</code>可以选出表中的若干条记录。我们注意到返回的二维表结构和原表是相同的，即结果集的所有列与原表的所有列都一一对应。</p><p>如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用<code>SELECT 列1, 列2, 列3 FROM …</code>，让结果集仅包含指定列。这种操作称为投影查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 使用投影查询，并将列名重命名<br><span class="hljs-keyword">SELECT</span> id, score points, name <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">WHERE</span> gender <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;M&#x27;</span>;<br></code></pre></td></tr></table></figure><p>返回的结果集中，原先的 <code>score</code> 列名变成了 <code>points</code>。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 按照 score 从低到高排序<br><span class="hljs-keyword">SELECT</span> id, name, gender, score <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score;<br><br># 按照 score 从高到低排序<br><span class="hljs-keyword">SELECT</span> id, name, gender, score <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>;<br><br># 按照 score 从高到低排序, 如果 score 相同，则根据 gender 列按从高到低排序<br><span class="hljs-keyword">SELECT</span> id, name, gender, score <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score <span class="hljs-keyword">DESC</span>, gender;<br></code></pre></td></tr></table></figure><p>排序规则中出了 <code>DESC</code>，还有 <code>ASC</code>，升序排序，即从小到大排列，可以省略，因为 <code>ORDER BY 列名</code> 和 <code>ORDER BY 列名 ASC</code> 等价。</p><h2 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h2><p>使用SELECT查询时，如果结果集数据量很大，比如几万行数据，放在一个页面显示的话数据量太大，就不如分页显示。比如，查处来的数据量多打几万条，此时可设置每页显示100条数据，那么第一页显示1～100条数据，第二页显示101～200条数据，以此类推。</p><p>分页实际上就是从结果集的第<code>N</code>条记录开始，取出后面的<code>M</code>条记录，这个查询可以通过<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>子句实现。</p><p>在这里<code>M</code>为<code>pageSize</code>，如果我们知道页码<code>index</code>，则<code>N</code>的计算公式为：<code>N = pageSize * (index - 1)</code>，<code>index</code> 默认大于0，因为页数一般是从第 1 页开始。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs sql"># 按照 score 升序排序，每页显示 <span class="hljs-number">3</span> 条数据<br># 查询第 <span class="hljs-number">1</span> 页数据<br><span class="hljs-keyword">SELECT</span> id, name, gender, score <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score LIMIT <span class="hljs-number">3</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">0</span>;<br><br># 查询第 <span class="hljs-number">2</span> 页数据<br><span class="hljs-keyword">SELECT</span> id, name, gender, score <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score LIMIT <span class="hljs-number">3</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">3</span>;<br><br># 查询第 <span class="hljs-number">3</span> 页数据<br><span class="hljs-keyword">SELECT</span> id, name, gender, score <span class="hljs-keyword">FROM</span> students <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> score LIMIT <span class="hljs-number">3</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">6</span>;<br></code></pre></td></tr></table></figure><p>如果省略<code>OFFSET N</code> ，则默认从第 0 条开始。</p><p>上面的<code>LIMIT M OFFSET N</code>也可以写成<code>LIMIT N, M</code>。</p><p><strong>注意：</strong>当 N 的值越来越大时，查询效率也会降低</p><h2 id="聚合查询"><a href="#聚合查询" class="headerlink" title="聚合查询"></a>聚合查询</h2>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
      <category>MySQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于Vagrant</title>
    <link href="/2021/03/04/Tools/Vagrant/%E5%85%B3%E4%BA%8EVagrant/"/>
    <url>/2021/03/04/Tools/Vagrant/%E5%85%B3%E4%BA%8EVagrant/</url>
    
    <content type="html"><![CDATA[<blockquote><p>转载于：<a href="https://www.ituring.com.cn/article/131600">https://www.ituring.com.cn/article/131600</a></p><p>作    者：麦满囤</p></blockquote><h1 id="Vagrant是什么，不是什么。"><a href="#Vagrant是什么，不是什么。" class="headerlink" title="Vagrant是什么，不是什么。"></a>Vagrant是什么，不是什么。</h1><p>Vagrant是构建在虚拟化技术之上的虚拟机运行环境管理工具。通过Vagrant可以方便实现的对虚拟机的管理，包括建立和删除虚拟机、配置虚拟机运行参数、管理虚拟机运行状态、自动化配置和安装开发环境必须的各类软件、打包和分发虚拟机运行环境等。</p><p>Vagrant的运行，需要依赖某项具体的虚拟化技术。由于VirtualBox是一项开源的虚拟化软件，可以同时在Windows、Linux、Macintosh、SSolaris等操作系统上运行并支持众多对众多操作系统的虚拟化，因此，在Vagrant开发的初期，唯一支持的是VirtualBox。随着虚拟化技术的快速发展，现在已经有了更多的虚拟化技术可供选择。VMware、HyperV、Docker等都已经可以通过Vagrant的管理而工作。Windows的HyperV技术在部分Windows发行版本中的集成，使得Vagrant在“开盒即用”的特性方面前进了一大步。</p><p>因此，Vagrant是虚拟机管理工具，不是某项具体的虚拟化技术。对于各项虚拟化技术而言，Vagrant提供了一套基于配置文件和命令行的管理工具。也正是因为如此，Vagrant完成了对虚拟化技术在一定程度上的封装。这为将虚拟化技术引入到基于桌面运行环境的开发工作流中创造了便利条件。</p><h1 id="为什么要使用Vagrant"><a href="#为什么要使用Vagrant" class="headerlink" title="为什么要使用Vagrant"></a>为什么要使用Vagrant</h1><h2 id="尽可能避免”Work-on-my-machine“错误"><a href="#尽可能避免”Work-on-my-machine“错误" class="headerlink" title="尽可能避免”Work on my machine“错误"></a>尽可能避免”Work on my machine“错误</h2><p>在Vagrant没有出现之前，在服务器端进行开发的人们通常都拥有一个专用的开发帐号。使用这个帐号，开发者可以在一定限度内配置自己的开发环境、完成编码、进行测试并完成向开发团队代码库的代码推送。于是，在团队合作开发的过程中，一个问题出现了：当A进行了一次新的代码推送之后，原本可以通过的代码持续集成测试无法通过了。通过代码检查，发现A的代码出现了异常。而A在自己的开发环境中的测试是可以通过的。这类错误被Vagrant称作为“Work on my machine”错误。这类错误要定位解决通常耗时很久。在一个可以进行面对面开发的团队中，问题的定位由于沟通手段的丰富相对较快。如果是分散在不同地方的人在合作开发，那么要解决此类错误，就没有那么简单了。</p><blockquote><p>小张在自己的机器上辛苦的完成了一项功能开发，通过了本机上的各项测试，高高兴兴的向团队代码库提交的自己的工作成果。心想终于可以放松一下了。“是不是可以买一只机械键盘犒劳一下？晚上和伙伴们出去聚会吧！嘿嘿。”小A心里美滋滋的想。</p><p>“小张，你来一下，代码有问题”。临近下班的时候，小A接到QA小组的一个电话。“怎么回事？”小张一头雾水的走进了QA小组的办公区。</p><p>“你今天下午提交的代码，无法通过测试。你自己做了测试了吗？”，老王是QA小组测试负责人，他面色凝重的问小张，“咱们就要发布一个新的代码版本了。这个时候你的代码出问题，可能会影响代码发布的。要不你赶紧看看？明天上午能修复吗。我们的测试报告和测试规范在这里”。</p><p>“明明没有问题的呀”，出了QA的办公区，小张仍然迷惑不解。“在我的机器上明明是可以运行的。而且为了晚上的聚会，测试规范中定义的各项测试也是提前跑过的呀。看来今天晚上的聚会要取消了。“小张无奈的拿出电话，打算给好友们打电话，通知自己无法参加晚上的聚会了。</p></blockquote><p>好吧，借助Vagrant，每一个开发者都可以得到一份服务器运行环境的虚拟机，可以以虚拟机的方式运行一个微型的”生产环境“。这样，在提交代码之前，开发这就可以在虚拟机上完成”生产环境“的验证。自然可以解决上面的问题了。</p><h2 id="缩短搭建开发环境的时间"><a href="#缩短搭建开发环境的时间" class="headerlink" title="缩短搭建开发环境的时间"></a>缩短搭建开发环境的时间</h2><p>搭建一个开发环境，需要完成操作系统的安装，必要的开发支撑软件的安装，配置操作系统和代码运行环境。如果所有的操作都需要由人来手动操作的话，一个下午的时间是必要的。搭建开发环境是团队中新人加入时的必不可少的第一课。而团队的老人们，无可避免的会接到无数的“新手”的发问。更不用说，当著名的Wxdows系统需要重新安装系统的时候，无论谁，基本上一天的工作时间算是交代了，更不用说各类开发软件的配置如果会影响代码执行结果的时候会引入什么样的“灾难”了。使用Vagrant实现开发环境的快速搭建成为提升效率的显著功能特性之一。</p><p>Vagrant提供了统一的安装程序配置环境：</p><ul><li>使用统一的配置文件（ <code>vagrantfile</code> ）实现对服务器的统一配置。</li><li>使用共享文件夹（ <code>shared folder</code> ）实现代码编辑向“服务器”的快速提交</li><li>使用软件配置脚本（ <code>Provisioning scripts</code> ）实现服务器上的运行环境的快速建立</li><li>拥有标准化的虚拟机分享网络，极大缓解了分享开发环境配置时的网络带宽压力</li><li>可以具备一个供安装维护测试使用的可抛弃的服务器端环境。</li></ul><blockquote><p>小李是进入开发团队的新人。从学校毕业出来，小李就到了一个公司从事服务器端的软件开发工作。由于兴趣爱好的原因，他新近加入了这个网游开发团队。他接到的第一个命令就是“搭建一个服务器工作日志分析系统，为服务器代码优化改进做准备”。</p><p>小李从团队项目经理那里得到了服务器环境安装手册以及服务器日志数据库设计文档。小李需要在自己的机器上用虚拟机安装一套服务器环境，用以进行日志数据的分析和提取。</p><p>“好吧，估计这几天的时间要搭到系统安装里去了。”小李做好了心理准备，打开了服务器环境安装手册。意外的，手册很简单：</p><ul><li>安装Vagrant和VirtualBox，从文件服务器（地址XX.XX.XX.XX&#x2F;Software）下载Vagrant、VirtualBox安装文件，并完成安装</li><li>执行 <code>git clone git@xx.xx.xx.xx:vagrantconfig.git</code> 获取vagrant配置文件</li><li>进入vagrantconfig目录，运行 <code>Vagrant up ftp://xx.xx.xx.xx/vagrant/trusty-server-cloudimg-amd64-vagrant-disk1</code></li><li>执行 <code>vagrant ssh</code> 验证安装</li><li>从文件服务器（xx.xx.xx.xx&#x2F;data）下载日志数据库dump文件，完成Mysql数据库内容的加载</li><li>……</li></ul><p>“这就完了？”半个小时后，小李目瞪口呆的看着自己机器上运行的虚拟机，一套服务器日志系统已经加载完成了。小李已经可以着手进行数据的分析并开始做具体编码设计了。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>如果还在为“Work on my machine”错误头疼，如果安装开发环境还是团队心头的痛，那为什么不试试用用Vagrant呢？</p><h1 id="Vagrant的主要使用者"><a href="#Vagrant的主要使用者" class="headerlink" title="Vagrant的主要使用者"></a>Vagrant的主要使用者</h1><p>对于需要在服务器端进行开发的人，Vagrant管理的虚拟机镜像提供了统一的生产运行环境。开发者可以随心所欲的决定什么时候想“服务器”端发布程序，什么时候在“服务器”端进行必要的测试，而丝毫不用担心会影响生产环境服务器的稳定运行。</p><p>对于各类设计人员，使用Vagrant，可以让设计人员可以随心所欲的选择自己的开发用操作系统、设计软件、编辑IDE软件，可以通过与虚拟机之间的共享目录，快速实现设计文件在生产环境中的测试验证。</p><p>对于系统维护人员，使用Vagrant，可以随意进行对系统安装设置的过程进行演练，验证工程安装手册的完备程度。也可以对系统维护中的各项操作指令随意进行实验。这对于提升售后服务团队的问题快速解决能力，获得实战经验的非常重要的手段。</p><h1 id="Vagrant对开源开发的贡献"><a href="#Vagrant对开源开发的贡献" class="headerlink" title="Vagrant对开源开发的贡献"></a>Vagrant对开源开发的贡献</h1><p>开源的开发者常常无法像一个普通团队那样面对面的坐在一起进行开发工作。由于开发团队是一种松散的组织模式，因此，也不是每一个开发者都可以获得在服务器端上的开发授权。此时Vagrant就提供给这些开发者必要的代码运行环境，极大程度的提升了开源开发者向开发中心小组提交代码的质量。此外，Vagrant的虚拟机分享模式，也使得开源开发者获得统一的服务器运行环境的成本变得异乎寻常的低廉。</p>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Vagrant</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vagrant</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>执行Shell脚本自动kill上次执行创建的进程</title>
    <link href="/2021/03/03/%E6%89%A7%E8%A1%8CShell%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8kill%E4%B8%8A%E6%AC%A1%E6%89%A7%E8%A1%8C%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%9B%E7%A8%8B/"/>
    <url>/2021/03/03/%E6%89%A7%E8%A1%8CShell%E8%84%9A%E6%9C%AC%E8%87%AA%E5%8A%A8kill%E4%B8%8A%E6%AC%A1%E6%89%A7%E8%A1%8C%E5%88%9B%E5%BB%BA%E7%9A%84%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>当项目启动需要指定很多参数时，每次启动都需要写很长的指令，于是考虑将启动指令写成脚本形式，于是产生了一个问题，第一次启动项目使用脚本可以正常启动，但是第二次就会报网络地址或者端口占用的错误，所以，需要每次执行脚本的时候，kill 掉上次的进程，然后启动。于是就有了下面的脚本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#/bin/bash</span><br>PROCESS=`ps -ef|grep <span class="hljs-string">&#x27;./go-admin server&#x27;</span>|grep -v grep|grep -v PPID|awk <span class="hljs-string">&#x27;&#123; print $2&#125;&#x27;</span>`<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-variable">$PROCESS</span><br><span class="hljs-keyword">do</span><br>    <span class="hljs-keyword">if</span> [ -z <span class="hljs-variable">$i</span> ]<br>    <span class="hljs-keyword">then</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;No process run&quot;</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Kill the go-admin process [ <span class="hljs-variable">$i</span> ]&quot;</span><br>        <span class="hljs-built_in">kill</span> <span class="hljs-variable">$i</span><br>    <span class="hljs-keyword">fi</span><br><span class="hljs-keyword">done</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Start run go-admin&quot;</span><br><br>go build<br>./go-admin server -c=config/settings.dev.yml<br></code></pre></td></tr></table></figure><p>对上面的代码坐几点说明：</p><ol><li><code>PROCESS</code> 变量的值中有 <code>grep &#39;./go-admin server&#39;</code> ，注意 <code>grep</code> 在进行匹配的时候是类似 <code>*Xxx*</code> 的前后全匹配方式，所以当有多个进程名字中都含有该值时，会返回多个进程ID，于是 <code>PROCESS</code> 变量是一个数组。</li><li><code>PROCESS</code> 变量值中<code>awk &#39;&#123; print $2&#125;&#39;</code> ，<code>awk</code> 文本处理命令，此处会返回进程信息中的第二个值。</li><li><code>if [ -z $i]</code> 中的 <code>-z</code> ，是判断 <code>$i</code> 是否为空的。</li></ol><p>当然，后面的 <code>kill</code> 命令，即使传入空值参数也不会产生问题，具体是否需要判断要根据实际情况来。该代码只是对一些特别的地方做了汇总而已。</p>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go中方法接受者为值传递或引用传递的区别</title>
    <link href="/2021/03/02/Go%E4%B8%AD%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%97%E8%80%85%E4%B8%BA%E5%80%BC%E4%BC%A0%E9%80%92%E6%88%96%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <url>/2021/03/02/Go%E4%B8%AD%E6%96%B9%E6%B3%95%E6%8E%A5%E5%8F%97%E8%80%85%E4%B8%BA%E5%80%BC%E4%BC%A0%E9%80%92%E6%88%96%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
    
    <content type="html"><![CDATA[<p>在 Go 中，方法的接收者有两种类型，一种是值传递类型，一种是引用传递类型，也就是指针类型。</p><ul><li>值传递：不能修改接受者参数，即对接受者内的数据只读不写。因为要进行数据的拷贝，所以内存消耗会比引用传递大。</li><li>引用传递：可以修改接受者参数。</li></ul><p>具体请参考如下代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">//值传递</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Cat)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>p.name = name<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Cat)</span></span> GetName() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> p.name<br>&#125;<br><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-type">string</span><br>&#125;<br><br><span class="hljs-comment">//引用传递</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dog)</span></span> SetName(name <span class="hljs-type">string</span>) &#123;<br>d.name = name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dog)</span></span> GetName() <span class="hljs-type">string</span> &#123;<br><span class="hljs-keyword">return</span> d.name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>cat := <span class="hljs-built_in">new</span>(Cat)<br>cat.name = <span class="hljs-string">&quot;old&quot;</span><br>cat.SetName(<span class="hljs-string">&quot;new&quot;</span>)<br>fmt.Println(cat.GetName()) <span class="hljs-comment">//输出 old</span><br><br>dog := <span class="hljs-built_in">new</span>(Dog)<br>dog.name = <span class="hljs-string">&quot;old&quot;</span><br>dog.SetName(<span class="hljs-string">&quot;new&quot;</span>)<br>fmt.Println(dog.GetName()) <span class="hljs-comment">//输出 new</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go动态创建多维数组</title>
    <link href="/2021/03/01/Go%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/"/>
    <url>/2021/03/01/Go%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>n, m, x := <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span><br>    <br><span class="hljs-comment">//创建二维数组</span><br>    two := <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> two &#123;<br>two[i] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, m)<br>&#125;<br><br><span class="hljs-comment">//创建三维数组</span><br>three := <span class="hljs-built_in">make</span>([][][]<span class="hljs-type">int</span>, n)<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> three &#123;<br>three[i] = <span class="hljs-built_in">make</span>([][]<span class="hljs-type">int</span>, m)<br><span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> three[i] &#123;<br>three[i][j] = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, x)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go测试文件放置位置</title>
    <link href="/2021/02/28/Go%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%E6%94%BE%E7%BD%AE%E4%BD%8D%E7%BD%AE/"/>
    <url>/2021/02/28/Go%E6%B5%8B%E8%AF%95%E6%96%87%E4%BB%B6%E6%94%BE%E7%BD%AE%E4%BD%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>关于测试文件的放置位置，主要分为两种情况：</p><ol><li><p>测试文件与被测试文件放置在相同目录</p><p> 在相同的目录下，测试文件与被测试文件包名要相同，测试文件中无需 <code>import</code> 被测试文件。</p></li><li><p>测试文件与被测试文件放置在不同目录中</p><p> 测试文件与被测试文件分离，方便对其进行集中管理，测试文件中要 <code>import</code> 被测试文件，测试文件包名随意，但注意同一目录下只能有一个包名。</p></li></ol><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="关于测试文件的几点约束"><a href="#关于测试文件的几点约束" class="headerlink" title="关于测试文件的几点约束"></a>关于测试文件的几点约束</h4><ul><li><strong>文件名</strong>必须是<code>_test.go</code>结尾(例如：filename_test.go)，这样在执行<code>go test</code>的时候才会执行到相应的代码</li><li>文件中须 import<code>testing</code>包</li><li>所有的测试用例<strong>函数</strong>必须是<code>Test</code>开头，而且 <code>Test</code> 后第一个字符必须是<code>大写字母</code>或 <code>_</code>，例如<code>Testintdiv</code> 是错误的函数名，应该是 <code>TestIntdiv</code> 或 <code>Test_intdiv</code>。</li><li>测试函数<code>TestXxx()</code>的参数是<code>testing.T</code>，我们可以使用该类型来记录错误或者是测试状态</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>git restore命令</title>
    <link href="/2021/02/27/Tools/Git/git-restore%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/02/27/Tools/Git/git-restore%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<p>在执行 <code>git status</code> 命令查看文件状态时发现类似如下输出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">Changes to be committed:                                                  <br>  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) <br></code></pre></td></tr></table></figure><p>这才想起来有个文件忘了执行 <code>git commit</code> 就直接 push 了，也顺便了解了下 <code>git restore</code>命令。</p><table><thead><tr><th align="center">命令</th><th align="center">作用</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center"><code>git restore --worktree README.md</code></td><td align="center">表示撤销 README.md 文件工作区的的修改</td><td align="center">参数等同于 -W</td></tr><tr><td align="center"><code>git restore --staged README.md</code></td><td align="center">表示撤销暂存区的修改，将文件状态恢复到未 <code>add</code> 之前</td><td align="center">参数等同于 -S</td></tr><tr><td align="center"><code>git restore -s HEAD~1 README.md</code></td><td align="center">表示将当前工作区切换到上个 commit 版本</td><td align="center"></td></tr><tr><td align="center"><code>git restore -s dbv213 README.md</code></td><td align="center">表示将当前工作区切换到指定 commit id 的版本</td><td align="center"></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Tools</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Tools</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go Modules</title>
    <link href="/2021/02/25/Go-Modules/"/>
    <url>/2021/02/25/Go-Modules/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是-Go-Modules"><a href="#什么是-Go-Modules" class="headerlink" title="什么是 Go Modules"></a>什么是 Go Modules</h3><p><code>Go modules</code> 是 Go 语言中正式官宣的项目依赖解决方案。Go modules(前身vgo) 于 Go 1.11 正式发布，在 Go 1.14 便可用在生产上中，Go 官方也鼓励用户从其他依赖管理工具迁移到 Go modules。</p><p>Go Modules 的出现解决了 Go 1.11 前长久以来的依赖管理问题。并“淘汰”了现有的 <code>GOPATH模式</code>，同时统一了社区中的其它的依赖管理工具（提供迁移功能）。</p><h4 id="GOPATH模式"><a href="#GOPATH模式" class="headerlink" title="GOPATH模式"></a>GOPATH模式</h4><h5 id="GOPATH是什么"><a href="#GOPATH是什么" class="headerlink" title="GOPATH是什么"></a>GOPATH是什么</h5><p>相信很多刚入行 Go 的小伙伴常常分不清 <code>GOPATH</code> 与 <code>GOROOT</code> 这两个环境变量，简单点讲就是 <code>GOPATH</code> 是你工作的目录，<code>GOROOT</code> 是你安装 Go 的目录，但是这个工作目录又不同于之前比如 Java 的项目目录，在这个目录下你的项目源码是存放在 <code>$GOPATH/src</code> 下，也就是在这个 <code>src</code> 下创建你的项目目录。</p><p>GOPATH 目录长下面这样：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">go<br>├── bin //存储所编译生成的二进制文件<br>├── pkg //存储预编译的目标文件，以加快程序的后续编译速度<br>└── src //存储所有.go文件或源代码。通过 go get 拉下来的库也在这里，和你的项目目录并列<br>    ├── github.com<br>    ├── golang.org<br>    ├── google.golang.org<br>    ├── gopkg.in<br></code></pre></td></tr></table></figure><p>总结下就是，在使用 <code>GOPATH模式 </code>时，我们需要将应用代码存放在固定的<code>$GOPATH/src</code>目录下，并且如果执行<code>go get</code>来拉取外部依赖会自动下载并安装到<code>$GOPATH/src</code>目录下。</p><h5 id="为何弃用GOPATH模式"><a href="#为何弃用GOPATH模式" class="headerlink" title="为何弃用GOPATH模式"></a>为何弃用GOPATH模式</h5><p>最主要的原因就是 <code>GOPATH模式</code> 下没有版本控制的概念，这会导致下面的几个问题：</p><ul><li>在执行<code>go get</code>的时候，你不能指定要拉取的版本，即你无法通过该命令获得你期望的代码版本。</li><li>当其他人或者你运行一份 Go 代码的时候，无法保证其他人或者你所期望的第三方依赖库版本。</li><li>没办法处理 v1、v2、v3 等不同版本的引用问题，因为 <code>GOPATH模式</code> 下的导入路径都是一样的，都是类似于<code>github.com/foo/bar</code>这样的形式。</li></ul><p>Go 语言官方从 Go 1.11 起开始推进 Go modules（前身vgo），Go 1.13 起不再推荐使用 GOPATH 模式，Go modules 也渐趋稳定，因此新项目也没有必要继续使用 GOPATH模式。</p><h5 id="GOPATH模式下的产物（简单一了解）"><a href="#GOPATH模式下的产物（简单一了解）" class="headerlink" title="GOPATH模式下的产物（简单一了解）"></a>GOPATH模式下的产物（简单一了解）</h5><blockquote><p>Go1 在 2012 年 03 月 28 日发布，而 Go1.11 是在 2018 年 08 月 25 日才正式发布（数据来源：GitHub Tag），在这个空档的时间内，并没有 Go modules 这一个东西，最早期可能还好说，因为刚发布，用的人不多，所以没有明显暴露，但是后期 Go 语言使用的人越来越多了，那怎么办？</p><p>这时候社区中逐渐的涌现出了大量的依赖解决方案，百花齐放，让人难以挑选，其中包括我们所熟知的 vendor 目录的模式，以及曾经一度被认为是“官宣”的 dep 的这类依赖管理工具。</p><p>但为什么 dep 没有正在成为官宣呢，其实是因为随着 Russ Cox 与 Go 团队中的其他成员不断深入地讨论，发现 dep 的一些细节似乎越来越不适合 Go，因此官方采取了另起 proposal 的方式来推进，其方案的结果一开始先是释出 vgo（Go modules 的前身，知道即可，不需要深入了解），最终演变为我们现在所见到的 Go modules，也在 Go1.11 正式进入了 Go 的工具链。</p></blockquote><h3 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h3><h4 id="开启-Go-Modules"><a href="#开启-Go-Modules" class="headerlink" title="开启 Go Modules"></a>开启 Go Modules</h4><p>运行 <code>go env</code> 命令查看 Go 的相关环境变量设置，找到 <code>GO111MODULE</code>，默认值是 <code>auto</code> ，共有三个可选值：</p><ul><li><strong>auto</strong>： 只要项目包含了 go.mod 文件的才启用 Go modules</li><li><strong>on</strong>：启用 Go Modules，推荐设置为此值，这将是一个趋势</li><li><strong>off</strong>：禁用 Go Modules，不推荐设置</li></ul><p>开启方式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">方式一: 使用 go <span class="hljs-built_in">env</span> 命令，注意不支持覆盖写入，若系统环境变量中已设置，将报错</span><br>go env -w GO111MODULE=on<br><span class="hljs-meta prompt_"># </span><span class="language-bash">方式二: 写入系统环境变量</span><br>export GO111MODULE=on<br></code></pre></td></tr></table></figure><h4 id="设置代理-GOPROXY"><a href="#设置代理-GOPROXY" class="headerlink" title="设置代理 GOPROXY"></a>设置代理 GOPROXY</h4><p>该环境变量用于使 Go 在后续拉取模块版本时能够脱离传统的 VCS 方式，直接通过镜像站点来快速拉取。</p><p>GOPROXY 的默认值是：<code>https://proxy.golang.org,direct</code>，但在国内是无法访问的，需要设置国内的 Go 模块代理，执行命令设置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go env -w GOPROXY=https://goproxy.cn,direct<br></code></pre></td></tr></table></figure><p>GOPROXY 的值是一个以英文逗号 <code>,</code> 分割的 Go 模块代理列表，可以设置多个模块代理。如果你不想使用代理，也可以将其设置为 <code>off</code> ，这将会禁止 Go 在后续操作中使用任何 Go 模块代理。</p><p>关于 <code>direct</code>，<code>direct</code> 是一个特殊指示符，用于指示 Go 回源到模块版本的源地址去抓取（比如 GitHub 等），场景如下：当值列表中上一个 Go 模块代理返回 <code>404</code> 或 <code>410</code> 错误时，Go 自动尝试列表中的下一个，遇见 <code>direct</code> 时回源，也就是回到源地址去抓取，而遇见 EOF 时终止并抛出类似 <code>invalid version: unknown revision...</code>的错误。</p><h4 id="数据校验-GOSUMDB"><a href="#数据校验-GOSUMDB" class="headerlink" title="数据校验 GOSUMDB"></a>数据校验 GOSUMDB</h4><p>该环境变量用于在拉取模块版本时（无论是从源站拉取还是通过 Go module proxy 拉取）保证拉取到的模块版本数据未经过篡改，若发现不一致，也就是可能存在篡改，将会立即中止。</p><p>GOSUMDB 的默认值为：<code>sum.golang.org</code>，在国内也是无法访问的，但是 <code>GOSUMDB</code> 可以被 Go 模块代理所代理。所以，设置完 <code>GOPROXY</code> 后一般不需要再设置。</p><p><code>GOSUMDB</code> 的值可以自定义，其支持如下格式：</p><ul><li>格式 1： <SUMDB_NAME>+<PUBLIC_KEY> 。</li><li>格式 2： <SUMDB_NAME>+<PUBLIC_KEY> <SUMDB_URL> 。</li></ul><p>也可以将其设置为 <code>off</code>，也就是禁止 Go 在后续操作中校验模块版本。</p><h4 id="依赖私有模块-GONOPROXY-x2F-GONOSUMDB-x2F-GOPRIVATE"><a href="#依赖私有模块-GONOPROXY-x2F-GONOSUMDB-x2F-GOPRIVATE" class="headerlink" title="依赖私有模块 GONOPROXY&#x2F;GONOSUMDB&#x2F;GOPRIVATE"></a>依赖私有模块 GONOPROXY&#x2F;GONOSUMDB&#x2F;GOPRIVATE</h4><p>这三个环境变量都是用在当前项目依赖了私有模块，例如像是你公司的私有 git 仓库，又或是 github 中的私有库，都属于私有模块。所谓私有模块，就是依赖了由 GOPROXY 指定的 Go 模块代理或由 GOSUMDB 指定 Go checksum database 都无法访问到的模块时的场景。所以要对其进行设置，否则会拉取失败。</p><p>一般建议直接设置 GOPRIVATE，它的值将作为 GONOPROXY 和 GONOSUMDB 的默认值。</p><p>它的值是一个用 <code>,</code> 分隔的模块列表，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">go env -w GOPRIVATE=&quot;git.example.com,github.com/eddycjy/mquote&quot;<br></code></pre></td></tr></table></figure><p>设置后，前缀为 git.example.com 和 github.com&#x2F;eddycjy&#x2F;mquote 的模块都会被认为是私有模块。</p><p>如果不想每次都重新设置，我们也可以利用通配符，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">go <span class="hljs-built_in">env</span> -w GOPRIVATE=<span class="hljs-string">&quot;*.example.com&quot;</span></span><br></code></pre></td></tr></table></figure><p>这样子设置的话，所有模块路径为 example.com 的子域名（例如：git.example.com）都将不经过 Go module proxy 和 Go checksum database，<strong>需要注意的是不包括 example.com 本身</strong>。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="go-mod-命令"><a href="#go-mod-命令" class="headerlink" title="go mod 命令"></a>go mod 命令</h4><p>Go modules 为我们提供了以下命令：</p><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>go mod init</td><td>生成 go.mod 文件</td></tr><tr><td>go mod download</td><td>下载 go.mod 文件中指明的所有依赖</td></tr><tr><td>go mod tidy</td><td>整理现有的依赖</td></tr><tr><td>go mod graph</td><td>查看现有的依赖结构</td></tr><tr><td>go mod edit</td><td>编辑 go.mod 文件</td></tr><tr><td>go mod vendor</td><td>导出项目所有的依赖到vendor目录</td></tr><tr><td>go mod verify</td><td>校验一个模块是否被篡改过</td></tr><tr><td>go mod why</td><td>查看为什么需要依赖某模块</td></tr></tbody></table><h4 id="初始化项目"><a href="#初始化项目" class="headerlink" title="初始化项目"></a>初始化项目</h4><h4 id="go-mod-文件"><a href="#go-mod-文件" class="headerlink" title="go.mod 文件"></a>go.mod 文件</h4><p>该文件有两个作用，一是标识作用，当环境变量 <code>GO!111MODULE=auto</code> 时，标识该项目为 <code>Go Modules</code> 项目，二是描述了当前项目的一些元信息，包括当前项目的模块路径、go 版本、需要依赖的模块等，内容类似下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go">module github.com/eddycjy/module-repo<br> <br><span class="hljs-keyword">go</span> <span class="hljs-number">1.13</span><br> <br>require (<br>    example.com/apple v0<span class="hljs-number">.1</span><span class="hljs-number">.2</span><br>    example.com/banana v1<span class="hljs-number">.2</span><span class="hljs-number">.3</span><br>    example.com/banana/v2 v2<span class="hljs-number">.3</span><span class="hljs-number">.4</span><br>    example.com/pear <span class="hljs-comment">// indirect</span><br>    example.com/strawberry <span class="hljs-comment">// incompatible</span><br>)<br> <br>exclude example.com/banana v1<span class="hljs-number">.2</span><span class="hljs-number">.4</span><br>replace example.com/apple v0<span class="hljs-number">.1</span><span class="hljs-number">.2</span> =&gt; example.com/fried v0<span class="hljs-number">.1</span><span class="hljs-number">.0</span> <br>replace example.com/banana =&gt; example.com/fish<br></code></pre></td></tr></table></figure><ul><li><strong>module</strong>：用于定义当前项目的模块路径。</li><li><strong>go</strong>：用于标识当前模块的 Go 语言版本，值为初始化模块时的版本，目前来看还只是个标识作用。</li><li><strong>require</strong>：用于设置一个特定的模块版本。</li><li><strong>exclude</strong>：用于从使用中排除一个特定的模块版本。</li><li><strong>replace</strong>：用于将一个模块版本替换为另外一个模块版本。</li></ul><p>另外你会发现 <code>example.com/pear</code> 的后面会有一个 <code>indirect</code> 标识，<code>indirect</code> 标识表示该模块为间接依赖，也就是在当前项目的所有 import 语句中，并没有发现这个模块的明确引用，有可能是你先手动 <code>go get</code> 拉取下来的，也有可能是你所依赖的模块所依赖的。</p><h4 id="go-sum-文件"><a href="#go-sum-文件" class="headerlink" title="go.sum 文件"></a>go.sum 文件</h4><p>在第一次拉取模块依赖后，会发现多出了一个 go.sum 文件，其详细罗列了当前项目直接或间接依赖的所有模块版本，并写明了那些模块版本的 SHA-256 哈希值以备 Go 在今后的操作中保证项目所依赖的那些模块版本不会被篡改。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">github.com/eddycjy/mquote v0.0.1 h1:4QHXKo7J8a6J/k8UA6CiHhswJQs0sm2foAQQUq8GFHM=<br>github.com/eddycjy/mquote v0.0.1/go.mod h1:ZtlkDs7Mriynl7wsDQ4cU23okEtVYqHwl7F1eDh4qPg=<br>github.com/eddycjy/mquote/module/tour v0.0.1 h1:cc+pgV0LnR8Fhou0zNHughT7IbSnLvfUZ+X3fvshrv8=<br>github.com/eddycjy/mquote/module/tour v0.0.1/go.mod h1:8uL1FOiQJZ4/1hzqQ5mv4Sm7nJcwYu41F3nZmkiWx5I=<br>....<br></code></pre></td></tr></table></figure><p>我们可以看到一个模块路径可能有如下两种：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">github.com/eddycjy/mquote v0.0.1 h1:4QHXKo7J8a6J/k8UA6CiHhswJQs0sm2foAQQUq8GFHM=<br>github.com/eddycjy/mquote v0.0.1/go.mod h1:ZtlkDs7Mriynl7wsDQ4cU23okEtVYqHwl7F1eDh4qPg=<br></code></pre></td></tr></table></figure><p>h1 hash 是 Go modules 将目标模块版本的 zip 文件开包后，针对所有包内文件依次进行 hash，然后再把它们的 hash 结果按照固定格式和算法组成总的 hash 值。</p><p>而 h1 hash 和 go.mod hash 两者，要不就是同时存在，要不就是只存在 go.mod hash。那什么情况下会不存在 h1 hash 呢，就是当 Go 认为肯定用不到某个模块版本的时候就会省略它的 h1 hash，就会出现不存在 h1 hash，只存在 go.mod hash 的情况。</p><h3 id="模块版本及其导入路径"><a href="#模块版本及其导入路径" class="headerlink" title="模块版本及其导入路径"></a>模块版本及其导入路径</h3><h4 id="语义化版本控制"><a href="#语义化版本控制" class="headerlink" title="语义化版本控制"></a>语义化版本控制</h4><p><img src="https://www.cmdbyte.com/2021/02/%E8%AF%AD%E4%B9%89%E5%8C%96%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6.jpg" alt="语义化版本控制"></p><p><code>Go Modules</code> 有一个语义化的版本规范，版本主要由三部分组成：<code>主版本号</code>，<code>次版本号</code>，<code>修订号</code>。另外，如果是先行版本或特殊情况，可以将版本信息追加到“主版本号.次版本号.修订号”的后面，作为延伸。</p><p>版本号的递增规则如下：</p><ul><li>主版本号：当你做了不兼容的 API 修改。</li><li>次版本号：当你做了向下兼容的功能性新增。</li><li>修订号：当你做了向下兼容的问题修正。</li></ul><p>基于上面两类版本号形式，在我们发布新版本打 tag 的时候，需要注意遵循，不遵循语义化版本规则的版本号都是无法进行拉取的。</p><h4 id="不同版本的导入路径"><a href="#不同版本的导入路径" class="headerlink" title="不同版本的导入路径"></a>不同版本的导入路径</h4><p>在导入模块时，若主版本号为 <code>v0</code> 或者 <code>v1</code>，则无需指定版本，而在主版本号为 <code>v2</code> 及以上则需要明确指定主版本号，否则会出现冲突，其 <code>tag</code> 与模块导入路径的大致对应关系如下：</p><table><thead><tr><th align="left">tag</th><th align="left">模块导入路径</th></tr></thead><tbody><tr><td align="left">v0.0.0</td><td align="left">github.com&#x2F;eddycjy&#x2F;mquote</td></tr><tr><td align="left">v1.0.0</td><td align="left">github.com&#x2F;eddycjy&#x2F;mquote</td></tr><tr><td align="left">v2.0.0</td><td align="left">github.com&#x2F;eddycjy&#x2F;mquote&#x2F;v2</td></tr><tr><td align="left">v3.0.0</td><td align="left">github.com&#x2F;eddycjy&#x2F;mquote&#x2F;v3</td></tr></tbody></table><p>注意，忽略主版本号 <code>v0</code> 和 <code>v1</code> 是强制性的（不是可选项），因此每个软件包只有一个明确且规范的导入路径。</p><h4 id="为什么忽略-v0-和-v1-的主版本号"><a href="#为什么忽略-v0-和-v1-的主版本号" class="headerlink" title="为什么忽略 v0 和 v1 的主版本号"></a>为什么忽略 v0 和 v1 的主版本号</h4><ul><li>忽略 <code>v1</code> 版本的原因是：考虑到许多开发人员创建一旦到达 v1 版本便永不改变的软件包，这是官方所鼓励的，不认为所有这些开发人员在无意发布 v2 版时都应被迫拥有明确的 v1 版本尾缀，这将导致 v1 版本变成“噪音”且无意义。</li><li>忽略 <code>v0</code> 版本的原因是：根据语义化版本规范，v0的这些版本完全没有兼容性保证。需要一个显式的 v0 版本的标识对确保兼容性没有多大帮助。</li></ul><h3 id="最小版本选择"><a href="#最小版本选择" class="headerlink" title="最小版本选择"></a>最小版本选择</h3><p>在实际项目中，一个模块往往依赖许多其他的模块，而这些其他的模块又可能依赖于别的模块，所以，很可能出现不同的模块依赖同一模块的不同版本的情况，比如下图 A1 的依赖关系：</p><p><img src="https://www.cmdbyte.com/2021/02/%E6%A8%A1%E5%9D%97%E4%BE%9D%E8%B5%961.png" alt="模块依赖1"></p><p>在上述依赖中，模块 A 依赖了模块 B 和模块 C，而模块 B 依赖了模块 D，模块 C 依赖了模块 D 和 F，模块 D 又依赖了模块 E，而且同模块的不同版本还依赖了对应模块的不同版本。那么这个时候 Go modules 怎么选择版本，选择的是哪一个版本呢？</p><p>面对这种情况，Go modules 会把每个模块的依赖版本清单都整理出来，最终得到一个构建清单，如下图：</p><p><img src="https://www.cmdbyte.com/2021/02/%E6%A8%A1%E5%9D%97%E6%9E%84%E5%BB%BA%E6%B8%85%E5%8D%951.png" alt="模块构建清单1"></p><p>可以看到 rough list 和 final list，两者的区别在于重复引用的模块 D（v1.3、v1.4），其最终清单选用了模块 D 的 v1.4 版本，主要原因：</p><ul><li>语义化版本的控制：因为模块 D 的 v1.3 和 v1.4 版本变更，都属于次版本号的变更，而在语义化版本的约束下，v1.4 必须是要向下兼容 v1.3 版本，因此认为不存在破坏性变更，也就是兼容的。</li><li>模块导入路径的规范：主版本号不同，模块的导入路径不一样，因此若出现不兼容的情况，其主版本号会改变，模块的导入路径自然也就改变了，因此不会与第一点的基础相冲突。</li></ul>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
      <tag>Go Modules</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go log包下的Print、Fatal、Panic接口</title>
    <link href="/2021/02/24/Go%20log%E5%8C%85%E4%B8%8B%E7%9A%84Print%E3%80%81Fatal%E3%80%81Panic%E6%8E%A5%E5%8F%A3/"/>
    <url>/2021/02/24/Go%20log%E5%8C%85%E4%B8%8B%E7%9A%84Print%E3%80%81Fatal%E3%80%81Panic%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>Golang 的 <code>log</code> 模块主要提供了三类接口，分别是 <code>Print</code>，<code>Panic</code>，<code>Fatal</code>，并对每一类接口提供了三种调用方式，分别是 “Xxxx”，”Xxxxln”，”Xxxxf”，基本和 fmt 中的相关函数类似。</p><h3 id="log-Print"><a href="#log-Print" class="headerlink" title="log.Print"></a>log.Print</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;log&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>arr := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>&#125;<br>log.Print(<span class="hljs-string">&quot;Print arrary:&quot;</span>, arr, <span class="hljs-string">&quot;\n&quot;</span>) <span class="hljs-comment">//默认输出后不换行，要换行加转义字符&quot;\n&quot;</span><br>log.Println(<span class="hljs-string">&quot;Println arrary:&quot;</span>, arr)  <span class="hljs-comment">//输出后自动换行</span><br>log.Printf(<span class="hljs-string">&quot;Print arrary with item [%d,%d]&quot;</span>, arr[<span class="hljs-number">0</span>], arr[<span class="hljs-number">1</span>]) <span class="hljs-comment">//可以指定输出格式</span><br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">2021/02/24 10:23:15 Print arrary:[0 1]<br>2021/02/24 10:23:15 Println arrary: [0 1]<br>2021/02/24 10:23:15 Print arrary with item [0,1]<br></code></pre></td></tr></table></figure><h3 id="log-Fatal"><a href="#log-Fatal" class="headerlink" title="log.Fatal"></a>log.Fatal</h3><p>该接口会将日志内容打印至标准输出，然后调用系统的 <code>os.Exit(1)</code> 接口，退出程序并返回状态 1 。</p><p>有一点需要注意，<strong>由于是直接调用系统接口退出，所以 defer 函数不会被调用。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test_deferpanic</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;-----first-----&quot;</span>)<br>&#125;()<br>log.Fatalln(<span class="hljs-string">&quot;Test for defer Fatal&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>test_deferpanic()<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">2021/02/24 10:33:58 Test for defer Fatal<br></code></pre></td></tr></table></figure><p>从运行结果可以看到，<code>defer</code>函数并没有被调用。</p><h3 id="log-Panic"><a href="#log-Panic" class="headerlink" title="log.Panic"></a>log.Panic</h3><p>该接口会将日志刷到标准错误后调用<code>panic</code> 函数。</p><p><strong>不同于 <code>Fatal</code>，在 <code>Panic</code>之前的 <code>defer</code>函数会执行，之后的则不执行。</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;log&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test_deferpanic</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;-----first-----&quot;</span>)<br>&#125;()<br>log.Panicln(<span class="hljs-string">&quot;Test for defer Fatal&quot;</span>)<br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;-----Second-----&quot;</span>)<br>&#125;()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>test_deferpanic()<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">2021/02/24 10:50:26 Test for defer Fatal<br>-----first-----<br>panic: Test for defer Fatal<br></code></pre></td></tr></table></figure><p>可以看到在触发 <code>Panic</code> 后，第一个 <code>defer</code>函数执行，第二个没有执行。说明在在Panic之后声明的defer是不会执行的。</p><h3 id="自定义Logger类型"><a href="#自定义Logger类型" class="headerlink" title="自定义Logger类型"></a>自定义Logger类型</h3><p>除了上面 <code>log</code> 模块下的三类接口，你也可以自定义 <code>Logger</code> 对象。 <code>log.Logger</code> 提供了 <code>New</code> 方法来创建自定义对象。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">New</span><span class="hljs-params">(out io.Writer, prefix <span class="hljs-type">string</span>, flag <span class="hljs-type">int</span>)</span></span> *Logger<br></code></pre></td></tr></table></figure><p>该函数一共有 3 个参数：</p><ul><li><p>out 用于指定输出位置，是一个 <code>io.Writer</code> 对象，该对象可以是一个文件也可以是实现了该接口的对象。通常我们可以用这个来指定日志输出到哪个文件。</p></li><li><p>prefix 就是日志内容前面的东西，我们可以将其置为 “[Info]” 、 “[Warning]”等来帮助区分日志级别。</p></li><li><p>flag 是一个选项，用于显示日志开头的东西，可选的值有：</p>  <figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">Ldate         = 1 &lt;&lt; iota     // 形如 2009/01/23 的日期<br>Ltime                         // 形如 01:23:23 的时间<br>Lmicroseconds                 // 形如 01:23:23.123123 的时间<br>Llongfile                     // 绝对路径文件名和行号 /a/b/c/d.go:23<br>Lshortfile                    // 文件名和行号 d.go:23. 重写 Llongfile<br>LUTC                          // 如果 Ldate 或者 Ltime 已经设置, 使用 UTC 时区<br>Lmsgprefix                    // 把 &quot;prefix&quot; 从每一行的开头移动到每段信息的开头<br>LstdFlags     = Ldate | Ltime // 标准日志输出的初始日期和时间<br></code></pre></td></tr></table></figure></li></ul><p>示例代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;log&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fileName := <span class="hljs-string">&quot;info_first.log&quot;</span><br>logFile, err := os.Create(fileName)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalln(<span class="hljs-string">&quot;Open file error&quot;</span>)<br>&#125;<br><span class="hljs-keyword">defer</span> logFile.Close()<br>debugLog := log.New(logFile, <span class="hljs-string">&quot;[Info]&quot;</span>, log.Lmsgprefix)<br>debugLog.Println(<span class="hljs-string">&quot;A info message here&quot;</span>)<br>debugLog.SetPrefix(<span class="hljs-string">&quot;[Debug]&quot;</span>)<br>debugLog.Println(<span class="hljs-string">&quot;A debug message here&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>会创建 <code>info_first.log</code> 文件，并将 log 信息写入，文件内容如下：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs text">[Info]A info message here<br>[Debug]A debug message here<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mac下给Docker配置镜像加速地址</title>
    <link href="/2021/02/23/problems/Mac%E4%B8%8B%E7%BB%99Docker%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%9C%B0%E5%9D%80/"/>
    <url>/2021/02/23/problems/Mac%E4%B8%8B%E7%BB%99Docker%E9%85%8D%E7%BD%AE%E9%95%9C%E5%83%8F%E5%8A%A0%E9%80%9F%E5%9C%B0%E5%9D%80/</url>
    
    <content type="html"><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><blockquote><p>Mac OS Big Sur 11.0.1</p><p>Docker Desktop 3.1.0(51484)</p></blockquote><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li><p>点击顶栏 Docker 图标，点击 <code>Preferences...</code>；</p></li><li><p>点击 <code>Docker Engine</code>，在代码区添加如下代码：</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>  <span class="hljs-string">&quot;https://7bezldxe.mirror.aliyuncs.com/&quot;</span><br><span class="hljs-punctuation">]</span><br></code></pre></td></tr></table></figure><p> 添加后效果：</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-punctuation">&#123;</span><br>  <span class="hljs-attr">&quot;experimental&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">false</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;features&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">&#123;</span><br>    <span class="hljs-attr">&quot;buildkit&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-keyword">true</span><br>  <span class="hljs-punctuation">&#125;</span><span class="hljs-punctuation">,</span><br>  <span class="hljs-attr">&quot;registry-mirrors&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span><br>    <span class="hljs-string">&quot;https://7bezldxe.mirror.aliyuncs.com/&quot;</span><br>  <span class="hljs-punctuation">]</span><br><span class="hljs-punctuation">&#125;</span><br></code></pre></td></tr></table></figure></li><li><p>点击顶栏图标，点击 <code>Restart Docker</code>；</p></li><li><p>检查，打开终端输入<code>docker info</code>命令，在输出信息中能找到如下信息即可完成。</p> <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs json">Registry Mirrors<span class="hljs-punctuation">:</span><br> https<span class="hljs-punctuation">:</span><span class="hljs-comment">//7bezldxe.mirror.aliyuncs.com/</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="其他国内镜像加速地址"><a href="#其他国内镜像加速地址" class="headerlink" title="其他国内镜像加速地址"></a>其他国内镜像加速地址</h3><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">https://registry.docker-cn.com<br>http://hub-mirror.c.163.com<br>https://3laho3y3.mirror.aliyuncs.com<br>http://f1361db2.m.daocloud.io<br>https://mirror.ccs.tencentyun.com<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Mac</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unix与C的前世今生</title>
    <link href="/2021/02/23/Unix%E4%B8%8EC%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/"/>
    <url>/2021/02/23/Unix%E4%B8%8EC%E7%9A%84%E5%89%8D%E4%B8%96%E4%BB%8A%E7%94%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>在当下的服务器领域，Linux 操作系统一直处于霸主地位，难以撼动。提起 Linux，我们常常会联想到 Unix，因为 Linux 是在Unix的基础上发展而来的，所以，现在也称 Linux 为 类Unix 的操作系统，同时，Unix 系统也是世界上第一个由 C 语言编写的操作系统，而 Unix 也促使了 C 语言的诞生，关于它们之间的关系，读完本文章你将很快有了答案。</p><h3 id="Mutics-和-Unix"><a href="#Mutics-和-Unix" class="headerlink" title="Mutics 和 Unix"></a>Mutics 和 Unix</h3><p>1964年，在 Unix 诞生之前，美国贝尔实验室、通用电气、和麻省理工学院联合开发了一个项目，叫做 Multics操作系统。Multics 在当时取得了巨大的成功，因为它给了人们一个真正可用并且很稳定的操作系统。当时从学校到政府机关，到处都在安装 Multics。</p><p>但是时间到了 1969年，因为种种原因，贝尔实验室的 Ken Thompson 和 Dennis Ritchie 决定放弃Multics，于是贝尔实验室退出了这个项目。Ken Thompson 和 Dennis Ritchie 决定开发一个更为简单并且高效的操作系统，并把它命名为 Unix，于是他们俩就成为了 Unix 之父。</p><p>和 Unix 相比，Multics 有两个比较致命的缺点，一是需要安装在非常昂贵的机器上，普通的计算机没有办法安装。二是设计非常复杂，这也是贝尔实验室的工程师退出的主要原因。不过 Ken Thompson 和 Dennis Ritchie 还是从 Multics 上得到很多启发，可以说 Unix 是 Multics 的简化以及更新。</p><p>说到这里，C 语言还没有出场，因为它在那个时候还没有被发明出来。Unix 操作系统的第一个版本是纯粹用汇编语言编写出来的。一直到了 1974 年，第四个版本才改用 C 语言进行开发。在讲 C 语言之前，我们还不得不先说一下 BCPL 和 B 语言。</p><h3 id="BCPL-和-B-语言"><a href="#BCPL-和-B-语言" class="headerlink" title="BCPL 和 B 语言"></a>BCPL 和 B 语言</h3><p>Ken Thompson 和 Dennis Ritchie 最初用汇编语言来开发 Unix，因为在那个时候，所有的操作系统都是用汇编语言来开发的。不过当时 Multics 是一个例外，Multics 项目组使用了 PL&#x2F;1 来进行开发。它的价值就在于向世人展示了用一门高级语言也可以开发出一套操作系统。Ken Thompson 和 Dennis Ritchie 也受到了鼓舞，他们决定用汇编之外的语言重新开发 Unix。他们最初的选择是 BCPL。BCPL 最早是由 Martin Richards 发明用来开发编译器的语言。但是 Ken Thompson 和 Dennis Ritchie 很快发现，如果他们想在小型计算机 DEC PDP-7 上使用 BCPL，就需要对这个语言本身进行一些修改。于是就产生了后来的 B 语言。</p><p>B 语言作为系统开发语言，也存在很多的缺点，于是后来它又被改进为 NB 语言(NB)。可是 NB 还是有很多的问题，于是 Dennis Ritchie 就又发明了 C 语言，最终在 1974年，Ken Thompson 和 Dennis Ritchie 一起用 C 语言重新编写了第四版的 Unix 系统。现在，C 语言已经成为了操作系统开发最常用的编程语言。</p><h3 id="C-语言取代-B-语言"><a href="#C-语言取代-B-语言" class="headerlink" title="C 语言取代 B 语言"></a>C 语言取代 B 语言</h3><p>Dennis Ritchie 曾经解释过自己为什么要发明 C 语言，以及使用 B 语言过程中遇到的一些困难：</p><ul><li>只能处理计算机字：B语言所有的操作都是通过计算机字来处理的，在那个时候，能够处理字节的编程语言对工程师们来说是一个梦。</li></ul><ul><li>没有类型：准确的说，B语言只有一种类型，计算机字。如果你有一个字符串，可能你需要把它分成多个变量来保存，比如一个21个字符的字符串，就需要 6 个变量。</li><li>不支持浮点类型运算：在那个时候，大部分硬件已经都可以开始支持浮点运算了，但是 B 语言还不支持这种操作。</li></ul><p>B 语言的这些问题，开发低效，在机器上运行缓慢等等，都迫使 Dennis Ritchie 发明一种新的编程语言。最开始被称为 New B，后来逐渐演化成了 C 语言。</p><p>C 语言解决了 B 语言的很多缺陷，并很快成为了开发操作系统最流行的一种编程语言。新版本的 Unix 以及今天很多类 Unix 的操作系统都是用 C 语言开发出来的。</p><p>好了，讲到这里，我想大家都清楚了 Unix 和 C 语言是怎么来的了，以及为什么要用 C 语言来编写 Unix。现在有很多非常流行的语言比如 Java 和 Python，它们是一种更高级的编程语言，是在 C 语言这一层之上的。但是如果大家想做设备驱动或者系统内核模块的修改，还是离不开 C 语言这把利器。</p>]]></content>
    
    
    <categories>
      
      <category>TODO</category>
      
      <category>传奇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Unix</tag>
      
      <tag>C</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PostgreSQL</title>
    <link href="/2020/03/13/todo/PostgreSQL%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B/"/>
    <url>/2020/03/13/todo/PostgreSQL%E4%BD%BF%E7%94%A8%E5%AE%9E%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> xtable (name <span class="hljs-type">varchar</span>(<span class="hljs-number">20</span>), address text, age <span class="hljs-type">int</span>);<br></code></pre></td></tr></table></figure><h3 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> xtable <span class="hljs-keyword">values</span>(&quot;X001&quot;, &quot;X City&quot;, <span class="hljs-number">24</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> xtable <span class="hljs-keyword">values</span>(&quot;Y001&quot;, &quot;Y City&quot;, <span class="hljs-number">22</span>);<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> xtable <span class="hljs-keyword">values</span>(&quot;Z001&quot;, &quot;Z City&quot;, <span class="hljs-number">22</span>);<br></code></pre></td></tr></table></figure><h3 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h3><h4 id="使用RETURNING子句返回更新后的字段"><a href="#使用RETURNING子句返回更新后的字段" class="headerlink" title="使用RETURNING子句返回更新后的字段"></a>使用RETURNING子句返回更新后的字段</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">update</span> xtable <span class="hljs-keyword">set</span> age <span class="hljs-operator">=</span> <span class="hljs-number">20</span> <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> &quot;X001&quot; returning age <span class="hljs-keyword">as</span> age_no;<br></code></pre></td></tr></table></figure><h3 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h3><h4 id="去重查询"><a href="#去重查询" class="headerlink" title="去重查询"></a>去重查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-keyword">distinct</span> age <span class="hljs-keyword">from</span> xtable <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h3 id="清空表"><a href="#清空表" class="headerlink" title="清空表"></a>清空表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">truncate</span> <span class="hljs-keyword">table</span> xtable;<br></code></pre></td></tr></table></figure><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><p>从数据库中删除表，包含表的所有关联数据，包括 索引、规则、触发器和约束。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">drop</span> <span class="hljs-keyword">table</span> if <span class="hljs-keyword">exists</span> xtable;<br></code></pre></td></tr></table></figure><h3 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h3><p>通过从表、子集或基础表中选择的列形成的虚拟表。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">or</span> replace <span class="hljs-keyword">view</span> vi <span class="hljs-keyword">as</span> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> xtable <span class="hljs-keyword">where</span> age <span class="hljs-keyword">is</span> <span class="hljs-keyword">null</span>;<br></code></pre></td></tr></table></figure><h3 id="使用select语句创建表"><a href="#使用select语句创建表" class="headerlink" title="使用select语句创建表"></a>使用select语句创建表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-string">&#x27;Jax&#x27;</span> <span class="hljs-keyword">as</span> col1, <span class="hljs-number">24</span> <span class="hljs-keyword">as</span> col2, <span class="hljs-string">&#x27;from china&#x27;</span> <span class="hljs-keyword">as</span> col3 <span class="hljs-keyword">into</span> ytable;<br></code></pre></td></tr></table></figure><h3 id="设定超时"><a href="#设定超时" class="headerlink" title="设定超时"></a>设定超时</h3><p>指定某个查询在规定时间后超时中止，精确到毫秒。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql">postgres# <span class="hljs-keyword">set</span> statement_timeout <span class="hljs-operator">=</span> <span class="hljs-number">10</span>;<br>postgres# <span class="hljs-keyword">select</span> pg_sleep(<span class="hljs-number">20</span>);<br>ERROR:  canceling statement due <span class="hljs-keyword">to</span> statement timeout<br></code></pre></td></tr></table></figure><h3 id="序号生成器"><a href="#序号生成器" class="headerlink" title="序号生成器"></a>序号生成器</h3><p>创建序列后，可以使用 <code>nextval</code> 和 <code>currval</code> 函数获取序列的下一个值和当前值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> sequence seq;<br><br>nextval(<span class="hljs-string">&#x27;seq&#x27;</span>);<br><br>currval(<span class="hljs-string">&#x27;seq&#x27;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Database</category>
      
      <category>PostgreSQL</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PostgreSQL</tag>
      
      <tag>Database</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>题1:Go代码里被defer的函数一定会执行吗?</title>
    <link href="/2020/03/13/todo/%E9%A2%981-Go%E4%BB%A3%E7%A0%81%E9%87%8C%E8%A2%ABdefer%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97/"/>
    <url>/2020/03/13/todo/%E9%A2%981-Go%E4%BB%A3%E7%A0%81%E9%87%8C%E8%A2%ABdefer%E7%9A%84%E5%87%BD%E6%95%B0%E4%B8%80%E5%AE%9A%E4%BC%9A%E6%89%A7%E8%A1%8C%E5%90%97/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>大家都知道Go编程中，假设在函数F里，执行了defer A()，那在函数F正常return之前或者因为panic要结束运行之前，被defer关键字修饰的函数调用A()都会被执行到。</p><p><strong>test1() 会在 main 结束之前运行</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;test&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;main start&quot;</span>)<br><span class="hljs-keyword">defer</span> test1()<br>fmt.Println(<span class="hljs-string">&quot;main end&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs txt">main start<br>main end<br>test<br></code></pre></td></tr></table></figure><p><strong>test1() 会在 panic 之前执行</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;test&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-built_in">panic</span>(<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;main start&quot;</span>)<br><span class="hljs-keyword">defer</span> test1()<br>test2()<br>fmt.Println(<span class="hljs-string">&quot;main end&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果:</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs txt">main start<br>test<br>panic: 1<br><br>goroutine 1 [running]:<br>main.test2(...)<br>        /path/defer2.go:12<br>main.main()<br>        /path/defer2.go:18 +0xa8<br>exit status 2<br></code></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>如果在函数F里，defer A() 这个语句执行了，是否意味着 A() 这个函数调用一定会执行？答案是不一定，如果在函数里调用了 os.Exit，程序会立刻停止，被 defer 的函数调用不会执行。</p><blockquote><p>关于os.Exit 的说明：<br>Exit causes the current program to exit with the given status code. Conventionally, code zero indicates success, non-zero an error. The program terminates immediately; deferred functions are not run. For portability, the status code should be in the range[0,125].</p></blockquote><p>示例:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-string">&quot;os&quot;</span><br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;test&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;main start&quot;</span>)<br><span class="hljs-keyword">defer</span> test1()<br>fmt.Println(<span class="hljs-string">&quot;main end&quot;</span>)<br>os.Exit(<span class="hljs-number">0</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs txt">main start<br>main end<br></code></pre></td></tr></table></figure><h3 id="defer-四原则回顾"><a href="#defer-四原则回顾" class="headerlink" title="defer 四原则回顾"></a>defer 四原则回顾</h3><h4 id="defer-后面跟的必须是函数或者方法调用，defer-后面的表达式不能加括号。"><a href="#defer-后面跟的必须是函数或者方法调用，defer-后面的表达式不能加括号。" class="headerlink" title="defer 后面跟的必须是函数或者方法调用，defer 后面的表达式不能加括号。"></a>defer 后面跟的必须是函数或者方法调用，defer 后面的表达式不能加括号。</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> (fmt.Println(<span class="hljs-number">1</span>)) <span class="hljs-comment">// 编译报错，因为defer后面跟的表达式不能加括号</span><br></code></pre></td></tr></table></figure><h4 id="被defer的函数的参数在执行到-defer-语句的时候就被确定下来了。"><a href="#被defer的函数的参数在执行到-defer-语句的时候就被确定下来了。" class="headerlink" title="被defer的函数的参数在执行到 defer 语句的时候就被确定下来了。"></a>被defer的函数的参数在执行到 defer 语句的时候就被确定下来了。</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> &#123;<br>   i := <span class="hljs-number">0</span><br>   <span class="hljs-keyword">defer</span> fmt.Println(i) <span class="hljs-comment">// 最终打印0</span><br>   i++<br>   <span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上例中，被defer的函数 fmt.Println 的参数i在执行到 defer 这一行的时候，i 的值是 0，fmt.Println 的参数就被确定下来是 0 了，因此最终打印的结果是 0，而不是 1。</p><h4 id="被-defer-的函数执行顺序满足LIFO原则，后defer的先执行。"><a href="#被-defer-的函数执行顺序满足LIFO原则，后defer的先执行。" class="headerlink" title="被 defer 的函数执行顺序满足LIFO原则，后defer的先执行。"></a>被 defer 的函数执行顺序满足LIFO原则，后defer的先执行。</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++ &#123;<br>   <span class="hljs-keyword">defer</span> fmt.Print(i)<br>      &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上例中，输出的结果是 3210，后 defer 的先执行。</p><h4 id="被-defer-的函数可以对-defer-语句所在的函数的命名返回值做读取和修改操作。"><a href="#被-defer-的函数可以对-defer-语句所在的函数的命名返回值做读取和修改操作。" class="headerlink" title="被 defer 的函数可以对 defer 语句所在的函数的命名返回值做读取和修改操作。"></a>被 defer 的函数可以对 defer 语句所在的函数的命名返回值做读取和修改操作。</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> (result <span class="hljs-type">int</span>) &#123;<br>   <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>   <span class="hljs-comment">// result is accessed after it was set to 6 by the return statement</span><br>   result *= <span class="hljs-number">7</span><br>   &#125;()<br>   <span class="hljs-keyword">return</span> <span class="hljs-number">6</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上例中，被 defer 的匿名函数对 defer 语句所在的 函数f 的命名返回值 result 做了修改操作。调用函数 f，返回的结果是42。执行顺序是函数f先把要返回的值 6 赋值给 result，然后执行被 defer 的函数 func，result 被修改为 42，然后 函数f 返回 result，也就是返回了 42。官方说明如下：</p><blockquote><p>Each time a “defer” statement executes, the function value and parameters to the call are evaluated as usual and saved anew but the actual function is not  invoked. Instead, deferred functions are invoked immediately before the  surrounding function returns, in the reverse order they were deferred. That is, if the surrounding function returns through an explicit return statement,  deferred functions are executed after any result parameters are set by that  return statement but before the function returns to its caller. If a deferred function value evaluates to nil, execution panics when the function is  invoked, not when the “defer” statement is executed.</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>编程语言</category>
      
      <category>Go</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Go</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
