

<!DOCTYPE html>
<html lang="en" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/favicon.png">
  <link rel="icon" href="/img/favicon.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Youpeng Cui">
  <meta name="keywords" content="Linux Go Mac">
  
    <meta name="description" content="mofan.life: Youpeng&amp;#39;s Technology Blog">
  
  
  
  <title>page.title - mofan.life: Youpeng&#39;s Technology Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />





<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"www.mofan.life","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":3},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":"e16cbb6ce764a8813654d6c255365079","google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 60vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Mofan</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                Home
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                Archive
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                Category
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                Tag
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/abouts/">
                <i class="iconfont icon-user-fill"></i>
                About
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                Links
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.1)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="page.title"></span>
          
        </div>

        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      <div class="container nopadding-x-md">
        <div id="board"
          >
          
          <div class="container">
            <div class="row">
              <div class="col-12 col-md-10 m-auto">
                

<article class="page-content">
  <h1 id="Mutex：解决资源并发问题"><a href="#Mutex：解决资源并发问题" class="headerlink" title="Mutex：解决资源并发问题"></a>Mutex：解决资源并发问题</h1><p>常见的并发问题：</p>
<ul>
<li>多个 goroutine 并发更新同一个资源，像计数器；</li>
<li>同时更新用户的账户信息；秒杀系统；</li>
<li>往同一个 buffer 中并发写入数据等等。</li>
</ul>
<p>如果没有互斥控制，就会出现一些异常情况，比如计数器的计数不准确、用户的账户可能出现透支、秒杀系统出现超卖、buffer 中的数据混乱，等等，后果都很严重。这些问题怎么解决呢？对，用互斥锁，那在 Go 语言里，就是 Mutex。</p>
<p>临界区的概念：</p>
<p>在并发编程中，如果程序中的一部分会被并发访问或修改，那么，为了避免并发访问导致的意想不到的结果，这部分程序需要被保护起来，这部分被保护起来的程序，就叫做<strong>临界区</strong>。</p>
<p>可以说，<strong>临界区就是一个被共享的资源，或者说是一个整体的一组共享资源</strong>，比如对数据库的访问、对某一个共享数据结构的操作、对一个 I/O 设备的使用、对一个连接池中的连接的调用，等等。</p>
<p>如果很多线程同步访问临界区，就会造成访问或操作错误，这当然不是我们希望看到的结果。所以，我们可以使用互斥锁，限定临界区只能同时由一个线程持有。</p>
<p>当临界区由一个线程持有的时候，其它线程如果想进入这个临界区，就会返回失败，或者是等待。直到持有的线程退出临界区，这些等待线程中的某一个才有机会接着持有这个临界区。</p>
<p><img src="https://www.cmdbyte.com/2022/202202101450295.webp" srcset="/img/loading.gif" lazyload></p>
<p>同步原语（Synchronization primitives）适用场景：</p>
<ul>
<li>共享资源。并发地读写共享资源，会出现数据竞争（data race）的问题，所以需要 Mutex、RWMutex 这样的并发原语来保护。</li>
<li>任务编排。需要 goroutine 按照一定的规律执行，而 goroutine 之间有相互等待或者依赖的顺序关系，我们常常使用 WaitGroup 或者 Channel 来实现。</li>
<li>消息传递。信息交流以及不同的 goroutine 之间的线程安全的数据交流，常常使用 Channel 来实现。</li>
</ul>
<p>Mutex有两种模式：正常模式和饥饿模式</p>
<p>正常模式下，waiter 都是进入先入先出队列，被唤醒的 waiter 并不会直接持有锁，而是要和新来的 goroutine 进行竞争。新来的 goroutine 有先天的优势，它们正在 CPU 中运行，可能它们的数量还不少，所以，在高并发情况下，被唤醒的 waiter 可能比较悲剧地获取不到锁，这时，它会被插入到队列的前面。如果 waiter 获取不到锁的时间超过阈值 1 毫秒，那么，这个 Mutex 就进入到了饥饿模式。在饥饿模式下，Mutex 的拥有者将直接把锁交给队列最前面的 waiter。新来的 goroutine 不会尝试获取锁，即使看起来锁没有被持有，它也不会去抢，也不会 spin，它会乖乖地加入到等待队列的尾部。如果拥有 Mutex 的 waiter 发现下面两种情况的其中之一，它就会把这个 Mutex 转换成正常模式:此 waiter 已经是队列中的最后一个 waiter 了，没有其它的等待锁的 goroutine 了；此 waiter 的等待时间小于 1 毫秒。正常模式拥有更好的性能，因为即使有等待抢锁的 waiter，goroutine 也可以连续多次获取到锁。饥饿模式是对公平性和性能的一种平衡，它避免了某些 goroutine 长时间的等待锁。在饥饿模式下，优先对待的是那些一直在等待的 waiter。</p>
<p><strong>问题：</strong></p>
<p>目前 Mutex 的 state 字段有几个意义，这几个意义分别是由哪些字段表示的？等待一个 Mutex 的 goroutine 数最大是多少？是否能满足现实的需求？</p>
<p>答：</p>
<ol>
<li><p>目前 Mutex 的 state 字段有几个意义，这几个意义分别是由哪些字段表示的？<br> 和第四个阶段的讲解基本一致：前三个bit分别为mutexLocked、mutexWoken、mutexStarving，剩余bit表示mutexWaiter</p>
</li>
<li><p>等待一个 Mutex 的 goroutine 数最大是多少？是否能满足现实的需求？<br> 单从程序来看，可以支持 1&lt;&lt;(32-3) -1 ，约 0.5 Billion个<br>   其中32为state的类型int32，3位waiter字段的shift<br> 考虑到实际goroutine初始化的空间为2K，0.5Billin*2K达到了1TB，单从内存空间来说已经要求极高了，当前的设计肯定可以满足了。</p>
</li>
</ol>
<h3 id="Mutex-使用四种易错场景盘点"><a href="#Mutex-使用四种易错场景盘点" class="headerlink" title="Mutex 使用四种易错场景盘点"></a>Mutex 使用四种易错场景盘点</h3><p>Mutex 常见的错误场景有 4 类，分别是 Lock/Unlock 不是成对出现、Copy 已使用的 Mutex、重入和死锁。下面我们一一来看。</p>
<h4 id="Lock-Unlock-不是成对出现"><a href="#Lock-Unlock-不是成对出现" class="headerlink" title="Lock/Unlock 不是成对出现"></a>Lock/Unlock 不是成对出现</h4><h5 id="缺少-Unlock"><a href="#缺少-Unlock" class="headerlink" title="缺少 Unlock"></a>缺少 Unlock</h5><ul>
<li>代码中有太多的 if-else 分支，可能在某个分支中漏写了 Unlock；</li>
<li>在重构的时候把 Unlock 给删除了；</li>
<li>Unlock 误写成了 Lock。</li>
</ul>
<h5 id="缺少-Lock"><a href="#缺少-Lock" class="headerlink" title="缺少 Lock"></a>缺少 Lock</h5><p>没有 Lock 直接 Unlock 会 panic。</p>
<h4 id="Copy-已使用的-Mutex"><a href="#Copy-已使用的-Mutex" class="headerlink" title="Copy 已使用的 Mutex"></a>Copy 已使用的 Mutex</h4><p>Package sync 的同步原语在使用后是不能复制的，而 Mutex 是最常用的一个同步原语，那么它为什么不能被复制？</p>
<p>因为 Mutex 是一个有状态的对象，它的 state 字段记录这个锁的状态，如果复制之前是加锁状态，那么复制之后就有锁了。但是你可能认为他是一个零值的 Mutex，于是又进行了一番 Lock 与 Unlock。关键是在并发环境下，你根本不知道要复制的 Mutex 状态是什么，因为要复制的 Mutex 是由其它 goroutine 并发访问的，状态可能总是在变化。</p>
<p>犯错误的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-keyword">type</span> Counter <span class="hljs-keyword">struct</span> &#123;<br>    sync.Mutex<br>    Count <span class="hljs-keyword">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    <span class="hljs-keyword">var</span> c Counter<br>    c.Lock()<br>    <span class="hljs-keyword">defer</span> c.Unlock()<br>    c.Count++<br>    foo(c) <span class="hljs-comment">// 复制锁</span><br>&#125;<br><br><span class="hljs-comment">// 这里Counter的参数是通过复制的方式传入的</span><br><span class="hljs-comment">// 复制之前已经使用了这个锁，这就导致，复制的 Counter 是一个带状态 Counter。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(c Counter)</span></span> &#123;<br>    c.Lock()<br>    <span class="hljs-keyword">defer</span> c.Unlock()<br>    fmt.Println(<span class="hljs-string">&quot;in foo&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>
<p>对于这种情况，Go 在运行的时候有死锁检查机制( <a target="_blank" rel="noopener" href="https://go.dev/src/runtime/proc.go?h=checkdead#L4345">checkdead()方法</a>)，它能够发现死锁的 goroutine，并打印死锁情况并输出错误信息。当然，在运行之前也可以发现复制 Mutex 导致的死锁问题，即使用 <strong>vet 工具</strong>，eg：<code>go vet main.go</code> 。可以将该命令放到 Makefile 中，以便在持续集成的时候发现问题。</p>
<blockquote>
<p>vet 工具是怎么发现 Mutex 复制使用问题的呢？</p>
<p>检查是通过copylock分析器静态分析实现的。这个分析器会分析函数调用、range 遍历、复制、声明、函数返回值等位置，有没有锁的值 copy 的情景，以此来判断有没有问题。可以说，只要是实现了 Locker 接口，就会被分析。我们看到，下面的代码就是确定什么类型会被分析，其实就是实现了 Lock/Unlock 两个方法的 Locker 接口：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> lockerType *types.Interface<br>  <br>  <span class="hljs-comment">// Construct a sync.Locker interface type.</span><br>  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>    nullary := types.NewSignature(<span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, <span class="hljs-literal">false</span>) <span class="hljs-comment">// func()</span><br>    methods := []*types.Func&#123;<br>      types.NewFunc(token.NoPos, <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;Lock&quot;</span>, nullary),<br>      types.NewFunc(token.NoPos, <span class="hljs-literal">nil</span>, <span class="hljs-string">&quot;Unlock&quot;</span>, nullary),<br>    &#125;<br>    lockerType = types.NewInterface(methods, <span class="hljs-literal">nil</span>).Complete()<br>  &#125;<br></code></pre></td></tr></table></figure>
</blockquote>
<h4 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h4><blockquote>
<p>重入锁：</p>
<p>当一个线程获取锁时，如果没有其它线程拥有这个锁，那么，这个线程就成功获取到这个锁。之后，如果其它线程再请求这个锁，就会处于阻塞等待的状态。但是，如果拥有这把锁的线程再请求这把锁的话，不会阻塞，而是成功返回，所以叫可重入锁（有时候也叫做递归锁）。只要你拥有这把锁，你可以可着劲儿地调用，比如通过递归实现一些算法，调用者不会阻塞或者死锁。</p>
</blockquote>
<p><strong>Mutex 是不可重入的锁</strong>，因为 Mutex 的实现中没有记录哪个 goroutine 拥有这把锁。理论上，任何 goroutine 都可以随意地 Unlock 这把锁，所以没办法计算重入条件。</p>
<p>误用 Mutex 重入的例子：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">foo</span><span class="hljs-params">(l sync.Locker)</span></span> &#123;<br>    fmt.Println(<span class="hljs-string">&quot;in foo&quot;</span>)<br>    l.Lock()<br>    bar(l)<br>    l.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bar</span><span class="hljs-params">(l sync.Locker)</span></span> &#123;<br>    l.Lock()<br>    fmt.Println(<span class="hljs-string">&quot;in bar&quot;</span>)<br>    l.Unlock()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>    l := &amp;sync.Mutex&#123;&#125;<br>    foo(l)<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="实现可重入锁"><a href="#实现可重入锁" class="headerlink" title="实现可重入锁"></a>实现可重入锁</h5><p>本质上 Mutex 还是只 Lock/Unlock 了一次。</p>
<h6 id="方案一：通过-hacker-的方式获取到-goroutine-id，记录下获取锁的-goroutine-id，它可以实现-Locker-接口。"><a href="#方案一：通过-hacker-的方式获取到-goroutine-id，记录下获取锁的-goroutine-id，它可以实现-Locker-接口。" class="headerlink" title="方案一：通过 hacker 的方式获取到 goroutine id，记录下获取锁的 goroutine id，它可以实现 Locker 接口。"></a>方案一：通过 hacker 的方式获取到 goroutine id，记录下获取锁的 goroutine id，它可以实现 Locker 接口。</h6><blockquote>
<p>使用 hacker 方式获取 goroutine id</p>
<p>首先，我们获取运行时的 g 指针，反解出对应的 g 的结构。每个运行的 goroutine 结构的 g 指针保存在当前 goroutine 的一个叫做 TLS 对象中。第一步：我们先获取到 TLS 对象；第二步：再从 TLS 中获取 goroutine 结构的 g 指针；第三步：再从 g 指针中取出 goroutine id。</p>
</blockquote>
<p>简单期间，这里使用了： <code>github.com/petermattis/goid</code> 库，用来获取 goroutine id</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// RecursiveMutex 包装一个Mutex,实现可重入</span><br><span class="hljs-keyword">type</span> RecursiveMutex <span class="hljs-keyword">struct</span> &#123;<br>    sync.Mutex<br>    owner     <span class="hljs-keyword">int64</span> <span class="hljs-comment">// 当前持有锁的goroutine id</span><br>    recursion <span class="hljs-keyword">int32</span> <span class="hljs-comment">// 这个goroutine 重入的次数</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *RecursiveMutex)</span> <span class="hljs-title">Lock</span><span class="hljs-params">()</span></span> &#123;<br>    gid := goid.Get()<br>    <span class="hljs-comment">// 如果当前持有锁的goroutine就是这次调用的goroutine,说明是重入</span><br>    <span class="hljs-keyword">if</span> atomic.LoadInt64(&amp;m.owner) == gid &#123;<br>        m.recursion++<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    m.Mutex.Lock()<br>    <span class="hljs-comment">// 获得锁的goroutine第一次调用，记录下它的goroutine id,调用次数加1</span><br>    atomic.StoreInt64(&amp;m.owner, gid)<br>    m.recursion = <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *RecursiveMutex)</span> <span class="hljs-title">Unlock</span><span class="hljs-params">()</span></span> &#123;<br>    gid := goid.Get()<br>    <span class="hljs-comment">// 非持有锁的goroutine尝试释放锁，错误的使用</span><br>    <span class="hljs-keyword">if</span> atomic.LoadInt64(&amp;m.owner) != gid &#123;<br>        <span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;wrong the owner(%d): %d!&quot;</span>, m.owner, gid))<br>    &#125;<br>    <span class="hljs-comment">// 调用次数减1</span><br>    m.recursion--<br>    <span class="hljs-keyword">if</span> m.recursion != <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 如果这个goroutine还没有完全释放，则直接返回</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-comment">// 此goroutine最后一次调用，需要释放锁</span><br>    atomic.StoreInt64(&amp;m.owner, <span class="hljs-number">-1</span>)<br>    m.Mutex.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure>
<h6 id="方案二：调用-Lock-Unlock-方法时，由-goroutine-提供一个-token，用来标识它自己，而不是我们通过-hacker-的方式获取到-goroutine-id，但是，这样一来，就不满足-Locker-接口了。"><a href="#方案二：调用-Lock-Unlock-方法时，由-goroutine-提供一个-token，用来标识它自己，而不是我们通过-hacker-的方式获取到-goroutine-id，但是，这样一来，就不满足-Locker-接口了。" class="headerlink" title="方案二：调用 Lock/Unlock 方法时，由 goroutine 提供一个 token，用来标识它自己，而不是我们通过 hacker 的方式获取到 goroutine id，但是，这样一来，就不满足 Locker 接口了。"></a>方案二：调用 Lock/Unlock 方法时，由 goroutine 提供一个 token，用来标识它自己，而不是我们通过 hacker 的方式获取到 goroutine id，但是，这样一来，就不满足 Locker 接口了。</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Token方式的递归锁</span><br><span class="hljs-keyword">type</span> TokenRecursiveMutex <span class="hljs-keyword">struct</span> &#123;<br>    sync.Mutex<br>    token     <span class="hljs-keyword">int64</span><br>    recursion <span class="hljs-keyword">int32</span><br>&#125;<br><br><span class="hljs-comment">// 请求锁，需要传入token</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *TokenRecursiveMutex)</span> <span class="hljs-title">Lock</span><span class="hljs-params">(token <span class="hljs-keyword">int64</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> atomic.LoadInt64(&amp;m.token) == token &#123; <span class="hljs-comment">//如果传入的token和持有锁的token一致，说明是递归调用</span><br>        m.recursion++<br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    m.Mutex.Lock() <span class="hljs-comment">// 传入的token不一致，说明不是递归调用</span><br>    <span class="hljs-comment">// 抢到锁之后记录这个token</span><br>    atomic.StoreInt64(&amp;m.token, token)<br>    m.recursion = <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-comment">// 释放锁</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *TokenRecursiveMutex)</span> <span class="hljs-title">Unlock</span><span class="hljs-params">(token <span class="hljs-keyword">int64</span>)</span></span> &#123;<br>    <span class="hljs-keyword">if</span> atomic.LoadInt64(&amp;m.token) != token &#123; <span class="hljs-comment">// 释放其它token持有的锁</span><br>        <span class="hljs-built_in">panic</span>(fmt.Sprintf(<span class="hljs-string">&quot;wrong the owner(%d): %d!&quot;</span>, m.token, token))<br>    &#125;<br>    m.recursion-- <span class="hljs-comment">// 当前持有这个锁的token释放锁</span><br>    <span class="hljs-keyword">if</span> m.recursion != <span class="hljs-number">0</span> &#123; <span class="hljs-comment">// 还没有回退到最初的递归调用</span><br>        <span class="hljs-keyword">return</span><br>    &#125;<br>    atomic.StoreInt64(&amp;m.token, <span class="hljs-number">0</span>) <span class="hljs-comment">// 没有递归调用了，释放锁</span><br>    m.Mutex.Unlock()<br>&#125;<br></code></pre></td></tr></table></figure>
<h5 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h5><p>什么是死锁？</p>
<p>答：两个或两个以上的进程（或线程，goroutine）在执行过程中，因争夺共享资源而处于一种互相等待的状态，如果没有外部干涉，它们都将无法推进下去，此时，我们称系统处于死锁状态或系统产生了死锁。</p>
<p>死锁产生的条件：</p>
<ol>
<li>互斥： 至少一个资源是被排他性独享的，其他线程必须处于等待状态，直到资源被释放。</li>
<li>持有和等待：goroutine 持有一个资源，并且还在请求其它 goroutine 持有的资源，也就是咱们常说的“吃着碗里，看着锅里”的意思。</li>
<li>不可剥夺：资源只能由持有它的 goroutine 来释放。</li>
<li>环路等待：一般来说，存在一组等待进程，P={P1，P2，…，PN}，P1 等待 P2 持有的资源，P2 等待 P3 持有的资源，依此类推，最后是 PN 等待 P1 持有的资源，这就形成了一个环路等待的死结。</li>
</ol>
<h4 id="流行的Go项目关于-Mutex-的-issue"><a href="#流行的Go项目关于-Mutex-的-issue" class="headerlink" title="流行的Go项目关于 Mutex 的 issue"></a>流行的Go项目关于 Mutex 的 issue</h4><p>第三方探测死锁的工具：<a target="_blank" rel="noopener" href="https://github.com/sasha-s/go-deadlock">go-deadlock</a>，<a target="_blank" rel="noopener" href="https://github.com/dominikh/go-tools">go-tools</a>。</p>
<p>并发程序最难跟踪调试的就是很难重现，因为并发问题不是按照我们指定的顺序执行的，由于计算机调度的问题和事件触发的时机不同，死锁的 Bug 可能会在极端的情况下出现。通过搜索日志、查看日志，我们能够知道程序有异常了，比如某个流程一直没有结束。这个时候，可以通过 Go pprof 工具分析，它提供了一个 block profiler 监控阻塞的 goroutine。除此之外，我们还可以查看全部的 goroutine 的堆栈信息，通过它，你可以查看阻塞的 groutine 究竟阻塞在哪一行哪一个对象上了。</p>


  

</article>



              </div>
            </div>
          </div>
        </div>
      </div>
    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">Search</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">Keyword</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div style="font-size: 0.85rem"> <span id="timeDate"></span> <!--  <span id="times"></span> --> <script src="/js/duration.js"></script> </div> 
    </div>
  
  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      京ICP备2022000091号
    </a>
  </span>
  
</div>

  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">Blog works best with JavaScript enabled</div>
  </noscript>
</body>
</html>
