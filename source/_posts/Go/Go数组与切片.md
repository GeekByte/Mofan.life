---
title: Go 数组与切片
categories:
  - Lang
  - Go
tags:
  - Go
date: 2021-11-18 21:01:17
---

## 数组

数组是由相同类型的元素的集合组成的数据结构，数组中的元素由一块连续的内存存储，因此可通过索引快速地访问数组中特定的元素。

Go的数组在编译期间初始化，初始化的过程会直接读写内存（如元素的赋值与更新）。数组初始化后无法改变，即数组长度与元素类型不可变。

Go中数组的类型在编译期间确定，类型受元素类型与数组长度影响，只有二者相同才认为是相同类型数组。

Go中数组在编译期间，会根据数组长度决定数组初始化的位置

* 长度小于等于4的数组在栈中初始化。
* 大于4的数组在静态存储区初始化，然后拷贝到栈上。

Go数组的表示：数组第一个元素的指针，元素类型的长度，元素的数量

Go为保证数组和字符串的访问不越界，分别在编译阶段与运行阶段进行判断。

* 编译阶段：可发现较简单的错误，如：非整数索引、负数索引、大于数组长度的索引
* 运行阶段：适用于用变量访问数组

## 切片

切片也就是动态数组，即向切片中追加元素，容量不足时会自动扩容。

由于切片容量是动态的，所以定义切片时只需指定切片中元素类型即可，当然也可通过 make 创建切片时指定初始容量。

切片在编译期间生成的类型只包含切片中的元素类型, `~/env/go/src/cmd/compile/internal/types2/builtins.go`  中的 `builtin` 方法在编译期间创建切片类型。

```go
func (check *Checker) builtin(x *operand, call *syntax.CallExpr, id builtinId) (_ bool) {
	// ...
    
	case _Slice:
		// ...

		x.mode = value
		x.typ = NewSlice(ptr.base)
		if check.recordTypes() {
			check.recordBuiltinType(call.Fun, makeSig(x.typ, ptr, y.typ))
		}
    
    // ...
}
```

上面的方法调用 `~/env/go/src/cmd/compile/internal/types2/slice.go` 中的 `NewSlice` 返回一个只包含元素类型的结构。

```go
// A Slice represents a slice type.
type Slice struct {
	elem Type
}

// NewSlice returns a new slice type for the given element type.
func NewSlice(elem Type) *Slice { return &Slice{elem: elem} }
```

上述方法返回结构体中的 `Extra` 字段是一个只包含切片内元素类型的结构，也就是说切片内元素的类型都是在编译期间确定的，编译器确定了类型之后，会将类型存储在 `Extra` 字段中帮助程序在运行时动态获取。

`NewSlice` 方法返回一个只包含切片内元素类型的结构，也就是说切片内元素的类型都是在编译期间确定的，编译器确定了类型之后，会将类型存储在 `Extra` 字段中帮助程序在运行时动态获取。

### 数据结构



在运行时，切片由`reflect.SliceHeader`结构体表示，包含三个字段：

* Data 指向数组的指针
* Len 当前切片的长度
* Cap 当前切片的容量，即Data数组的大小

切片的底层与数组一样，仍然有连续的内存存储，只是，切片的概念相比于数组，在连续内存空间上，多了长度和容量两个标识。



### 初始化

Go 语言中包含三种初始化切片的方式：

1. 通过下标的方式获得数组或者切片的一部分；
2. 使用字面量初始化新的切片；
3. 使用关键字 `make` 创建切片：

```go
arr[0:3] or slice[0:3]
slice := []int{1, 2, 3}
slice := make([]int, 10)
```

#### 使用下标

使用下标创建切片是最原始也最接近汇编语言的方式，需要注意的是使用下标初始化切片不会拷贝原数组或者原切片中的数据，它只会创建一个指向原数组的切片结构体，所以修改新切片的数据也会修改原切片。

#### 使用字面量

最终也是使用下标创建切片。

```go
var vstat [3]int
vstat[0] = 1
vstat[1] = 2
vstat[2] = 3
var vauto *[3]int = new([3]int)
*vauto = vstat
slice := vauto[:]
```

1. 根据切片中的元素数量对底层数组的大小进行推断并创建一个数组；
2. 将这些字面量元素存储到初始化的数组中；
3. 创建一个同样指向 `[3]int` 类型的数组指针；
4. 将静态存储区的数组 `vstat` 赋值给 `vauto` 指针所在的地址；
5. 通过 `[:]` 操作获取一个底层使用 `vauto` 的切片；

#### 关键字

使用字面量或下标创建的切片，大部分工作会在编译期间完成，而使用 make 创建切片，大部分工作则在运行时完成，正因如此，make 创建切片会进行类型检查。

在编译期间创建切片时，会通过下面两个条件判断切片的创建方式：

* 切片的大小和容量是否足够小
* 切片是否发生逃逸，若是则最终在堆上创建

如果切片的大小和容量非常小，则会转换成使用下标创建切片的方式，最终分配到栈上。在堆上分配时，会先计算切片占用的内存空间，然后在堆上申请一片连续的内存。

```txt
内存空间 = 元素数据类型大小 * 切片容量
```

虽然编译期间可以检查出很多错误，但是在创建切片的过程中如果发生了以下错误会直接触发运行时错误并崩溃：

1. 内存空间的大小发生了溢出；
2. 申请的内存大于最大可分配的内存；
3. 传入的长度小于 0 或者长度大于容量；


### 访问切片
使用 `len` 和 `cap` 可获取切片的长度和容量.

切片的操作基本都是在编译期间完成的，除了访问切片的长度、容量或者其中的元素之外，编译期间也会将包含 `range` 关键字的遍历转换成形式更简单的循环

### 追加和扩容

编译阶段会根据 append 返回的切片是否覆盖原变量，生成两种处理流程，这两种流程的逻辑类似，最大的区别在于是否覆盖原变量，若覆盖原变量，则无需关心切片发生拷贝影响性能，因为 Go 的编译器对这种情况做了优化。

>  可参考:  [Go slice扩容深度分析 - 掘金](https://juejin.cn/post/6844903812331732999)

append的时候发生扩容的动作

- append单个元素，或者append少量的多个元素，这里的少量指double之后的容量能容纳，这样就会走以下扩容流程
    - 不足1024，双倍扩容
    - 超过1024的，1.25倍扩容
- 若是append多个元素，且double后的容量不能容纳，直接使用预估的容量。

**此外，以上两个分支得到新容量后，均需要根据slice的类型size，算出新的容量所需的内存情况`capmem`，然后再进行`capmem`向上取整，得到新的所需内存，除上类型size，得到真正的最终容量,作为新的slice的容量。**

### 切片拷贝

copy(a, b)

拷贝可发生在编译阶段与运行时

* 区别：
    * 编译阶段直接使用 `copy`
    * 运行时拷贝会将 `copy` 替换成 `runtime.slicecopy`
* 相同点：
    *  两种拷贝方式最终都通过 `runtime.memmove` 将整块内存的内容拷贝到目标的内存区域中

相较于通过遍历的的方式达到拷贝的效果，`runtime.memmove` 可以达到更高的性能，但大片内存拷贝仍会占用更多的资源，开发中要注意到内存拷贝对性能的影响。
