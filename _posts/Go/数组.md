---
title: Go 数组与切片
categories:
  - Go
tags:
  - Go
date: 2021-11-18 21:01:17
---

## 数组

数组是由相同类型的元素的集合组成的数据结构，数组中的元素由一块连续的内存存储，因此可通过索引快速地访问数组中特定的元素。

Go的数组在编译期间初始化，初始化的过程会直接读写内存（如元素的赋值与更新）。数组初始化后无法改变，即数组长度与元素类型不可变。

Go中数组的类型在编译期间确定，类型受元素类型与数组长度影响，只有二者相同才认为是相同类型数组。

Go中数组在编译期间，会根据数组长度决定数组初始化的位置

* 长度小于等于4的数组在栈中初始化。
* 大于4的数组在静态存储区初始化，然后拷贝到栈上。

Go数组的表示：数组第一个元素的指针，元素类型的长度，元素的数量

Go为保证数组和字符串的访问不越界，分别在编译阶段与运行阶段进行判断。

* 编译阶段：可发现较简单的错误，如：非整数索引、负数索引、大于数组长度的索引
* 运行阶段：适用于用变量访问数组

## 切片

切片的长度是动态的。

在编译阶段生成的切片类型，类型只受切片中元素的类型影响（注意与数组区分，数组还受长度影响）。

在运行时，切片由`reflect.SliceHeader`结构体表示，包含三个字段：

* Data 指向数组的指针
* Len 当前切片的长度
* Cap 当前切片的容量，即Data数组的大小

切片的底层与数组一样，仍然有连续的内存存储，只是，切片的概念相比于数组，在连续内存空间上，多了长度和容量两个标识。



### 切片初始化

* 通过下标的方式获得数组或者切片的一部分, arr[0:3] or slice[0:3]
    - 这种方式最原始，即最接近汇编语言的方式
    - 通过这种方式不会拷贝原数组或原切片中的数据，只是创建了一个指向原数据的切片结构体，故改变新切片中的数据会同时改变原数据
* 使用字面量初始化新的切片, slice := []int{1, 2, 3}
* 使用关键字make, slice := make([]int, 10)


切片的操作基本都是在编译期间完成的，除了访问切片的长度、容量或者其中的元素之外，编译期间也会将包含 `range` 关键字的遍历转换成形式更简单的循环


### 访问切片
使用 `len` 和 `cap` 可获取切片的长度和容量.


### 追加扩容

>  可参考:  [Go slice扩容深度分析 - 掘金](https://juejin.cn/post/6844903812331732999)

append的时候发生扩容的动作

- append单个元素，或者append少量的多个元素，这里的少量指double之后的容量能容纳，这样就会走以下扩容流程
    - 不足1024，双倍扩容
    - 超过1024的，1.25倍扩容
- 若是append多个元素，且double后的容量不能容纳，直接使用预估的容量。

**此外，以上两个分支得到新容量后，均需要根据slice的类型size，算出新的容量所需的内存情况`capmem`，然后再进行`capmem`向上取整，得到新的所需内存，除上类型size，得到真正的最终容量,作为新的slice的容量。**

### 切片拷贝

copy(a, b)

拷贝可发生在编译阶段与运行时

* 区别：
    * 编译阶段直接使用 `copy`
    * 运行时拷贝会将 `copy` 替换成 `runtime.slicecopy`
* 相同点：
    *  两种拷贝方式最终都通过 `runtime.memmove` 将整块内存的内容拷贝到目标的内存区域中

相较于通过遍历的的方式达到拷贝的效果，`runtime.memmove` 可以达到更高的性能，但大片内存拷贝仍会占用更多的资源，开发中要注意到内存拷贝对性能的影响。
