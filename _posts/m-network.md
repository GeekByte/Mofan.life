---
title: 网络
categories:
  - 面试
  - 网络
tags:
  - 面试
date: 2021-03-10 09:17:51
---

## 讲一下TCP和HTTP

TCP协议对应传输层，HTTP协议对应应用层，HTTP协议是建立在TCP协议基础之上的。

TCP协议可以对上层网络提供接口，使上层网络数据的传输建立在“无差别”的网络之上。完成一个TCP连接需要经历三次握手，断开则需要四次挥手。理想状态下，TCP连接一旦建立，在通信双方任一方没有断开之前，都是处于连接状态的，

HTTP协议是负责传输数据的协议，它是一种无状态的协议，HTTP连接是一种“短连接”，在HTTP1.0中，客户端的每次请求都对应一次连接，请求完成则断开连接。在HTTP1.1中可以在一次连接中处理多个请求，并且多个请求重叠进行，不需要每个请求都经历一次“连接-断开”的过程。

## TCP和UDP的特性

* TCP是面向连接的，连接要经过三次握手，断开要经过四次挥手。UDP是面向无连接的，它是一个可以随时通信的协议，只要双方建立了Socket，设置了监听端口，就可以收到到达的UDP包，并能够随时建立Socket
* TCP具有流量控制和用塞控制机制，通过控制滑动窗口的大小来控制数据发送速率。而UDP理论上可以向网络中无限制的发送数据，除非在程序端做了控制。
* TCP可以保证数据传输的可靠性，有速率控制、重传机制、数据校验等机制。而UDP则是尽力的传输数据，不能保证数据的可靠性。
* TCP报文段头部占20个字节，比UDP多12个，加上连接有握手机制，使用效率上不如UDP。

## TCP三次握手、四次挥手，四次能不能变成三次

### 三次握手

客户端➡️服务器：标志位：SYN=1 序号为：seq=x（默认x=1）

服务器➡️客户端：标志位：SYN=1，ACK=1 确认位：ack=x+1 序号位：seq=y

客户端➡️服务器：标志位：ACK=1 确认位：ack=y+1 序号位：seq=x+1

## HTTP2.0了解吗？和HTTP1.1的差距

HTTP2.0可以说是SPDY的升级版，性能很高

HTTP2.0相比HTTP1.1的新特性有：

* 新的二进制格式：HTTP1.x基于文本，HTTP2.0的解析基于二进制，实现方便且健壮
* 多路复用：一个连接里可以有多个request，每个request都有一个id，接收方可以根据id选择对应的服务
* header压缩：使用encoder减少传输大小，通信双方个cache一份header fileds表
* 服务端推送

## 服务器如何处理大流量高并发请求

* 增加资源供给：更大的带宽、更高配置的服务器、更高性能的web服务应用、更高性能的数据库
* 请求分流：使用集群，分布式的系统架构
* 应用优化：使用高效的编程语言、优化业务逻辑算法、优化访问数据库的SQL语句

## 计算机网络七层协议

主机代表着高层，网络代表低层。

![七层网络模型](https://www.cmdbyte.com/2021/02/%E4%B8%83%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png)

## TCP保证可靠性

* 校验和
* 确认应答与序列号
* 超时重传
* 连接管理
* 流量控制
* 用塞控制
	* 慢开始
	* 拥塞避免避免
	* 快重传
	* 快恢复

## TCP十六位校验如何实现的

在发送方将整个报文段分成多个16位的段，将所有段进行反码相加，然后将结果存放在校验和字段中，接收方也采用相同的方法进行计算，若最终结果为检验字段所有位全为1，则正确，否则存在错误。

## TCP粘包



## 802.3x工作在第几层，为什么



## HTTPS握手，为什么需要非对称加密和对称加密



## 基于UDP再设计一个可靠的协议，如何设计



## QUIC



## HTTP和HTTPS的区别



## HTTP和HTTPS的应用场景



## HTTPS最耗时的环节



##  ipv4 和 ipv6 

 

## tcp 的阻塞控制 

* 慢开始
* 拥塞避免
* 快重传
* 快恢复

## 拥塞避免后再次慢开始还会从1开始吗 

 是的。目的就是要迅速减少主机发送到网络中的分组数，使得发生拥塞的路由器有足够时间把队列中积压的分组处理完毕。

## 为什么 tcp 需要拥塞控制 

**防止过多的数据注入到网络中，这样可以使网络中的路由器或链路不致过载。**

当发送端给接收端发送数据时，只有接收端收到了数据，才会给发送端返回应答信息。如果接收端一直没有收到应答信息，则发送端会认为数据已经丢失，会进行重新发送。

接收端收不到信息其实有两种情况，一种是数据真的丢失，一种是网络通信处于拥塞状态，拥塞控制针对的就是第二种情况。

## Cookie与Session的区别

* **数据存放位置不同**
	* Cookie数据存放在客户的浏览器上
	* Session数据存放在服务器上
* **安全程度不同**
	* cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session
* **性能使用程度不同**
	* session会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能,考虑到减轻服务器性能方面，应当使用cookie
* **数据存储大小不同**
	* 单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，而session则存储与服务端，浏览器对其没有限制。
* **会话机制不同**
	* session会话机制：session会话机制是一种服务器端机制，它使用类似于哈希表（可能还有哈希表）的结构来保存信息。
	* cookies会话机制：cookie是服务器存储在本地计算机上的小块文本，并随每个请求发送到同一服务器。 Web服务器使用HTTP标头将cookie发送到客户端。在客户端终端，浏览器解析cookie并将其保存为本地文件，该文件自动将来自同一服务器的任何请求绑定到这些cookie。



## Session ID如何维护（Cookie里带有Session ID）

A．保存session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。
B．由于cookie可以被人为的禁止，必须有其它的机制以便在cookie被禁止时仍然能够把session id传递回服务器，经常采用的一种技术叫做URL重写，就是把session id附加在URL路径的后面，附加的方式也有两种，一种是作为URL路径的附加信息，另一种是作为查询字符串附加在URL后面。网络在整个交互过程中始终保持状态，就必须在每个客户端可能请求的路径后面都包含这个session id。
C．另一种技术叫做表单隐藏字段。就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把session id传递回服务器。

## XSS和CSRF



## 多台服务器session存储怎么设计



## 多台服务器session除了存在redis还可以存在哪里



## https详细过程



## get post区别，还有什么其他方法，分别是做什么的




## web安全问题有哪些

**1、SQL注入**
拼接的SQL字符串改变了设计者原来的意图，执行了如泄露、改变数据等操作，甚至控制数据库
服务器， SQL Injection与Command Injection等攻击包括在内

**2、跨站脚本攻击（XSS或css）**

跨站脚本(Cross-Site Scripting)是指远程WEB页面的html代码可以插入具有恶意目的的数据，当
浏览器下载该页面，嵌入其中的恶意脚本将被解释执行，从而对客户端用户造成伤害。简称CSS
或XSS
**3、没有限制URL访问**

系统已经对URL的访问做了限制，但这种限制却实际并没有生效。攻击者能够很容易的就伪造
请求直接访问未被授权的页面

**4、越权访问**

用户对系统的某个模块或功能没有权限，通过拼接URL或Cookie欺骗来访问该模块或功能

**5、泄露配置信息**

服务器返回的提示或错误信息中出现服务器版本信息泄露、程序出错泄露物理路径、程序查询
出错返回SQL语句、过于详细的用户验证返回信息。

**6、不安全的加密存储**

常见的问题是不安全的密钥生成和储存、不轮换密钥，和使用弱算法。使用弱的或者不带salt 
的哈希算法来保护密码也很普遍。外部攻击者因访问的局限性很难探测这种漏洞。他们通常
必须首先破解其他东西以获得需要的访问。

**7、传输层保护不足**

在身份验证过程中没有使用SSL / TLS，因此暴露传输数据和会话ID，被攻击者截听，或使
用过期或者配置不正确的证书。

**8、登录信息提示**

用户登录提示信息会给攻击者一些有用的信息，作为程序的开发人员应该做到对登录提示信
息的模糊化，以防攻击者利用登录得知用户是否存在

**9、重复提交请求**

程序员在代码中没有对重复提交请求做限制，这样就会出现订单被多次下单，帖子被重
复发布。恶意攻击者可能利用此漏洞对网站进行批量灌水，致使网站瘫痪

**10、网页脚本错误**

访问者所使用的浏览器不能完全支持页面里的脚本，形成“脚本错误”，也就是网站中的脚
本没有被成功执行。遇到“脚本错误”时一般会弹出一个非常难看的脚本运行错误警告窗口

