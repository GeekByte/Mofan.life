---
title: Gorm框架避坑指南
categories:
  - 开源项目
  - Go
  - Gorm
tags:
  - Go
  - Gorm
date: 2021-08-15 23:32:44
---

使用 Gorm 框架出问题，主要出在创建和更新的时候，其中更新要格外小心。

### 创建(Create())

#### 数据一致性问题

在日常开发过程中，可能会觉得创建是最简单的，因为不管是一层的struct结构还是嵌套的struct结构，往往一个 create 方法就搞定了。但是，对于嵌套的 struct 结构，如果你对数据一致性又要求，最好采用事务对每个表分别应用 create 方法，因为一个 create 情况下，如果第二层结构创建失败了，会出现第一层创建成功，而第二层创建失败的情况。



### 更新(Update())

#### 零值问题

gorm 框架默认是不更新某类型数据对应的零值数据的，虽然很多人吐槽这一点，但gorm这样设计我觉得确实一个很好的设计，因为它有效的防止了数据误更新导致的数据丢失，但这样设计给刚开始使用的小伙伴一记重击。

如果在更新的时候想要更新零值，通常有两种方法，一种是将要更新的 struct 转成 map 形式去更新，另一种是使用它的 select 或 select 与 omit 组合的形式。问题出在第二种方法上：

##### select(*) 形式

这种相当于取消 gorm 零值不更新的限制，所以对于 struct 中所有的值，都会更新到表中，乍一看好像没什么问题，但问题就出在我们认为的所有值都更新这点上，我先列出几个显而易见的坑：

* 每次更新时，它会让数据库的自增主键变成0，导致下次更新别的数据时，报主键重复错误
* 每次更新时，它会将 created_at 字段变成0，从而丢失数据的创建时间

另外，我再说一个逻辑上的错误：如果该条记录，我们用 0/1 标识它未删除/删除，那么，当它处于删除状态，即值为 1 时，这时，我们要更新这条记录，在提交记录中，一般不会提交该字段，所以它默认值是 0， 于是它被更新为 0，于是数据由删除状态变成未删除状态，引发业务逻辑上的bug。

##### select(*).omit()的形式

这种形式，可以解决上面那两个显而易见的坑，即不让主键和 created_at 字段更新，除此之外，其他字段都要被更新，还是有可能会出现那种逻辑上的问题。



**最好的方式是，用select("字段1", "字段2") 明确指定哪些字段要更新，尽可能让数据保持在可控范围，同时也减少误更新导致数据丢失范围。**
